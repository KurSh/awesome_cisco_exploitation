/* $Id: save_stack.c,v 3.3 1996/01/19 23:51:21 mdb Exp $
 * $Source: /vws/aam/cherf.111/ios/boot/save_stack.c,v $
 *------------------------------------------------------------------
 * save_stack.c - save trace of current stack when restarting system
 *
 * July 27, 1989, Chris Shaker
 *
 * Copyright (c) 1989-1996 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 * $Log: save_stack.c,v $
 * Revision 3.3  1996/01/19  23:51:21  mdb
 * CSCdi47065:  misuse of NULL macro in IOS sources
 *
 * Revision 3.2  1995/11/17  07:41:40  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  09:04:46  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.1  1995/06/07  19:12:34  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

#include "defs.h"
#include "stdio.h"
#include "emt.h"
#include "reason.h"
#include "extern.h"
#include "save_stack.h"

void buserrnote();
extern volatile short buserrcnt;
struct frame frames[BOOT_STACK_FRAMES];

struct frame *save_stack(reg_fp)
    long reg_fp;
{
    register int cnt;
    struct frame *fp;

    fp = (struct frame *)reg_fp;
    for (cnt = 0; cnt < BOOT_STACK_FRAMES; cnt++) {
	/*
	 * Check for end of stack trace:
	 */
	if (fp != (struct frame *)NULL) {
	    if(chk_buserr((long *)(&fp->fp)) || chk_buserr((long *)(&fp->pc))) {
		printf("save_stack: discarding corrupt frame pointer (%#08x)\n",fp);
		fp = NULL;                      /* NULL everything from this point */
		goto null_frame;
	    }
	    frames[cnt].fp = (long)fp;		/* Save stack frame */
	    frames[cnt].pc = fp->pc;
	    fp = (struct frame *)fp->fp;	/* Next stack frame */
	} else {
null_frame:
	    /*
	     * Zero out remaining frames:
	     */
	    frames[cnt].fp = 0;
	    frames[cnt].pc = 0;
	}
    }
    return(frames);
}

/*
 * Returns the number of bus errors generated by doing a longword
 * access at the address.
 */
chk_buserr(addr)
    volatile unsigned long *addr;
{
    unsigned long temp;
    char abortsav = abortstate;

    abortstate = ABORT_INTERNAL;  /* set up to handle possible bus error */
    buserrhandler = buserrnote;
    buserrcnt = 0;
    temp = ltouchr(addr);                 /* Access the address, protected */
    abortstate = abortsav;
    buserrhandler = 0;
    return(buserrcnt);
}
