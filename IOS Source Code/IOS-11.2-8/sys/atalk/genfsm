#
#
# $Id: genfsm,v 3.1 1995/11/09 10:58:48 shaker Exp $
# $Source $
#
# Dummy file for Atalk_branch.
#
# Copyright (c) 1993-1994 by cisco Systems, Inc.
# All rights reserved.
#
# $Log $
#
# 
$Endlog$
#INPUT FILE FORMAT:
#fsm_name initial_state halt_state	#must be line #1 in file!!
#| curr_state	| STATE_EVENT	| next_state	| comment...
# ^ note whitespace!	       ^ note whitespace!
# (Must have exactly one whitespace delimited identifier between '|' marks)
# OR
#| curr_state	| TIMEOUT	| next_state	| TIMER_CONSTANT_NAME comment..
#
# a <curr_state> of "*" means "entered from any state"
# a <next_state> is "*" means "return to calling state"
#
#SAMPLE INPUT FILE (delete comment marks):
#boob initial halt
#+---------------+-----------------------+---------------+----------------------
#| State		| Event			| New State	| TIMEOUT/Notes
#+---------------+-----------------------+---------------+----------------------
#| initial	| BOO			| boo		|
#| initial	| TIMEOUT		| initial	| INIT_WAIT
#| boo		| BOOP			| booboop	|
#| booboop	| DEE			| booboopdee	|
#| booboopdee	| DOOP			| booboopdeedoo	|
#| booboopdeedoo	| TIMEOUT		| halt		| HALT_WAIT
#| *		| HEE			| *		|
#| *		| HAW			| halt		|
#+---------------+-----------------------+---------------+----------------------
#END OF SAMPLE INPUT FILE
#NOTE:  don't change the name of the column headings, as the word
#	count between '|' marks is used to determine if the line is
#	part of the table (otherwise the line is treated as a comment).
#

BEGIN {
    abort = 0
    if (ARGC < 2) {
	abort = 1
	exit		#this execs END statement, which prints usage.
    }

    nrecs = 0
    nevents = 0
    nfuncs = 0
    ndelays = 0
    table_name = ARGV[1]
}

NR == 1 {
    #set name of table, initial & halt states:
    fsmname	= $1
    ufsmname= toupper(fsmname)
    initial	= $2
    halt	= $3
    next
}

NF >= 7 {
    #ignore comment lines:
    if ($1 != "|" || $3 != "|" || $5 != "|" || $7 != "|") {
	    next
    }

    line[nrecs] = $0
    if ($2 == "*")
	    curr[nrecs] = "NILFSMFUNC"
    else
	    curr[nrecs] = $2
    if ($4 == "TIMEOUT") {
	#if timeout expression...
	if (substr($8,1,1) == "(")
	    timeout[nrecs] = $8
	else {
	    timeout[nrecs] = sprintf("%s_FSM_%s", ufsmname, $8)
	    addtimeout($8)
	}

	event[nrecs] =  "ATFSM_TIMEOUT"
    }
    else {
	timeout[nrecs] = "0"
	event[nrecs] = sprintf("%s_FSM_%s", ufsmname, $4)
	addevent(event[nrecs])
    }

    if ($6 == "*")
	    nxtstate[nrecs] = "NILFSMFUNC"
    else
	    nxtstate[nrecs] = $6
    addfunc($2)
    addfunc($6)
    ++nrecs
}

END {
    if (abort) {
	#print usage and exit
	printf ("Usage:  genfsm table.fsm\n")
	exit
    }

    #print errors in state machine def:
    check_fsm()

    #
    #generate .h file
    #
printf("/*\n")
printf(" * %s_fsm.h -\n", fsmname)
printf(" *	information for users of the %s FSM.\n", fsmname)
printf(" *	Generated by the script \"genfsm\", from table \"%s\".\n", table_name)
printf(" *\n")
printf(" *	WARNING:  do not edit this file, edit \"%s\"\n", table_name)
printf(" *		  and use genfsm to rebuild.\n")
printf(" */\n")
printf("\n")
printf("/* state transition events are numbered from 1..%s_FSM_NEVENTS */\n",ufsmname)

    #output event tokens:
    for (ii=0; ii<nevents; ii++) {
printf("#define %s	%d\n", uevents[ii], ii+1)
    }

printf("#define	%s_FSM_NEVENTS    %d\n", ufsmname, nevents)

    #output extern function defs:
printf("\n")
printf("extern char *%s_eventStr(atfsmEvent ee);\n", fsmname)
printf("extern char *%s_stateStr(FSMFUNC func);\n", fsmname)
printf("extern void %s_fsm_init(at_fsm *fsm, char *uarg);\n", fsmname)
printf("\n")

    #output extern defs for state execution functions:
printf("/* functions supplied by programmer to implement %s fsm */\n", fsmname)
    for (ii=0; ii<nfuncs; ii++) {
printf("extern void %s_fsm_%s (at_fsm *fsm);\n", fsmname, funcs[ii])
    }

    #generate .c file
printf("--------------------------------CUT--------------------------------\n")
printf("/*\n")
printf(" * %s_fsm.c -\n", fsmname)
printf(" *	implement the %s FSM.\n", fsmname)
printf(" *	Generated by the script \"genfsm\", from table \"%s\".\n", table_name)
printf(" *\n")
printf(" */\n")
printf("\n")
printf("#ifndef SUNTEST\n")
printf("#include \"master.h\"\n")
printf("#endif\n")
printf("#include \"macip_util.h\"\n")
printf("#include \"at_fsm.h\"\n")
printf("#include \"%s_fsm.h\"\n", fsmname)
printf("\n")

	put_timer_defs()
printf("\n")

printf("#define    FSM_NAME    \"%s\"\n", fsmname)
printf("\n")
printf("\n")
printf("/*************************  PRIVATE FUNCTIONS  ************************/\n")

    #output state functions:
    for (ii=0; ii<nfuncs; ii++) {
printf("\n")
printf("void\n")
printf("%s_fsm_%s (at_fsm *fsm)\n", fsmname, funcs[ii])
printf("/*\n")
	put_states(funcs[ii])
printf("*/\n")
printf("{\n")
printf("    if (ATFSM_TRACE_DEBUG(fsm))\n")
printf("	buginf(\"\\nFSM '%%s.%%lx', state '%%s'\",\n")
printf("		fsm->name, fsm, fsm->stateStr(fsm->stateFunc));\n")
printf("\n")
	put_template(funcs[ii])
printf("}\n")
    }

    #output state table (must go after function defs):
printf("\nstatic atfsm_table stab[] = {\n")
    for (ii=0; ii<nrecs; ii++)
printf("    { %s_fsm_%s, %s, %s_fsm_%s },\n", fsmname,
	curr[ii],event[ii],fsmname, nxtstate[ii])

    #end with NIL entry:
printf("    { NILFSMFUNC, ATFSM_NILEVENT, NILFSMFUNC }\n")
printf("};\n")
    #generate exported functions:
printf("\n")
printf("\n")
printf("/*************************  EXPORTED FUNCTIONS  ***********************/\n")
printf("\n")

    #output Str functions:
printf("char *\n")
printf("%s_eventStr(atfsmEvent ee)\n", fsmname)
printf("{\n")
printf("    switch(ee) {\n")
printf("    /* special events common to all state machines: */\n")
printf("    case ATFSM_TIMEOUT:		return(\"ATFSM_TIMEOUT\");\n")
printf("    case ATFSM_NILEVENT:	return(\"ATFSM_NILEVENT\");\n")
    for (ii=0; ii<nevents; ii++) {
printf("    case %s:\treturn(\"%s\");\n", uevents[ii],uevents[ii])
    }
printf("    default:	return(\"\");\n")
printf("    }\n")
printf("}\n")

printf("\n")
printf("char *\n")
printf("%s_stateStr(FSMFUNC func)\n", fsmname)
printf("{\n")
    for (ii=0; ii<nfuncs; ii++) {
	if (ii == 0)
printf("    if (func == %s_fsm_%s)\n", fsmname, funcs[ii]);
	else
printf("    else if (func == %s_fsm_%s)\n", fsmname, funcs[ii]);
printf("\treturn(\"%s_fsm_%s\");\n", fsmname, funcs[ii]);
    }
printf("    else if (func == NILFSMFUNC)\n")
printf("	return(\"*\");\n")
printf("    else    \n")
printf("	return(\"%s_stateStr:  bad arg\");\n", fsmname)
printf("}\n")

    #output init function:
printf("\n")
printf("void\n")
printf("%s_fsm_init (at_fsm *fsm, char *uarg)\n", fsmname)
printf("/* initialize a %s FSM */\n", fsmname)
printf("{\n")
printf("    queue_init(&fsm->stateQ, 0);	/* init state event queue */\n")
printf("    fsm->name = FSM_NAME;		/* init state machine name */\n")
printf("    fsm->traceInfo = FALSE;		/* state transitions only */\n")
printf("    fsm->traceDebug = FALSE;		/* verbose trace */\n")
printf("    fsm->timeout = FALSE;		/* TRUE if TIMEOUT event */\n")
printf("    fsm->timer = 0;			/* timer */\n")
printf("    fsm->delay = 0;			/* delay before TIMEOUT */\n")
printf("    fsm->stab = stab;			/* pointer to state table */\n")
printf("    fsm->userArg = uarg;		/* user arg. passed thru fsm */\n")
printf("    fsm->initialState = %s_fsm_%s;	/* INITIAL state */\n", fsmname, initial)
printf("    fsm->haltState = %s_fsm_%s;		/* HALT state */\n", fsmname, halt)
printf("    fsm->stateFunc = %s_fsm_%s;		/* current state routine */\n", fsmname, initial)
printf("    fsm->prevStateFunc = %s_fsm_%s;	/* for \"any state\" events */\n", fsmname, initial)
printf("    fsm->stateStr = %s_stateStr;	/* returns name of state func */\n", fsmname)
printf("    fsm->eventStr = %s_eventStr;	/* returns name of fsm event */\n", fsmname)
printf("}\n")

}

function addfunc(var) {
    #add <var> to funcs and increment <nfuncs> if first occurance.

    if (var == "*")
	    return	#ignore 

    for (ii=0; ii<nfuncs; ii++)
	    if (funcs[ii] == var)
		    return
    
    #not there, add:
    funcs[nfuncs++] = var
}

function addevent(var) {
    #add <var> to uevents (list of unique event names)
    if (var == "TIMEOUT")
	return		#special event, use ATFSM_TIMEOUT

    for (ii=0; ii<nevents; ii++)
	if (uevents[ii] == var)
	    return
    
    #not there, add:
    uevents[nevents++] = var
}

function addtimeout(var) {
    #add <var> to delays and increment <ndelays> if first occurance.

    for (ii=0; ii<ndelays; ii++)
	    if (delays[ii] == var)
		    return
    
    #not there, add:
    delays[ndelays++] = var
}

function put_states(ss) {
    #print the state transitions for state <ss>
    for (jj=0; jj<nrecs; jj++)
	    if (curr[jj] == ss)
		    printf("%s\n",line[jj])
}

function put_template(ss) {
    #output function body of user template

printf("    /* set timer when state first entered: */\n")
printf("    if (fsm->timer == 0)\n")

    #look for TIMEOUT event:
    no_timeout = 1
    for (jj=0; jj<nrecs; jj++) {
	if (curr[jj] == ss && event[jj] == "ATFSM_TIMEOUT") {
printf("	ATFSM_SET_DELAY(fsm, %s);\n", timeout[jj])
	    no_timeout = 0
	    break;
	}
    }

    if (no_timeout) {
printf("	ATFSM_NO_TIMEOUT(fsm);	/* state has no TIMEOUT's */\n")
    }
printf("\n")
printf("    /* EDIT code to implement state %s here:*/\n", ss)
}

function put_timer_defs() {
    #output template defs for TIMEOUTS

    printf("ndelays=%d\n",ndelays)>"/dev/stderr"

    #look for TIMEOUT event:
    for (jj=0; jj<ndelays; jj++) {
	if (substr(timeout[jj],1,1) != "(")
	    printf("#define	%s	30	/* EDIT */\n", timeout[jj])
    }
}

function check_fsm() {
    #check state machine for consistency
    nerrs = 0

    #every current state s.b. used:
    hasinit = 0
    for (jj=0; jj<nrecs; jj++) {
	if (curr[jj] == initial) {
	    hasinit = 1
	    continue
	}

	found = 0
	for (ii=0; ii<nrecs; ii++) {
	    if (curr[jj] == nxtstate[ii]) {
		found = 1
		break
	    }
	}

	if (!found) {
printf("WARNING:  UNUSED STATE:  '%s'\n", curr[jj])>"/dev/stderr"
	    ++nerrs
	}
    }
    if (!hasinit) {
printf("WARNING:  INITIAL STATE  '%s' not in table\n", initial)>"/dev/stderr"
	++nerrs
    }

    #every next state except halt state s.b. defined:
    hashalt = 0
    for (jj=0; jj<nrecs; jj++) {
	if (nxtstate[jj] == halt) {
	    hashalt = 1
	    continue
	}

	found = 0
	for (ii=0; ii<nrecs; ii++) {
	    if (nxtstate[jj] == curr[ii]) {
		found = 1
		break
	    }
	}

	if (!found) {
printf("WARNING:  UNDEFINED STATE:  '%s'\n", nxtstate[jj])>"/dev/stderr"
	    ++nerrs
	}
    }
    if (!hashalt) {
printf("WARNING:  HALT STATE  '%s' not in table\n", halt)>"/dev/stderr"
	++nerrs
    }

printf("%d ERRORS found in table\n", nerrs)>"/dev/stderr"
}
