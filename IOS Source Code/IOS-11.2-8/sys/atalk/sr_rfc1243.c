/* $Id: sr_rfc1243.c,v 3.6.10.3 1996/07/01 18:43:48 hampton Exp $
 * $Source: /release/112/cvs/Xsys/atalk/sr_rfc1243.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * March 1994, Yunsen Wang (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1994-1997 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_rfc1243.c,v $
 * Revision 3.6.10.3  1996/07/01  18:43:48  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.6.10.2  1996/04/19  17:55:52  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.6.10.1  1996/03/23  01:28:48  slin
 * Branch: California_branch
 *
 * AppleTalk makes its exodus from the idb.
 *
 * Revision 3.6  1996/02/23  20:33:39  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.5  1996/01/18  15:42:08  anke
 * CSCdi46969:  Change empty req and/or seq strings in SUBSYS_HEADERs to
 * NULL
 *              Five bytes saved is five bytes earne
 *
 * Revision 3.4  1995/12/14  08:22:24  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.3  1995/11/17  08:45:24  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.2  1995/11/16  23:06:34  gstovall
 * Ladies and gentlemen, I introduce to you, the port ready commit.
 *
 * Revision 3.1  1995/11/09  10:59:17  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.5  1995/09/15  21:31:16  slin
 * CSCdi40232:  Spurious access in atalk - k_rtmpEntry_get()
 * - Incorporate code reviewer comments
 *
 * Revision 2.4  1995/09/15  18:10:56  slin
 * CSCdi40232:  Spurious access in atalk - k_rtmpEntry_get()
 * - Make sure retrieve route points to an interface
 *
 * Revision 2.3  1995/07/17  07:30:43  bchan
 * CSCdi34760:  Ifindex usage incorrect
 *
 * Revision 2.2  1995/06/28  09:21:48  smackie
 * Repair widespread subsystem header braindamage. (CSCdi23568)
 *
 *   o Fix subsystem entry points to be foo(subsystype *) not foo(void)
 *   o Repair nonsensical and redundant subsystem sequences
 *   o Use NULL where no property is required
 *
 * Revision 2.1  1995/06/07  20:11:03  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1993 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include "subsys.h"
#include <interface_private.h>
#include "packet.h"
#include "../snmp/snmp_api.h"

#include "atalk_private.h"
#include "at_arp.h"
#include "sr_rfc1243.h"
#include "sr_rfc1243-mib.h"
#include "sr_old_latalkmib.h"
#include "../if/network.h"
#include "../ip/tunnel.h"
#define DDPBYTES 3
#define DDPNETBYTES 2

static ulong snmp_atportType(idbtype *idb);
static ulong snmp_atportStatus(idbtype *idb);
static ulong snmp_atConfigBy(idbtype *idb);
boolean
nve_snmpget (long nbpIndex, uchar** objectp, uchar** typep, uchar** zonep);

static aarpEntry_t aarpEntryData;
static atportEntry_t atportEntryData;
static ddp_t    ddpData;
static rtmpEntry_t rtmpEntryData;
static zipEntry_t zipEntryData;
static nbpEntry_t nbpEntryData;
static atecho_t atechoData;

void
init_rfc1243 (subsystype *subsys)
{
    memset(&aarpEntryData, 0, sizeof(aarpEntryData));
    memset(&atportEntryData, 0, sizeof(atportEntryData));
    memset(&ddpData, 0, sizeof(ddpData));
    memset(&rtmpEntryData, 0, sizeof(rtmpEntryData));
    memset(&zipEntryData, 0, sizeof(zipEntryData));
    memset(&nbpEntryData, 0, sizeof(nbpEntryData));
    memset(&atechoData, 0, sizeof(atechoData));
    load_mib(rfc1243_OidList, rfc1243_OidListNum);
    load_oid(rfc1243_oid_table);
    init_old_latalkmib();
}


/*---------------------------------------------------------------------
 * Retrieve data from the aarpEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
aarpEntry_get(OID *incoming,ObjectInfo *object, int searchType,
	      ContextInfo *contextInfo, int serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    aarpEntry_t    *data = NULL;
    unsigned long   buffer[4];
    OID             inst;
    int             carry;
    int             i;
    long            aarpIfIndex;
    int             aarpIfIndex_offset;
    OctetString    *aarpNetAddress;
    int             aarpNetAddress_offset;
    int             index;
    int             final_index;

    aarpIfIndex_offset = object->oid.length;
    aarpNetAddress_offset = aarpIfIndex_offset + 1;
    final_index = aarpNetAddress_offset + 3;

    if (searchType == EXACT) {
	if (instLength != 4) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToFixedOctetString(incoming, aarpNetAddress_offset, &aarpNetAddress, searchType, &carry, 3)) < 0) {
	arg = -1;
    }

    if ((InstToInt(incoming, aarpIfIndex_offset, &aarpIfIndex, searchType, &carry)) < 0) {
	arg = -1;
    }

    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_aarpEntry_get(serialNum, contextInfo, arg, searchType, aarpIfIndex, aarpNetAddress)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	inst.oid_ptr[index++] = (unsigned long) data->aarpIfIndex;
	for (i = 0; i < data->aarpNetAddress->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->aarpNetAddress->octet_ptr[i];
	}

	inst.length = index;
    }

    if (aarpNetAddress != NULL) {
	FreeOctetString(aarpNetAddress);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_aarpIfIndex
      case I_aarpIfIndex:
	dp = &data->aarpIfIndex;
	break;
#endif				       /* I_aarpIfIndex */

#ifdef I_aarpPhysAddress
      case I_aarpPhysAddress:
	dp = MakeOctetString(data->aarpPhysAddress->octet_ptr, data->aarpPhysAddress->length);
	break;
#endif				       /* I_aarpPhysAddress */

#ifdef I_aarpNetAddress
      case I_aarpNetAddress:
	dp = MakeOctetString(data->aarpNetAddress->octet_ptr, data->aarpNetAddress->length);
	break;
#endif				       /* I_aarpNetAddress */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the atportEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
atportEntry_get(OID *incoming, ObjectInfo *object, int searchType,
		ContextInfo *contextInfo, int serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    atportEntry_t  *data = NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            atportIndex;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &atportIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_atportEntry_get(serialNum, contextInfo, arg, searchType, atportIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->atportIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_atportIndex
      case I_atportIndex:
	dp = &data->atportIndex;
	break;
#endif				       /* I_atportIndex */

#ifdef I_atportDescr
      case I_atportDescr:
	dp = MakeOctetString(data->atportDescr->octet_ptr, data->atportDescr->length);
	break;
#endif				       /* I_atportDescr */

#ifdef I_atportType
      case I_atportType:
	dp = &data->atportType;
	break;
#endif				       /* I_atportType */

#ifdef I_atportNetStart
      case I_atportNetStart:
	dp = MakeOctetString(data->atportNetStart->octet_ptr, data->atportNetStart->length);
	break;
#endif				       /* I_atportNetStart */

#ifdef I_atportNetEnd
      case I_atportNetEnd:
	dp = MakeOctetString(data->atportNetEnd->octet_ptr, data->atportNetEnd->length);
	break;
#endif				       /* I_atportNetEnd */

#ifdef I_atportNetAddress
      case I_atportNetAddress:
	dp = MakeOctetString(data->atportNetAddress->octet_ptr, data->atportNetAddress->length);
	break;
#endif				       /* I_atportNetAddress */

#ifdef I_atportStatus
      case I_atportStatus:
	dp = &data->atportStatus;
	break;
#endif				       /* I_atportStatus */

#ifdef I_atportNetConfig
      case I_atportNetConfig:
	dp = &data->atportNetConfig;
	break;
#endif				       /* I_atportNetConfig */

#ifdef I_atportZoneConfig
      case I_atportZoneConfig:
	dp = &data->atportZoneConfig;
	break;
#endif				       /* I_atportZoneConfig */

#ifdef I_atportZone
      case I_atportZone:
	dp = MakeOctetString(data->atportZone->octet_ptr, data->atportZone->length);
	break;
#endif				       /* I_atportZone */

#ifdef I_atportIfIndex
      case I_atportIfIndex:
	dp = &data->atportIfIndex;
	break;
#endif				       /* I_atportIfIndex */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the atportEntry data object.
 *---------------------------------------------------------------------*/
void
atportEntry_free (atportEntry_t  *data)
{
    if (data != NULL) {
	if (data->atportNetStart != NULL) {
	    FreeOctetString(data->atportNetStart);
	}
	if (data->atportNetEnd != NULL) {
	    FreeOctetString(data->atportNetEnd);
	}
	if (data->atportNetAddress != NULL) {
	    FreeOctetString(data->atportNetAddress);
	}
	if (data->atportZone != NULL) {
	    FreeOctetString(data->atportZone);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after atportEntry set/undo
 *---------------------------------------------------------------------*/
static int
atportEntry_cleanup(doList_t *trash)
{
    atportEntry_free(trash->data);
#ifdef SR_SNMPv2
    atportEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Undo a previous set of the atportEntry family.
 *---------------------------------------------------------------------*/
#ifdef SR_SNMPv2
int
atportEntry_undo(doList_t *doHead, doList_t *doCur, ContextInfo *contextInfo)
{
    return UNDO_FAILED_ERROR;
}

#endif	/* SR_SNMPv2 */

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
atportEntry_test(OID *incoming, ObjectInfo *object, ObjectSyntax *value,
		 doList_t *doHead, doList_t *doCur, ContextInfo *contextInfo)
{
    doList_t       *dp;
    int             found;
    int             carry = 0;
    atportEntry_t  *atportEntry;
    long            atportIndex;

    return (NOT_WRITABLE_ERROR); 

    /*
     * Validate the object instance
     * 
     */
    if ((InstToInt(incoming, 0 + object->oid.length, &atportIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    atportEntry = k_atportEntry_get(-1, contextInfo, object->nominator, EXACT, atportIndex);

#ifndef atportEntry_READ_CREATE

    if (atportEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* atportEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == atportEntry_set) &&
	    (((atportEntry_t *) (dp->data)) != NULL) &&
	    (((atportEntry_t *) (dp->data))->atportIndex == atportIndex)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(atportEntry_t))) == NULL) {
	    DPRINTF((0, "snmpd: Cannot allocate memory\n"));
	    return (GEN_ERROR);
	}
	memset(dp->data, 0, sizeof(atportEntry_t));

	dp->setMethod = atportEntry_set;
	dp->cleanupMethod = atportEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = atportEntry_undo;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_atportIndex, ((atportEntry_t *) (dp->data))->valid);
	((atportEntry_t *) (dp->data))->atportIndex = atportIndex;

#ifdef atportEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (atportEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, atportEntry, sizeof(atportEntry_t));

	    SET_ALL_VALID(((atportEntry_t *) (dp->data))->valid);

	    ((atportEntry_t *) (dp->data))->atportNetStart =
		CloneOctetString(value->os_value);


	    ((atportEntry_t *) (dp->data))->atportNetEnd =
		CloneOctetString(value->os_value);


	    ((atportEntry_t *) (dp->data))->atportNetAddress =
		CloneOctetString(value->os_value);


	    ((atportEntry_t *) (dp->data))->atportZone =
		CloneOctetString(value->os_value);


	} else {


	    /* Fill in default values here */


	}
#endif				       /* atportEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_atportType
      case I_atportType:

	SET_VALID(I_atportType, ((atportEntry_t *) (dp->data))->valid);

	((atportEntry_t *) (dp->data))->atportType = value->sl_value;
	break;
#endif				       /* I_atportType */

#ifdef I_atportNetStart
      case I_atportNetStart:

	SET_VALID(I_atportNetStart, ((atportEntry_t *) (dp->data))->valid);

	if (((atportEntry_t *) (dp->data))->atportNetStart != NULL) {
	    FreeOctetString(((atportEntry_t *) (dp->data))->atportNetStart);
	}
	((atportEntry_t *) (dp->data))->atportNetStart =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_atportNetStart */

#ifdef I_atportNetEnd
      case I_atportNetEnd:

	SET_VALID(I_atportNetEnd, ((atportEntry_t *) (dp->data))->valid);

	if (((atportEntry_t *) (dp->data))->atportNetEnd != NULL) {
	    FreeOctetString(((atportEntry_t *) (dp->data))->atportNetEnd);
	}
	((atportEntry_t *) (dp->data))->atportNetEnd =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_atportNetEnd */

#ifdef I_atportNetAddress
      case I_atportNetAddress:

	SET_VALID(I_atportNetAddress, ((atportEntry_t *) (dp->data))->valid);

	if (((atportEntry_t *) (dp->data))->atportNetAddress != NULL) {
	    FreeOctetString(((atportEntry_t *) (dp->data))->atportNetAddress);
	}
	((atportEntry_t *) (dp->data))->atportNetAddress =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_atportNetAddress */

#ifdef I_atportStatus
      case I_atportStatus:

	SET_VALID(I_atportStatus, ((atportEntry_t *) (dp->data))->valid);

	((atportEntry_t *) (dp->data))->atportStatus = value->sl_value;
	break;
#endif				       /* I_atportStatus */

#ifdef I_atportZone
      case I_atportZone:

	SET_VALID(I_atportZone, ((atportEntry_t *) (dp->data))->valid);

	if (((atportEntry_t *) (dp->data))->atportZone != NULL) {
	    FreeOctetString(((atportEntry_t *) (dp->data))->atportZone);
	}
	((atportEntry_t *) (dp->data))->atportZone =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_atportZone */

#ifdef I_atportIfIndex
      case I_atportIfIndex:

	SET_VALID(I_atportIfIndex, ((atportEntry_t *) (dp->data))->valid);

	((atportEntry_t *) (dp->data))->atportIfIndex = value->sl_value;
	break;
#endif				       /* I_atportIfIndex */

      default:
	DPRINTF((0, "snmpd: Internal error (invalid nominator in atportEntry)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
atportEntry_set(doList_t *doHead, doList_t *doCur, ContextInfo *contextInfo)
{
    return (k_atportEntry_set((atportEntry_t *) (doCur->data),
			      contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the ddp family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ddp_get(OID *incoming, ObjectInfo *object, int searchType, 
	ContextInfo *contextInfo, int serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = -1;
    void           *dp;
    ddp_t          *data = NULL;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1 and the single
     * instance element be 0.
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    switch (searchType) {
      case EXACT:
	if (instLength == 1 && incoming->oid_ptr[incoming->length - 1] == 0) {
	    arg = object->nominator;
	}
	break;

      case NEXT:
	if (instLength <= 0) {
	    arg = object->nominator;
	}
	break;

    }

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ddp_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ddpOutRequests
      case I_ddpOutRequests:
	dp = &data->ddpOutRequests;
	break;
#endif				       /* I_ddpOutRequests */

#ifdef I_ddpOutShorts
      case I_ddpOutShorts:
	dp = &data->ddpOutShorts;
	break;
#endif				       /* I_ddpOutShorts */

#ifdef I_ddpOutLongs
      case I_ddpOutLongs:
	dp = &data->ddpOutLongs;
	break;
#endif				       /* I_ddpOutLongs */

#ifdef I_ddpInReceives
      case I_ddpInReceives:
	dp = &data->ddpInReceives;
	break;
#endif				       /* I_ddpInReceives */

#ifdef I_ddpForwRequests
      case I_ddpForwRequests:
	dp = &data->ddpForwRequests;
	break;
#endif				       /* I_ddpForwRequests */

#ifdef I_ddpInLocalDatagrams
      case I_ddpInLocalDatagrams:
	dp = &data->ddpInLocalDatagrams;
	break;
#endif				       /* I_ddpInLocalDatagrams */

#ifdef I_ddpNoProtocolHandlers
      case I_ddpNoProtocolHandlers:
	dp = &data->ddpNoProtocolHandlers;
	break;
#endif				       /* I_ddpNoProtocolHandlers */

#ifdef I_ddpOutNoRoutes
      case I_ddpOutNoRoutes:
	dp = &data->ddpOutNoRoutes;
	break;
#endif				       /* I_ddpOutNoRoutes */

#ifdef I_ddpTooShortErrors
      case I_ddpTooShortErrors:
	dp = &data->ddpTooShortErrors;
	break;
#endif				       /* I_ddpTooShortErrors */

#ifdef I_ddpTooLongErrors
      case I_ddpTooLongErrors:
	dp = &data->ddpTooLongErrors;
	break;
#endif				       /* I_ddpTooLongErrors */

#ifdef I_ddpBroadcastErrors
      case I_ddpBroadcastErrors:
	dp = &data->ddpBroadcastErrors;
	break;
#endif				       /* I_ddpBroadcastErrors */

#ifdef I_ddpShortDDPErrors
      case I_ddpShortDDPErrors:
	dp = &data->ddpShortDDPErrors;
	break;
#endif				       /* I_ddpShortDDPErrors */

#ifdef I_ddpHopCountErrors
      case I_ddpHopCountErrors:
	dp = &data->ddpHopCountErrors;
	break;
#endif				       /* I_ddpHopCountErrors */

#ifdef I_ddpChecksumErrors
      case I_ddpChecksumErrors:
	dp = &data->ddpChecksumErrors;
	break;
#endif				       /* I_ddpChecksumErrors */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the rtmpEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
rtmpEntry_get(OID *incoming, ObjectInfo *object, int searchType,
	      ContextInfo *contextInfo, int serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    rtmpEntry_t    *data = NULL;
    unsigned long   buffer[2];
    OID             inst;
    int             carry;
    int             i;
    OctetString    *rtmpRangeStart;
    int             rtmpRangeStart_offset;
    int             index;
    int             final_index;

    rtmpRangeStart_offset = object->oid.length;
    final_index = rtmpRangeStart_offset + 2;

    if (searchType == EXACT) {
	if (instLength != 2) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToFixedOctetString(incoming, rtmpRangeStart_offset, &rtmpRangeStart, searchType, &carry, 2)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_rtmpEntry_get(serialNum, contextInfo, arg, searchType, rtmpRangeStart)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	for (i = 0; i < data->rtmpRangeStart->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->rtmpRangeStart->octet_ptr[i];
	}

	inst.length = index;
    }

    if (rtmpRangeStart != NULL) {
	FreeOctetString(rtmpRangeStart);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_rtmpRangeStart
      case I_rtmpRangeStart:
	dp = MakeOctetString(data->rtmpRangeStart->octet_ptr, data->rtmpRangeStart->length);
	break;
#endif				       /* I_rtmpRangeStart */

#ifdef I_rtmpRangeEnd
      case I_rtmpRangeEnd:
	dp = MakeOctetString(data->rtmpRangeEnd->octet_ptr, data->rtmpRangeEnd->length);
	break;
#endif				       /* I_rtmpRangeEnd */

#ifdef I_rtmpNextHop
      case I_rtmpNextHop:
	dp = MakeOctetString(data->rtmpNextHop->octet_ptr, data->rtmpNextHop->length);
	break;
#endif				       /* I_rtmpNextHop */

#ifdef I_rtmpType
      case I_rtmpType:
	dp = &data->rtmpType;
	break;
#endif				       /* I_rtmpType */

#ifdef I_rtmpPort
      case I_rtmpPort:
	dp = &data->rtmpPort;
	break;
#endif				       /* I_rtmpPort */

#ifdef I_rtmpHops
      case I_rtmpHops:
	dp = &data->rtmpHops;
	break;
#endif				       /* I_rtmpHops */

#ifdef I_rtmpState
      case I_rtmpState:
	dp = &data->rtmpState;
	break;
#endif				       /* I_rtmpState */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the rtmpEntry data object.
 *---------------------------------------------------------------------*/
void
rtmpEntry_free (rtmpEntry_t *data)
{
    if (data != NULL) {
	if (data->rtmpRangeStart != NULL) {
	    FreeOctetString(data->rtmpRangeStart);
	}
	if (data->rtmpRangeEnd != NULL) {
	    FreeOctetString(data->rtmpRangeEnd);
	}
	if (data->rtmpNextHop != NULL) {
	    FreeOctetString(data->rtmpNextHop);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after rtmpEntry set/undo
 *---------------------------------------------------------------------*/
static int
rtmpEntry_cleanup(doList_t *trash)
{
    rtmpEntry_free(trash->data);
#ifdef SR_SNMPv2
    rtmpEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Undo a previous set of the rtmpEntry family.
 *---------------------------------------------------------------------*/
#ifdef SR_SNMPv2
int
rtmpEntry_undo(doList_t *doHead, doList_t *doCur, ContextInfo *contextInfo)
{
    return UNDO_FAILED_ERROR;
}

#endif	/* SR_SNMPv2 */

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
rtmpEntry_test(OID *incoming, ObjectInfo *object, ObjectSyntax *value,
	       doList_t *doHead, doList_t *doCur, ContextInfo *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int             found;
    int             carry = 0;
    rtmpEntry_t    *rtmpEntry;
    OctetString    *rtmpRangeStart;
    int             rtmpRangeStart_offset;
    int             final_index;

    return (NOT_WRITABLE_ERROR); 

    /*
     * Validate the object instance
     * 
     */
    rtmpRangeStart_offset = object->oid.length;
    final_index = rtmpRangeStart_offset + 2;

    if (instLength != final_index) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToFixedOctetString(incoming, rtmpRangeStart_offset, &rtmpRangeStart, EXACT, &carry, 2)) < 0) {
	return (NO_CREATION_ERROR);
    }
    rtmpEntry = k_rtmpEntry_get(-1, contextInfo, object->nominator, EXACT, rtmpRangeStart);

#ifndef rtmpEntry_READ_CREATE

    if (rtmpEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* rtmpEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == rtmpEntry_set) &&
	    (((rtmpEntry_t *) (dp->data)) != NULL) &&
	 (((rtmpEntry_t *) (dp->data))->rtmpRangeStart == rtmpRangeStart)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(rtmpEntry_t))) == NULL) {
	    DPRINTF((0, "snmpd: Cannot allocate memory\n"));
	    return (GEN_ERROR);
	}
	memset(dp->data, 0, sizeof(rtmpEntry_t));

	dp->setMethod = rtmpEntry_set;
	dp->cleanupMethod = rtmpEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = rtmpEntry_undo;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_rtmpRangeStart, ((rtmpEntry_t *) (dp->data))->valid);
	((rtmpEntry_t *) (dp->data))->rtmpRangeStart = rtmpRangeStart;

#ifdef rtmpEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (rtmpEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, rtmpEntry, sizeof(rtmpEntry_t));

	    SET_ALL_VALID(((rtmpEntry_t *) (dp->data))->valid);

	    ((rtmpEntry_t *) (dp->data))->rtmpRangeStart =
		CloneOctetString(value->os_value);


	    ((rtmpEntry_t *) (dp->data))->rtmpRangeEnd =
		CloneOctetString(value->os_value);


	    ((rtmpEntry_t *) (dp->data))->rtmpNextHop =
		CloneOctetString(value->os_value);


	} else {


	    /* Fill in default values here */


	}
#endif				       /* rtmpEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_rtmpRangeStart
      case I_rtmpRangeStart:

	SET_VALID(I_rtmpRangeStart, ((rtmpEntry_t *) (dp->data))->valid);

	if (((rtmpEntry_t *) (dp->data))->rtmpRangeStart != NULL) {
	    FreeOctetString(((rtmpEntry_t *) (dp->data))->rtmpRangeStart);
	}
	((rtmpEntry_t *) (dp->data))->rtmpRangeStart =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_rtmpRangeStart */

#ifdef I_rtmpRangeEnd
      case I_rtmpRangeEnd:

	SET_VALID(I_rtmpRangeEnd, ((rtmpEntry_t *) (dp->data))->valid);

	if (((rtmpEntry_t *) (dp->data))->rtmpRangeEnd != NULL) {
	    FreeOctetString(((rtmpEntry_t *) (dp->data))->rtmpRangeEnd);
	}
	((rtmpEntry_t *) (dp->data))->rtmpRangeEnd =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_rtmpRangeEnd */

#ifdef I_rtmpNextHop
      case I_rtmpNextHop:

	SET_VALID(I_rtmpNextHop, ((rtmpEntry_t *) (dp->data))->valid);

	if (((rtmpEntry_t *) (dp->data))->rtmpNextHop != NULL) {
	    FreeOctetString(((rtmpEntry_t *) (dp->data))->rtmpNextHop);
	}
	((rtmpEntry_t *) (dp->data))->rtmpNextHop =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_rtmpNextHop */

#ifdef I_rtmpType
      case I_rtmpType:

	SET_VALID(I_rtmpType, ((rtmpEntry_t *) (dp->data))->valid);

	((rtmpEntry_t *) (dp->data))->rtmpType = value->sl_value;
	break;
#endif				       /* I_rtmpType */

#ifdef I_rtmpPort
      case I_rtmpPort:

	SET_VALID(I_rtmpPort, ((rtmpEntry_t *) (dp->data))->valid);

	((rtmpEntry_t *) (dp->data))->rtmpPort = value->sl_value;
	break;
#endif				       /* I_rtmpPort */

#ifdef I_rtmpHops
      case I_rtmpHops:

	SET_VALID(I_rtmpHops, ((rtmpEntry_t *) (dp->data))->valid);

	((rtmpEntry_t *) (dp->data))->rtmpHops = value->sl_value;
	break;
#endif				       /* I_rtmpHops */

#ifdef I_rtmpState
      case I_rtmpState:

	SET_VALID(I_rtmpState, ((rtmpEntry_t *) (dp->data))->valid);

	((rtmpEntry_t *) (dp->data))->rtmpState = value->sl_value;
	break;
#endif				       /* I_rtmpState */

      default:
	DPRINTF((0, "snmpd: Internal error (invalid nominator in rtmpEntry)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
rtmpEntry_set(doList_t *doHead, doList_t *doCur, ContextInfo *contextInfo)
{
    return (k_rtmpEntry_set((rtmpEntry_t *) (doCur->data),
			    contextInfo, doCur->state));
}

#endif				       /* SETS */



/*---------------------------------------------------------------------
 * Retrieve data from the zipEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
zipEntry_get(OID *incoming, ObjectInfo *object, int searchType,
	     ContextInfo *contextInfo, int serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    zipEntry_t     *data = NULL;
    unsigned long   buffer[3];
    OID             inst;
    int             carry;
    int             i;
    OctetString    *zipZoneNetStart;
    int             zipZoneNetStart_offset;
    long            zipZoneIndex;
    int             zipZoneIndex_offset;
    int             index;

    zipZoneNetStart_offset = object->oid.length;
    zipZoneIndex_offset = zipZoneNetStart_offset + 2;

    if (searchType == EXACT) {
	if (instLength != 3) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, zipZoneIndex_offset, &zipZoneIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToFixedOctetString(incoming, zipZoneNetStart_offset, &zipZoneNetStart, searchType, &carry, 2)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_zipEntry_get(serialNum, contextInfo, arg, searchType, zipZoneNetStart, zipZoneIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	for (i = 0; i < data->zipZoneNetStart->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->zipZoneNetStart->octet_ptr[i];
	}

	inst.oid_ptr[index++] = (unsigned long) data->zipZoneIndex;
	inst.length = index;
    }

    if (zipZoneNetStart != NULL) {
	FreeOctetString(zipZoneNetStart);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_zipZoneName
      case I_zipZoneName:
	dp = MakeOctetString(data->zipZoneName->octet_ptr, data->zipZoneName->length);
	break;
#endif				       /* I_zipZoneName */

#ifdef I_zipZoneIndex
      case I_zipZoneIndex:
	dp = &data->zipZoneIndex;
	break;
#endif				       /* I_zipZoneIndex */

#ifdef I_zipZoneNetStart
      case I_zipZoneNetStart:
	dp = MakeOctetString(data->zipZoneNetStart->octet_ptr, data->zipZoneNetStart->length);
	break;
#endif				       /* I_zipZoneNetStart */

#ifdef I_zipZoneNetEnd
      case I_zipZoneNetEnd:
	dp = MakeOctetString(data->zipZoneNetEnd->octet_ptr, data->zipZoneNetEnd->length);
	break;
#endif				       /* I_zipZoneNetEnd */

#ifdef I_zipZoneState
      case I_zipZoneState:
	dp = &data->zipZoneState;
	break;
#endif				       /* I_zipZoneState */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the zipEntry data object.
 *---------------------------------------------------------------------*/
void
zipEntry_free (zipEntry_t *data)
{
    if (data != NULL) {
	if (data->zipZoneName != NULL) {
	    FreeOctetString(data->zipZoneName);
	}
	if (data->zipZoneNetStart != NULL) {
	    FreeOctetString(data->zipZoneNetStart);
	}
	if (data->zipZoneNetEnd != NULL) {
	    FreeOctetString(data->zipZoneNetEnd);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after zipEntry set/undo
 *---------------------------------------------------------------------*/
static int
zipEntry_cleanup(doList_t *trash)
{
    zipEntry_free(trash->data);
#ifdef SR_SNMPv2
    zipEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Undo a previous set of the zipEntry family.
 *---------------------------------------------------------------------*/
#ifdef SR_SNMPv2
int
zipEntry_undo(doList_t *doHead, doList_t *doCur, ContextInfo *contextInfo)
{
    return UNDO_FAILED_ERROR;
}

#endif	/* SR_SNMPv2 */

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
zipEntry_test(OID *incoming, ObjectInfo *object, ObjectSyntax *value,
	      doList_t *doHead, doList_t *doCur, ContextInfo *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int             found;
    int             carry = 0;
    zipEntry_t     *zipEntry;
    OctetString    *zipZoneNetStart;
    int             zipZoneNetStart_offset;
    long            zipZoneIndex;
    int             zipZoneIndex_offset;
    int             final_index;

    return (NOT_WRITABLE_ERROR); 

    /*
     * Validate the object instance
     * 
     */
    zipZoneNetStart_offset = object->oid.length;
    zipZoneIndex_offset = zipZoneNetStart_offset + 2;
    final_index = zipZoneIndex_offset + 1;

    if (instLength != final_index) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToFixedOctetString(incoming, zipZoneNetStart_offset, &zipZoneNetStart, EXACT, &carry, 2)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, zipZoneIndex_offset, &zipZoneIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    zipEntry = k_zipEntry_get(-1, contextInfo, object->nominator, EXACT, zipZoneNetStart, zipZoneIndex);

#ifndef zipEntry_READ_CREATE

    if (zipEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* zipEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == zipEntry_set) &&
	    (((zipEntry_t *) (dp->data)) != NULL) &&
	(((zipEntry_t *) (dp->data))->zipZoneNetStart == zipZoneNetStart) &&
	    (((zipEntry_t *) (dp->data))->zipZoneIndex == zipZoneIndex)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(zipEntry_t))) == NULL) {
	    DPRINTF((0, "snmpd: Cannot allocate memory\n"));
	    return (GEN_ERROR);
	}
	memset(dp->data, 0, sizeof(zipEntry_t));

	dp->setMethod = zipEntry_set;
	dp->cleanupMethod = zipEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = zipEntry_undo;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_zipZoneNetStart, ((zipEntry_t *) (dp->data))->valid);
	((zipEntry_t *) (dp->data))->zipZoneNetStart = zipZoneNetStart;

	SET_VALID(I_zipZoneIndex, ((zipEntry_t *) (dp->data))->valid);
	((zipEntry_t *) (dp->data))->zipZoneIndex = zipZoneIndex;

#ifdef zipEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (zipEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, zipEntry, sizeof(zipEntry_t));

	    SET_ALL_VALID(((zipEntry_t *) (dp->data))->valid);

	    ((zipEntry_t *) (dp->data))->zipZoneName =
		CloneOctetString(value->os_value);


	    ((zipEntry_t *) (dp->data))->zipZoneNetStart =
		CloneOctetString(value->os_value);


	    ((zipEntry_t *) (dp->data))->zipZoneNetEnd =
		CloneOctetString(value->os_value);


	} else {


	    /* Fill in default values here */


	}
#endif				       /* zipEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_zipZoneName
      case I_zipZoneName:

	SET_VALID(I_zipZoneName, ((zipEntry_t *) (dp->data))->valid);

	if (((zipEntry_t *) (dp->data))->zipZoneName != NULL) {
	    FreeOctetString(((zipEntry_t *) (dp->data))->zipZoneName);
	}
	((zipEntry_t *) (dp->data))->zipZoneName =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_zipZoneName */

#ifdef I_zipZoneNetStart
      case I_zipZoneNetStart:

	SET_VALID(I_zipZoneNetStart, ((zipEntry_t *) (dp->data))->valid);

	if (((zipEntry_t *) (dp->data))->zipZoneNetStart != NULL) {
	    FreeOctetString(((zipEntry_t *) (dp->data))->zipZoneNetStart);
	}
	((zipEntry_t *) (dp->data))->zipZoneNetStart =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_zipZoneNetStart */

#ifdef I_zipZoneNetEnd
      case I_zipZoneNetEnd:

	SET_VALID(I_zipZoneNetEnd, ((zipEntry_t *) (dp->data))->valid);

	if (((zipEntry_t *) (dp->data))->zipZoneNetEnd != NULL) {
	    FreeOctetString(((zipEntry_t *) (dp->data))->zipZoneNetEnd);
	}
	((zipEntry_t *) (dp->data))->zipZoneNetEnd =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_zipZoneNetEnd */

#ifdef I_zipZoneState
      case I_zipZoneState:

	SET_VALID(I_zipZoneState, ((zipEntry_t *) (dp->data))->valid);

	((zipEntry_t *) (dp->data))->zipZoneState = value->sl_value;
	break;
#endif				       /* I_zipZoneState */

      default:
	DPRINTF((0, "snmpd: Internal error (invalid nominator in zipEntry)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
zipEntry_set(doList_t *doHead, doList_t *doCur, ContextInfo    *contextInfo)
{
    return (k_zipEntry_set((zipEntry_t *) (doCur->data),
			   contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the nbpEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
nbpEntry_get(OID *incoming, ObjectInfo *object, int searchType,
	     ContextInfo *contextInfo, int serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    nbpEntry_t     *data = NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            nbpIndex;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &nbpIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_nbpEntry_get(serialNum, contextInfo, arg, searchType, nbpIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->nbpIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_nbpIndex
      case I_nbpIndex:
	dp = &data->nbpIndex;
	break;
#endif				       /* I_nbpIndex */

#ifdef I_nbpObject
      case I_nbpObject:
	dp = MakeOctetString(data->nbpObject->octet_ptr, data->nbpObject->length);
	break;
#endif				       /* I_nbpObject */

#ifdef I_nbpType
      case I_nbpType:
	dp = MakeOctetString(data->nbpType->octet_ptr, data->nbpType->length);
	break;
#endif				       /* I_nbpType */

#ifdef I_nbpZone
      case I_nbpZone:
	dp = MakeOctetString(data->nbpZone->octet_ptr, data->nbpZone->length);
	break;
#endif				       /* I_nbpZone */

#ifdef I_nbpState
      case I_nbpState:
	dp = &data->nbpState;
	break;
#endif				       /* I_nbpState */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the nbpEntry data object.
 *---------------------------------------------------------------------*/
void
nbpEntry_free (nbpEntry_t *data)
{
    if (data != NULL) {
	if (data->nbpObject != NULL) {
	    FreeOctetString(data->nbpObject);
	}
	if (data->nbpType != NULL) {
	    FreeOctetString(data->nbpType);
	}
	if (data->nbpZone != NULL) {
	    FreeOctetString(data->nbpZone);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after nbpEntry set/undo
 *---------------------------------------------------------------------*/
static int
nbpEntry_cleanup(doList_t *trash)
{
    nbpEntry_free(trash->data);
#ifdef SR_SNMPv2
    nbpEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Undo a previous set of the nbpEntry family.
 *---------------------------------------------------------------------*/
#ifdef SR_SNMPv2
int
nbpEntry_undo(doList_t *doHead, doList_t *doCur, ContextInfo *contextInfo)
{
    return UNDO_FAILED_ERROR;
}

#endif	/* SR_SNMPv2 */

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
nbpEntry_test(OID *incoming, ObjectInfo *object, ObjectSyntax *value,
	      doList_t *doHead, doList_t *doCur, ContextInfo *contextInfo)
{
    doList_t       *dp;
    int             found;
    int             carry = 0;
    nbpEntry_t     *nbpEntry;
    long            nbpIndex;

    return (NOT_WRITABLE_ERROR); 

    /*
     * Validate the object instance
     * 
     */

    if ((InstToInt(incoming, 0 + object->oid.length, &nbpIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    nbpEntry = k_nbpEntry_get(-1, contextInfo, object->nominator, EXACT, nbpIndex);

#ifndef nbpEntry_READ_CREATE

    if (nbpEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* nbpEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == nbpEntry_set) &&
	    (((nbpEntry_t *) (dp->data)) != NULL) &&
	    (((nbpEntry_t *) (dp->data))->nbpIndex == nbpIndex)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(nbpEntry_t))) == NULL) {
	    DPRINTF((0, "snmpd: Cannot allocate memory\n"));
	    return (GEN_ERROR);
	}
	memset(dp->data, 0, sizeof(nbpEntry_t));

	dp->setMethod = nbpEntry_set;
	dp->cleanupMethod = nbpEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = nbpEntry_undo;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_nbpIndex, ((nbpEntry_t *) (dp->data))->valid);
	((nbpEntry_t *) (dp->data))->nbpIndex = nbpIndex;

#ifdef nbpEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (nbpEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, nbpEntry, sizeof(nbpEntry_t));

	    SET_ALL_VALID(((nbpEntry_t *) (dp->data))->valid);

	    ((nbpEntry_t *) (dp->data))->nbpObject =
		CloneOctetString(value->os_value);


	    ((nbpEntry_t *) (dp->data))->nbpType =
		CloneOctetString(value->os_value);


	    ((nbpEntry_t *) (dp->data))->nbpZone =
		CloneOctetString(value->os_value);


	} else {


	    /* Fill in default values here */


	}
#endif				       /* nbpEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_nbpObject
      case I_nbpObject:

	SET_VALID(I_nbpObject, ((nbpEntry_t *) (dp->data))->valid);

	if (((nbpEntry_t *) (dp->data))->nbpObject != NULL) {
	    FreeOctetString(((nbpEntry_t *) (dp->data))->nbpObject);
	}
	((nbpEntry_t *) (dp->data))->nbpObject =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_nbpObject */

#ifdef I_nbpType
      case I_nbpType:

	SET_VALID(I_nbpType, ((nbpEntry_t *) (dp->data))->valid);

	if (((nbpEntry_t *) (dp->data))->nbpType != NULL) {
	    FreeOctetString(((nbpEntry_t *) (dp->data))->nbpType);
	}
	((nbpEntry_t *) (dp->data))->nbpType =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_nbpType */

#ifdef I_nbpZone
      case I_nbpZone:

	SET_VALID(I_nbpZone, ((nbpEntry_t *) (dp->data))->valid);

	if (((nbpEntry_t *) (dp->data))->nbpZone != NULL) {
	    FreeOctetString(((nbpEntry_t *) (dp->data))->nbpZone);
	}
	((nbpEntry_t *) (dp->data))->nbpZone =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_nbpZone */

#ifdef I_nbpState
      case I_nbpState:

	SET_VALID(I_nbpState, ((nbpEntry_t *) (dp->data))->valid);

	((nbpEntry_t *) (dp->data))->nbpState = value->sl_value;
	break;
#endif				       /* I_nbpState */

      default:
	DPRINTF((0, "snmpd: Internal error (invalid nominator in nbpEntry)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
nbpEntry_set(doList_t *doHead, doList_t *doCur, ContextInfo *contextInfo)
{
    return (k_nbpEntry_set((nbpEntry_t *) (doCur->data),
			   contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the atecho family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
atecho_get(OID *incoming, ObjectInfo *object, int searchType,
	   ContextInfo *contextInfo, int serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = -1;
    void           *dp;
    atecho_t       *data = NULL;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1 and the single
     * instance element be 0.
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    switch (searchType) {
      case EXACT:
	if (instLength == 1 && incoming->oid_ptr[incoming->length - 1] == 0) {
	    arg = object->nominator;
	}
	break;

      case NEXT:
	if (instLength <= 0) {
	    arg = object->nominator;
	}
	break;

    }

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_atecho_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_atechoRequests
      case I_atechoRequests:
	dp = &data->atechoRequests;
	break;
#endif				       /* I_atechoRequests */

#ifdef I_atechoReplies
      case I_atechoReplies:
	dp = &data->atechoReplies;
	break;
#endif				       /* I_atechoReplies */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}


aarpEntry_t    *
k_aarpEntry_get(int serialNum, ContextInfo *contextInfo, int nominator,
		int searchType, long aarpIfIndex, OctetString *aarpNetAddress)
{
    static OctetString aarpPhysAddress;
    static OctetString aarpNetAddr; /* saved get-result, not instance */
    atalkidbtype        *idb;
    aarpentry_t    *p = NULL, *prep = NULL;
    ataddrtype      addr;
    
    if(!atalk_running)
	return (NULL);

    addr = OctetStringToUlong(aarpNetAddress);

    if(searchType == EXACT) {
	FOR_ALL_ATIDBS(idb) {
	    if ((prep = aarp_FindEntry(addr, idb)) != NULL &&
		prep->idb->phys_idb->hwptr->snmp_if_index == (uint) aarpIfIndex)
	    break;
	}
    } else {
	prep = NULL;
	p = aarp_GetNextEntry(NULL); /* get 1st entry */
	while (p) {
	    if (p->idb->phys_idb->hwptr->snmp_if_index < (uint)aarpIfIndex ||
		(p->idb->phys_idb->hwptr->snmp_if_index == (uint)aarpIfIndex &&
		 p->proto_addr < addr)) 
		goto next_aarpEntry;
	    if (prep != NULL) {
		if (p->idb->phys_idb->hwptr->snmp_if_index > prep->idb->phys_idb->hwptr->snmp_if_index ||
		    (p->idb->phys_idb->hwptr->snmp_if_index == prep->idb->phys_idb->hwptr->snmp_if_index && 
		     p->proto_addr > prep->proto_addr)) 
		    goto next_aarpEntry;
	    }
	    prep = p;
	next_aarpEntry:
	    p = aarp_GetNextEntry(p); 
	}
    }

    if (prep == NULL)
        return (NULL);

    aarpEntryData.aarpIfIndex = prep->idb->phys_idb->hwptr->snmp_if_index;
    aarpEntryData.aarpPhysAddress = &aarpPhysAddress;
    aarpPhysAddress.length = IEEEBYTES;
    aarpPhysAddress.octet_ptr = prep->hw_addr;
    aarpEntryData.aarpNetAddress = &aarpNetAddr;
    aarpNetAddr.length = DDPBYTES;
    aarpNetAddr.octet_ptr = ((uchar*)&prep->proto_addr) + 1;

    return (&aarpEntryData);
}

atportEntry_t  *
k_atportEntry_get(int serialNum, ContextInfo *contextInfo, int nominator,
    int searchType, long atportIndex)
{
    static OctetString namestring; /* saved get-result, not instance */
    static OctetString netstart; 
    static OctetString netend; 
    static OctetString netaddress; 
    static OctetString zonename; 
    idbtype        *idb = NULL, *cur_idb = NULL;
    atalkidbtype *atalkidb;
    static ataddrtype addr;
    
    /* every swidb is viewed as a atport with valid or invalid status */

    if(searchType == EXACT) {
	if (atportIndex == 1)
	    idb = nullidb;
	else {
	    FOR_ALL_SWIDBS(idb) {
		if (idb->if_number == (ulong) atportIndex)
		    break;
	    }
	}
    } else {
	if (atportIndex <= 1)
	    idb = nullidb;
	else {
	    FOR_ALL_SWIDBS(cur_idb) {
		if (idb == NULL) {
		    if (cur_idb->if_number >= (ulong) atportIndex) 
			idb = cur_idb;
		} else {
		    if ((cur_idb->if_number >= (ulong) atportIndex) &&
			(cur_idb->if_number < idb->if_number))
			idb = cur_idb;
		}
	    }
	}
    }
    if (idb == NULL)
        return (NULL);

    atalkidb = atalk_getidb(idb);
    if (atalkidb == NULL)
	return (NULL);
    
    atportEntryData.atportIndex = idb->if_number;
    atportEntryData.atportDescr = &namestring;
    namestring.length = strlen(idb->namestring);
    namestring.octet_ptr = idb->namestring;
    atportEntryData.atportType = snmp_atportType(idb);
    atportEntryData.atportNetStart = &netstart;
    netstart.length = DDPNETBYTES;
    netstart.octet_ptr = (uchar *)&atalkidb->atalk_cablestart;
    atportEntryData.atportNetEnd = &netend;
    netend.length = DDPNETBYTES;
    netend.octet_ptr = (uchar *)&atalkidb->atalk_cableend;
    atportEntryData.atportNetAddress = &netaddress;
    netaddress.length = DDPBYTES;
    addr = atalkif_MyAddress(atalkidb);
    netaddress.octet_ptr = ((uchar *)&addr) + 1;
    atportEntryData.atportStatus = snmp_atportStatus(idb);
    atportEntryData.atportNetConfig = snmp_atConfigBy(idb);
    atportEntryData.atportZoneConfig = snmp_atConfigBy(idb);
    atportEntryData.atportZone = &zonename;
    if (atalkidb->zonelist != NULL && atalkidb->zonelist->zone != NULL) {
	zonename.length = atalkidb->zonelist->zone->length;
	zonename.octet_ptr = atalkidb->zonelist->zone->name;
    } else {
	zonename.length = 0;
	zonename.octet_ptr = NULL;
    }
    atportEntryData.atportIfIndex = idb->hwptr->snmp_if_index;

    return (&atportEntryData);
}

int
k_atportEntry_set(atportEntry_t *data, ContextInfo *contextInfo, int function)
{

    return (GEN_ERROR);
}

ddp_t          *
k_ddp_get(int serialNum, ContextInfo *contextInfo, int nominator)
{
    ddpData.ddpOutRequests = atalk_stat[ATALK_DDP_CREATED];
    ddpData.ddpOutShorts = 0;
    ddpData.ddpOutLongs = atalk_stat[ATALK_OUTPUT];
    ddpData.ddpInReceives = atalk_stat[ATALK_INPUT];
    ddpData.ddpForwRequests = atalk_stat[ATALK_FORWARDED] \
                            + atalk_stat[ATALK_FASTFORWARD] \
                            + atalk_stat[ATALK_XFASTFORWARD];
    ddpData.ddpInLocalDatagrams = atalk_stat[ATALK_LOCALDEST];
    ddpData.ddpNoProtocolHandlers = atalk_stat[ATALK_NO_HANDLER];
    ddpData.ddpOutNoRoutes = atalk_stat[ATALK_NOROUTE];
    ddpData.ddpTooShortErrors = atalk_stat[ATALK_DDP_2SHORT_ERR];
    ddpData.ddpTooLongErrors = atalk_stat[ATALK_DDP_2LONG_ERR];
    ddpData.ddpBroadcastErrors = atalk_stat[ATALK_BCAST_NOTMINE];
    ddpData.ddpShortDDPErrors = 0;
    ddpData.ddpHopCountErrors = atalk_stat[ATALK_HOPCOUNT];
    ddpData.ddpChecksumErrors = atalk_stat[ATALK_CKSUMERR];

    return (&ddpData);
}

rtmpEntry_t    *
k_rtmpEntry_get(int serialNum, ContextInfo *contextInfo, int nominator,
		int searchType, OctetString *rtmpRangeStart)
{

    static OctetString netstart; 
    static OctetString netend; 
    static OctetString netaddress; 
    ushort net;
    atalk_rdb_t *p;
    rbTree *tree;

    if(!atalk_running)
	return (NULL);

    net = OctetStringToUlong(rtmpRangeStart);
    p = NULL;
    tree = atroute_GetTree();

    if(searchType == EXACT) {
	p = atroute_LookupRoute(tree, net, TRUE);
    } else {
	for (p = GetFirstRoute(tree); p != NULL; p = GetNextRoute(tree, p)) {
	    if (p->dstrngstr >= net && p->rpath.idb != NULL) 
		break;
	}
    }

    if (p == NULL || p->rpath.idb == NULL)
	return (NULL);

    rtmpEntryData.rtmpRangeStart = &netstart;
    netstart.length = DDPNETBYTES;
    netstart.octet_ptr = (uchar *)&p->dstrngstr;
    rtmpEntryData.rtmpRangeEnd = &netend;
    netend.length = DDPNETBYTES;
    netend.octet_ptr = (uchar *)&p->dstrngend;
    rtmpEntryData.rtmpNextHop = &netaddress;
    netaddress.length = DDPBYTES;
    netaddress.octet_ptr = ((uchar *)&p->rpath.gateway) + 1;
    if(p->rpath.idb->phys_idb->subif_link_type == SUBIF_TYPE_MULTI)
	rtmpEntryData.rtmpType = D_rtmpType_appletalk; 
    else if(p->rpath.idb->phys_idb->subif_link_type == SUBIF_TYPE_P2P)
	rtmpEntryData.rtmpType = D_rtmpType_serial_ppp; 
    else 
	rtmpEntryData.rtmpType = D_rtmpType_other;
    rtmpEntryData.rtmpPort = p->rpath.idb->phys_idb->if_number;
    rtmpEntryData.rtmpHops = p->rpath.metric.u.rtmp.hops;
    if (p->rpath.state == at_state_good)
	 rtmpEntryData.rtmpState = D_rtmpState_good;
    else if (p->rpath.state == at_state_suspect)
	rtmpEntryData.rtmpState = D_rtmpState_suspect;
    else if (p->rpath.state == at_state_bad1)
	rtmpEntryData.rtmpState = D_rtmpState_goingBad;
    else if (p->rpath.state == at_state_delete)
	rtmpEntryData.rtmpState = D_rtmpState_bad;
    else
	rtmpEntryData.rtmpState = D_rtmpState_bad;

    return (&rtmpEntryData);
}

int
k_rtmpEntry_set(rtmpEntry_t *data, ContextInfo *contextInfo, int function)
{

    return (GEN_ERROR);
}


zipEntry_t     *
k_zipEntry_get(int serialNum, ContextInfo *contextInfo, int nominator,
	       int searchType, OctetString *zipZoneNetStart, long zipZoneIndex)
{
    static OctetString zonename; 
    static OctetString netstart; 
    static OctetString netend; 
    ushort net;
    ulong i = 0;
    atalk_rdb_t *p;
    zipnetentry *z;
    zipnetentry *z1;
    rbTree *tree;

    if(!atalk_running)
	return (NULL);

    net = OctetStringToUlong(zipZoneNetStart);
    p = NULL;
    z = NULL;
    z1 = NULL;
    tree = atroute_GetTree();

    /* zoneIndex is defined as 0x aaaabbbb where aaaa is just a sequence 
       number, starting from 1, bbbb is the netstart of first net of this 
       zone */
    if(searchType == EXACT) {
	p = atroute_LookupRoute(tree, net, TRUE);
	if (p != NULL) {
	    for (z = atalk_firstZone(p); z != NULL ; z = atalkzn_nextZone(z)) {
		z1 = atalk_firstNet(z->zone);
		if ((z1 != NULL) && 
		    (((ulong)(z1->net->dstrngstr) + i) == zipZoneIndex))
		    break;
		else
		    i = i + 0x10000;
	    }
	}
    } else { /* get next */
	for (p = GetFirstRoute(tree); p != NULL; p = GetNextRoute(tree, p)) {
	    i = 0;
	    if (p->dstrngstr >= net) {
		if (p->dstrngstr == net) {
		    for (z = atalk_firstZone(p); 
			 z != NULL; z = atalkzn_nextZone(z)) {
			z1 = atalk_firstNet(z->zone);
			if ((z1 != NULL) &&
			    (((ulong)(z1->net->dstrngstr) + i) >= zipZoneIndex))
			    break;
			else
			    i = i + 0x10000;
		    }
		} else { /* dstrngstr > net */
		    z = atalk_firstZone(p);
		    if (z != NULL)
			z1 = atalk_firstNet(z->zone);
		}
	    if (z != NULL && z1 != NULL)
		break;
	    }
	}
    }

    if (z == NULL || z1 == NULL)
	return (NULL);

    zipEntryData.zipZoneName = &zonename;
    zonename.length = z->zone->length;
    zonename.octet_ptr = z->zone->name;
    zipEntryData.zipZoneIndex = ((ulong) z1->net->dstrngstr) + i;
    zipEntryData.zipZoneNetStart = &netstart;
    netstart.length = DDPNETBYTES;
    netstart.octet_ptr = (uchar *)&z->net->dstrngstr;
    zipEntryData.zipZoneNetEnd = &netend;
    netend.length = DDPNETBYTES;
    netend.octet_ptr = (uchar *)&z->net->dstrngend;
    zipEntryData.zipZoneState = D_zipZoneState_valid;
    
    return (&zipEntryData);
}

int
k_zipEntry_set(zipEntry_t *data, ContextInfo *contextInfo, int function)
{

    return (GEN_ERROR);
}

nbpEntry_t     *
k_nbpEntry_get(int serialNum, ContextInfo *contextInfo, int nominator,
	       int searchType, long nbpIndex)
{
    static OctetString objectname; 
    static OctetString typename; 
    static OctetString zonename; 

    if(!atalk_running)
	return (NULL);

    if(searchType == EXACT) {
	if(nve_snmpget(nbpIndex, &objectname.octet_ptr, &typename.octet_ptr,
		       &zonename.octet_ptr) == FALSE)
	    return (NULL);
    } else {
	if (nbpIndex == 0)
	    nbpIndex = 1;
	if(nve_snmpget(nbpIndex, &objectname.octet_ptr, &typename.octet_ptr,
		       &zonename.octet_ptr) == FALSE)
	    return (NULL);
    }

    nbpEntryData.nbpIndex = nbpIndex;
    nbpEntryData.nbpObject = &objectname;
    objectname.length = strlen(objectname.octet_ptr);
    nbpEntryData.nbpType = &typename;
    typename.length = strlen(typename.octet_ptr);
    nbpEntryData.nbpZone = &zonename;
    zonename.length = strlen(zonename.octet_ptr);
    nbpEntryData.nbpState = D_nbpState_valid;

    return (&nbpEntryData);
}

int
k_nbpEntry_set(nbpEntry_t *data, ContextInfo *contextInfo, int function)
{

    return (GEN_ERROR);
}

atecho_t       *
k_atecho_get(int serialNum, ContextInfo *contextInfo, int nominator)
{
    atechoData.atechoRequests = atalk_stat[ATALK_ECHO];
    atechoData.atechoReplies = atalk_stat[ATALK_ECHO_REPLIES];

    return (&atechoData);
}

static ulong
snmp_atportType(idbtype *swidb)
{
    atalkidbtype *idb;

    idb = atalk_getidb(swidb);

    if (idb == NULL)
	return OTHER;
    
    if (is_tunnel(swidb->hwptr) &&
	swidb->hwptr->tunnel->mode == TUN_MODE_IPTALK_UDP)
	return (D_atportType_iptalk);
    if (idb->atalk_enctype == ET_PPP)
	return (D_atportType_serial_ppp);
    if ((idb->atalk_enctype == ET_ETHERTALK) && 
	(swidb->hwptr->status & IDB_ETHER))
	return (D_atportType_ethertalk1);
    if (idb->atalk_enctype == ET_SNAP) {
	if (swidb->hwptr->status & IDB_TR)
	    return (D_atportType_tokentalk);
	if (swidb->hwptr->status & IDB_ETHER)
	    return (D_atportType_ethertalk2);
    }
    return (OTHER);
}

static ulong
snmp_atportStatus(idbtype *swidb)
{
    atalkidbtype *idb;

    idb = atalk_getidb(swidb);

    if (idb == NULL)
	return (D_atportStatus_unconfigured);
    else if (idb->atalk_enabled != TRUE)
	return (D_atportStatus_invalid);
    else if (atalkif_operational(idb))
	return (D_atportStatus_operational);
    else
	return (D_atportStatus_unconfigured);
}

static ulong
snmp_atConfigBy(idbtype *swidb)
{
    atalkidbtype *idb;

    idb = atalk_getidb(swidb);

    if (idb == NULL)
	return (D_atportNetConfig_unconfigured); /* not even as a end node */	
    if (atalkif_operational(idb)) {
	if (idb->atalk_discovery != TRUE) {
	    return (D_atportNetConfig_configured);
	} else { /* discovery desired */
	    if (idb->atalk_confaddr != 0)
		return (D_atportNetConfig_garnered); /* configured by another device */
	    else
		return(D_atportNetConfig_unconfigured); /* function as end node but not 
					 configured as a router */; 
	}
    } else /* not operational */
	return (D_atportNetConfig_unconfigured); /* not even as a end node */
}
       



/*
 * atalkmib subsystem header
 */

#define MAJVERSION_atalkmib 1
#define MINVERSION_atalkmib 0
#define EDITVERSION_atalkmib 0

SUBSYS_HEADER(atalkmib,
              MAJVERSION_atalkmib,
              MINVERSION_atalkmib,
              EDITVERSION_atalkmib,
              init_rfc1243,
              SUBSYS_CLASS_MANAGEMENT,
              "req: atalk",
              NULL);


      
