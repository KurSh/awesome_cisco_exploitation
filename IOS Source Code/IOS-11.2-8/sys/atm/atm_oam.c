/* $Id: atm_oam.c,v 3.9.8.7 1996/09/08 03:02:22 rzagst Exp $
 * $Source: /release/112/cvs/Xsys/atm/atm_oam.c,v $
 *------------------------------------------------------------------
 * A T M _ O A M . C
 *
 * This module deals with the ATM OAM cells.  These include F5 Loopback
 * as well as AIS & FERF type cells.
 *
 * January 1995, Ricky Li Fo Sjoe
 *
 * Copyright (c) 1995-1997 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 * $Log: atm_oam.c,v $
 * Revision 3.9.8.7  1996/09/08  03:02:22  rzagst
 * CSCdi62883:  debug atm packet shows incorrect message for oam cells
 * Branch: California_branch
 * Use a status to prevent oam and inarp timers from being started when
 * running or stopped when not running.
 *
 * Revision 3.9.8.6  1996/08/03  23:17:33  fox
 * CSCdi63400:  high priority compatibility queue must die
 * Branch: California_branch
 * Remove high priority compatibility queue and activatehigh flag.
 * Convert high priority cfork'd processes to new-style processes with
 * watched queues, timers, and booleans.  Split Multilink PPP input
 * into separate high priority process.  Split load and busy calculations
 * into separate processes.  Speed up PPP input and scheduler processing.
 * Miscellaneous code changes.
 *
 * Revision 3.9.8.5  1996/07/10  22:20:02  dstine
 * CSCdi62471:  Superfluous #include files in atalk, atm, os files
 * Branch: California_branch
 *
 * Revision 3.9.8.4  1996/06/29  22:04:19  rzagst
 * CSCdi59683:  OAM cells are not transmitted after ATM int was shut/noshut
 * Branch: California_branch
 *
 * Revision 3.9.8.3  1996/06/28  23:05:10  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.9.8.2  1996/05/21  09:43:01  thille
 * CSCdi51599:  multiple /interface/ literals bloat code.
 * Branch: California_branch
 * Save another 392 bytes by doing away with duplicate literals.
 *
 * Revision 3.9.8.1  1996/03/18  18:59:30  gstovall
 * Branch: California_branch
 * Elvis has left the building.  He headed out to California, and took the
 * port ready changes with him.
 *
 * Revision 3.4.14.3  1996/03/16  06:27:55  gstovall
 * Branch: DeadKingOnAThrone_branch
 * Make the king aware of V111_1_3.
 *
 * Revision 3.4.14.2  1996/03/07  08:30:17  mdb
 * Branch: DeadKingOnAThrone_branch
 * cisco and ANSI/POSIX libraries.
 *
 * Revision 3.4.14.1  1996/02/20  00:18:45  dstine
 * Branch: DeadKingOnAThrone_branch
 *         Sync from DeadKingOnAThrone_baseline_960122 to
 *                   DeadKingOnAThrone_baseline_960213
 *
 * Revision 3.9  1996/02/27  19:26:53  achopra
 * CSCdi45189:  "show atm traffic" shows different (wrong) packet counts
 *
 * Revision 3.8  1996/02/13  19:50:14  hampton
 * Remove unnecessary includes.  [CSCdi48844]
 *
 * Revision 3.7  1996/02/01  05:59:36  hampton
 * Migrate files out of the parser directory.  [CSCdi47717]
 *   Step 2: Change all files which reference the moved parser files to
 *   point to their new locations.
 *
 * Revision 3.6  1996/01/30  20:10:00  rzagst
 * CSCdi46580:  debug atm packet needs to filter on an interface or vc
 * basis
 *
 * Revision 3.5  1996/01/29  07:26:21  hampton
 * Remove unnecessary includes of parser definition files.  [CSCdi47717]
 *
 * Revision 3.4  1995/12/17  18:24:42  thille
 * CSCdi45760: Parser needs to go on a diet.
 * Move object files that are not part of parser to os_exec or libutil.a
 * as appropriate.  Rename parser files to make it clear what is part of
 * parser and avoid other stuff accumulating.  Modify files that include
 * parser .h files to deal with new names.
 *
 * Revision 3.3  1995/11/17  08:45:49  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.2  1995/11/16  23:07:02  gstovall
 * Ladies and gentlemen, I introduce to you, the port ready commit.
 *
 * Revision 3.1  1995/11/09  10:59:37  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.4  1995/08/10  23:29:51  wfried
 * CSCdi37608:  oam f5 cells generated by 4500 are not recognized by
 * analyzer
 * Changed ATM code to pass VC pointer for OAM cells and other related
 * changes
 *
 * Revision 2.3  1995/08/10  00:59:54  awu
 * CSCdi37887:  ATM OAM cells are transmitted and received incorrect.
 *
 * Revision 2.2  1995/06/18  06:18:00  hampton
 * Change all processes that set their priority to use the new scheduler
 * calls for this purpose. [CSCdi36039]
 *
 * Revision 2.1  1995/06/07 20:11:24  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

#include "master.h"
#include <string.h>
#include <ciscolib.h>
#include "sys_registry.h"
#include "interface_private.h"
#include "packet.h"
#include "config.h"
#include "../ui/debug.h"
#include "../if/network.h"
#include "../if/atm_debug_flags.h"
#include "../if/atm.h"
#include "../snmp/snmp_api.h"
#include "mgd_timers.h"
#include "atmsig_api.h"
#include "../if/static_map.h"
#include "atmsig_private.h"
#include "../atm/atmsig_smap.h"
#include "../atm/atm_oam.h"


#define	OAM_SWITCHCOUNT		100  /* # of OAM cells to handle in one shot */

watched_queue *atm_oam_packetQ;       /* OAM packets */
static boolean atm_oam_enabled = FALSE;

static mgd_timer master_timer;
static mgd_timer master_oam_timer;
/*
 * Locals
 */
static unsigned oam_gfc, oam_vpi, oam_vci, oam_pti, oam_clp;
static unsigned oam_type, oam_func, oam_loopind;
static boolean	segment;	/* 0=Segment, 1=End-to-End indicator */
static ushort return_dm;

/*
 * atm_oam_encap:      Called by OAM layer to send an OAM cell out
 * OUTPUT/
 */
static boolean
atm_oam_encap(paktype *pak, vc_info_t *vc)
{
    idbtype     *idb;
    hwidbtype   *hwout;
    atm_db_t    *atm;
    atm_oam_hdr_t  	*oam;
    atm_loopback_t *oam_loop;
    unsigned	 ndx;
    atm_oam_type_func_t *oam_type_func_ptr;

    idb = pak->if_output;
    hwout = pak->if_output ? pak->if_output->hwptr : 0;
    if (!atm_interface_up(idb)) {
       if (atm_errors_debug)
          buginf("\nATM(%s): ATM not active yet(oam_encap)", 
	    hwout->hw_namestring);
       return(FALSE);
    }

    atm = hwout->atm_db;
    pak->encsize = 0;

    oam = (atm_oam_hdr_t *)pak->datagramstart;
    oam->oam_vpi = vc->vpi;
    oam->oam_vci_ms = ATM_GET_VCI_MS(vc->vci);
    oam->oam_vci_ls = ATM_GET_VCI_LS(vc->vci);
    oam->oam_pt = ATM_OAM_F5_ENDTOEND;
    
    oam_type_func_ptr = (atm_oam_type_func_t *)oam->data;
    oam_type_func_ptr->oam_type = ATM_OAM_FAULT_MGMT;
    oam_type_func_ptr->oam_func = ATM_OAM_LOOP_FUNC;
    
    oam_loop = (atm_loopback_t *)oam_type_func_ptr->data;

    /*
     * Set UNUSED fields to 0x6A as per UNI3.1
     */
    for (ndx = 0; ndx < ATM_OAM_FILLBYTES; ndx++) {
	oam_loop->oam_fill[ndx] = ATM_OAM_FILL;
    }
    /*
     * Set SourceID to all 1's.  This is the default as per UNI3.1
     * Set Loopback Location ID to all 1's.  This is the default as per UNI3.1
     */
    for (ndx = 0; ndx < ATM_OAM_UNUSEDBYTES; ndx++) {
	oam_loop->src_id[ndx] = 0xFF;
	oam_loop->loc_id[ndx] = 0xFF;
    }
    PUTLONG(oam_loop->ctag, ++vc->corr_oam);
    oam_loop->loop_ind = 1;		/* Required to be 1 */
    pak->encsize += (*atm->funcs.encapsulate)(atm, pak, vc, AIP_DM_PKT_OAM_DM);
    pak->datagramsize = ATM_OAM_CELL_SIZE - ATM_CELLHDR_HEC_BYTES +
	pak->encsize;

    atm_show_packet(hwout, pak, TRUE);

    atm_counters[ATM_OAM_OUTPUT_CELLS]++;
    atm_counters[ATM_OUTPUT]++;		/* Count as output packets */
    atm->outpkts++;

    return(TRUE);
}

/*
 * atm_oam_periodic()
 */
static void
atm_oam_periodic(void)
{
    vc_info_t *vc;
    mgd_timer *expired_timer;
    paktype *newpak;
    atmSvcType *found_svc;

    while (mgd_timer_expired(&master_timer)) {
	expired_timer = mgd_timer_first_expired(&master_timer);
	vc = mgd_timer_context(expired_timer);
	if (!vc) {
	    continue;
	}
	mgd_timer_stop(&vc->oam_timer);

	if (atm_oam_debug) {
	    /* Only print this message if we are not filtering oam debug
             * in which case atm_debug_swidb will be NULL
             * or if we are filtering on this interface in which
             * case atm_debug_swidb{ATM_OAM_FILTERING] will == vc->swidb
             */
	  if ((atm_debug_swidb[ATM_OAM_FILTERING] == NULL) ||
	      (vc->swidb == atm_debug_swidb[ATM_OAM_FILTERING])) {
	    buginf("\nATM OAM(%s): Timer: VCD#%d Status:%d CTag:%d Tries:%d",              vc->swidb->namestring, vc->vc, vc->oam_status, 
		   vc->corr_oam, vc->oam_retries);
	  }
	}
	switch(vc->oam_status) {
	case ATM_OAM_FAILED:		/* Got an OAM, it was BAD */
	    vc->oam_status = ATM_OAM_SENT;
   	    mgd_timer_start(&vc->oam_timer, vc->oam * ONESEC);
	    break;
	case ATM_OAM_SENT:		/* Sent one, but no reply */
	    /*
	     * OAM failed on this VCD.  Shutdown VCC? 
	     */
	    if (++vc->oam_retries > MAX_OAM_RETRIES && IS_ATMVC_SVC(vc)) {
		    vc->oam_status = ATM_OAM_FAILED;
		found_svc = atmSig_findSvcBlockByVC(vc->swidb,
					    vc->vc);
		if (found_svc)
	  	    atmSmap_closeSvcConnection(found_svc); 
		if (atm_errors_debug) {
		    buginf("\nATM(%s): VCD#%d failed to echo OAM. VCD shutdown",
			vc->swidb->namestring, vc->vc);
		}
		break;
	    } else {
		if (atm_errors_debug) {
		      buginf("\nATM(%s): VCD#%d failed to echo OAM. %d tries",
			vc->swidb->namestring, vc->vc, vc->oam_retries);
		}
	    }
	    /*
	     * Fall thru & send another OAM now.
	     */
	case ATM_OAM_RECEIVED:		/* Got a valid reply */
	    /*
	     * OAM loopback was received.  VCC is still alive.
	     */
    	    newpak = getbuffer(SMALLDATA);
    	    if(!newpak) {
		    continue;
   	    }
	    memset(newpak->datagramstart, 0, SMALLDATA);
	    newpak->if_output = vc->swidb;
	    if(atm_oam_encap(newpak, vc)) {
		if (atm_oam_debug) {
		  /* Only print this message if we are not filtering oam debug
		   * in which case atm_debug_swidb[ATM_OAM_FILTERING] will
		   * be NULL or if we are filtering on this interface in
		   * which case atm_debug_swidb[ATM_OAM_FILTERING] will
		   * == vc->swidb
		   */
		  if ((atm_debug_swidb[ATM_OAM_FILTERING] == NULL) || 
		      (vc->swidb == atm_debug_swidb[ATM_OAM_FILTERING])) {
		    buginf("\nATM OAM LOOP(%s) O: VCD#%d CTag:%x",
			   vc->swidb->namestring, vc->vc, vc->corr_oam);
		  }
		}
	 	datagram_out(newpak);
		vc->out_oam++;
		vc->oam_status = ATM_OAM_SENT;
    		mgd_timer_start(&vc->oam_timer, vc->oam * ONESEC);
	    }
	    break;
	case ATM_OAM_DISABLED:	/* Nothing to do.  OAM disabled */
	default:
	    break;

	}
    }
}

/*
 * Handle the 3 basic OAM cells, LoopBACK, AIS & FERF
 */
static void
atm_oam_loopback(paktype *pak)
{
    atm_loopback_t *loopb;
    vc_info_t *vc;
    hwidbtype *hwidb;
    idbtype *idb;
    atm_db_t *atm;
    unsigned corr_tag;

    idb = pak->if_input;
    hwidb = pak->if_input ? pak->if_input->hwptr : 0;
    atm = hwidb->atm_db;
    pak->datagramstart += ATM_ENCAP_HDRBYTES;
    pak->datagramsize -= ATM_ENCAP_HDRBYTES;
    loopb = (atm_loopback_t *)(pak->datagramstart + ATM_CELL_ENCAPBYTES +
	ATM_OAM_ENCAPBYTES);
    /*
     * Check the VCD to see if it really exists
     */
    vc = atm_vpivci_to_vc(hwidb->atm_db, oam_vpi, oam_vci);
    if (!vc) {
	if (atm_errors_debug) {
    	    buginf("\nATM OAM LOOP(%s): No VCD for OAM cell VPI:%d VCI:%d",
		idb->namestring, oam_vpi, oam_vci);
	}
    	datagram_done(pak);
    	return;
    }
    vc->in_oam++;
    corr_tag = GETLONG(loopb->ctag);
    if (atm_oam_debug) {
	if ((atm_debug_swidb[ATM_OAM_FILTERING] == NULL) || 
	    (vc->swidb == atm_debug_swidb[ATM_OAM_FILTERING])) {
	    buginf("\nATM OAM LOOP(%s) I: VCD#%d LoopInd:%d CTag:%x",
		   idb->namestring, vc->vc, loopb->loop_ind, corr_tag);
	}
    }
    /*
     * LOOPBACK......  If the loop_ind == 1 it's valid.  We simply
     * decrement loop_ind and send the packet back the way it came.
     * If loop_ind != 1 then just drop the cell.
     */
    switch(loopb->loop_ind) {
    case 0:		/* Received answer to our loopback */
	if (corr_tag != vc->corr_oam) {
	    if(atm_errors_debug) {
		buginf("\nATM_OAM(%s): Bad Correlation tag.  Received 0x%x, Expected 0x%x from VPI:%d VCI:%d",
			hwidb->hw_namestring, corr_tag, vc->corr_oam, 
			oam_vpi, oam_vci);
	    }
	    vc->oam_status = ATM_OAM_FAILED;	/* It failed */
	} else {
    	    vc->oam_status = ATM_OAM_RECEIVED;	/* Set it received */
    	    vc->oam_retries = 0;
	}
    	datagram_done(pak);
	break;
    case 1:
	/*
	 * Received an OAM cell we *MUST* echo to the sender.
	 */
	loopb->loop_ind--;
	pak->if_output = pak->if_input;
        pak->encsize = (*atm->funcs.encapsulate)(atm, pak, vc, return_dm);
	atm_show_packet(hwidb, pak, TRUE);
	if (atm_oam_debug) {
	    if ((atm_debug_swidb[ATM_OAM_FILTERING] == NULL) || 
		(vc->swidb == atm_debug_swidb[ATM_OAM_FILTERING])) {
		buginf("\nATM OAM LOOP(%s) O: VCD#%d CTag:%x",
		       vc->swidb->namestring, vc->vc, vc->corr_oam);
	    }
	}
	
	datagram_out(pak);
	atm_counters[ATM_OAM_OUTPUT_CELLS]++;
        atm_counters[ATM_OUTPUT]++;		/* Count as output packets */
	atm->outpkts++;
	vc->out_oam++;
	break;
    default:		/* UNI3.1 says we discard these */
	if (atm_errors_debug) {
	    buginf("\nATM_OAM(%s): Bad loop indicator %d received for VPI:%d, VCI:%D",
		hwidb->hw_namestring, loopb->loop_ind, oam_vpi, oam_vci);
	}
	datagram_done(pak);
	break;
    }
}

static void
atm_oam_ais(paktype *pak)
{
    atm_ais_ferf_t *ais;
    hwidbtype *hwidb;
    vc_info_t *vc;
    atm_db_t *atm;
    atm_oam_type_func_t *oam_type_func_ptr;

    hwidb = pak->if_input ? pak->if_input->hwptr : 0;
    atm = hwidb->atm_db;
    pak->datagramstart += ATM_ENCAP_HDRBYTES;
    pak->datagramsize -= ATM_ENCAP_HDRBYTES;
    ais = (atm_ais_ferf_t *)(pak->datagramstart + ATM_CELL_ENCAPBYTES +
	ATM_OAM_ENCAPBYTES);
    if (atm_oam_debug) {
	if ((atm_debug_swidb[ATM_OAM_FILTERING] == NULL) || 
		      (atm_debug_swidb[ATM_OAM_FILTERING]->hwptr == hwidb)) {
	    buginf("\naip_raw_input(%s): AIS signal, failure=0x%x",
		   hwidb->hw_namestring, ais->failure);
	}
    }
    if (ais->failure != ATM_AIS_FAIL) {
	datagram_done(pak);
	return;
    }
    /*
     * Check the VCD to see if it really exists
     */
    vc = atm_vpivci_to_vc(atm, oam_vpi, oam_vci);
    if (!vc) {
	if (atm_errors_debug) {
    	    buginf("\nATM_OAM_PROCESS(): No VCD for OAM cell");
	}
    	datagram_done(pak);
    	return;
    }
    vc->in_oam++;

    oam_type_func_ptr = (atm_oam_type_func_t *) (pak->datagramstart + ATM_CELL_ENCAPBYTES);
    oam_type_func_ptr->oam_func = ATM_OAM_FERF_FUNC; 

    pak->if_output = pak->if_input;
    pak->encsize = (*atm->funcs.encapsulate)(atm, pak, vc, return_dm);
    atm_show_packet(hwidb, pak, TRUE);
    datagram_out(pak);
    atm_counters[ATM_OAM_OUTPUT_CELLS]++;
    atm_counters[ATM_OUTPUT]++;		/* Count as output packets */
    atm->outpkts++;
    vc->out_oam++;
}

static void
atm_oam_ferf(paktype *pak)
{
    atm_ais_ferf_t *ais;
    hwidbtype *hwidb;

    hwidb = pak->if_input ? pak->if_input->hwptr : 0;
    ais = (atm_ais_ferf_t *)(pak->datagramstart + ATM_CELL_ENCAPBYTES +
	ATM_OAM_ENCAPBYTES);

    if (atm_oam_debug) {
	if ((atm_debug_swidb[ATM_OAM_FILTERING] == NULL) || 
	    (atm_debug_swidb[ATM_OAM_FILTERING]->hwptr == hwidb)) {
	    buginf("\naip_raw_input(%s): FERF signal, failure=0x%x",
		   hwidb->hw_namestring, ais->failure);
	}
    }
    if (ais->failure != ATM_AIS_FAIL) {
	datagram_done(pak);
	return;
    }
    /*
     * RLFS:
     * Code neede to fill this zone.  What to do with FERF notification?
     * SNMP TRAP? Bring the link down?
     */
    datagram_done(pak);
}

/*
 * atm_oam_process
 * handle incoming OAM packets
 */
static process 
atm_oam_process (void)
{
    int pak_count;
    hwidbtype *hwidb;
    paktype *pak;
    atm_db_t *atm;
    atm_oam_hdr_t	*oam_hdr_ptr;
    atm_oam_type_func_t *oam_type_func_ptr;
    atm_loopback_t *oam_loopback_ptr;

    process_wait_on_system_init();

    /*
     * Set up this process' world.
     */
    atm_oam_packetQ = create_watched_queue("ATM OAM Input", 40, 0);
    process_watch_queue(atm_oam_packetQ, ENABLE, RECURRING);

    while (TRUE) {
	process_wait_for_event();

	pak_count = OAM_SWITCHCOUNT;

	while (TRUE) {
	    /*
 	     * Process only a limited number of packets per pass
	     */
	    if (pak_count-- == 0) {
		break;
	    }

	    pak = process_dequeue(atm_oam_packetQ);
	    if (pak == NULL) {
		break;
	    }
            hwidb = pak->if_input ? pak->if_input->hwptr : 0;
            if (!hwidb) {
	    	buginf("\nATM_OAM_PROCESS(): source idb not set");
	    	datagram_done(pak);
	    	continue;
            }
 	    atm = hwidb->atm_db;
	    atm_show_packet(hwidb, pak, FALSE);
    	    atm_counters[ATM_OAM_INPUT_CELLS]++;
    	    atm_counters[ATM_INPUT]++;		/* Count as input packets */
	    atm->inpkts++;
	    segment = FALSE;
	    return_dm = 0;
	    
	    oam_hdr_ptr = (atm_oam_hdr_t *) (pak->datagramstart + ATM_ENCAP_HDRBYTES);
	    oam_gfc = oam_hdr_ptr->oam_gfc;
	    oam_vpi = oam_hdr_ptr->oam_vpi;
	    oam_vci = ATM_CONSTRUCT_VCI(oam_hdr_ptr->oam_vci_ms,
					oam_hdr_ptr->oam_vci_ls);
	    oam_pti = oam_hdr_ptr->oam_pt;
	    oam_clp = oam_hdr_ptr->oam_clp;
	    
	    oam_type_func_ptr = (atm_oam_type_func_t *)oam_hdr_ptr->data;
	    oam_type = oam_type_func_ptr->oam_type;
	    oam_func = oam_type_func_ptr->oam_func;

	    oam_loopback_ptr = (atm_loopback_t *)oam_type_func_ptr->data;
	    oam_loopind = oam_loopback_ptr->loop_ind; 

    	    /*
    	     * At this point we check everything to make sure we're 
	     * dealing with a real F4/F5 packet.
    	     */
    	    if (oam_type != ATM_OAM_FAULT_MGMT) {
    	        if (atm_errors_debug) {
  	    	    buginf("\naip_raw_input(%s): bad OAM type %x", 
	    		hwidb->hw_namestring, oam_type);
		}
		datagram_done(pak);
		continue;
    	    }

    	    /*
    	     * Figure out if we've got end-to-end or segment functionality
    	     */
    	    if (oam_vci == ATM_OAM_F4_SEGMENT || 
	      oam_pti == ATM_OAM_F5_SEGMENT) {
		    segment = TRUE;
    	    } else 
       	        if (oam_vci == ATM_OAM_F4_ENDTOEND || 
	          oam_pti == ATM_OAM_F5_ENDTOEND) {
	    	    segment = FALSE;
    	    } else {
	        if (atm_errors_debug) {
  	    	    buginf("\naip_raw_input(%s): bad OAM function %x", 
		         hwidb->hw_namestring, oam_func);
	    	}
	    	datagram_done(pak);
		continue;
    	    }
    	    /* 
    	     * Set the DM value for a possible return packet.
    	     */
    	    if ((oam_vci == ATM_OAM_F4_SEGMENT) || 
      	      (oam_vci == ATM_OAM_F4_ENDTOEND)) {	/* F4 OAM cell */
	        return_dm = AIP_DM_PKT_OAM_VC;	/* Get PTI from VC table */
    	    } else {		/* Else, must be F5 OAM cell */
	        return_dm = AIP_DM_PKT_OAM_DM;	/* PTI from descriptor table */
    	    }
    	    /*
     	     * Now handle the particular function for each OAM cell.
    	     */
    	    switch (oam_func) {
    	    case ATM_OAM_AIS_FUNC:
		atm_oam_ais(pak);
	        break;
    	    case ATM_OAM_FERF_FUNC:
	    	atm_oam_ferf(pak);
		break;
    	    case ATM_OAM_LOOP_FUNC:
	    	atm_oam_loopback(pak);
		break;
    	    default:
	        if (atm_errors_debug) {
	    	    buginf("\naip_raw_input(%s): bad OAM function %x", 
			hwidb->hw_namestring, oam_func);
	        }
		datagram_done(pak);
		break;
    	    }
	}
    }
}

/*
 * atm_oam_enable_timer:	Enable managed timer for this VCC
 */
void
atm_oam_enable_timer(vc_info_t *vc_info, uint oam_time)
{
    if (vc_info && oam_time) {
	if (vc_info->oam_status != ATM_OAM_DISABLED)
	    return;
	vc_info->oam = oam_time;
    	mgd_timer_init_leaf(&vc_info->oam_timer, &master_oam_timer,
			0, vc_info, TRUE);
    	mgd_timer_start(&vc_info->oam_timer, vc_info->oam * ONESEC);
	vc_info->oam_status = ATM_OAM_RECEIVED;	
    }
}

/* 
 * atm_oam_disable_timer:	Disable managed timer for this VCC
 */
void
atm_oam_disable_timer(vc_info_t *vc_info)
{
    if (vc_info && vc_info->oam) {
    	mgd_timer_stop(&vc_info->oam_timer);
	vc_info->oam_status = ATM_OAM_DISABLED;
    }
}

/*
 * atm_oam_init
 * Initialize the OAM queue
 */
void
atm_oam_init (void)
{
    if(!atm_oam_enabled) {
	(void) process_create(atm_oam_process, "ATM OAM Input", NORMAL_STACK,
			      PRIO_HIGH);
	mgd_timer_init_parent(&master_timer, NULL);
    	mgd_timer_init_parent(&master_oam_timer, &master_timer);
	reg_add_onesec(atm_oam_periodic, "ATM OAM Periodic");
	atm_oam_enabled = TRUE;
    }
}
      
