/* $Id: sr_flashmib.c,v 3.8.12.5 1996/07/03 20:40:57 thille Exp $
 * $Source: /release/112/cvs/Xsys/dev/sr_flashmib.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * April 1995, Shalabh Agarwal (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1995-1996 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 * $Log: sr_flashmib.c,v $
 * Revision 3.8.12.5  1996/07/03  20:40:57  thille
 * CSCdi61860: Implement Jeffs glass of slim-fast for snmp
 * Branch: California_branch
 * Take hunk of common code from many mib files, make it a procedure in
 * snmp_util.c and call it from the mibs.  Save 1640 bytes.
 *
 * Revision 3.8.12.4  1996/07/01  18:44:07  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.8.12.3  1996/04/22  18:57:56  ssangiah
 * CSCdi54920:  Need to add support for the flash MIB on c7200.
 * Branch: California_branch
 *
 * Revision 3.8.12.2  1996/04/19  17:57:06  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.8.12.1  1996/03/18  19:13:04  gstovall
 * Branch: California_branch
 * Elvis has left the building.  He headed out to California, and took the
 * port ready changes with him.
 *
 * Revision 3.6.6.2  1996/03/07  08:43:36  mdb
 * Branch: DeadKingOnAThrone_branch
 * cisco and ANSI/POSIX libraries.
 *
 * Revision 3.6.6.1  1996/02/20  00:44:52  dstine
 * Branch: DeadKingOnAThrone_branch
 *         Sync from DeadKingOnAThrone_baseline_960122 to
 *                   DeadKingOnAThrone_baseline_960213
 *
 * Revision 3.8  1996/02/12  19:29:28  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.7  1996/01/24  20:13:03  jenny
 * CSCdi47046:  TCP/IP need code clean up (part 3)
 * . removed ip/tuba.c, ip/tuba_default.c and ip/tuba.h
 * . removed all includes for ip/tuba.h.
 * . removed more TUBA related code.
 *
 * Revision 3.6  1996/01/11  02:23:31  jenny
 * CSCdi46513:  TCP/IP need code clean up (part 2)
 * changed registry function ip_tuba_move_address to inline
 * ip_copy_address().
 *
 * Revision 3.5  1995/12/18  07:08:49  schaefer
 * CSCdi45771: include slave devices in 75xx flash mib
 *
 * Revision 3.4  1995/12/14  08:23:10  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.3  1995/11/17  09:01:46  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.2  1995/11/16  23:15:49  gstovall
 * Ladies and gentlemen, I introduce to you, the port ready commit.
 *
 * Revision 3.1  1995/11/09  11:21:02  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.4  1995/11/08  20:54:31  shaker
 * Merge Arkansas_branch into 11.1 mainline.
 *
 * Revision 2.3  1995/10/25  21:40:20  sagarwal
 * CSCdi41798:  Flash mib problems on the 4500
 * o Remove check for device subunit to prevent passing of corrupt data
 * o Init chipinfo array from beginning
 * o Make SNMP chip info static (and reupdate on partitioning or insertion
 *   of PCMCIA card) to make getnext retrievals faster
 *
 * Revision 2.2  1995/06/09  13:00:06  hampton
 * Rename old scheduler calls to fit the new naming convention.
 * [CSCdi35514]
 *
 * Revision 2.1  1995/06/07 20:25:38  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include <ciscolib.h>
#include "interface_private.h"
#include "subsys.h"
#include "sys_registry.h"
#include "../ip/ip.h"
#include "../ip/ip_registry.h"
#include "flash_defines.h"
#include "../dev/flash_registry.h"
#include "../snmp/snmp_api.h"
#include "sr_flashmib.h"
#include "sr_flashmib-mib.h"
#include "snmp_flashmib_cmnds.h"
#include "../snmp/snmp_registry.h"
#include "sr_flashmibtype.h"
#include "../dev/snmp_flashmib_cmnds.h"
#include "../dev/flash_defines.h"

typedef struct copyQ_ {
    struct copyQ_          *next;
    ciscoFlashCopyEntry_t  *entry;
    int                    pid;
    sys_timestamp          timer;
    boolean                active;
} copyQ;

typedef struct partQ_ {
    struct partQ_                  *next;
    ciscoFlashPartitioningEntry_t  *entry;
    int                            pid;
    sys_timestamp                  timer;
    boolean                        active;
} partQ;

typedef struct miscopQ_ {
    struct miscopQ_                *next;
    ciscoFlashMiscOpEntry_t        *entry;
    int                            pid;
    sys_timestamp                  timer;
    boolean                        active;
} miscopQ;

static queuetype        snmpcopyQ;
static queuetype 	snmppartQ;
static queuetype 	snmpmiscopQ;

#define FLASHOP_ENTRY_AGEOUT               	(ONEMIN * 5)

/*
 * The following default values are taken directly from the MIB
 */

/* Copy operation related defaults */
#define DEF_ciscoFlashCopyCommand                       D_ciscoFlashCopyCommand_copyToFlashWithErase
#define DEF_ciscoFlashCopyProtocol     	                D_ciscoFlashCopyProtocol_tftp
#define DEF_ciscoFlashCopyServerAddress		        -1L
#define DEF_ciscoFlashCopyDestinationName		""
#define DEF_ciscoFlashCopyRemoteUserName		""
#define DEF_ciscoFlashCopyNotifyOnCompletion            D_ciscoFlashCopyNotifyOnCompletion_false

/* Partitioning operation related defaults */
#define DEF_ciscoFlashPartitioningCommand               D_ciscoFlashPartitioningCommand_partition
#define DEF_ciscoFlashPartitioningPartitionCount        2
#define DEF_ciscoFlashPartitioningNotifyOnCompletion    D_ciscoFlashPartitioningNotifyOnCompletion_false
#define DEF_ciscoFlashPartitioningDestinationName       "flash"
#define DEF_ciscoFlashPartitioningPartitionSizes        ""

/* Miscellaneous flash operation related defaults */
#define DEF_ciscoFlashMiscOpDestinationName		"flash:"
#define DEF_ciscoFlashMiscOpNotifyOnCompletion		D_ciscoFlashMiscOpNotifyOnCompletion_false

static boolean flash_in_use;	/* Local semaphore for flash operations */

/* Forward references -- Prototypes */
static forktype snmp_start_copy(copyQ *copy);
static void snmp_copy_ageout(void);
static void snmp_flashcopy_notify_trap(ciscoFlashCopyEntry_t *entry);

static forktype snmp_partition_task(partQ *part_request);
static void snmp_flash_partition_ageout(void);
static void snmp_partition_completion_trap(ciscoFlashPartitioningEntry_t *entry);

static forktype snmp_miscop_task(miscopQ *miscop_request);
static void snmp_flash_miscop_ageout(void);
static void snmp_miscop_completion_trap(ciscoFlashMiscOpEntry_t *miscop);

static void
init_flashmib (subsystype* subsys)
{
    /* Initialize the device database to be used by SNMP functions */
    if (snmp_init_dev_database() > 0) {
        /* Initialize global flag to indicate flash is free */
	flash_in_use = FALSE;

        /* Initialize queues */
	queue_init(&snmpcopyQ, 0);
        queue_init(&snmppartQ, 0);
        queue_init(&snmpmiscopQ, 0);

        /* Load the MIB */
        load_mib(flashmib_OidList, flashmib_OidListNum);
	load_oid(flashmib_oid_table);

        /* Register garbage collection functions */
	reg_add_onemin(snmp_copy_ageout, "snmp_copy_ageout");
        reg_add_onemin(snmp_flash_partition_ageout, "Flash Partition Ageout");
        reg_add_onemin(snmp_flash_miscop_ageout, "Flash Misc Ops Ageout");
    }
}

/*---------------------------------------------------------------------
 * Retrieve data from the ciscoFlashDevice family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ciscoFlashDevice_get (OID            *incoming,
		      ObjectInfo     *object,
		      int             searchType,
		      ContextInfo    *contextInfo,
		      int             serialNum)
{
    int             arg;
    void           *dp;
    ciscoFlashDevice_t *data = NULL;


    arg = snmp_scalar_instance(incoming, object, searchType);

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ciscoFlashDevice_get(serialNum, 
                                                contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ciscoFlashDevicesSupported
      case I_ciscoFlashDevicesSupported:
	dp = &data->ciscoFlashDevicesSupported;
	break;
#endif				       /* I_ciscoFlashDevicesSupported */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the ciscoFlashDeviceEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ciscoFlashDeviceEntry_get (OID            *incoming,
    			   ObjectInfo     *object,
    			   int             searchType,
    			   ContextInfo    *contextInfo,
    			   int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ciscoFlashDeviceEntry_t *data = NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            ciscoFlashDeviceIndex;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &ciscoFlashDeviceIndex, 
                                                   searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ciscoFlashDeviceEntry_get(serialNum, 
                                            contextInfo, arg, searchType, 
                                            ciscoFlashDeviceIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->ciscoFlashDeviceIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ciscoFlashDeviceSize
      case I_ciscoFlashDeviceSize:
	dp = &data->ciscoFlashDeviceSize;
	break;
#endif				       /* I_ciscoFlashDeviceSize */

#ifdef I_ciscoFlashDeviceMinPartitionSize
      case I_ciscoFlashDeviceMinPartitionSize:
	dp = &data->ciscoFlashDeviceMinPartitionSize;
	break;
#endif				       /* I_ciscoFlashDeviceMinPartitionSize */

#ifdef I_ciscoFlashDeviceMaxPartitions
      case I_ciscoFlashDeviceMaxPartitions:
	dp = &data->ciscoFlashDeviceMaxPartitions;
	break;
#endif				       /* I_ciscoFlashDeviceMaxPartitions */

#ifdef I_ciscoFlashDevicePartitions
      case I_ciscoFlashDevicePartitions:
	dp = &data->ciscoFlashDevicePartitions;
	break;
#endif				       /* I_ciscoFlashDevicePartitions */

#ifdef I_ciscoFlashDeviceChipCount
      case I_ciscoFlashDeviceChipCount:
	dp = &data->ciscoFlashDeviceChipCount;
	break;
#endif				       /* I_ciscoFlashDeviceChipCount */

#ifdef I_ciscoFlashDeviceName
      case I_ciscoFlashDeviceName:
	dp = MakeOctetString(data->ciscoFlashDeviceName->octet_ptr, 
                                           data->ciscoFlashDeviceName->length);
	break;
#endif				       /* I_ciscoFlashDeviceName */

#ifdef I_ciscoFlashDeviceDescr
      case I_ciscoFlashDeviceDescr:
	dp = MakeOctetString(data->ciscoFlashDeviceDescr->octet_ptr, 
                                          data->ciscoFlashDeviceDescr->length);
	break;
#endif				       /* I_ciscoFlashDeviceDescr */

#ifdef I_ciscoFlashDeviceController
      case I_ciscoFlashDeviceController:
	dp = MakeOctetString(data->ciscoFlashDeviceController->octet_ptr, 
                                     data->ciscoFlashDeviceController->length);
	break;
#endif				       /* I_ciscoFlashDeviceController */

#ifdef I_ciscoFlashDeviceCard
      case I_ciscoFlashDeviceCard:
	dp = MakeOID(data->ciscoFlashDeviceCard->oid_ptr, 
                                           data->ciscoFlashDeviceCard->length);
	break;
#endif				       /* I_ciscoFlashDeviceCard */

#ifdef I_ciscoFlashDeviceProgrammingJumper
      case I_ciscoFlashDeviceProgrammingJumper:
	dp = &data->ciscoFlashDeviceProgrammingJumper;
	break;
#endif				       /* I_ciscoFlashDeviceProgrammingJumper */

#ifdef I_ciscoFlashDeviceInitTime
      case I_ciscoFlashDeviceInitTime:
	dp = &data->ciscoFlashDeviceInitTime;
	break;
#endif				       /* I_ciscoFlashDeviceInitTime */

#ifdef I_ciscoFlashDeviceRemovable
      case I_ciscoFlashDeviceRemovable:
	dp = &data->ciscoFlashDeviceRemovable;
	break;
#endif				       /* I_ciscoFlashDeviceRemovable */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the ciscoFlashChipEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ciscoFlashChipEntry_get (OID            *incoming,
    			 ObjectInfo     *object,
    			 int             searchType,
    			 ContextInfo    *contextInfo,
    			 int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ciscoFlashChipEntry_t *data = NULL;
    unsigned long   buffer[2];
    OID             inst;
    int             carry;
    long            ciscoFlashDeviceIndex;
    long            ciscoFlashChipIndex;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 2
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 2) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 1 + object->oid.length, &ciscoFlashChipIndex, 
                                                    searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &ciscoFlashDeviceIndex, 
                                                    searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ciscoFlashChipEntry_get(serialNum,
                                               contextInfo, arg, searchType, 
                                               ciscoFlashDeviceIndex, 
                                               ciscoFlashChipIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 2;
	inst.oid_ptr[0] = data->ciscoFlashDeviceIndex;
	inst.oid_ptr[1] = data->ciscoFlashChipIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ciscoFlashChipCode
      case I_ciscoFlashChipCode:
	dp = MakeOctetString(data->ciscoFlashChipCode->octet_ptr, 
                                             data->ciscoFlashChipCode->length);
	break;
#endif				       /* I_ciscoFlashChipCode */

#ifdef I_ciscoFlashChipDescr
      case I_ciscoFlashChipDescr:
	dp = MakeOctetString(data->ciscoFlashChipDescr->octet_ptr, 
                                            data->ciscoFlashChipDescr->length);
	break;
#endif				       /* I_ciscoFlashChipDescr */

#ifdef I_ciscoFlashChipWriteRetries
      case I_ciscoFlashChipWriteRetries:
	dp = &data->ciscoFlashChipWriteRetries;
	break;
#endif				       /* I_ciscoFlashChipWriteRetries */

#ifdef I_ciscoFlashChipEraseRetries
      case I_ciscoFlashChipEraseRetries:
	dp = &data->ciscoFlashChipEraseRetries;
	break;
#endif				       /* I_ciscoFlashChipEraseRetries */

#ifdef I_ciscoFlashChipMaxWriteRetries
      case I_ciscoFlashChipMaxWriteRetries:
	dp = &data->ciscoFlashChipMaxWriteRetries;
	break;
#endif				       /* I_ciscoFlashChipMaxWriteRetries */

#ifdef I_ciscoFlashChipMaxEraseRetries
      case I_ciscoFlashChipMaxEraseRetries:
	dp = &data->ciscoFlashChipMaxEraseRetries;
	break;
#endif				       /* I_ciscoFlashChipMaxEraseRetries */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the ciscoFlashPartitionEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ciscoFlashPartitionEntry_get (OID            *incoming, 
    			      ObjectInfo     *object,
    			      int             searchType,
    			      ContextInfo    *contextInfo,
    			      int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ciscoFlashPartitionEntry_t *data = NULL;
    unsigned long   buffer[2];
    OID             inst;
    int             carry;
    long            ciscoFlashDeviceIndex;
    long            ciscoFlashPartitionIndex;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 2
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 2) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 1 + object->oid.length, &ciscoFlashPartitionIndex, 
                                                     searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &ciscoFlashDeviceIndex, 
                                                    searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ciscoFlashPartitionEntry_get(serialNum, 
                               contextInfo, arg, searchType, 
                               ciscoFlashDeviceIndex, 
                               ciscoFlashPartitionIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 2;
	inst.oid_ptr[0] = data->ciscoFlashDeviceIndex;
	inst.oid_ptr[1] = data->ciscoFlashPartitionIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ciscoFlashPartitionStartChip
      case I_ciscoFlashPartitionStartChip:
	dp = &data->ciscoFlashPartitionStartChip;
	break;
#endif				       /* I_ciscoFlashPartitionStartChip */

#ifdef I_ciscoFlashPartitionEndChip
      case I_ciscoFlashPartitionEndChip:
	dp = &data->ciscoFlashPartitionEndChip;
	break;
#endif				       /* I_ciscoFlashPartitionEndChip */

#ifdef I_ciscoFlashPartitionSize
      case I_ciscoFlashPartitionSize:
	dp = &data->ciscoFlashPartitionSize;
	break;
#endif				       /* I_ciscoFlashPartitionSize */

#ifdef I_ciscoFlashPartitionFreeSpace
      case I_ciscoFlashPartitionFreeSpace:
	dp = &data->ciscoFlashPartitionFreeSpace;
	break;
#endif				       /* I_ciscoFlashPartitionFreeSpace */

#ifdef I_ciscoFlashPartitionFileCount
      case I_ciscoFlashPartitionFileCount:
	dp = &data->ciscoFlashPartitionFileCount;
	break;
#endif				       /* I_ciscoFlashPartitionFileCount */

#ifdef I_ciscoFlashPartitionChecksumAlgorithm
      case I_ciscoFlashPartitionChecksumAlgorithm:
	dp = &data->ciscoFlashPartitionChecksumAlgorithm;
	break;
#endif				       /* I_ciscoFlashPartitionChecksumAlgorit
				        * hm */

#ifdef I_ciscoFlashPartitionStatus
      case I_ciscoFlashPartitionStatus:
	dp = &data->ciscoFlashPartitionStatus;
	break;
#endif				       /* I_ciscoFlashPartitionStatus */

#ifdef I_ciscoFlashPartitionUpgradeMethod
      case I_ciscoFlashPartitionUpgradeMethod:
	dp = &data->ciscoFlashPartitionUpgradeMethod;
	break;
#endif				       /* I_ciscoFlashPartitionUpgradeMethod */

#ifdef I_ciscoFlashPartitionName
      case I_ciscoFlashPartitionName:
	dp = MakeOctetString(data->ciscoFlashPartitionName->octet_ptr, 
                                        data->ciscoFlashPartitionName->length);
	break;
#endif				       /* I_ciscoFlashPartitionName */

#ifdef I_ciscoFlashPartitionNeedErasure
      case I_ciscoFlashPartitionNeedErasure:
	dp = &data->ciscoFlashPartitionNeedErasure;
	break;
#endif				       /* I_ciscoFlashPartitionNeedErasure */

#ifdef I_ciscoFlashPartitionFileNameLength
      case I_ciscoFlashPartitionFileNameLength:
	dp = &data->ciscoFlashPartitionFileNameLength;
	break;
#endif				       /* I_ciscoFlashPartitionFileNameLength */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the ciscoFlashFileEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ciscoFlashFileEntry_get (OID            *incoming,
    			 ObjectInfo     *object,
    			 int             searchType,
    			 ContextInfo    *contextInfo,
    			 int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ciscoFlashFileEntry_t *data = NULL;
    unsigned long   buffer[3];
    OID             inst;
    int             carry;
    long            ciscoFlashDeviceIndex;
    long            ciscoFlashPartitionIndex;
    long            ciscoFlashFileIndex;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 3
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 3) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 2 + object->oid.length, &ciscoFlashFileIndex, 
                                                   searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 1 + object->oid.length, &ciscoFlashPartitionIndex,
                                                   searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &ciscoFlashDeviceIndex, 
                                                   searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ciscoFlashFileEntry_get(serialNum, contextInfo,
                               arg, searchType, ciscoFlashDeviceIndex, 
                               ciscoFlashPartitionIndex, 
                               ciscoFlashFileIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 3;
	inst.oid_ptr[0] = data->ciscoFlashDeviceIndex;
	inst.oid_ptr[1] = data->ciscoFlashPartitionIndex;
	inst.oid_ptr[2] = data->ciscoFlashFileIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ciscoFlashFileSize
      case I_ciscoFlashFileSize:
	dp = &data->ciscoFlashFileSize;
	break;
#endif				       /* I_ciscoFlashFileSize */

#ifdef I_ciscoFlashFileChecksum
      case I_ciscoFlashFileChecksum:
	dp = MakeOctetString(data->ciscoFlashFileChecksum->octet_ptr, 
                                         data->ciscoFlashFileChecksum->length);
	break;
#endif				       /* I_ciscoFlashFileChecksum */

#ifdef I_ciscoFlashFileStatus
      case I_ciscoFlashFileStatus:
	dp = &data->ciscoFlashFileStatus;
	break;
#endif				       /* I_ciscoFlashFileStatus */

#ifdef I_ciscoFlashFileName
      case I_ciscoFlashFileName:
	dp = MakeOctetString(data->ciscoFlashFileName->octet_ptr, 
                                             data->ciscoFlashFileName->length);
	break;
#endif				       /* I_ciscoFlashFileName */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}


/*************************************************************************
 *                 Queue Manipulation Functions
 * These functions are used to extract and insert entries from the
 * Copy, Partitioning and MiscOp queues.
 *************************************************************************/

/*
 * copyQinsert:  insert a new entry into the ordered snmpcopyQ
 */
static void
copyQinsert (copyQ     *newFlashCopy)
{
    leveltype           level;
    copyQ               *prev;
    copyQ               *test;
    long                serialNumber;

    /*
     * don't allow the timeout task access to the Q
     */
    level = raise_interrupt_level(ALL_DISABLE);

    serialNumber = newFlashCopy->entry->ciscoFlashCopySerialNumber;
    prev = NULL;
    test = snmpcopyQ.qhead;
    while (test) {
        if (serialNumber < test->entry->ciscoFlashCopySerialNumber)
            break;
        prev = test;
        test = test->next;
    }

    insqueue(&snmpcopyQ, newFlashCopy, prev);

    /*
     * re-allow access to the snmpFlashOp1Q
     */
    reset_interrupt_level(level);

    return;
}

/*
 * copyQget:  grab the requested snmpcopyQ entry
 */
static copyQ *
copyQget (int   searchType,
          long  serialNumber)
{
    leveltype              level;
    copyQ                  *test;
    ciscoFlashCopyEntry_t  *entry;

    /*
     * don't allow the timeout task access to the Q
     */
    level = raise_interrupt_level(ALL_DISABLE);

    for (test = snmpcopyQ.qhead; test; test = test->next) {
        /*
         * skip any entries that are being hidden from SNMP
         */
        if (!test->active)
            continue;

        entry = test->entry;
        /*
         * the snmpcopyQ is sorted by serial number, so we can stop a NEXT
         * search when we find a candidate
         */
        if ((entry->ciscoFlashCopySerialNumber == serialNumber) ||
            ((entry->ciscoFlashCopySerialNumber > serialNumber) &&
             (searchType == NEXT)))
            break;

        if ((entry->ciscoFlashCopySerialNumber > serialNumber) &&
            (searchType == EXACT)) {
            /*
             * gone too far for an exact match
             */
            test = NULL;
            break;
        }
    }

    /*
     * re-allow access to the snmpFlashOp1Q
     */
    reset_interrupt_level(level);

    return (test);
}

/*
 * partQget: Get the requested partQ entry from snmppartQ
 */
static partQ *partQget (int searchType, 
			long serialNumber)
{
    leveltype             level;
    partQ                 *test;
    ciscoFlashPartitioningEntry_t  *entry;

    /* disallow access to snmppartQ by the timeout process */
    level = raise_interrupt_level(ALL_DISABLE);
    for (test = snmppartQ.qhead; test; test = test->next) {
        /* skip entries hidden from snmp */
        if (!test->active)
            continue;
        entry = test->entry;

        if ((entry->ciscoFlashPartitioningSerialNumber == serialNumber) ||
            ((entry->ciscoFlashPartitioningSerialNumber > serialNumber) &&
             (searchType == NEXT)))
            break;

        if ((entry->ciscoFlashPartitioningSerialNumber > serialNumber) &&
            (searchType == EXACT)) {
            test = NULL;
            break;
        }
    }
    /* allow access again to the snmppartQ */
    reset_interrupt_level(level);
    return (test);
}

/*
 * partQinsert: Insert the provided partQ entry into the snmppartQ
 *              Note that this queue is ordered in ascending order
 *              of the serial numbers.
 */
static void partQinsert (partQ *newpartQ)
{
    leveltype level;
    partQ     *prev;
    partQ     *test;
    long      serialNumber;

    /* disallow access to snmppartQ by the timeout process */
    level = raise_interrupt_level(ALL_DISABLE);
    serialNumber = newpartQ->entry->ciscoFlashPartitioningSerialNumber;
    prev = NULL;
    test = snmppartQ.qhead;

    while (test) {
        if (serialNumber < test->entry->ciscoFlashPartitioningSerialNumber)
            break;
        prev = test;
        test = test->next;
    }

    insqueue(&snmppartQ, newpartQ, prev);
    /* allow access again to the snmppartQ */
    reset_interrupt_level(level);
    return;
}

/*
 * miscopQget: Get the requested miscopQ entry from snmpmiscopQ
 */
static miscopQ *miscopQget (int searchType, 
			    long serialNumber)
{
    leveltype             level;
    miscopQ                 *test;
    ciscoFlashMiscOpEntry_t  *entry;

    /* disallow access to snmpmiscopQ by the timeout process */
    level = raise_interrupt_level(ALL_DISABLE);
    for (test = snmpmiscopQ.qhead; test; test = test->next) {
        /* skip entries hidden from snmp */
        if (!test->active)
            continue;
        entry = test->entry;

        if ((entry->ciscoFlashMiscOpSerialNumber == serialNumber) ||
            ((entry->ciscoFlashMiscOpSerialNumber > serialNumber) &&
             (searchType == NEXT)))
            break;

        if ((entry->ciscoFlashMiscOpSerialNumber > serialNumber) &&
            (searchType == EXACT)) {
            test = NULL;
            break;
        }
    }
    /* allow access again to the snmpmiscopQ */
    reset_interrupt_level(level);
    return (test);
}

/*
 * miscopQinsert: Insert the provided miscopQ entry into the snmpmiscopQ
 *                Note that this queue is ordered in ascending order
 *                of the serial numbers.
 */
static void miscopQinsert (miscopQ *newmiscopQ)
{
    leveltype level;
    miscopQ     *prev;
    miscopQ     *test;
    long      serialNumber;

    /* disallow access to snmpmiscopQ by the timeout process */
    level = raise_interrupt_level(ALL_DISABLE);
    serialNumber = newmiscopQ->entry->ciscoFlashMiscOpSerialNumber;
    prev = NULL;
    test = snmpmiscopQ.qhead;

    while (test) {
        if (serialNumber < test->entry->ciscoFlashMiscOpSerialNumber)
            break;
        prev = test;
        test = test->next;
    }

    insqueue(&snmpmiscopQ, newmiscopQ, prev);
    /* allow access again to the snmpmiscopQ */
    reset_interrupt_level(level);
    return;
}



/*---------------------------------------------------------------------
 * Retrieve data from the ciscoFlashCopyEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ciscoFlashCopyEntry_get (OID            *incoming,
    			 ObjectInfo     *object,
    			 int             searchType,
    			 ContextInfo    *contextInfo,
    			 int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ciscoFlashCopyEntry_t *data = NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            ciscoFlashCopySerialNumber;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, 
                   &ciscoFlashCopySerialNumber, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ciscoFlashCopyEntry_get(serialNum, contextInfo,
                               arg, searchType, 
                               ciscoFlashCopySerialNumber)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->ciscoFlashCopySerialNumber;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ciscoFlashCopyCommand
      case I_ciscoFlashCopyCommand:
	dp = &data->ciscoFlashCopyCommand;
	break;
#endif				       /* I_ciscoFlashCopyCommand */

#ifdef I_ciscoFlashCopyProtocol
      case I_ciscoFlashCopyProtocol:
	dp = &data->ciscoFlashCopyProtocol;
	break;
#endif				       /* I_ciscoFlashCopyProtocol */

#ifdef I_ciscoFlashCopyServerAddress
      case I_ciscoFlashCopyServerAddress:
	dp = IPToOctetString(data->ciscoFlashCopyServerAddress);
	break;
#endif				       /* I_ciscoFlashCopyServerAddress */

#ifdef I_ciscoFlashCopySourceName
      case I_ciscoFlashCopySourceName:
	dp = MakeOctetString(data->ciscoFlashCopySourceName->octet_ptr, 
                                        data->ciscoFlashCopySourceName->length);
	break;
#endif				       /* I_ciscoFlashCopySourceName */

#ifdef I_ciscoFlashCopyDestinationName
      case I_ciscoFlashCopyDestinationName:
	dp = MakeOctetString(data->ciscoFlashCopyDestinationName->octet_ptr, 
                                   data->ciscoFlashCopyDestinationName->length);
	break;
#endif				       /* I_ciscoFlashCopyDestinationName */

#ifdef I_ciscoFlashCopyRemoteUserName
      case I_ciscoFlashCopyRemoteUserName:
	dp = MakeOctetString(data->ciscoFlashCopyRemoteUserName->octet_ptr, 
                                    data->ciscoFlashCopyRemoteUserName->length);
	break;
#endif				       /* I_ciscoFlashCopyRemoteUserName */

#ifdef I_ciscoFlashCopyStatus
      case I_ciscoFlashCopyStatus:
	dp = &data->ciscoFlashCopyStatus;
	break;
#endif				       /* I_ciscoFlashCopyStatus */

#ifdef I_ciscoFlashCopyNotifyOnCompletion
      case I_ciscoFlashCopyNotifyOnCompletion:
	dp = &data->ciscoFlashCopyNotifyOnCompletion;
	break;
#endif				       /* I_ciscoFlashCopyNotifyOnCompletion */

#ifdef I_ciscoFlashCopyTime
      case I_ciscoFlashCopyTime:
	dp = &data->ciscoFlashCopyTime;
	break;
#endif				       /* I_ciscoFlashCopyTime */

#ifdef I_ciscoFlashCopyEntryStatus
      case I_ciscoFlashCopyEntryStatus:
	dp = &data->ciscoFlashCopyEntryStatus;
	break;
#endif				       /* I_ciscoFlashCopyEntryStatus */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    if ((dp == NULL) || !VALID(arg, data->valid))
	return ((VarBind *) NULL);
    else
	return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the ciscoFlashCopyEntry data object.
 *---------------------------------------------------------------------*/
void
ciscoFlashCopyEntry_free (ciscoFlashCopyEntry_t *data)
{
    if (data != NULL) {
	if (data->ciscoFlashCopySourceName != NULL) {
	    FreeOctetString(data->ciscoFlashCopySourceName);
	}
	if (data->ciscoFlashCopyDestinationName != NULL) {
	    FreeOctetString(data->ciscoFlashCopyDestinationName);
	}
	if (data->ciscoFlashCopyRemoteUserName != NULL) {
	    FreeOctetString(data->ciscoFlashCopyRemoteUserName);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after ciscoFlashCopyEntry set/undo
 *---------------------------------------------------------------------*/
static int
ciscoFlashCopyEntry_cleanup (doList_t  *trash)
{
    ciscoFlashCopyEntry_free(trash->data);
#ifdef SR_SNMPv2
    ciscoFlashCopyEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
ciscoFlashCopyEntry_test (OID            *incoming, 
    			  ObjectInfo     *object,
    			  ObjectSyntax   *value,
    			  doList_t       *doHead,
    			  doList_t       *doCur,
    			  ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    /* VarBind        *vb = (VarBind *) NULL; */
    int             found;
    int 	    retval;
    boolean 	    good_row;
    int             carry = 0;
    ciscoFlashCopyEntry_t *ciscoFlashCopyEntry;
    long            ciscoFlashCopySerialNumber;
    boolean 	    copy_entry_found;

    /*
     * Validate the object instance
     * 
     */
    if (instLength != 1) 
	return NO_CREATION_ERROR;

    if ((InstToInt(incoming, 0 + object->oid.length, 
                   &ciscoFlashCopySerialNumber, EXACT, &carry)) < 0) 
	return (NO_CREATION_ERROR);
    
    ciscoFlashCopyEntry = k_ciscoFlashCopyEntry_get(-1, contextInfo, 
                          object->nominator, EXACT, ciscoFlashCopySerialNumber);

    copy_entry_found = (ciscoFlashCopyEntry != NULL);
    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == ciscoFlashCopyEntry_set) &&
	    (((ciscoFlashCopyEntry_t *) (dp->data)) != NULL) &&
	    (((ciscoFlashCopyEntry_t *) (dp->data))->ciscoFlashCopySerialNumber == ciscoFlashCopySerialNumber)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(ciscoFlashCopyEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(ciscoFlashCopyEntry_t));

	dp->setMethod = ciscoFlashCopyEntry_set;
	dp->cleanupMethod = ciscoFlashCopyEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (copy_entry_found) {
	    /* use existing values as default values */
	    memcpy((char *) (dp->data), (char *) (ciscoFlashCopyEntry), 
                                                sizeof(ciscoFlashCopyEntry_t));
	    if (ciscoFlashCopyEntry->ciscoFlashCopySourceName != NULL)
		((ciscoFlashCopyEntry_t *) (dp->data))->ciscoFlashCopySourceName 		 = CloneOctetString(ciscoFlashCopyEntry->ciscoFlashCopySourceName);

	    if (ciscoFlashCopyEntry->ciscoFlashCopyDestinationName != NULL)
		((ciscoFlashCopyEntry_t *) (dp->data))->ciscoFlashCopyDestinationName 
	         = CloneOctetString(ciscoFlashCopyEntry->ciscoFlashCopyDestinationName);

	    if (ciscoFlashCopyEntry->ciscoFlashCopyRemoteUserName != NULL)
		((ciscoFlashCopyEntry_t *) (dp->data))->ciscoFlashCopyRemoteUserName 
		 = CloneOctetString(ciscoFlashCopyEntry->ciscoFlashCopyRemoteUserName);
		ciscoFlashCopyEntry = (ciscoFlashCopyEntry_t *) dp->data;

	} else {
	    /*
	     * Fill in default values for the
             * new row
	     */		
	    ciscoFlashCopyEntry = (ciscoFlashCopyEntry_t *) dp->data;

	    SET_VALID(I_ciscoFlashCopySerialNumber, ciscoFlashCopyEntry->valid);
            ciscoFlashCopyEntry->ciscoFlashCopySerialNumber = 
                                                     ciscoFlashCopySerialNumber;
	    SET_VALID(I_ciscoFlashCopyCommand, ciscoFlashCopyEntry->valid);
	    ciscoFlashCopyEntry->ciscoFlashCopyCommand = 
                                                      DEF_ciscoFlashCopyCommand;

	    SET_VALID(I_ciscoFlashCopyProtocol, ciscoFlashCopyEntry->valid);
	    ciscoFlashCopyEntry->ciscoFlashCopyProtocol = 
                                                     DEF_ciscoFlashCopyProtocol;
	    SET_VALID(I_ciscoFlashCopyServerAddress, ciscoFlashCopyEntry->valid);
	    ciscoFlashCopyEntry->ciscoFlashCopyServerAddress = 
                                                DEF_ciscoFlashCopyServerAddress;
	    SET_VALID(I_ciscoFlashCopyDestinationName, ciscoFlashCopyEntry->valid);
	    ciscoFlashCopyEntry->ciscoFlashCopyDestinationName = 
		            MakeOctetString(DEF_ciscoFlashCopyDestinationName,
			             strlen(DEF_ciscoFlashCopyDestinationName));
	    SET_VALID(I_ciscoFlashCopyRemoteUserName, ciscoFlashCopyEntry->valid);
	    ciscoFlashCopyEntry->ciscoFlashCopyRemoteUserName = 
		              MakeOctetString(DEF_ciscoFlashCopyRemoteUserName,
			              strlen(DEF_ciscoFlashCopyRemoteUserName));
	    SET_VALID(I_ciscoFlashCopyNotifyOnCompletion, ciscoFlashCopyEntry->valid);
	    ciscoFlashCopyEntry->ciscoFlashCopyNotifyOnCompletion = 
                                           DEF_ciscoFlashCopyNotifyOnCompletion;
	    /*
	     * The row isn't ready yet
	     */ 
	    ciscoFlashCopyEntry->ciscoFlashCopyEntryStatus = 
                                          D_ciscoFlashCopyEntryStatus_notReady;
	}
    } else
	ciscoFlashCopyEntry = (ciscoFlashCopyEntry_t *) dp->data;

    /*
     * manager cannot keep changing his mind
     */
    if ((object->nominator != I_ciscoFlashCopyEntryStatus) &&
         (ciscoFlashCopyEntry->ciscoFlashCopyEntryStatus ==
               D_ciscoFlashCopyEntryStatus_active)) 
         return (INCONSISTENT_VALUE_ERROR); 
    
    
    switch (object->nominator) {

#ifdef I_ciscoFlashCopyCommand
      case I_ciscoFlashCopyCommand:
	
	if ((value->sl_value < D_ciscoFlashCopyCommand_copyToFlashWithErase) ||
	    (value->sl_value > D_ciscoFlashCopyCommand_copyFromFlhLog)) 
	    return (WRONG_VALUE_ERROR);
	

	SET_VALID(I_ciscoFlashCopyCommand, ciscoFlashCopyEntry->valid);
	ciscoFlashCopyEntry->ciscoFlashCopyCommand = value->sl_value;
	break;
#endif				       /* I_ciscoFlashCopyCommand */

#ifdef I_ciscoFlashCopyProtocol
      case I_ciscoFlashCopyProtocol:

        if ((value->sl_value < D_ciscoFlashCopyProtocol_tftp) ||
            (value->sl_value > D_ciscoFlashCopyProtocol_lex)) 
            return (WRONG_VALUE_ERROR);

	SET_VALID(I_ciscoFlashCopyProtocol, ciscoFlashCopyEntry->valid);
	ciscoFlashCopyEntry->ciscoFlashCopyProtocol = value->sl_value;
	break;
#endif				       /* I_ciscoFlashCopyProtocol */

#ifdef I_ciscoFlashCopyServerAddress
      case I_ciscoFlashCopyServerAddress:

	if (value->os_value->length != 4) 
	    return (WRONG_LENGTH_ERROR);
	
	SET_VALID(I_ciscoFlashCopyServerAddress, ciscoFlashCopyEntry->valid);
	ciscoFlashCopyEntry->ciscoFlashCopyServerAddress = 
                                               OctetStringToIP(value->os_value);
	break;
#endif				       /* I_ciscoFlashCopyServerAddress */

#ifdef I_ciscoFlashCopySourceName
      case I_ciscoFlashCopySourceName:

	if (value->os_value->length > SYSSIZE) 
            return (WRONG_LENGTH_ERROR);
        
        if (!IsDisplayString(value->os_value)) 
            return (WRONG_VALUE_ERROR);
        
	SET_VALID(I_ciscoFlashCopySourceName, ciscoFlashCopyEntry->valid);

	if (ciscoFlashCopyEntry->ciscoFlashCopySourceName != NULL) {
	    FreeOctetString(ciscoFlashCopyEntry->ciscoFlashCopySourceName);
	}
	ciscoFlashCopyEntry->ciscoFlashCopySourceName =
	   MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_ciscoFlashCopySourceName */

#ifdef I_ciscoFlashCopyDestinationName
      case I_ciscoFlashCopyDestinationName:

        if (value->os_value->length > SYSSIZE) 
            return (WRONG_LENGTH_ERROR);

	SET_VALID(I_ciscoFlashCopyDestinationName, ciscoFlashCopyEntry->valid);

	if (ciscoFlashCopyEntry->ciscoFlashCopyDestinationName != NULL) {
	    FreeOctetString(ciscoFlashCopyEntry->ciscoFlashCopyDestinationName);
	}
	ciscoFlashCopyEntry->ciscoFlashCopyDestinationName =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_ciscoFlashCopyDestinationName */

#ifdef I_ciscoFlashCopyRemoteUserName
      case I_ciscoFlashCopyRemoteUserName:

        if (value->os_value->length > SYSSIZE) 
            return (WRONG_LENGTH_ERROR);
        
        if (!IsDisplayString(value->os_value)) 
            return (WRONG_VALUE_ERROR);
        

	SET_VALID(I_ciscoFlashCopyRemoteUserName, ciscoFlashCopyEntry->valid);

	if (ciscoFlashCopyEntry->ciscoFlashCopyRemoteUserName != NULL) {
	    FreeOctetString(ciscoFlashCopyEntry->ciscoFlashCopyRemoteUserName);
	}
	ciscoFlashCopyEntry->ciscoFlashCopyRemoteUserName =
	   MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_ciscoFlashCopyRemoteUserName */

#ifdef I_ciscoFlashCopyNotifyOnCompletion
      case I_ciscoFlashCopyNotifyOnCompletion:
	
	if ((value->sl_value != D_ciscoFlashCopyNotifyOnCompletion_true) &&
	    (value->sl_value != D_ciscoFlashCopyNotifyOnCompletion_false)) 
	    return (WRONG_VALUE_ERROR); 

	SET_VALID(I_ciscoFlashCopyNotifyOnCompletion, ciscoFlashCopyEntry->valid);

	ciscoFlashCopyEntry->ciscoFlashCopyNotifyOnCompletion = value->sl_value;
	break;
#endif				       /* I_ciscoFlashCopyNotifyOnCompletion */

#ifdef I_ciscoFlashCopyEntryStatus
      case I_ciscoFlashCopyEntryStatus:

        /*
         * don't allow status to be set to notInService
         */
        if (value->sl_value == D_ciscoFlashCopyEntryStatus_notInService) 
            return (INCONSISTENT_VALUE_ERROR);

        /*
         * perform generic row status processing
         */
        retval = set_row_status(value->sl_value,
                             copy_entry_found ? 1 : -1,
                             &(dp->state),
                             &(ciscoFlashCopyEntry->ciscoFlashCopyEntryStatus));

        if (retval != NO_ERROR) 
            return (retval);

	SET_VALID(I_ciscoFlashCopyEntryStatus, ciscoFlashCopyEntry->valid);

	ciscoFlashCopyEntry->ciscoFlashCopyEntryStatus = value->sl_value;
	break;
#endif				       /* I_ciscoFlashCopyEntryStatus */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in ciscoFlashCopyEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    /*
     * See if we have a complete row. Note that the case for the command
     * to copy the flh-log to a server is handled differently. This is 
     * done since a source filename is not needed in that case.
     */
    if (ciscoFlashCopyEntry->ciscoFlashCopyCommand == 
                                 D_ciscoFlashCopyCommand_copyFromFlhLog) {
        if (VALID(I_ciscoFlashCopyEntryStatus, ciscoFlashCopyEntry->valid))
            good_row = TRUE;
        else
            good_row = FALSE;
    }
    else {
        if (VALID(I_ciscoFlashCopySourceName, ciscoFlashCopyEntry->valid) &&
            VALID(I_ciscoFlashCopyEntryStatus, ciscoFlashCopyEntry->valid))
            good_row = TRUE;
        else 
            good_row = FALSE;
    }

    /*
     * transition the row status as necessary
     */
    if (copy_entry_found) {
        switch (ciscoFlashCopyEntry->ciscoFlashCopyEntryStatus) {
        case D_ciscoFlashCopyEntryStatus_notInService:
            if (good_row) 
                dp->state = ADD_MODIFY;
            else 
                dp->state = NOT_READY_STATE;
            break;

        case D_ciscoFlashCopyEntryStatus_destroy:
            dp->state = DELETE;
            break;

        case D_ciscoFlashCopyEntryStatus_notReady:
            if (good_row)
                ciscoFlashCopyEntry->ciscoFlashCopyEntryStatus = 
                                       D_ciscoFlashCopyEntryStatus_notInService;
            dp->state = ADD_MODIFY;
            break;

        case D_ciscoFlashCopyEntryStatus_active:
            if (good_row) 
                dp->state = ADD_MODIFY;
            else 
                dp->state = NOT_READY_STATE;
            break;

        default:
            return (INCONSISTENT_VALUE_ERROR);
            break;

        }
    } else {
        switch (ciscoFlashCopyEntry->ciscoFlashCopyEntryStatus) {
        case D_ciscoFlashCopyEntryStatus_createAndWait:
            if (good_row)
                ciscoFlashCopyEntry->ciscoFlashCopyEntryStatus = 
                                       D_ciscoFlashCopyEntryStatus_notInService;
            else
                ciscoFlashCopyEntry->ciscoFlashCopyEntryStatus = 
                                           D_ciscoFlashCopyEntryStatus_notReady;
            dp->state = ADD_MODIFY;
            break;

        case D_ciscoFlashCopyEntryStatus_notReady:
            if (good_row)
                ciscoFlashCopyEntry->ciscoFlashCopyEntryStatus = 
                                       D_ciscoFlashCopyEntryStatus_notInService;
            if (VALID(I_ciscoFlashCopyEntryStatus, ciscoFlashCopyEntry->valid)) 
                dp->state = ADD_MODIFY;
            break;

        case D_ciscoFlashCopyEntryStatus_createAndGo:
            if (good_row) 
                dp->state = ADD_MODIFY;
            else
                dp->state = CREATE_AND_GO_STATE;
            break;

        case D_ciscoFlashCopyEntryStatus_destroy:
            dp->state = DELETE;
            break;

        case D_ciscoFlashCopyEntryStatus_notInService:
            if (!good_row)
                ciscoFlashCopyEntry->ciscoFlashCopyEntryStatus = 
                                           D_ciscoFlashCopyEntryStatus_notReady;
            dp->state = ADD_MODIFY;
            break;

        default:
            return (INCONSISTENT_VALUE_ERROR);
            break;
        }
    }
    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
ciscoFlashCopyEntry_set (doList_t       *doHead, 
    			 doList_t       *doCur,
    			 ContextInfo    *contextInfo)
{
    return (k_ciscoFlashCopyEntry_set((ciscoFlashCopyEntry_t *) (doCur->data),
				      contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the ciscoFlashPartitioningEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ciscoFlashPartitioningEntry_get (OID            *incoming,  
    				 ObjectInfo     *object,
    				 int             searchType,
    				 ContextInfo    *contextInfo,
    				 int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp = NULL;
    ciscoFlashPartitioningEntry_t *data = NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            ciscoFlashPartitioningSerialNumber;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, 
               &ciscoFlashPartitioningSerialNumber, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ciscoFlashPartitioningEntry_get(serialNum, 
                               contextInfo, arg, searchType, 
                               ciscoFlashPartitioningSerialNumber)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->ciscoFlashPartitioningSerialNumber;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ciscoFlashPartitioningCommand
      case I_ciscoFlashPartitioningCommand:
	dp = &data->ciscoFlashPartitioningCommand;
	break;
#endif				       /* I_ciscoFlashPartitioningCommand */

#ifdef I_ciscoFlashPartitioningDestinationName
      case I_ciscoFlashPartitioningDestinationName:
	dp = CloneOctetString(data->ciscoFlashPartitioningDestinationName);
	break;
#endif				       /* I_ciscoFlashPartitioningDestinationN
				        * ame */

#ifdef I_ciscoFlashPartitioningPartitionCount
      case I_ciscoFlashPartitioningPartitionCount:
	dp = &data->ciscoFlashPartitioningPartitionCount;
	break;
#endif			    /* I_ciscoFlashPartitioningPartitionCount */

#ifdef I_ciscoFlashPartitioningPartitionSizes
      case I_ciscoFlashPartitioningPartitionSizes:
	dp = CloneOctetString(data->ciscoFlashPartitioningPartitionSizes);
	break;
#endif			       /* I_ciscoFlashPartitioningPartitionSizes */

#ifdef I_ciscoFlashPartitioningStatus
      case I_ciscoFlashPartitioningStatus:
        dp = &data->ciscoFlashPartitioningStatus;
	break;
#endif				       /* I_ciscoFlashPartitioningStatus */

#ifdef I_ciscoFlashPartitioningNotifyOnCompletion
      case I_ciscoFlashPartitioningNotifyOnCompletion:
	dp = &data->ciscoFlashPartitioningNotifyOnCompletion;
	break;
#endif			       /* I_ciscoFlashPartitioningNotifyOnCompletion */

#ifdef I_ciscoFlashPartitioningTime
      case I_ciscoFlashPartitioningTime:
	dp = &data->ciscoFlashPartitioningTime;
	break;
#endif				       /* I_ciscoFlashPartitioningTime */

#ifdef I_ciscoFlashPartitioningEntryStatus
      case I_ciscoFlashPartitioningEntryStatus:
	dp = &data->ciscoFlashPartitioningEntryStatus;
	break;
#endif			       /* I_ciscoFlashPartitioningEntryStatus */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    if ((dp == NULL) || !VALID(arg, data->valid))
        return((VarBind *) NULL);
    else
        return(MakeVarBind(object, &inst, dp));
}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the ciscoFlashPartitioningEntry data object.
 *---------------------------------------------------------------------*/
void
ciscoFlashPartitioningEntry_free (ciscoFlashPartitioningEntry_t *data)
{
    if (data != NULL) {
	if (data->ciscoFlashPartitioningDestinationName != NULL) {
	    FreeOctetString(data->ciscoFlashPartitioningDestinationName);
	}
	if (data->ciscoFlashPartitioningPartitionSizes != NULL) {
	    FreeOctetString(data->ciscoFlashPartitioningPartitionSizes);
	}
	free(data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after ciscoFlashPartitioningEntry set/undo
 *---------------------------------------------------------------------*/
static int
ciscoFlashPartitioningEntry_cleanup (doList_t  *trash)
{
    ciscoFlashPartitioningEntry_free(trash->data);
#ifdef SR_SNMPv2
    ciscoFlashPartitioningEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
ciscoFlashPartitioningEntry_test (OID            *incoming,  
    				  ObjectInfo     *object,
    				  ObjectSyntax   *value,
    				  doList_t       *doHead,
    				  doList_t       *doCur,
    				  ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    /* VarBind        *vb = (VarBind *) NULL; */
    int             found, retval;
    int             carry = 0;
    ciscoFlashPartitioningEntry_t *ciscoFlashPartitioningEntry;
    long            ciscoFlashPartitioningSerialNumber;
    boolean         entry_found, good_row;

    /*
     * Validate the object instance
     *
     */
    if (instLength != 1) {
        return NO_CREATION_ERROR;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, 
                   &ciscoFlashPartitioningSerialNumber, EXACT, &carry)) < 0) {
        return (NO_CREATION_ERROR);
    }
    ciscoFlashPartitioningEntry = k_ciscoFlashPartitioningEntry_get(-1, 
                                     contextInfo, object->nominator, 
                                     EXACT, ciscoFlashPartitioningSerialNumber);
    entry_found = (ciscoFlashPartitioningEntry != NULL);

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = FALSE;

    for (dp = doHead; dp != NULL; dp = dp->next) {
        if ((dp->setMethod == ciscoFlashPartitioningEntry_set) &&
            (((ciscoFlashPartitioningEntry_t *) (dp->data)) != NULL) &&
            (((ciscoFlashPartitioningEntry_t *) (dp->data))->ciscoFlashPartitioningSerialNumber == ciscoFlashPartitioningSerialNumber)) {

            found = TRUE;
            break;
        }
    }
  
    if (found) {
        ciscoFlashPartitioningEntry = dp->data;
    }
    else {
        dp = doCur;
        if ((dp->data = malloc(sizeof(ciscoFlashPartitioningEntry_t)))
                                                                      == NULL) {
            DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
            return (RESOURCE_UNAVAILABLE_ERROR);
        }
        memset(dp->data, 0, sizeof(ciscoFlashPartitioningEntry_t));

        dp->setMethod = ciscoFlashPartitioningEntry_set;
        dp->cleanupMethod = ciscoFlashPartitioningEntry_cleanup;
#ifdef SR_SNMPv2
        dp->undoMethod = NULL;
#endif                                 /* SR_SNMPv2 */
        dp->state = UNKNOWN;
       /*
        * Try to fill in reasonable defaults for this new doList entry
        */
        if (entry_found) {
           /*
            * We will copy over values that already exist
            */
            memcpy(dp->data, ciscoFlashPartitioningEntry, 
                                        sizeof(ciscoFlashPartitioningEntry_t));
            if (ciscoFlashPartitioningEntry->ciscoFlashPartitioningDestinationName != NULL)
                ((ciscoFlashPartitioningEntry_t *)(dp->data))->ciscoFlashPartitioningDestinationName = CloneOctetString(
            ciscoFlashPartitioningEntry->ciscoFlashPartitioningDestinationName);

            if (ciscoFlashPartitioningEntry->ciscoFlashPartitioningPartitionSizes != NULL)
                ((ciscoFlashPartitioningEntry_t *)(dp->data))->ciscoFlashPartitioningPartitionSizes = CloneOctetString(
             ciscoFlashPartitioningEntry->ciscoFlashPartitioningPartitionSizes);

            ciscoFlashPartitioningEntry = dp->data;
        }
        else {
           /*
            * This is a brand new row
            */
            ciscoFlashPartitioningEntry = dp->data;

          SET_VALID(I_ciscoFlashPartitioningSerialNumber, 
                                            ciscoFlashPartitioningEntry->valid);
          ciscoFlashPartitioningEntry->ciscoFlashPartitioningSerialNumber =
                                           ciscoFlashPartitioningSerialNumber;

          SET_VALID(I_ciscoFlashPartitioningCommand, 
                                            ciscoFlashPartitioningEntry->valid);
          ciscoFlashPartitioningEntry->ciscoFlashPartitioningCommand =
                                         DEF_ciscoFlashPartitioningCommand; 

          SET_VALID(I_ciscoFlashPartitioningDestinationName, 
                                            ciscoFlashPartitioningEntry->valid);
          ciscoFlashPartitioningEntry->ciscoFlashPartitioningDestinationName =
          MakeOctetString(DEF_ciscoFlashPartitioningDestinationName,
                             strlen(DEF_ciscoFlashPartitioningDestinationName));
 
          SET_VALID(I_ciscoFlashPartitioningPartitionCount,
                                            ciscoFlashPartitioningEntry->valid);
          ciscoFlashPartitioningEntry->ciscoFlashPartitioningPartitionCount =
                                       DEF_ciscoFlashPartitioningPartitionCount;

          SET_VALID(I_ciscoFlashPartitioningPartitionSizes, 
                                            ciscoFlashPartitioningEntry->valid);
          ciscoFlashPartitioningEntry->ciscoFlashPartitioningPartitionSizes =
              MakeOctetString(DEF_ciscoFlashPartitioningPartitionSizes,
                              strlen(DEF_ciscoFlashPartitioningPartitionSizes));

          SET_VALID(I_ciscoFlashPartitioningNotifyOnCompletion,
                                            ciscoFlashPartitioningEntry->valid);
          ciscoFlashPartitioningEntry->ciscoFlashPartitioningNotifyOnCompletion
                                 = DEF_ciscoFlashPartitioningNotifyOnCompletion;

         /*
          * Assign a value to the ciscoFlashPartitioningEntryStatus but do NOT
          * set the valid flag. The valid flag will be set later when
          * a set request for this object is received.
          */
          ciscoFlashPartitioningEntry->ciscoFlashPartitioningEntryStatus =
                                D_ciscoFlashPartitioningEntryStatus_notReady;
        }
    }

   /* 
    * Once a row is active, do not allow any column other than
    * the EntryStatus to change.
    */
    if ((object->nominator != I_ciscoFlashPartitioningEntryStatus) &&    
        (ciscoFlashPartitioningEntry->ciscoFlashPartitioningEntryStatus ==
         D_ciscoFlashPartitioningEntryStatus_active))
        return(INCONSISTENT_VALUE_ERROR);

    switch (object->nominator) {

#ifdef I_ciscoFlashPartitioningCommand
      case I_ciscoFlashPartitioningCommand:

       if (value->sl_value != D_ciscoFlashPartitioningCommand_partition)
           return (WRONG_VALUE_ERROR);

       SET_VALID(I_ciscoFlashPartitioningCommand, 
                                            ciscoFlashPartitioningEntry->valid);
        ciscoFlashPartitioningEntry->ciscoFlashPartitioningCommand = 
                                                                value->sl_value;
        break;
#endif                                 /* I_ciscoFlashPartitioningCommand */

#ifdef I_ciscoFlashPartitioningDestinationName
      case I_ciscoFlashPartitioningDestinationName:

        if (value->os_value->length > SYSSIZE)
            return (WRONG_LENGTH_ERROR);

        SET_VALID(I_ciscoFlashPartitioningDestinationName, 
                                            ciscoFlashPartitioningEntry->valid);
        if (ciscoFlashPartitioningEntry->ciscoFlashPartitioningDestinationName 
                                                                      != NULL) {
            FreeOctetString(
            ciscoFlashPartitioningEntry->ciscoFlashPartitioningDestinationName);
        }
        ciscoFlashPartitioningEntry->ciscoFlashPartitioningDestinationName =
                                              CloneOctetString(value->os_value);
        break;
#endif                           /* I_ciscoFlashPartitioningDestinationName */

#ifdef I_ciscoFlashPartitioningPartitionCount
      case I_ciscoFlashPartitioningPartitionCount:

        SET_VALID(I_ciscoFlashPartitioningPartitionCount, 
                                            ciscoFlashPartitioningEntry->valid);
        ciscoFlashPartitioningEntry->ciscoFlashPartitioningPartitionCount = 
                                                                value->sl_value;
        break;
#endif                          /* I_ciscoFlashPartitioningPartitionCount */

#ifdef I_ciscoFlashPartitioningPartitionSizes
      case I_ciscoFlashPartitioningPartitionSizes:

        if (value->os_value->length > SYSSIZE)
            return (WRONG_LENGTH_ERROR);

        SET_VALID(I_ciscoFlashPartitioningPartitionSizes, 
                                            ciscoFlashPartitioningEntry->valid);
        if (ciscoFlashPartitioningEntry->ciscoFlashPartitioningPartitionSizes 
                                                                       !=NULL) {
            FreeOctetString(
             ciscoFlashPartitioningEntry->ciscoFlashPartitioningPartitionSizes);
        }
        ciscoFlashPartitioningEntry->ciscoFlashPartitioningPartitionSizes =
            CloneOctetString(value->os_value);
        break;
#endif                          /* I_ciscoFlashPartitioningPartitionSizes */

#ifdef I_ciscoFlashPartitioningNotifyOnCompletion
      case I_ciscoFlashPartitioningNotifyOnCompletion:

      if ((value->sl_value < D_ciscoFlashPartitioningNotifyOnCompletion_true) ||
         (value->sl_value > D_ciscoFlashPartitioningNotifyOnCompletion_false))
            return (WRONG_VALUE_ERROR);

        SET_VALID(I_ciscoFlashPartitioningNotifyOnCompletion, 
                                            ciscoFlashPartitioningEntry->valid);
        ciscoFlashPartitioningEntry->ciscoFlashPartitioningNotifyOnCompletion 
                                                              = value->sl_value;
        break;
#endif                        /* I_ciscoFlashPartitioningNotifyOnCompletion */

#ifdef I_ciscoFlashPartitioningEntryStatus
      case I_ciscoFlashPartitioningEntryStatus:

        /* Do NOT allow status to be set to notInService */
        if (value->sl_value == D_ciscoFlashPartitioningEntryStatus_notInService)
            return(INCONSISTENT_VALUE_ERROR);

        /* Perform generic row-status processing */
        retval = set_row_status(value->sl_value,
                               entry_found ? 1 : -1,
                               &(dp->state),
                               &(ciscoFlashPartitioningEntry->ciscoFlashPartitioningEntryStatus));
        if (retval != NO_ERROR)
            return(retval);

        SET_VALID(I_ciscoFlashPartitioningEntryStatus, 
                                            ciscoFlashPartitioningEntry->valid);

        break;
#endif                                 /* I_ciscoFlashPartitioningEntryStatus */

      default:
        DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in ciscoFlashPartitioningEntry_test)\n"));
        return (GEN_ERROR);

    }                                  /* switch */
    dp->state = ADD_MODIFY;

    /*
     * Check to see if we have a complete row. Note that we only need to
     * check if the EntryStatus is valid since all the other columns have
     * default values.
     */
    if (VALID(I_ciscoFlashPartitioningEntryStatus, 
                                          ciscoFlashPartitioningEntry->valid)) {
        good_row = TRUE;
    }
    else {
        good_row = FALSE;
    }

    /* Transition the row status as necessary */
    if (entry_found) {
        switch (ciscoFlashPartitioningEntry->ciscoFlashPartitioningEntryStatus){
        case D_ciscoFlashPartitioningEntryStatus_notInService:
            if (good_row)
                dp->state = ADD_MODIFY;
            else
                dp->state = NOT_READY_STATE;
            break;

        case D_ciscoFlashPartitioningEntryStatus_destroy:
            dp->state = DELETE;
            break;

        case D_ciscoFlashPartitioningEntryStatus_notReady:
            if (good_row)
                ciscoFlashPartitioningEntry->ciscoFlashPartitioningEntryStatus =
                              D_ciscoFlashPartitioningEntryStatus_notInService;
            dp->state = ADD_MODIFY;
            break;

        case D_ciscoFlashPartitioningEntryStatus_active:
            if (good_row)
                dp->state = ADD_MODIFY;
            else
                dp->state = NOT_READY_STATE;
            break;

        default:
            return(INCONSISTENT_VALUE_ERROR);
            break;
        }
    }
    else {
        switch (ciscoFlashPartitioningEntry->ciscoFlashPartitioningEntryStatus){
        case D_ciscoFlashPartitioningEntryStatus_createAndWait:
            if (good_row)
                ciscoFlashPartitioningEntry->ciscoFlashPartitioningEntryStatus =
                              D_ciscoFlashPartitioningEntryStatus_notInService;
            else
                ciscoFlashPartitioningEntry->ciscoFlashPartitioningEntryStatus =
                                  D_ciscoFlashPartitioningEntryStatus_notReady;
            dp->state = ADD_MODIFY;
            break;

        case D_ciscoFlashPartitioningEntryStatus_notReady:
            if (good_row)
                ciscoFlashPartitioningEntry->ciscoFlashPartitioningEntryStatus =
                              D_ciscoFlashPartitioningEntryStatus_notInService;
            if (VALID(I_ciscoFlashPartitioningEntryStatus, 
                                            ciscoFlashPartitioningEntry->valid))
                dp->state = ADD_MODIFY;
            break;

        case D_ciscoFlashPartitioningEntryStatus_createAndGo:
            if (good_row)
                dp->state = ADD_MODIFY;
            else
                dp->state = CREATE_AND_GO_STATE;
            break;

        case D_ciscoFlashPartitioningEntryStatus_destroy:
            dp->state = DELETE;
            break;

        case D_ciscoFlashPartitioningEntryStatus_notInService:
            if (!good_row)
                ciscoFlashPartitioningEntry->ciscoFlashPartitioningEntryStatus =
                                  D_ciscoFlashPartitioningEntryStatus_notReady;
            dp->state = ADD_MODIFY;
            break;

        default:
            return(INCONSISTENT_VALUE_ERROR);
            break;
        }
    }
    return (NO_ERROR);
}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
ciscoFlashPartitioningEntry_set (doList_t       *doHead, 
    				 doList_t       *doCur,
    				 ContextInfo    *contextInfo)
{
    return (k_ciscoFlashPartitioningEntry_set((ciscoFlashPartitioningEntry_t *) (doCur->data), contextInfo, doCur->state));
}

#endif                                 /* SETS */

/*---------------------------------------------------------------------
 * Retrieve data from the ciscoFlashMiscOpEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ciscoFlashMiscOpEntry_get (OID            *incoming, 
    			   ObjectInfo     *object,
    			   int             searchType,
    			   ContextInfo    *contextInfo,
    			   int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ciscoFlashMiscOpEntry_t *data = NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            ciscoFlashMiscOpSerialNumber;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, 
                     &ciscoFlashMiscOpSerialNumber, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ciscoFlashMiscOpEntry_get(serialNum, 
                               contextInfo, arg, searchType, 
                               ciscoFlashMiscOpSerialNumber)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->ciscoFlashMiscOpSerialNumber;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ciscoFlashMiscOpCommand
      case I_ciscoFlashMiscOpCommand:
	dp = &data->ciscoFlashMiscOpCommand;
	break;
#endif				       /* I_ciscoFlashMiscOpCommand */

#ifdef I_ciscoFlashMiscOpDestinationName
      case I_ciscoFlashMiscOpDestinationName:
	dp = MakeOctetString(data->ciscoFlashMiscOpDestinationName->octet_ptr, 
                                 data->ciscoFlashMiscOpDestinationName->length);
	break;
#endif				       /* I_ciscoFlashMiscOpDestinationName */

#ifdef I_ciscoFlashMiscOpStatus
      case I_ciscoFlashMiscOpStatus:
	dp = &data->ciscoFlashMiscOpStatus;
	break;
#endif				       /* I_ciscoFlashMiscOpStatus */

#ifdef I_ciscoFlashMiscOpNotifyOnCompletion
      case I_ciscoFlashMiscOpNotifyOnCompletion:
	dp = &data->ciscoFlashMiscOpNotifyOnCompletion;
	break;
#endif				       /* I_ciscoFlashMiscOpNotifyOnCompletion
				        *  */

#ifdef I_ciscoFlashMiscOpTime
      case I_ciscoFlashMiscOpTime:
	dp = &data->ciscoFlashMiscOpTime;
	break;
#endif				       /* I_ciscoFlashMiscOpTime */

#ifdef I_ciscoFlashMiscOpEntryStatus
      case I_ciscoFlashMiscOpEntryStatus:
	dp = &data->ciscoFlashMiscOpEntryStatus;
	break;
#endif				       /* I_ciscoFlashMiscOpEntryStatus */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    if ((dp == NULL) || !VALID(arg, data->valid))
        return ((VarBind *) NULL);
    else
        return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the ciscoFlashMiscOpEntry data object.
 *---------------------------------------------------------------------*/
void
ciscoFlashMiscOpEntry_free (ciscoFlashMiscOpEntry_t *data)
{
    if (data != NULL) {
	if (data->ciscoFlashMiscOpDestinationName != NULL) {
	    FreeOctetString(data->ciscoFlashMiscOpDestinationName);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after ciscoFlashMiscOpEntry set/undo
 *---------------------------------------------------------------------*/
static int
ciscoFlashMiscOpEntry_cleanup (doList_t  *trash)
{
    ciscoFlashMiscOpEntry_free(trash->data);
#ifdef SR_SNMPv2
    ciscoFlashMiscOpEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
ciscoFlashMiscOpEntry_test (OID            *incoming, 
    			    ObjectInfo     *object,
    			    ObjectSyntax   *value,
    			    doList_t       *doHead,
    			    doList_t       *doCur,
    			    ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    /* VarBind        *vb = (VarBind *) NULL; */
    int             found;
    int             retval;
    int             carry = 0;
    ciscoFlashMiscOpEntry_t *ciscoFlashMiscOpEntry;
    long            ciscoFlashMiscOpSerialNumber;
    boolean         entry_found, good_row;

    /*
     * Validate the object instance
     *
     */
    if (instLength != 1) {
        return NO_CREATION_ERROR;
    }
    if ((InstToInt(incoming, 0 + object->oid.length,
                          &ciscoFlashMiscOpSerialNumber, EXACT, &carry)) < 0) {        return (NO_CREATION_ERROR);
    }
    ciscoFlashMiscOpEntry = k_ciscoFlashMiscOpEntry_get(-1, contextInfo,
                        object->nominator, EXACT, ciscoFlashMiscOpSerialNumber);
    entry_found = (ciscoFlashMiscOpEntry != NULL);

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = FALSE;

    for (dp = doHead; dp != NULL; dp = dp->next) {
        if ((dp->setMethod == ciscoFlashMiscOpEntry_set) &&
            (((ciscoFlashMiscOpEntry_t *) (dp->data)) != NULL) &&
            (((ciscoFlashMiscOpEntry_t *) (dp->data))->ciscoFlashMiscOpSerialNumber == ciscoFlashMiscOpSerialNumber)) {

            found = TRUE;
            break;
        }
    }

    if (found) {
        ciscoFlashMiscOpEntry = dp->data;
    }
    else {
        dp = doCur;
        if ((dp->data = malloc(sizeof(ciscoFlashMiscOpEntry_t)))
                                                               == NULL) {
            DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
            return (RESOURCE_UNAVAILABLE_ERROR);
        }
        memset(dp->data, 0, sizeof(ciscoFlashMiscOpEntry_t));

        dp->setMethod = ciscoFlashMiscOpEntry_set;
        dp->cleanupMethod = ciscoFlashMiscOpEntry_cleanup;
#ifdef SR_SNMPv2
        dp->undoMethod = NULL;
#endif                                 /* SR_SNMPv2 */
        dp->state = UNKNOWN;
       /*
        * Try to fill in reasonable defaults for this new doList entry
        */
        if (entry_found) {
           /*
            * We will copy over values that already exist
            */
            memcpy(dp->data, ciscoFlashMiscOpEntry,
                                        sizeof(ciscoFlashMiscOpEntry_t));
     if (ciscoFlashMiscOpEntry->ciscoFlashMiscOpDestinationName != NULL)
                ((ciscoFlashMiscOpEntry_t *)(dp->data))->ciscoFlashMiscOpDestinationName = CloneOctetString(
            ciscoFlashMiscOpEntry->ciscoFlashMiscOpDestinationName);

            ciscoFlashMiscOpEntry = dp->data;
        }
        else {
           /*
            * This is a brand new row
            */
            ciscoFlashMiscOpEntry = dp->data;

          SET_VALID(I_ciscoFlashMiscOpSerialNumber,
                                            ciscoFlashMiscOpEntry->valid);
          ciscoFlashMiscOpEntry->ciscoFlashMiscOpSerialNumber =
                                           ciscoFlashMiscOpSerialNumber;

          SET_VALID(I_ciscoFlashMiscOpDestinationName,
                                            ciscoFlashMiscOpEntry->valid);
          ciscoFlashMiscOpEntry->ciscoFlashMiscOpDestinationName =
          MakeOctetString(DEF_ciscoFlashMiscOpDestinationName,
                      strlen(DEF_ciscoFlashMiscOpDestinationName));

          SET_VALID(I_ciscoFlashMiscOpNotifyOnCompletion,
                                            ciscoFlashMiscOpEntry->valid);
          ciscoFlashMiscOpEntry->ciscoFlashMiscOpNotifyOnCompletion
                    = DEF_ciscoFlashMiscOpNotifyOnCompletion;

         /*
          * Assign a value to the ciscoFlashMiscOpEntryStatus but do NOT
          * set the valid flag. The valid flag will be set later when
          * a set request for this object is received.
          */
          ciscoFlashMiscOpEntry->ciscoFlashMiscOpEntryStatus =
                                D_ciscoFlashMiscOpEntryStatus_notReady;
        }
    }

   /*
    * Once a row is active, do not allow any column other than
    * the EntryStatus to change.
    */
    if ((object->nominator != I_ciscoFlashMiscOpEntryStatus) &&
        (ciscoFlashMiscOpEntry->ciscoFlashMiscOpEntryStatus ==
         D_ciscoFlashMiscOpEntryStatus_active))
        return(INCONSISTENT_VALUE_ERROR);

    switch (object->nominator) {

#ifdef I_ciscoFlashMiscOpCommand
      case I_ciscoFlashMiscOpCommand:

       if ((value->sl_value < D_ciscoFlashMiscOpCommand_erase) ||
           (value->sl_value > D_ciscoFlashMiscOpCommand_format))
           return (WRONG_VALUE_ERROR);

       SET_VALID(I_ciscoFlashMiscOpCommand, ciscoFlashMiscOpEntry->valid);
        ciscoFlashMiscOpEntry->ciscoFlashMiscOpCommand = value->sl_value;
        break;
#endif                                 /* I_ciscoFlashMiscOpCommand */

#ifdef I_ciscoFlashMiscOpDestinationName
      case I_ciscoFlashMiscOpDestinationName:

        if (value->os_value->length > SYSSIZE)
            return (WRONG_LENGTH_ERROR);

        SET_VALID(I_ciscoFlashMiscOpDestinationName,
                                            ciscoFlashMiscOpEntry->valid);
        if (ciscoFlashMiscOpEntry->ciscoFlashMiscOpDestinationName != NULL) {
            FreeOctetString(
            ciscoFlashMiscOpEntry->ciscoFlashMiscOpDestinationName);
        }
        ciscoFlashMiscOpEntry->ciscoFlashMiscOpDestinationName =
            CloneOctetString(value->os_value);
        break;
#endif                           /* I_ciscoFlashMiscOpDestinationName */

#ifdef I_ciscoFlashMiscOpNotifyOnCompletion
      case I_ciscoFlashMiscOpNotifyOnCompletion:

        if ((value->sl_value != D_ciscoFlashMiscOpNotifyOnCompletion_true) &&
            (value->sl_value != D_ciscoFlashMiscOpNotifyOnCompletion_false))
            return (WRONG_VALUE_ERROR);

        SET_VALID(I_ciscoFlashMiscOpNotifyOnCompletion,
                                            ciscoFlashMiscOpEntry->valid);
        ciscoFlashMiscOpEntry->ciscoFlashMiscOpNotifyOnCompletion
                                                              = value->sl_value;
        break;
#endif                        /* I_ciscoFlashMiscOpNotifyOnCompletion */

#ifdef I_ciscoFlashMiscOpEntryStatus
      case I_ciscoFlashMiscOpEntryStatus:

        /* Do NOT allow status to be set to notInService */
        if (value->sl_value == D_ciscoFlashMiscOpEntryStatus_notInService)
            return(INCONSISTENT_VALUE_ERROR);
        /* Perform generic row-status processing */
        retval = set_row_status(value->sl_value,
                         entry_found ? 1 : -1,
                         &(dp->state),
                         &(ciscoFlashMiscOpEntry->ciscoFlashMiscOpEntryStatus));
        if (retval != NO_ERROR)
            return(retval);

        SET_VALID(I_ciscoFlashMiscOpEntryStatus,
                                            ciscoFlashMiscOpEntry->valid);

        break;
#endif                                 /* I_ciscoFlashMiscOpEntryStatus */

      default:
        DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in ciscoFlashMiscOpEntry_test)\n"));
        return (GEN_ERROR);

    }                                  /* switch */
    dp->state = ADD_MODIFY;

    /*
     * Check to see if we have a complete row
     */
    if (VALID(I_ciscoFlashMiscOpCommand,
                                         ciscoFlashMiscOpEntry->valid) &&
        VALID(I_ciscoFlashMiscOpEntryStatus,
                                          ciscoFlashMiscOpEntry->valid)) {
        good_row = TRUE;
    }
    else {
        good_row = FALSE;
    }

    /* Transition the row status as necessary */
    if (entry_found) {
        switch (ciscoFlashMiscOpEntry->ciscoFlashMiscOpEntryStatus){
        case D_ciscoFlashMiscOpEntryStatus_notInService:
            if (good_row)
                dp->state = ADD_MODIFY;
            else
                dp->state = NOT_READY_STATE;
            break;

        case D_ciscoFlashMiscOpEntryStatus_destroy:
            dp->state = DELETE;
            break;

        case D_ciscoFlashMiscOpEntryStatus_notReady:
            if (good_row)
                ciscoFlashMiscOpEntry->ciscoFlashMiscOpEntryStatus =
                              D_ciscoFlashMiscOpEntryStatus_notInService;
     dp->state = ADD_MODIFY;
            break;

        case D_ciscoFlashMiscOpEntryStatus_active:
            if (good_row)
                dp->state = ADD_MODIFY;
            else
                dp->state = NOT_READY_STATE;
            break;

        default:
            return(INCONSISTENT_VALUE_ERROR);
            break;
        }
    }
    else {
        switch (ciscoFlashMiscOpEntry->ciscoFlashMiscOpEntryStatus){
        case D_ciscoFlashMiscOpEntryStatus_createAndWait:
            if (good_row)
                ciscoFlashMiscOpEntry->ciscoFlashMiscOpEntryStatus =
                              D_ciscoFlashMiscOpEntryStatus_notInService;
     else
                ciscoFlashMiscOpEntry->ciscoFlashMiscOpEntryStatus =
                                  D_ciscoFlashMiscOpEntryStatus_notReady;
     dp->state = ADD_MODIFY;
            break;

        case D_ciscoFlashMiscOpEntryStatus_notReady:
            if (good_row)
                ciscoFlashMiscOpEntry->ciscoFlashMiscOpEntryStatus =
                              D_ciscoFlashMiscOpEntryStatus_notInService;
     if (VALID(I_ciscoFlashMiscOpEntryStatus,
                                            ciscoFlashMiscOpEntry->valid))
                dp->state = ADD_MODIFY;
            break;

        case D_ciscoFlashMiscOpEntryStatus_createAndGo:
            if (good_row)
                dp->state = ADD_MODIFY;
            else
                dp->state = CREATE_AND_GO_STATE;
            break;

        case D_ciscoFlashMiscOpEntryStatus_destroy:
            dp->state = DELETE;
            break;

        case D_ciscoFlashMiscOpEntryStatus_notInService:
            if (!good_row)
                ciscoFlashMiscOpEntry->ciscoFlashMiscOpEntryStatus =
                                  D_ciscoFlashMiscOpEntryStatus_notReady;
            dp->state = ADD_MODIFY;
            break;

        default:
            return(INCONSISTENT_VALUE_ERROR);
            break;
        }
    }
    return (NO_ERROR);
}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
ciscoFlashMiscOpEntry_set (doList_t       *doHead, 
    			   doList_t       *doCur,
    			   ContextInfo    *contextInfo)
{
    return(k_ciscoFlashMiscOpEntry_set((ciscoFlashMiscOpEntry_t *)(doCur->data),
                                                    contextInfo, doCur->state));
}

#endif				       /* SETS */


ciscoFlashDevice_t *
k_ciscoFlashDevice_get (int             serialNum, 
    			ContextInfo    *contextInfo,
    			int             nominator)
{
    static ciscoFlashDevice_t ciscoFlashDeviceData;

    ciscoFlashDeviceData.ciscoFlashDevicesSupported = snmp_flash_device_count();

    return (&ciscoFlashDeviceData);
}

ciscoFlashDeviceEntry_t *
k_ciscoFlashDeviceEntry_get (int             serialNum, 
    			     ContextInfo    *contextInfo,
    			     int             nominator,
    			     int             searchType,
    			     long            ciscoFlashDeviceIndex)
{
    int dev_cnt;
    static ciscoFlashDeviceEntry_t ciscoFlashDeviceEntryData;
    static char devnm[FLASH_DEV_NAME_LEN];
    char *dev_cntlr_name = NULL;
    char *dev_descr = NULL;

    if ((searchType != EXACT) && (ciscoFlashDeviceIndex == 0)) 
	ciscoFlashDeviceIndex = 1;

    dev_cnt = snmp_flash_device_count();
    for (;;) {
	snmp_make_devnm(ciscoFlashDeviceIndex, 0, devnm);
	if (strlen(devnm) != 0)
	    break;
	if (searchType == EXACT)
	    return (NULL);
	if (++ciscoFlashDeviceIndex > dev_cnt)
	    return (NULL);
    }

    ciscoFlashDeviceEntryData.ciscoFlashDeviceIndex = ciscoFlashDeviceIndex;
    ciscoFlashDeviceEntryData.ciscoFlashDeviceSize = snmp_flash_dev_size(devnm);
    ciscoFlashDeviceEntryData.ciscoFlashDeviceMinPartitionSize = 
                                           snmp_flash_dev_min_partn_size(devnm);
    ciscoFlashDeviceEntryData.ciscoFlashDeviceMaxPartitions = 
                                               snmp_flash_dev_max_partns(devnm);
    ciscoFlashDeviceEntryData.ciscoFlashDevicePartitions = 
                                               snmp_flash_dev_num_partns(devnm);
    ciscoFlashDeviceEntryData.ciscoFlashDeviceChipCount = 
                                               snmp_flash_device_chipcnt(devnm);

    if (ciscoFlashDeviceEntryData.ciscoFlashDeviceName)
	FreeOctetString(ciscoFlashDeviceEntryData.ciscoFlashDeviceName);
    ciscoFlashDeviceEntryData.ciscoFlashDeviceName = 
                                          MakeOctetString(devnm, strlen(devnm));

    dev_descr = snmp_flash_dev_desc(devnm);
    if (ciscoFlashDeviceEntryData.ciscoFlashDeviceDescr)
	FreeOctetString(ciscoFlashDeviceEntryData.ciscoFlashDeviceDescr);
    ciscoFlashDeviceEntryData.ciscoFlashDeviceDescr = 
                                  MakeOctetString(dev_descr, strlen(dev_descr));

    dev_cntlr_name = snmp_flash_dev_cntlr(devnm);
    if (ciscoFlashDeviceEntryData.ciscoFlashDeviceController)
	FreeOctetString(ciscoFlashDeviceEntryData.ciscoFlashDeviceController);
    ciscoFlashDeviceEntryData.ciscoFlashDeviceController = 
                        MakeOctetString(dev_cntlr_name, strlen(dev_cntlr_name));
    if (ciscoFlashDeviceEntryData.ciscoFlashDeviceCard)
	FreeOID(ciscoFlashDeviceEntryData.ciscoFlashDeviceCard);
    ciscoFlashDeviceEntryData.ciscoFlashDeviceCard = 
	snmp_flash_dev_card_index(devnm);

    ciscoFlashDeviceEntryData.ciscoFlashDeviceProgrammingJumper = 
                                                      snmp_flash_dev_vpp(devnm);
    ciscoFlashDeviceEntryData.ciscoFlashDeviceInitTime = 
	SNMP_ABSOLUTE_TIME(snmp_flash_dev_init_t(devnm));
    ciscoFlashDeviceEntryData.ciscoFlashDeviceRemovable = 
                                                snmp_flash_dev_removable(devnm);

    if (ciscoFlashDeviceEntryData.ciscoFlashDeviceIndex == 
                                                          ciscoFlashDeviceIndex)
    	return (&ciscoFlashDeviceEntryData);
    else
	return (NULL);
}

ciscoFlashChipEntry_t *
k_ciscoFlashChipEntry_get (int             serialNum, 
    			   ContextInfo    *contextInfo,
    			   int             nominator,
    			   int             searchType,
    			   long            ciscoFlashDeviceIndex,
    			   long            ciscoFlashChipIndex)
{
    static ciscoFlashChipEntry_t ciscoFlashChipEntryData;
    uchar *chipcodeStr, *chipdescStr;
    int devNum, chipNum, chip_cnt, dev_cnt;
    char *devnm;
    boolean flash_dev_removed = FALSE;

    devnm = malloc(FLASH_PHY_DEV_NAME_LEN);
    if (!devnm)
	return (NULL);
    chipcodeStr = malloc(FLASH_FILE_NAME_LEN);  
    if (!chipcodeStr) {
	free(devnm);
	return (NULL);
    }

    devNum = (searchType == NEXT && ciscoFlashDeviceIndex == 0) ?
			1 : ciscoFlashDeviceIndex;
    chipNum = (searchType == NEXT && ciscoFlashChipIndex == 0) ?
			1 : ciscoFlashChipIndex;

    if ((devNum == 0) || (chipNum == 0)) {
	free(devnm);
	free(chipcodeStr);
	return (NULL);
    }

    dev_cnt = snmp_flash_device_count();
    do {
	/*
	 * EXACT search - if the device doesn't exist or has been removed
	 * we return back NOTHING
	 * GETNEXT srch - find the next flash device present in its slot
	 */
        snmp_make_devnm(devNum, 0, devnm);
        flash_dev_removed = snmp_flash_dev_removed(devnm);
        chip_cnt = snmp_flash_device_chipcnt(devnm);

	if (strlen(devnm) && !flash_dev_removed && (chipNum <= chip_cnt))
	    break;

	if ((searchType == EXACT) ||
	    (++devNum > dev_cnt)) {
	    free(devnm);
	    free(chipcodeStr);
	    return (NULL);
        }
        chipNum = 1; /* Point to first chip */

    } while (TRUE);
	
    /* Get the device name from the device and partition number */
    snmp_make_devnm(devNum, 0, devnm);

    if (strlen(devnm)) {
	ciscoFlashChipEntryData.ciscoFlashDeviceIndex = devNum;
	ciscoFlashChipEntryData.ciscoFlashChipIndex = chipNum;
	chipNum--;
	snmp_flash_chipcode(devnm, chipNum, chipcodeStr);
	if (ciscoFlashChipEntryData.ciscoFlashChipCode != NULL)
	    FreeOctetString(ciscoFlashChipEntryData.ciscoFlashChipCode);
	ciscoFlashChipEntryData.ciscoFlashChipCode =
		MakeOctetString(chipcodeStr, strlen(chipcodeStr));
	free (chipcodeStr);
	chipdescStr = snmp_flash_chipdesc(devnm, chipNum);
	if (ciscoFlashChipEntryData.ciscoFlashChipDescr != NULL)
	    FreeOctetString(ciscoFlashChipEntryData.ciscoFlashChipDescr);
	ciscoFlashChipEntryData.ciscoFlashChipDescr =
		MakeOctetString(chipdescStr, strlen(chipdescStr));
	ciscoFlashChipEntryData.ciscoFlashChipWriteRetries =
	    snmp_flash_chip_wretries(devnm, chipNum);
	ciscoFlashChipEntryData.ciscoFlashChipEraseRetries =
	    snmp_flash_chip_eretries(devnm, chipNum);
	ciscoFlashChipEntryData.ciscoFlashChipMaxWriteRetries =
	    snmp_flash_chip_max_wretries(devnm);
	ciscoFlashChipEntryData.ciscoFlashChipMaxEraseRetries =
	    snmp_flash_chip_max_eretries(devnm);

	/* Make sure this is the one chip we want to return info. for */
	if ((ciscoFlashChipEntryData.ciscoFlashChipIndex == chipNum+1) &&
	    (ciscoFlashChipEntryData.ciscoFlashDeviceIndex == devNum)){
	    free(devnm);
	    return (&ciscoFlashChipEntryData);
	}
    } else {
	free(chipcodeStr);
    }
    free(devnm);
    return (NULL);
}

ciscoFlashPartitionEntry_t *
k_ciscoFlashPartitionEntry_get (int             serialNum,
    				ContextInfo    *contextInfo,
    				int             nominator,
    				int             searchType,
    				long            ciscoFlashDeviceIndex,
    				long            ciscoFlashPartitionIndex)
{
    static ciscoFlashPartitionEntry_t ciscoFlashPartitionEntryData;
    static char *devnm;
    char *part_name;
    int part_cnt, dev_cnt;
    boolean flash_dev_removed = FALSE;

    devnm = malloc(FLASH_PHY_DEV_NAME_LEN);
    if (!devnm) 
        return((ciscoFlashPartitionEntry_t *)NULL);

    if (searchType == EXACT) {
        /* The device and partition indices should not be zero */
        if ((ciscoFlashPartitionIndex == 0) || (ciscoFlashDeviceIndex == 0)) {
	    free(devnm);
            return ((ciscoFlashPartitionEntry_t *)NULL);
	}
    }
    else {  /* searchType is NEXT */
        /* If indices are 0, set them to 1 */
        if (ciscoFlashPartitionIndex == 0)
            ciscoFlashPartitionIndex = 1;
        if (ciscoFlashDeviceIndex == 0)
            ciscoFlashDeviceIndex = 1;
    }

    dev_cnt = snmp_flash_device_count();
    do {
        /*
         * EXACT search - if the device doesn't exist or has been removed
         * we return back NOTHING
         * GETNEXT srch - find the next flash device present in its slot
         */
        snmp_make_devnm(ciscoFlashDeviceIndex, 0, devnm);
        flash_dev_removed = snmp_flash_dev_removed(devnm);
        part_cnt = snmp_flash_dev_num_partns(devnm);

	if ((strlen(devnm) &&
	     !flash_dev_removed &&
	     (ciscoFlashPartitionIndex <= part_cnt)))
	    break;

	if ((searchType == EXACT) ||
	    (++ciscoFlashDeviceIndex > dev_cnt)) {
	    free(devnm);
	    return (NULL);
	}
        ciscoFlashPartitionIndex = 1; /* Point to first partition */
     } while (TRUE);

    snmp_make_devnm(ciscoFlashDeviceIndex, ciscoFlashPartitionIndex, devnm);

    if (strlen(devnm)) {
        ciscoFlashPartitionEntryData.ciscoFlashDeviceIndex =
                                                       ciscoFlashDeviceIndex;
        ciscoFlashPartitionEntryData.ciscoFlashPartitionIndex = 
                                          snmp_flash_partition_number(devnm); 
        snmp_flash_partition_chip_bounds(devnm,
                   &ciscoFlashPartitionEntryData.ciscoFlashPartitionStartChip,
                   &ciscoFlashPartitionEntryData.ciscoFlashPartitionEndChip);
        ciscoFlashPartitionEntryData.ciscoFlashPartitionSize =
                                            snmp_flash_partition_size(devnm);
        ciscoFlashPartitionEntryData.ciscoFlashPartitionFreeSpace =
                                      snmp_flash_partition_free_space(devnm);
        ciscoFlashPartitionEntryData.ciscoFlashPartitionFileCount =
                                       snmp_flash_partition_filecount(devnm);
        ciscoFlashPartitionEntryData.ciscoFlashPartitionChecksumAlgorithm =
                                     snmp_flash_partition_chksum_algo(devnm);
        ciscoFlashPartitionEntryData.ciscoFlashPartitionStatus =
                                          snmp_flash_partition_status(devnm);
        ciscoFlashPartitionEntryData.ciscoFlashPartitionUpgradeMethod =
                                  snmp_flash_partition_upgrade_method(devnm);
        part_name = snmp_flash_partition_name(devnm);
        if (ciscoFlashPartitionEntryData.ciscoFlashPartitionName)
          FreeOctetString(
                       ciscoFlashPartitionEntryData.ciscoFlashPartitionName);
        ciscoFlashPartitionEntryData.ciscoFlashPartitionName =
                  MakeOctetString(part_name, strlen(part_name));
        ciscoFlashPartitionEntryData.ciscoFlashPartitionNeedErasure =
                                    snmp_flash_partition_need_erasure(devnm);
        ciscoFlashPartitionEntryData.ciscoFlashPartitionFileNameLength =
                                 snmp_flash_partition_filename_length(devnm);

        /* Make sure the partition and device numbers are right */
        if ((ciscoFlashPartitionEntryData.ciscoFlashPartitionIndex ==
                                                ciscoFlashPartitionIndex) &&
            (ciscoFlashPartitionEntryData.ciscoFlashDeviceIndex ==
                                                   ciscoFlashDeviceIndex)) {
            free(devnm);
            return (&ciscoFlashPartitionEntryData); /* Return collected data */
        }
    }

    free(devnm);
    return ((ciscoFlashPartitionEntry_t *)NULL);
}

ciscoFlashFileEntry_t *
k_ciscoFlashFileEntry_get (int             serialNum, 
    			   ContextInfo    *contextInfo,
    			   int             nominator,
    			   int             searchType,
    			   long            ciscoFlashDeviceIndex,
    			   long            ciscoFlashPartitionIndex,
    			   long            ciscoFlashFileIndex)
{
    static ciscoFlashFileEntry_t ciscoFlashFileEntryData;
    uchar *chksumStr, *fnameStr;
    int devNum, partNum, fileNum, part_cnt, file_cnt, dev_cnt;
    char *devnm;
    boolean flash_dev_removed;
    
    devnm = malloc(FLASH_PHY_DEV_NAME_LEN);
    if (!devnm) 
        return(NULL);
    chksumStr = malloc(FLASH_FILE_NAME_LEN);  
    if (!chksumStr) {
	free(devnm);
	return (NULL);
    }

    devNum = (searchType == NEXT && (ciscoFlashDeviceIndex == 0)) ?
		    1 : ciscoFlashDeviceIndex;
    partNum = (searchType == NEXT && (ciscoFlashPartitionIndex == 0)) ?
		    1 : ciscoFlashPartitionIndex; 
    fileNum = (searchType == NEXT && (ciscoFlashFileIndex == 0)) ?
		    1 : ciscoFlashFileIndex;
    
    if ((devNum == 0) || (partNum == 0) || (fileNum == 0)) {
	free(devnm);
	free(chksumStr);
	return (NULL);
    }

    dev_cnt = snmp_flash_device_count();
    do {	
        /*
         * EXACT search - if the device doesn't exist or has been removed
         * we return back NOTHING
         * GETNEXT srch - find the next flash device present in its slot
         */

        /* Make devnm corresponding to entire device */
        snmp_make_devnm(devNum, 0, devnm);
	flash_dev_removed = snmp_flash_dev_removed(devnm);

        /* Determine number of partitions on that device */
        part_cnt = snmp_flash_dev_num_partns(devnm);

	/* Make devnm corresponding to a partition */
        snmp_make_devnm(devNum, partNum, devnm);
	/* Determine number of files on that device */
	file_cnt = snmp_flash_partition_filecount(devnm);

	if (strlen(devnm) &&
	    !flash_dev_removed &&
	    (partNum <= part_cnt) &&
	    (fileNum <= file_cnt))
	    break;

	if (searchType == EXACT) {
	    free(devnm);
	    free(chksumStr);
	    return (NULL);
	}

        if (fileNum > file_cnt) {
            partNum++;   /* Point to next partition */
	    fileNum = 1; /* Point to first file */
        }
	if (partNum > part_cnt) {
	    devNum++;
	    partNum = 1;
	    fileNum = 1;
	}
	if (devNum > dev_cnt) {
	    free(devnm);
	    free(chksumStr);
	    return NULL;
        }
    } while (TRUE);

    /* Get the device name from the device and partition number */
    snmp_make_devnm(devNum, partNum, devnm);

    if (strlen(devnm)) {
	fileNum--;
	ciscoFlashFileEntryData.ciscoFlashDeviceIndex = devNum;
	ciscoFlashFileEntryData.ciscoFlashPartitionIndex = partNum;
	ciscoFlashFileEntryData.ciscoFlashFileIndex =
		snmp_flash_fileindx(devnm, fileNum);
	ciscoFlashFileEntryData.ciscoFlashFileSize =
		snmp_flash_file_size(devnm, fileNum);
	snmp_flash_filechksum(devnm, fileNum, chksumStr);
	if (ciscoFlashFileEntryData.ciscoFlashFileChecksum != NULL)
	    FreeOctetString(ciscoFlashFileEntryData.ciscoFlashFileChecksum);
	ciscoFlashFileEntryData.ciscoFlashFileChecksum =
		MakeOctetString(chksumStr, strlen(chksumStr));
	ciscoFlashFileEntryData.ciscoFlashFileStatus =
	    snmp_flash_filestatus(devnm, fileNum);
	fnameStr = snmp_flash_filename(devnm, fileNum);
	if (ciscoFlashFileEntryData.ciscoFlashFileName != NULL)
	    FreeOctetString(ciscoFlashFileEntryData.ciscoFlashFileName);
	if (fnameStr != NULL)		
	    ciscoFlashFileEntryData.ciscoFlashFileName =
		MakeOctetString(fnameStr, strlen(fnameStr));
	else   /* No file, display name as a blank */
	    ciscoFlashFileEntryData.ciscoFlashFileName =
		MakeOctetString("", 1);

	/* Make sure this is the one file we want to return info. for */
	if ((ciscoFlashFileEntryData.ciscoFlashFileIndex == fileNum+1) &&
	    (ciscoFlashFileEntryData.ciscoFlashDeviceIndex == devNum) &&
	    (ciscoFlashFileEntryData.ciscoFlashPartitionIndex == partNum)){
	    free (chksumStr);
	    free(devnm);
	    return (&ciscoFlashFileEntryData);
	}
    } 
    free(chksumStr);
    free(devnm);
    return (NULL);
}

ciscoFlashCopyEntry_t *
k_ciscoFlashCopyEntry_get (int             serialNum, 
    			   ContextInfo    *contextInfo,
    			   int             nominator,
    			   int             searchType,
    			   long            ciscoFlashCopySerialNumber)
{
    static ciscoFlashCopyEntry_t ciscoFlashCopyEntryData;
    copyQ	*data;
    leveltype	level;

    while (TRUE) {
	data = copyQget(searchType, ciscoFlashCopySerialNumber);
	if (data == NULL)
	    return (NULL);

	/*
	 * disable the flash copy task for a quick snapshot
	 */
	level = raise_interrupt_level(ALL_DISABLE);
	memcpy(&ciscoFlashCopyEntryData,
		data->entry,
		sizeof(ciscoFlashCopyEntry_t));
	reset_interrupt_level(level);

	/*
	 * if the request was a get, or if the request was a
	 * get-next and the requested field has data, then
	 * return the record
	 */
	if ((searchType == EXACT) || 
	    (VALID(nominator, ciscoFlashCopyEntryData.valid)))
	    return (&ciscoFlashCopyEntryData);

	/*
	 * the request was obviously a get-next on a sparse field so
	 * look for another
	 */
	ciscoFlashCopySerialNumber = 
	    ciscoFlashCopyEntryData.ciscoFlashCopySerialNumber + 1;
    }
}

ciscoFlashPartitioningEntry_t *
k_ciscoFlashPartitioningEntry_get (int             serialNum, 
    				   ContextInfo    *contextInfo,
    				   int             nominator,
    				   int             searchType,
    				   long            ciscoFlashPartitioningSerialNumber)
{
    static ciscoFlashPartitioningEntry_t ciscoFlashPartitioningEntryData;
    partQ      *data;
    leveltype  level;

    while (TRUE) {
        data = partQget(searchType, ciscoFlashPartitioningSerialNumber);
        if (data == NULL)
            return (NULL);

        /* Block interrupts while taking a quick snapshot */
        level = raise_interrupt_level(ALL_DISABLE);
        memcpy(&ciscoFlashPartitioningEntryData, data->entry,
               sizeof(ciscoFlashPartitioningEntry_t));
        reset_interrupt_level(level);

        /*
         * If the searchType was EXACT, or if the requested field
         * has valid data, then return this record.
         */
         if ((searchType == EXACT) ||
             (VALID(nominator, ciscoFlashPartitioningEntryData.valid)))
             return(&ciscoFlashPartitioningEntryData);

         /* This request must have been a get-next on a sparse field */
         ciscoFlashPartitioningSerialNumber =
         ciscoFlashPartitioningEntryData.ciscoFlashPartitioningSerialNumber + 1;
    }
}

ciscoFlashMiscOpEntry_t *
k_ciscoFlashMiscOpEntry_get (int             serialNum, 
    			     ContextInfo    *contextInfo,
    			     int             nominator,
    			     int             searchType,
    			     long            ciscoFlashMiscOpSerialNumber)
{
    static ciscoFlashMiscOpEntry_t ciscoFlashMiscOpEntryData;
    miscopQ      *data;
    leveltype  level;

    while (TRUE) {
        data = miscopQget(searchType, ciscoFlashMiscOpSerialNumber);
        if (data == NULL)
            return (NULL);

         /* Block interrupts while taking a quick snapshot */
         level = raise_interrupt_level(ALL_DISABLE);
         memcpy(&ciscoFlashMiscOpEntryData, data->entry,
                sizeof(ciscoFlashMiscOpEntry_t));
         reset_interrupt_level(level);

        /*
         * If the searchType was EXACT, or if the requested field
         * has valid data, then return this record.
         */
         if ((searchType == EXACT) ||
             (VALID(nominator, ciscoFlashMiscOpEntryData.valid))) 
             return(&ciscoFlashMiscOpEntryData);
         
         /* This request must have been a get-next on a sparse field */
         ciscoFlashMiscOpSerialNumber =
          ciscoFlashMiscOpEntryData.ciscoFlashMiscOpSerialNumber + 1;
    }
}


#ifdef SETS

int
k_ciscoFlashCopyEntry_set (ciscoFlashCopyEntry_t *data, 
    			   ContextInfo    *contextInfo,
    			   int             function)
{
    copyQ                  *current;
    ciscoFlashCopyEntry_t  *entry;

    current = copyQget(EXACT, data->ciscoFlashCopySerialNumber);

    switch (function) {
    case DELETE:
        if (current) {

            /*
             * we've located the appropriate copyQ record
             */
            if (current->pid == 0) {
                /*
                 * the op either was never started or has completed
                 * so the associated entry may be deleted
                 */
                p_unqueue(&snmpcopyQ, current);
                ciscoFlashCopyEntry_free(current->entry);
                free(current);
            } else
                /*
                 * the op is still active. we'll let it run to completion,
                 * and we'll hide the associated entry from SNMP
                 */
                current->active = FALSE;
        }
        return (NO_ERROR);

    case ADD_MODIFY:
        if (current == NULL) {
            /*
             * adding a new row
             */
            current = malloc(sizeof(copyQ));
            if (current == NULL)
                return (RESOURCE_UNAVAILABLE_ERROR);

            entry = malloc(sizeof(ciscoFlashCopyEntry_t));
            if (entry == NULL) {
                free(current);
                return (RESOURCE_UNAVAILABLE_ERROR);
            }

            current->next = NULL;
            current->active = TRUE;
            current->pid = 0;
            current->entry = entry;
            entry->ciscoFlashCopySerialNumber = 
                                               data->ciscoFlashCopySerialNumber;
            entry->ciscoFlashCopyEntryStatus = data->ciscoFlashCopyEntryStatus;
            copyQinsert(current);
        } else {
            entry = current->entry;
        }

        /*
         * entry is being modified, so restart the ageout timer
         */
        TIMER_START(current->timer, FLASHOP_ENTRY_AGEOUT);

        if (VALID(I_ciscoFlashCopyCommand, data->valid)) {
            SET_VALID(I_ciscoFlashCopyCommand, entry->valid);
            entry->ciscoFlashCopyCommand = data->ciscoFlashCopyCommand;
        }

        if (VALID(I_ciscoFlashCopyProtocol, data->valid)) {
            SET_VALID(I_ciscoFlashCopyProtocol, entry->valid);
            entry->ciscoFlashCopyProtocol = data->ciscoFlashCopyProtocol;
        }

        if (VALID(I_ciscoFlashCopyServerAddress, data->valid)) {
            SET_VALID(I_ciscoFlashCopyServerAddress, entry->valid);
            entry->ciscoFlashCopyServerAddress = 
                                              data->ciscoFlashCopyServerAddress;
        }

        if (VALID(I_ciscoFlashCopySourceName, data->valid)) {
            SET_VALID(I_ciscoFlashCopySourceName, entry->valid);
            if (entry->ciscoFlashCopySourceName != NULL) {
                FreeOctetString(entry->ciscoFlashCopySourceName);
            }
            entry->ciscoFlashCopySourceName = 
                               CloneOctetString(data->ciscoFlashCopySourceName);
        }

        if (VALID(I_ciscoFlashCopyDestinationName, data->valid)) {
            SET_VALID(I_ciscoFlashCopyDestinationName, entry->valid);
            if (entry->ciscoFlashCopyDestinationName != NULL) {
                FreeOctetString(entry->ciscoFlashCopyDestinationName);
            }
            entry->ciscoFlashCopyDestinationName = 
                          CloneOctetString(data->ciscoFlashCopyDestinationName);
        }

        if (VALID(I_ciscoFlashCopyRemoteUserName, data->valid)) {
            SET_VALID(I_ciscoFlashCopyRemoteUserName, entry->valid);
            if (entry->ciscoFlashCopyRemoteUserName != NULL) {
                FreeOctetString(entry->ciscoFlashCopyRemoteUserName);
            }
            entry->ciscoFlashCopyRemoteUserName = 
                           CloneOctetString(data->ciscoFlashCopyRemoteUserName);
        }

        if (VALID(I_ciscoFlashCopyStatus, data->valid)) {
            SET_VALID(I_ciscoFlashCopyStatus, entry->valid);
            entry->ciscoFlashCopyStatus = data->ciscoFlashCopyStatus;
        }

        if (VALID(I_ciscoFlashCopyNotifyOnCompletion, data->valid)) {
            SET_VALID(I_ciscoFlashCopyNotifyOnCompletion, entry->valid);
            entry->ciscoFlashCopyNotifyOnCompletion = 
                                         data->ciscoFlashCopyNotifyOnCompletion;
        }

        if (VALID(I_ciscoFlashCopyTime, data->valid)) {
            SET_VALID(I_ciscoFlashCopyTime, entry->valid);
            entry->ciscoFlashCopyTime = data->ciscoFlashCopyTime;
        }

        if (VALID(I_ciscoFlashCopyEntryStatus, data->valid)) {
            /*
             * turn createAndGo into active since they're the same
             * thing at this point
             */
            if (data->ciscoFlashCopyEntryStatus == 
                                        D_ciscoFlashCopyEntryStatus_createAndGo)
                data->ciscoFlashCopyEntryStatus = 
                                            D_ciscoFlashCopyEntryStatus_active ;

            SET_VALID(I_ciscoFlashCopyEntryStatus, entry->valid);
            entry->ciscoFlashCopyEntryStatus = data->ciscoFlashCopyEntryStatus;
            /*
             * if we're active and a task hasn't been started, do it
             */
            if ((entry->ciscoFlashCopyEntryStatus == 
                               D_ciscoFlashCopyEntryStatus_active)  &&
                (current->pid == 0)) {
                if ((current->pid = (cfork((forkproc *)snmp_start_copy,
                                 (long)current, 0, "Flash Copy", 0))) == -1) {
                    flash_in_use = FALSE;
                    current->pid = 0;
                    return (RESOURCE_UNAVAILABLE_ERROR);
                }
            }
        }
        return (NO_ERROR);
    }
    return (GEN_ERROR);
}

#endif                                 /* SETS */


#ifdef SETS

int
k_ciscoFlashPartitioningEntry_set (ciscoFlashPartitioningEntry_t *data, 
    				   ContextInfo    *contextInfo,
    				   int             function)
{
    partQ                 *current;
    ciscoFlashPartitioningEntry_t  *entry;

    current = partQget(EXACT, data->ciscoFlashPartitioningSerialNumber);

    switch (function) {
    case DELETE:
        if (current) {
            /* We have located the appropriate partQ record */
            if (current->pid == 0) {
               /*
                * The partitioning command was either never started or
                * has completed. Anyway, delete this entry.
                */
                p_unqueue(&snmppartQ, current);
                ciscoFlashPartitioningEntry_free(current->entry);
                free(current);
            }
            else {
               /*
                * The partitioning command is still active.
                * Just hide the entry from SNMP.
                */
                current->active = FALSE;
            }
        }
        return(NO_ERROR);

    case ADD_MODIFY:
        if (current == NULL) {
            /* Adding a new row */
            current = malloc(sizeof(partQ));
            if (current == NULL)
                return (RESOURCE_UNAVAILABLE_ERROR);
            entry = malloc(sizeof(ciscoFlashPartitioningEntry_t));
            if (entry == NULL) {
                free(current);
                return (RESOURCE_UNAVAILABLE_ERROR);
            }
            current->next = NULL;
            current->active = TRUE;
            current->pid = 0;
            current->entry = entry;
            entry->ciscoFlashPartitioningSerialNumber = 
                                       data->ciscoFlashPartitioningSerialNumber;
            entry->ciscoFlashPartitioningEntryStatus = 
                                        data->ciscoFlashPartitioningEntryStatus;
            partQinsert(current);
        }
        else {
            entry = current->entry;
        }
        /*
         * Entry is being modified; So restart ageout timer.
         */
        TIMER_START(current->timer, FLASHOP_ENTRY_AGEOUT);

        if (VALID(I_ciscoFlashPartitioningCommand, data->valid)) {
            SET_VALID(I_ciscoFlashPartitioningCommand, entry->valid);
            entry->ciscoFlashPartitioningCommand = 
                                            data->ciscoFlashPartitioningCommand;
        }

        if (VALID(I_ciscoFlashPartitioningDestinationName, data->valid)) {
            SET_VALID(I_ciscoFlashPartitioningDestinationName, entry->valid);
            if (entry->ciscoFlashPartitioningDestinationName != NULL)
                FreeOctetString(
                                  entry->ciscoFlashPartitioningDestinationName);
            entry->ciscoFlashPartitioningDestinationName =
                  CloneOctetString(data->ciscoFlashPartitioningDestinationName);
        }

        if (VALID(I_ciscoFlashPartitioningPartitionCount, data->valid)) {
            SET_VALID(I_ciscoFlashPartitioningPartitionCount, entry->valid);
            entry->ciscoFlashPartitioningPartitionCount =
                                     data->ciscoFlashPartitioningPartitionCount;
        }

        if (VALID(I_ciscoFlashPartitioningPartitionSizes, data->valid)) {
            SET_VALID(I_ciscoFlashPartitioningPartitionSizes, entry->valid);
            if (entry->ciscoFlashPartitioningPartitionSizes != NULL)
                FreeOctetString(
                                   entry->ciscoFlashPartitioningPartitionSizes);
            entry->ciscoFlashPartitioningPartitionSizes =
                      CloneOctetString(
                                    data->ciscoFlashPartitioningPartitionSizes);
        }

        if (VALID(I_ciscoFlashPartitioningNotifyOnCompletion, data->valid)) {
            SET_VALID(I_ciscoFlashPartitioningNotifyOnCompletion, entry->valid);
            entry->ciscoFlashPartitioningNotifyOnCompletion =
                                 data->ciscoFlashPartitioningNotifyOnCompletion;
        }

        if (VALID(I_ciscoFlashPartitioningEntryStatus, data->valid)) {
            /*
             * Change CreateAndGo to Active. If we are here, they are
             * equivalent.
             */
            if (data->ciscoFlashPartitioningEntryStatus ==
                               D_ciscoFlashPartitioningEntryStatus_createAndGo)
                data->ciscoFlashPartitioningEntryStatus =
                               D_ciscoFlashPartitioningEntryStatus_active;

            SET_VALID(I_ciscoFlashPartitioningEntryStatus, entry->valid);
            entry->ciscoFlashPartitioningEntryStatus =
                                        data->ciscoFlashPartitioningEntryStatus;

            /*
             * If this entry is active and a partitioning task has not
             * been started, do so now.
             */
            if ((entry->ciscoFlashPartitioningEntryStatus ==
                             D_ciscoFlashPartitioningEntryStatus_active) &&
                (current->pid == 0)) {
                current->pid = cfork((forkproc *)snmp_partition_task,
                                     (long)current, 0,
                                     "SNMP PARTITIONING", 0);
                if (current->pid == -1) {
                    current->pid = 0;
                    return (RESOURCE_UNAVAILABLE_ERROR);
                }
            }
        }
        return (NO_ERROR);
    }
    return (GEN_ERROR);
}

int
k_ciscoFlashMiscOpEntry_set (ciscoFlashMiscOpEntry_t *data, 
    			     ContextInfo    *contextInfo,
    			     int             function)
{
    miscopQ                 *current;
    ciscoFlashMiscOpEntry_t  *entry;

    current = miscopQget(EXACT, data->ciscoFlashMiscOpSerialNumber);

    switch (function) {
    case DELETE:
        if (current) {
            /* We have located the appropriate miscopQ record */
            if (current->pid == 0) {
               /*
                * The miscop command was either never started or
                * has completed. Anyway, delete this entry.
                */
                p_unqueue(&snmpmiscopQ, current);
                ciscoFlashMiscOpEntry_free(current->entry);
                free(current);
            }
            else {
               /*
                * The miscop command is still active.
                * Just hide the entry from SNMP.
                */
                current->active = FALSE;
            }
        }
        return(NO_ERROR);

    case ADD_MODIFY:
        if (current == NULL) {
            /* Adding a new row */
            current = malloc(sizeof(miscopQ));
            if (current == NULL)
                return (RESOURCE_UNAVAILABLE_ERROR);
            entry = malloc(sizeof(ciscoFlashMiscOpEntry_t));
            if (entry == NULL) {
                free(current);
                return (RESOURCE_UNAVAILABLE_ERROR);
            }
            current->next = NULL;
            current->active = TRUE;
            current->pid = 0;
            current->entry = entry;
            entry->ciscoFlashMiscOpSerialNumber = 
                                            data->ciscoFlashMiscOpSerialNumber;
            entry->ciscoFlashMiscOpEntryStatus = 
                                             data->ciscoFlashMiscOpEntryStatus;
            miscopQinsert(current);
        }
        else {
            entry = current->entry;
        }
        /*
         * Entry is being modified; So restart ageout timer.
         */
        TIMER_START(current->timer, FLASHOP_ENTRY_AGEOUT);

        if (VALID(I_ciscoFlashMiscOpCommand, data->valid)) {
            SET_VALID(I_ciscoFlashMiscOpCommand, entry->valid);
            entry->ciscoFlashMiscOpCommand = data->ciscoFlashMiscOpCommand;
        }

        if (VALID(I_ciscoFlashMiscOpDestinationName, data->valid)) {
            SET_VALID(I_ciscoFlashMiscOpDestinationName, entry->valid);
            if (entry->ciscoFlashMiscOpDestinationName != NULL)
                FreeOctetString(
                                  entry->ciscoFlashMiscOpDestinationName);
            entry->ciscoFlashMiscOpDestinationName =
                  CloneOctetString(
                                   data->ciscoFlashMiscOpDestinationName);
        }

        if (VALID(I_ciscoFlashMiscOpNotifyOnCompletion, data->valid)) {
            SET_VALID(I_ciscoFlashMiscOpNotifyOnCompletion, entry->valid);
            entry->ciscoFlashMiscOpNotifyOnCompletion =
                                    data->ciscoFlashMiscOpNotifyOnCompletion;
        }

        if (VALID(I_ciscoFlashMiscOpEntryStatus, data->valid)) {
            /*
             * Change CreateAndGo to Active. If we are here, they are
             * equivalent.
             */
            if (data->ciscoFlashMiscOpEntryStatus ==
                               D_ciscoFlashMiscOpEntryStatus_createAndGo)
                data->ciscoFlashMiscOpEntryStatus =
                               D_ciscoFlashMiscOpEntryStatus_active;

            SET_VALID(I_ciscoFlashMiscOpEntryStatus, entry->valid);
            entry->ciscoFlashMiscOpEntryStatus =
                                           data->ciscoFlashMiscOpEntryStatus;

            /*
             * If this entry is active and a miscop task has not
             * been started, do so now.
             */
            if ((entry->ciscoFlashMiscOpEntryStatus ==
                             D_ciscoFlashMiscOpEntryStatus_active) &&
                (current->pid == 0)) {
                current->pid = cfork((forkproc *)snmp_miscop_task,
                                     (long)current, 0,
                                     "FLASH MISC OP", 0);
                if (current->pid == -1) {
                    current->pid = 0;
                    return (RESOURCE_UNAVAILABLE_ERROR);
                }
            }
        }
        return (NO_ERROR);
    }
    return (GEN_ERROR);
}

#endif                                 /* SETS */


/***********************************************************************
 *                Garbage Collection Functions
 * These functions are used to clean up the various queues. They get
 * called periodically via the one-min registry.
 ***********************************************************************/

/*
 * copy entry ageout function
 * called via the ONEMIN registry
 */
static void
snmp_copy_ageout (void)
{
    leveltype           level;
    copyQ              *test;
    copyQ              *next;

    /*
     * make sure we have exclusive access to the snmpcopyQ
     */
    level = raise_interrupt_level(ALL_DISABLE);

    for (test = snmpcopyQ.qhead; test; test = next) {
        next = test->next;

        if (TIMER_RUNNING(test->timer) && AWAKE(test->timer)) {
            unqueue(&snmpcopyQ, test);
            ciscoFlashCopyEntry_free(test->entry);
            free(test);
        }
    }

    /*
     * re-allow access to the snmpcopyQ
     */
    reset_interrupt_level(level);

}
/*
 * Flash partitioning ageout function that is called via the
 * ONEMIN registry.
 */
static void snmp_flash_partition_ageout (void)
{
    leveltype   level;
    partQ       *test, *next;

    /* Ensure exclusive access to the snmppartQ */
    level = raise_interrupt_level(ALL_DISABLE);

    for (test = snmppartQ.qhead; test; test = next) {
        next = test->next;

        if (TIMER_RUNNING(test->timer) && AWAKE(test->timer)) {
            unqueue(&snmppartQ, test);
            ciscoFlashPartitioningEntry_free(test->entry);
            free(test);
        }
    }

    /* Re-allow access to snmppartQ */
    reset_interrupt_level(level);
}

/*
 * Flash miscop ageout function that is called via the
 * ONEMIN registry.
 */
static void snmp_flash_miscop_ageout (void)
{
    leveltype   level;
    miscopQ       *test, *next;

    /* Ensure exclusive access to the snmpmiscopQ */
    level = raise_interrupt_level(ALL_DISABLE);

    for (test = snmpmiscopQ.qhead; test; test = next) {
        next = test->next;

        if (TIMER_RUNNING(test->timer) && AWAKE(test->timer)) {
            unqueue(&snmpmiscopQ, test);
            ciscoFlashMiscOpEntry_free(test->entry);
            free(test);
        }
    }

    /* Re-allow access to snmpmiscopQ */
    reset_interrupt_level(level);
}



/************************************************************************
 * Functions that are cforked to perform the various requested operations
 * on the flash device.
 ************************************************************************/

/*
 * The SNMP copy operation task.
 * An instance  of this task is cforked for each copy request.
 */
static forktype snmp_start_copy (copyQ *copy)
{
    addrtype            address;
    char                *sfname, *dfname, *rcp_user; 
    long                time_elapsed;
    long                status = 0;
    int                 size = 0;

    if (!flash_in_use) {
        flash_in_use = TRUE;

	/* In case of no more memory, set error status and kill myself */
	sfname = malloc(SYSSIZE);
	dfname = malloc(SYSSIZE);
	rcp_user = malloc(SYSSIZE);
	if (!sfname || !dfname || !rcp_user) {
		copy->entry->ciscoFlashCopyStatus = 
                                            D_ciscoFlashCopyStatus_copyNoMemory;
		SET_VALID(I_ciscoFlashCopyStatus, copy->entry->valid);
		SET_VALID(I_ciscoFlashCopyTime, copy->entry->valid);
		if (sfname)
		    free (sfname);
		if (dfname)
		    free (dfname);
		if (rcp_user)
		    free (rcp_user);
		process_kill (-1);
	}
    
        /* Disable ageout while the task is running */
        TIMER_STOP(copy->timer);
	
        ip_copy_address((copy->entry->ciscoFlashCopyServerAddress), &address);
        if (copy->entry->ciscoFlashCopySourceName) {
            size = copy->entry->ciscoFlashCopySourceName->length;
            bcopy(copy->entry->ciscoFlashCopySourceName->octet_ptr, 
                                                           sfname, size);
            sfname[size] = '\0';
        }
        if (copy->entry->ciscoFlashCopyDestinationName) {
            size = copy->entry->ciscoFlashCopyDestinationName->length;
            bcopy(copy->entry->ciscoFlashCopyDestinationName->octet_ptr, 
                                                           dfname, size);
            dfname[size] = '\0';
        }
        if (copy->entry->ciscoFlashCopyRemoteUserName)
	    size = copy->entry->ciscoFlashCopyRemoteUserName->length;
	if (size != 0) {
	    bcopy(copy->entry->ciscoFlashCopyRemoteUserName->octet_ptr, 
		  rcp_user, size);
	    rcp_user[size] = '\0';
	} else {
	    free (rcp_user);
	    rcp_user = NULL;
	}

        copy->entry->ciscoFlashCopyStatus = 
                                          D_ciscoFlashCopyStatus_copyInProgress;
        SET_VALID(I_ciscoFlashCopyStatus, copy->entry->valid);
        SET_VALID(I_ciscoFlashCopyTime, copy->entry->valid);

        switch (copy->entry->ciscoFlashCopyCommand) {
            case D_ciscoFlashCopyCommand_copyToFlashWithErase:
                switch (copy->entry->ciscoFlashCopyProtocol) {
                    case D_ciscoFlashCopyProtocol_tftp:
                        status = snmp_tftp_to_flash(&address, sfname, dfname,
                                        &time_elapsed, TRUE);
                        break;
                    case D_ciscoFlashCopyProtocol_rcp:
                        status = snmp_rcp_to_flash(&address, sfname, dfname,
                                        rcp_user, &time_elapsed, TRUE);
                        break;
                    default:
                        status = D_ciscoFlashCopyStatus_copyInvalidProtocol;
                }
                break;
            case D_ciscoFlashCopyCommand_copyToFlashWithoutErase:
                switch (copy->entry->ciscoFlashCopyProtocol) {
                    case D_ciscoFlashCopyProtocol_tftp:
                        status = snmp_tftp_to_flash(&address, sfname, dfname,
                                        &time_elapsed, FALSE);
                        break;
                    case D_ciscoFlashCopyProtocol_rcp:
                        status = snmp_rcp_to_flash(&address, sfname, dfname,
                                        rcp_user, &time_elapsed, FALSE);
                        break;
                    default:
                        status = D_ciscoFlashCopyStatus_copyInvalidProtocol;
                }
                break;
            case D_ciscoFlashCopyCommand_copyFromFlash:
                switch (copy->entry->ciscoFlashCopyProtocol) {
                    case D_ciscoFlashCopyProtocol_tftp:
			status = snmp_flash_to_tftp(&address, sfname, dfname,
						    &time_elapsed);
                        break;
                    case D_ciscoFlashCopyProtocol_rcp:
			status = snmp_flash_to_rcp(&address, sfname, dfname,
						   rcp_user, &time_elapsed);
                        break;
                    case D_ciscoFlashCopyProtocol_lex:
			/*
  			 * The lex box support will be added in a future rel.
			 */
			status = D_ciscoFlashCopyStatus_copyInvalidProtocol;
                        break;
                    default:
                        status = D_ciscoFlashCopyStatus_copyInvalidProtocol;
                }
                break;
            case D_ciscoFlashCopyCommand_copyFromFlhLog:
                switch (copy->entry->ciscoFlashCopyProtocol) {
                    case D_ciscoFlashCopyProtocol_tftp:
                        status = snmp_flhlog_to_server(&address, dfname, 
                                                             &time_elapsed);
                        break;
                    default:
                        status = D_ciscoFlashCopyStatus_copyInvalidProtocol;
                }
                break;
            default:
                status = D_ciscoFlashCopyStatus_copyInvalidOperation;
        }

        copy->entry->ciscoFlashCopyStatus = status;
        copy->entry->ciscoFlashCopyTime = SNMP_DELTA_TIME(time_elapsed);

	free(sfname);
	free(dfname);
	if (rcp_user)
	    free(rcp_user);
        flash_in_use = FALSE;
    } else { 
	copy->entry->ciscoFlashCopyStatus = 
                                          D_ciscoFlashCopyStatus_copyDeviceBusy;
	SET_VALID(I_ciscoFlashCopyStatus, copy->entry->valid);
	SET_VALID(I_ciscoFlashCopyTime, copy->entry->valid);
    }

    /* Send a trap if one was requested */
    if (copy->active) {
        /*
         * the entry is still active from an snmp point-of-view
         * issue a completion trap if one was requested
         */
        if (copy->entry->ciscoFlashCopyNotifyOnCompletion == 
                                    D_ciscoFlashCopyNotifyOnCompletion_true)
            snmp_flashcopy_notify_trap(copy->entry);

        /*
         * restart the ageout timer
         */
        TIMER_START(copy->timer, FLASHOP_ENTRY_AGEOUT);
    } else {
        /*
         * this entry was already deleted via snmp, so delete it
         */
        p_unqueue(&snmpcopyQ, copy);
        ciscoFlashCopyEntry_free(copy->entry);
        free(copy);
    }

    process_kill (-1);
}

/*
 * The SNMP flash partitioning task.
 * An instance of this task is cforked for each SNMP partition request
 */
static forktype
snmp_partition_task (partQ *part_request)
{
    if (!flash_in_use) {
        flash_in_use = TRUE;
        /* Disable ageout while the task is running */
        TIMER_STOP(part_request->timer);

        /* Set status to indicate that partitioning is in progress */
        part_request->entry->ciscoFlashPartitioningStatus =
                         D_ciscoFlashPartitioningStatus_partitioningInProgress;
        SET_VALID(I_ciscoFlashPartitioningStatus, part_request->entry->valid);

        /* Perform the actual partitioning */
        if (partition_flash_snmp_wrapper(part_request->entry))
            SET_VALID(I_ciscoFlashPartitioningTime, part_request->entry->valid);

        flash_in_use = FALSE;
    }
    else {
        part_request->entry->ciscoFlashPartitioningStatus =
                          D_ciscoFlashPartitioningStatus_partitioningDeviceBusy;
        SET_VALID(I_ciscoFlashPartitioningStatus, part_request->entry->valid);
    }

    /* Send the trap, if requested */
    if (part_request->active) {
        /*
         * This entry is still active from SNMP's viewpoint.
         * Issue a trap, if one was requested.
         */
        if (part_request->entry->ciscoFlashPartitioningNotifyOnCompletion ==
                            D_ciscoFlashPartitioningNotifyOnCompletion_true)
        {
            snmp_partition_completion_trap(part_request->entry);
         }
       /* Restart the ageout timer */
       TIMER_START(part_request->timer, FLASHOP_ENTRY_AGEOUT);
    }
    else {
        /* This entry has already been deleted by SNMP */
        p_unqueue(&snmppartQ, part_request);
        ciscoFlashPartitioningEntry_free(part_request->entry);
        free(part_request);
    }

    /* Kill this child process */
    process_kill(THIS_PROCESS);
}

/*
 * The SNMP flash miscellaneous operation task.
 * An instance of this task is cforked for each SNMP miscop request
 */
static forktype
snmp_miscop_task (miscopQ  *miscop_request)
{
    ciscoFlashMiscOpEntry_t  *entry;
    flash_copy_parms_t       *fparms;
    sys_timestamp            miscop_time;
    boolean                  miscop_success = FALSE;
    char		     *dfname;
    int			     size;

    entry = miscop_request->entry;

    if (!flash_in_use) {
        flash_in_use = TRUE;
        fparms = malloc(sizeof(flash_copy_parms_t));
        if (!fparms) {
            entry->ciscoFlashMiscOpStatus = 
                                  D_ciscoFlashMiscOpStatus_miscOpNoMemory;
            SET_VALID(I_ciscoFlashMiscOpStatus, entry->valid);
            flash_in_use = FALSE;
            process_kill(THIS_PROCESS);
        }

	dfname = malloc(SYSSIZE);
	if (!dfname) {
            entry->ciscoFlashMiscOpStatus = 
                                  D_ciscoFlashMiscOpStatus_miscOpNoMemory;
            SET_VALID(I_ciscoFlashMiscOpStatus, entry->valid);
	    if (fparms)
		free (fparms);
            flash_in_use = FALSE;
            process_kill(THIS_PROCESS);
	}

        /* Disable ageout while the task is running */
        TIMER_STOP(miscop_request->timer);

        /* Set status to indicate that miscop is in progress */
        entry->ciscoFlashMiscOpStatus =
                                D_ciscoFlashMiscOpStatus_miscOpInProgress;
        SET_VALID(I_ciscoFlashMiscOpStatus, entry->valid);
        GET_TIMESTAMP(miscop_time);

	/* Make local copy of the destination name */
	size = entry->ciscoFlashMiscOpDestinationName->length;
	bcopy(entry->ciscoFlashMiscOpDestinationName->octet_ptr, dfname, size);
	dfname[size] = '\0';

        /* Perform the actual operation */  
        if ((snmp_process_name(dfname, fparms)) &&
	     (!snmp_flash_dev_removed(fparms->devnm))) {
            switch(entry->ciscoFlashMiscOpCommand) {
            case D_ciscoFlashMiscOpCommand_erase:
                /* Filename not allowed for the erase command */
                if (strlen(fparms->sfname)) {
                    fparms->snmp_sts = SNMP_INVALID_DEST_FILE;
                    break;
                }
                if (snmp_flash_erase(entry, fparms))
                    miscop_success = TRUE;
                break;
            case D_ciscoFlashMiscOpCommand_verify:
                if (!strlen(fparms->sfname)) {
                    fparms->snmp_sts = SNMP_INVALID_DEST_FILE;
                    break;
                }
                if (snmp_flash_verify(entry, fparms))
                    miscop_success = TRUE;
                break;
            case D_ciscoFlashMiscOpCommand_delete:
                if (!strlen(fparms->sfname)) {
                    fparms->snmp_sts = SNMP_INVALID_DEST_FILE;
                    break;
                }
                if (snmp_flash_delete(entry, fparms))
                    miscop_success = TRUE;
                break;
            case D_ciscoFlashMiscOpCommand_undelete:
                if (!strlen(fparms->sfname)) {
                    fparms->snmp_sts = SNMP_INVALID_DEST_FILE;
                    break;
                }
                if (snmp_flash_undelete(entry, fparms))
                    miscop_success = TRUE;
                break;
            case D_ciscoFlashMiscOpCommand_squeeze:
                if (strlen(fparms->sfname)) {
                    fparms->snmp_sts = SNMP_INVALID_DEST_FILE;
                    break;
                }
                if (snmp_flash_squeeze(entry, fparms))
                    miscop_success = TRUE;
                break;
            case D_ciscoFlashMiscOpCommand_format:
                if (strlen(fparms->sfname)) {
                    fparms->snmp_sts = SNMP_INVALID_DEST_FILE;
                    break;
                }
                if (snmp_flash_format(entry, fparms))
                    miscop_success = TRUE;
                break;
            default:
                fparms->snmp_sts = SNMP_UNKNOWN_ERROR;
                break;
            }

            if (miscop_success) { /* Set OpStatus to indicate success */
                entry->ciscoFlashMiscOpStatus =
                            D_ciscoFlashMiscOpStatus_miscOpOperationSuccess;
                entry->ciscoFlashMiscOpTime = ELAPSED_TIME(miscop_time);
                SET_VALID(I_ciscoFlashMiscOpTime, entry->valid);
            }
            else { /* Set appropriate error status in OpStatus */
                entry->ciscoFlashMiscOpStatus =
                                snmp_copy_misc_op_status(fparms->snmp_sts);
            }
        }
        else {
            entry->ciscoFlashMiscOpStatus =
                          D_ciscoFlashMiscOpStatus_miscOpInvalidDestName;
        }

        /* Free malloced memory */
        free(fparms);
	free(dfname);
        flash_in_use = FALSE;
    }
    else {
        entry->ciscoFlashMiscOpStatus =
                          D_ciscoFlashMiscOpStatus_miscOpDeviceBusy;
        SET_VALID(I_ciscoFlashMiscOpStatus, entry->valid);
    }

    /* Send the trap, if requested */
    if (miscop_request->active) {
        /*
         * This entry is still active from SNMP's viewpoint.
         * Issue a trap, if one was requested.
         */
        if (entry->ciscoFlashMiscOpNotifyOnCompletion ==
                            D_ciscoFlashMiscOpNotifyOnCompletion_true)
        {
            snmp_miscop_completion_trap(entry);
         }
       /* Restart the ageout timer */
       TIMER_START(miscop_request->timer, FLASHOP_ENTRY_AGEOUT);
    }
    else {
        /* This entry has already been deleted by SNMP */
        p_unqueue(&snmpmiscopQ, miscop_request);
        ciscoFlashMiscOpEntry_free(entry);
        free(miscop_request);
    }

    /* Kill this child process */
    process_kill(THIS_PROCESS);
}



#ifdef SETS

/*************************************************************************
 *                      Copy completion notify trap.
 *************************************************************************/

#define FLASH_COPY_TRAP_NUMBER        1
#define FLASH_COPY_TRAP_VARBIND_COUNT 1

/*
 * The OID that identifies the SNMPv2 trap
 */
static const OID flashcopy_trapOID =
    {LNciscoFlashCopyNotifyOnCompletion,
     (ulong *)IDciscoFlashCopyNotifyOnCompletion};

/*
 * The OID that identifies the SNMPv1 enterprise. This is identical to the
 * SNMPv2 trap OID with the last two subidentifiers removed
 */
static const OID flashcopy_enterpriseOID =
    {LNciscoFlashCopyNotifyOnCompletion - 2,
     (ulong *)IDciscoFlashCopyNotifyOnCompletion};

static const OID flashcopy_trap_varbinds[FLASH_COPY_TRAP_VARBIND_COUNT] = {
    {LNciscoFlashCopyStatus, (ulong *)IDciscoFlashCopyStatus}};

/* The copy completion trap */
static void snmp_flashcopy_notify_trap (ciscoFlashCopyEntry_t *entry)
{
    int         vbIndex;
    OID         *vbList[FLASH_COPY_TRAP_VARBIND_COUNT+1];
    OID         instanceOID;
    ulong       instance[1];
    char        trapoid_str[80];

    /*
     * For some unknown reason, SNMP Research made all the object
     * identifier parameters (OID *) *except* for the SNMPv2
     * trap identifier which is (char *).  It is much easier for
     * us to use the mib-compiler generate OID structure, so
     * we'll just convert that into a string.
     */
    if (MakeDotFromOID((OID *)&flashcopy_trapOID, trapoid_str) == -1) {
        return;
    }

    /*
     * All the trap varbind objects have an instance described by
     * INDEX { ciscoFlashCopySerialNumber }
     */
    instance[0] = entry->ciscoFlashCopySerialNumber;
    instanceOID.oid_ptr = instance;
    instanceOID.length = 1;

    /*
     * create the varbind list
     */
    for (vbIndex = 0; vbIndex < FLASH_COPY_TRAP_VARBIND_COUNT; vbIndex++) {
        vbList[vbIndex] = CatOID((OID *) &flashcopy_trap_varbinds[vbIndex],
                                 &instanceOID);
    }
    vbList[vbIndex] = NULL;

    /*
     * tell snmp to do something
     */
     snmp_trap(ENTERPRISE_TRAP, FLASH_COPY_TRAP_NUMBER, vbList,
                          (OID *)&flashcopy_enterpriseOID, trapoid_str);

    /*
     * free data allocated by the CatOID service
     */
    for (vbIndex = 0; vbIndex < FLASH_COPY_TRAP_VARBIND_COUNT; vbIndex++) {
        FreeOID(vbList[vbIndex]);
    }
}

/***************************************************************************
 *                     Partitioning Completion Trap.
 ***************************************************************************/

#define PART_TRAP_VARBIND_COUNT 1
#define PART_TRAP_NUMBER        1

/*
 * The OID that identifies the SNMPv2 trap
 */
static const OID partitioning_trapOID =
    {LNciscoFlashPartitioningNotifyOnCompletion, 
     (ulong *)IDciscoFlashPartitioningNotifyOnCompletion};

/*
 * The OID that identifies the SNMPv1 enterprise. This is identical to the
 * SNMPv2 trap OID with the last two subidentifiers removed
 */
static const OID partitioning_enterpriseOID =
    {LNciscoFlashPartitioningNotifyOnCompletion - 2, 
     (ulong *)IDciscoFlashPartitioningNotifyOnCompletion};

static const OID partitioning_trap_varbinds[PART_TRAP_VARBIND_COUNT] = {
    {LNciscoFlashPartitioningStatus, (ulong *)IDciscoFlashPartitioningStatus}};

/* The partitioning trap */
static void
snmp_partition_completion_trap (ciscoFlashPartitioningEntry_t *entry)
{
    int         vbIndex;
    OID         *vbList[PART_TRAP_VARBIND_COUNT+1];
    OID         instanceOID;
    ulong       instance[1];
    char        trapoid_str[80];

    /*
     * For some unknown reason, SNMP Research made all the object
     * identifier parameters (OID *) *except* for the SNMPv2
     * trap identifier which is (char *).  It is much easier for
     * us to use the mib-compiler generate OID structure, so
     * we'll just convert that into a string.
     */
    if (MakeDotFromOID((OID *)&partitioning_trapOID, trapoid_str) == -1) {
        return;
    }
    
    /*
     * All the trap varbind objects have an instance described by
     * INDEX { ciscoFlashPartitioningSerialNumber }
     */
    instance[0] = entry->ciscoFlashPartitioningSerialNumber;
    instanceOID.oid_ptr = instance;
    instanceOID.length = 1;

    /*
     * create the varbind list
     */
    for (vbIndex = 0; vbIndex < PART_TRAP_VARBIND_COUNT; vbIndex++) {
        vbList[vbIndex] = CatOID((OID *) &partitioning_trap_varbinds[vbIndex], 
                                  &instanceOID);
    }
    vbList[vbIndex] = NULL;

    /*
     * tell snmp to do something
     */
     snmp_trap(ENTERPRISE_TRAP, PART_TRAP_NUMBER, vbList,
                          (OID *)&partitioning_enterpriseOID, trapoid_str);

    /*
     * free data allocated by the CatOID service
     */
    for (vbIndex = 0; vbIndex < PART_TRAP_VARBIND_COUNT; vbIndex++) {
        FreeOID(vbList[vbIndex]);
    }
}

/***************************************************************************
 *             Miscellaneous Flash Operation Completion Trap.
 ***************************************************************************/

#define  MISCOP_TRAP_VARBIND_COUNT  1
#define  MISCOP_TRAP_NUMBER         1

/*
 * The OID that identifies the SNMPv2 trap
 */
static const OID miscop_trapOID =
    {LNciscoFlashMiscOpNotifyOnCompletion,
     (ulong *)IDciscoFlashMiscOpNotifyOnCompletion};

/*
 * The OID that identifies the SNMPv1 enterprise. This is identical to the
 * SNMPv2 trap OID with the last two subidentifiers removed
 */
static const OID miscop_enterpriseOID =
    {LNciscoFlashMiscOpNotifyOnCompletion - 2,
     (ulong *)IDciscoFlashMiscOpNotifyOnCompletion};

static const OID miscop_trap_varbinds[MISCOP_TRAP_VARBIND_COUNT] = {
    {LNciscoFlashMiscOpStatus, (ulong *)IDciscoFlashMiscOpStatus}};

/* The miscellaneous flash operation completion trap */
static void
snmp_miscop_completion_trap (ciscoFlashMiscOpEntry_t *entry)
{
    int         vbIndex;
    OID         *vbList[MISCOP_TRAP_VARBIND_COUNT+1];
    OID         instanceOID;
    ulong       instance[1];
    char        trapoid_str[80];

    /*
     * For some unknown reason, SNMP Research made all the object
     * identifier parameters (OID *) *except* for the SNMPv2
     * trap identifier which is (char *).  It is much easier for
     * us to use the mib-compiler generate OID structure, so
     * we'll just convert that into a string.
     */
    if (MakeDotFromOID((OID *)&miscop_trapOID, trapoid_str) == -1) {
        return;
    }

    /*
     * All the trap varbind objects have an instance described by
     * INDEX { ciscoFlashMiscOpSerialNumber }
     */
    instance[0] = entry->ciscoFlashMiscOpSerialNumber;
    instanceOID.oid_ptr = instance;
    instanceOID.length = 1;

    /*
     * create the varbind list
     */
    for (vbIndex = 0; vbIndex < MISCOP_TRAP_VARBIND_COUNT; vbIndex++) {
        vbList[vbIndex] = CatOID((OID *)&miscop_trap_varbinds[vbIndex], 
                                  &instanceOID);
    }
    vbList[vbIndex] = NULL;

    /*
     * tell snmp to do something
     */
     snmp_trap(ENTERPRISE_TRAP, MISCOP_TRAP_NUMBER, vbList,
                          (OID *)&miscop_enterpriseOID, trapoid_str);

    /*
     * free data allocated by the CatOID service
     */
    for (vbIndex = 0; vbIndex < MISCOP_TRAP_VARBIND_COUNT; vbIndex++) {
        FreeOID(vbList[vbIndex]);
    }
}
#endif				       /* SETS */


/*
 * Subsystem header for the new flash MIB subsystem.
 */

#define FLASHMIB_MAJVERSION 1
#define FLASHMIB_MINVERSION 0
#define FLASHMIB_EDITVERSION 1

SUBSYS_HEADER(les_flashmib,
	      FLASHMIB_MAJVERSION, FLASHMIB_MINVERSION, FLASHMIB_EDITVERSION,
	      init_flashmib, SUBSYS_CLASS_MANAGEMENT,
	      NULL /* no sequencing */,
	      NULL /* no prerequisites */);
      
