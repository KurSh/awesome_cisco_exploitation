# $Id: sys_registry.reg,v 3.17.4.32 1996/09/14 00:52:09 ramk Exp $
#------------------------------------------------------------------
# sys_registry.reg - Service Points for System Registry
#
# 21-Jul-1993, Gannu Satish Kumar
#
# Copyright (c) 1993-1997 by cisco Systems, Inc.
# All rights reserved.
#
#------------------------------------------------------------------
# $Log: sys_registry.reg,v $
# Revision 3.17.4.32  1996/09/14  00:52:09  ramk
# CSCdi66329:  SNMP syslog traps specify wrong enterpriseOID,sysLogEvent
# needs fix
# Branch: California_branch
# Save sysloghistoryentry_t data until traps can be sent from process
# level
# (if syslog trap notification is enabled). Create SyslogTrapProcess to
# handle the sending of traps and freeing buffers used for saving the
# data
#
# Revision 3.17.4.31  1996/08/28  12:43:00  thille
# CSCdi67083: Message externs need a cleanup.
# Branch: California_branch
# Get rid of all extern msgsym()s in .c files, rework logger.h and
# msg_foo.c files so they are included and provide the externs.  Clean up
# other random externs in .c files.
#
# Revision 3.17.4.30  1996/08/21  20:37:22  hampton
# Further isolate VLAN code from IPX internals.  [CSCdi66726]
# Branch: California_branch
#
# Revision 3.17.4.29  1996/08/16  08:01:31  dlobete
# CSCdi59971:  DACL needs modularity work
# Branch: California_branch
# For the sake of future maintenance of IP access-lists, share as much
# source code as possible between VIP and RSP.
#
# Revision 3.17.4.28  1996/07/30  01:14:48  ccartee
# CSCdi60470:  Custom-queue-list command cant be applied to channelized
# T1 interfac
# Branch: California_branch
# Change name of encaps_queueing to encaps_queuing_allowed and change
# type to RETVAL.  Insure that default behavior is to allow queuing
# commands on interface.  Cauterize legacy references encaps_queuing to
# remove references to passed in (ptr to) return value.
#
# Revision 3.17.4.27  1996/07/25  23:34:53  ccartee
# CSCdi63068:  queuing strategy cannot be recovered after reboot or
# download
# Branch: California_branch
# Invoke parser operation in traversed 'plist' order, and not in fixed
# 'command' order.
#
# Revision 3.17.4.26  1996/07/20  03:19:09  fred
# CSCdi63607:  add access list to traffic shaping per customer request
#              requires change of parameters on function called by
#              fastsend routines in drivers
# Branch: California_branch
#
# Revision 3.17.4.25  1996/07/18  05:21:21  ccpoe
# CSCdi53787:  Interface queueing shouldnt be allowed with VC Queueing. A
# CASE registry function is created to check if fancy queueing is allowed
# under a certain encapsulation
# Branch: California_branch
#
# Revision 3.17.4.24  1996/07/16  08:01:12  raj
# CSCdi61197:  Part of  CSCdi49395 patches missing from 11.2
# Branch: California_branch
# Inserted patches which were missing and update dirresp code as well.
#
# Revision 3.17.4.23  1996/07/04  02:11:00  jhernand
# CSCdi61640:  Cobra code does not conform to Cisco guidelines
#              Corrected some spelling errors.
# Branch: California_branch
#
# Revision 3.17.4.22  1996/06/21  19:07:18  fred
# CSCdi57507:  RSVP gets installed with Conversation number 0 on ethernet.
#         Install registry callback from WFQ setup to RSVP to make sure
#         that some reservable queues are allocated.
# Branch: California_branch
#
# Revision 3.17.4.21  1996/06/17  08:31:29  jhernand
# Commit Modular Cobra to California_branch
#
# Revision 3.17.4.20  1996/06/16  21:12:12  vnguyen
# Finally committing Brasil to California_branch
#
# Revision 3.17.4.19  1996/06/02  15:31:06  motto
# CSCdi50208:  Issuing csna, llc or tcp CIP show cmd immed after CIP
# reset fails
# Branch: California_branch
#
# Revision 3.17.4.18  1996/05/30  01:19:09  asastry
# CSCdi58810:  DEC 'advertise' route is wiped out by "dec routing"
# command.
# Branch: California_branch
#
# Revision 3.17.4.17  1996/05/29  19:08:20  asastry
# CSCdi46634:  Misc DECnet code cleanup - get rid of unwanted registry
# call.
# Branch: California_branch
#
# Revision 3.17.4.16  1996/05/28  16:08:34  xliu
# CSCdi58788:  code changes for vip named access list and encryption perf
# Branch: California_branch
#
# Revision 3.17.4.15  1996/05/21  06:27:56  mordock
# Branch: California_branch
# Improve snmp modularity via creating services to register interfaces
# and chassis cards.
# Add syslog mib.
#
# Revision 3.17.4.14  1996/05/17  11:16:18  ppearce
# Merge IbuMod into Calif
#
# Revision 3.15.2.4  1996/05/05  23:05:43  ppearce
# Sync to IbuMod_Calif_baseline_960504
#
# Revision 3.15.2.3  1996/05/02  22:02:14  hampton
# Remove support for old Multibus token ring cards.
# Branch: IbuMod_Calif_branch
#
# Revision 3.15.2.2  1996/04/03  14:26:12  ppearce
# Sync to IbuMod_Calif_baseline_960402
#
# Revision 3.15.2.1  1996/03/17  17:48:08  ppearce
# Sync IbuMod_Calif_branch to V111_1_3
#
# Revision 3.17.4.13  1996/05/15  05:31:40  fowler
# Frame relay VC queuing and rate enforcement
# Branch: California_branch
#
# Revision 3.17.4.12  1996/05/13  23:20:18  ahh
# CSCdi56426:  NAT: EFT bugs and feedback
# Fix hash algorithm, fix address block coalescing, reduce up-front
# memory allocation, drop untranslatable packets, clean up debugs.
# Branch: California_branch
#
# Revision 3.17.4.11  1996/05/13  14:46:13  fred
# CSCdi56825:  RSP box crashes when configuring a virtual interface
#         check for cbus/mci usage before invoking cbus_mci_txlimit().
#         Also, change name of serial_cfg_modified registry to
#         interface_cfg_modified
# Branch: California_branch
#
# Revision 3.17.4.10  1996/05/09  14:13:36  rbadri
# Branch: California_branch
# LANE, UNI3.1 features
#
# Revision 3.17.4.9  1996/05/08  02:43:16  grobelch
# - Create system list registry functions invoked by static-map software
#   when:
#     a static-map is deleted, a map-group is deleted, and when a
#     static-map is updated. A provider of static-map service (such
#     as ATM signalling) can register for this, check for one of it's
#     map's being the subject of the call, and act appropriately.
#   - Provide ATM signalling routines for the static-map and group
#     registries. Remove ARP table entries for IP and free up
#     ATM signalling-specific data structures.
#   - Improve vc "glomming" for point-to-point VCs to take in
#     AAL5MUX case.
#   - Fix mistaken use of an enumeration as a bit-value.
# CSCdi53027:  ATMSIG: SVC static maps not updated properly in all cases
# Branch: California_branch
#
# Revision 3.17.4.8  1996/05/04  00:42:35  wilber
# Branch: California_branch
#
# Integrated Routing and Bridging
# - Rip out MTR transparent bridging support.
# - New interafce type: BVI(Bridge-group Virtual Interface).
# - New fast-switching flavor: FS_BVI.
# - Introduce idb->tbridge_bridge_linktypes, idb->user_configured_mtu and
#   pak->irb_rcvd_input.
#
# Constrained Multicast Flooding
# - Declare tbifd_type.
# - Define the CMF parser link points.
# - Declare the return_one stub function.
# - Declare the Transparent Bridging registry.
# - Add tbridge_cmf to the fastswitch registry.
#
# Name Access List
#
# Revision 3.17.4.7  1996/04/30  05:43:47  gchristy
# CSCdi56163:  SSE: move low_mem function to system registry
# Branch: California_branch
#
# Revision 3.17.4.6  1996/04/29  09:37:25  fox
# CSCdi55358:  PPP subsystem needs to be more modular
# Branch: California_branch
# Move Network Control Protocol (NCP) support from PPP subsystem to
# individual subsystems.  Attach NCP subsystems to respective protocol
# subsystems.  Add registry calls to network protocol init code to
# register default NCP support for NCPs not requiring option negotiation.
#
# Revision 3.17.4.5.4.1  1996/04/27  06:35:34  cakyol
# non sync sync from V112_0_2 to ....
# Branch: LE_Cal_ATM_FR_California_Postsync_960425_branch
#
# Revision 3.17.4.5  1996/04/16  18:52:41  rchandra
# CSCdi54830:  IP features commit
# Branch: California_branch
#
# Revision 3.17.4.4  1996/04/15  21:13:40  bcole
# CSCdi54649:  IP Host Modularity, IP Automatic Stub Routing feature
# commit
# Branch: California_branch
#
# Revision 3.17.4.3  1996/04/15  14:57:48  widmer
# CSCdi47180:  No Single Command to Collect General Router Data
# Branch: California_branch
# Add "show tech-support" command
# Change references to encryption types to uint
# Change tt_soc to use password_struct
#
# Revision 3.17.4.2.6.1  1996/04/08  01:46:07  bbenson
# Branch: LE_Cal_V112_0_2_branch
# Sync of LE_Cal to new V112_0_2 sync point (post Port Ready).
#
# Revision 3.17.4.2  1996/03/21  22:38:11  gstovall
# Branch: California_branch
# The ELC_branch now knows the joy of California dreaming.
#
# Revision 3.17.4.1  1996/03/18  19:37:42  gstovall
# Branch: California_branch
# Elvis has left the building.  He headed out to California, and took the
# port ready changes with him.
#
# Revision 3.17.8.1  1996/03/22  09:35:53  rlowe
# Non-sync Synalc3_LE_Cal_V111_1_0_3_merge_branch to V111_1_3
# yielding LE_Syn_Cal_V111_1_3_branch.
# Branch: LE_Syn_Cal_V111_1_3_branch
#
# Revision 3.17  1996/03/09  22:54:54  widmer
# CSCdi47890:  HTTP server doesnt work
# Add HTTP server
#
# Revision 3.16  1996/02/29  02:07:46  asastry
# CSCdi49406:  Port fix (for MOP over Frame-Relay) to 10.0 and later
# releases.
#
# Revision 3.15  1996/02/23  08:18:05  dlobete
# CSCdi47188:  micro reload on RSP halts IPC traffic to VIPs
# Reset sequence numbers in Master's seat structure when we initialize
# IPC slaves.
#
# Revision 3.14.8.1  1996/03/05  06:10:40  rlowe
# Apply LANE content to merge branch.
# Branch: Synalc3_LE_Cal_V111_1_0_3_merge_branch
#
# Revision 3.14.4.1  1996/02/27  20:41:29  cakyol
# non sync sync of LE_Cal_V111_0_16_branch to V111_1_0_3 yielding
# LE_Cal_V111_1_0_3_branch
# Branch: LE_Cal_V111_1_0_3_branch
#
# Revision 3.14  1996/02/07  00:46:38  irfan
# CSCdi48054:  async interfaces should default to no keepalive
# Allow hwidb's to have default other than KEEPALIVE_DEFAULT.
#
# Revision 3.13  1996/01/30  19:15:50  foster
# CSCdi47228:  HSA slave image needs config parsing disabled
#
# Revision 3.12  1996/01/16  07:42:10  billw
# CSCdi46868:  latgroup.o should not be in core subsystem
#
# Revision 3.11  1996/01/13  03:09:10  dlobete
# CSCdi44696:  OIR and IPC troubles - selective sequence number synch
# needed
# Add slot granularity to IPC seat reset.
#
# Revision 3.10  1996/01/13  01:34:26  irfan
# CSCdi44881:  dialer interface dead after removal and redefine
# disallow removal of dialer interface as long as it has members in
# the rotary group.
#
# Revision 3.9.2.1  1996/02/15  19:12:29  rbadri
# Branch: LE_Cal_V111_0_16_branch
# Add an additional swidb pointer to the registry bump_cache_version
# to invalidate caches based on swidb too.
#
# Revision 3.9  1996/01/03  03:32:05  ahh
# CSCdi45528:  Move key manager out of core
#
# Revision 3.8  1995/12/12  09:02:39  dbath
# CSCdi45422:  HSA systems forget what time it is on failover
# Whenever we write to the battery-backed calendar hardware on
# the master, ship the value across to the slave's calendar too.
#
# Revision 3.7  1995/12/11  04:03:47  dbath
# CSCdi45341:  Cant get crash stack on HSA systems.
# Include the slave's crash stack (if it has crashed recently)
# at the bottom of the 'show stack' output.
#
# Revision 3.6  1995/12/05  07:03:58  dbath
# CSCdi43178:  rommon boot info not kept in sync on slave
# Ship the three boot related environment variables, and the config
# register setting, across to the slave whenever autosync is enabled,
# or whenever the user manually syncs the slave config.
#
# Revision 3.5  1995/12/03  17:56:33  thille
# CSCdi44905:  ciscopro targets not in 11.1
# Put them in.
#
# Revision 3.4  1995/11/26  08:08:47  mmcneali
# CSCdi43630:  ISL VLAN Multicast changed--IOS gs7 images are DEAF
#
#              ISL vLAN support for the RSP platform.
#
# Revision 3.3  1995/11/17  09:13:39  hampton
# Remove old entries from the RCS header logs.
#
# Revision 3.2  1995/11/16  23:24:34  gstovall
# Ladies and gentlemen, I introduce to you, the port ready commit.
#
# Revision 3.1  1995/11/09  11:36:18  shaker
# Bump version numbers from 2.x to 3.x.
#
# Revision 2.12  1995/11/08  20:59:04  shaker
# Merge Arkansas_branch into 11.1 mainline.
#
# Revision 2.11  1995/09/23  07:17:40  tkolar
# CSCdi40082:  Dialer requires PPP subsystem hence also require CHAT
# subsystem
# Create registry for returning first member of an interface group
#
# Revision 2.10  1995/09/23  05:57:15  enf
# CSCdi39189:  100X need insurance against loading incorrect image
#
# Revision 2.9  1995/09/22  04:39:15  enf
# CSCdi40869:  Add frankenstorm to 11.0
#
# Revision 2.8  1995/08/30  07:40:47  pitargue
# CSCdi30543:  dns invalid  with domain-name and domain-list specified
# create a name lookup path for FQDN's only.  domain-list will not affect
# the lookup, i.e., domains will not be appended to FQDN's.
#
# Revision 2.7  1995/08/13  19:32:50  motto
# CSCdi36478:  Show interface statistical info is missing for Channel
# interface
#
# Revision 2.6  1995/07/16  18:04:06  thille
# CSCdi37049:  Console output from SNMP WriteNet SET confuses console user
# Bad programmer, no doggie biscuit.
#
# Revision 2.5  1995/07/15  02:36:50  thille
# CSCdi37049:  Console output from SNMP WriteNet SET confuses console user
# Add a silent_mode parameter to some routines and registries and set it
# to TRUE when making the calls from SNMP WriteNet, netConfigSet, or
# hostConfigSet.  Also, add an errmsg for each so the event can still get
# logged, and make it clear what caused the event.  Fix other callers to
# pass FALSE so current behavior will be maintained.
#
# Revision 2.4  1995/06/28  09:23:58  smackie
# Repair widespread subsystem header braindamage. (CSCdi23568)
#
#   o Fix subsystem entry points to be foo(subsystype *) not foo(void)
#   o Repair nonsensical and redundant subsystem sequences
#   o Use NULL where no property is required
#
# Revision 2.3  1995/06/21  02:06:30  alam
# CSCdi36191:  IBM spanning tree doesnt form with SRB/FDDI
# Insert IEEE spanning tree multicast address into SMF when AST over
# SRB/FDDI is enabled.
#
# Revision 2.2  1995/06/16  04:27:04  dkatz
# CSCdi35882:  Time-of-day code needs cleanup
#
# Revision 2.1  1995/06/07  20:36:48  hampton
# Bump version numbers from 1.x to 2.x.
#
#------------------------------------------------------------------
# $Endlog$

#
# Syntax for defining a registry
#
# Each item must begin a line of its own.
# Lines may be continued by ending with a \
#
# BEGIN REGISTRY <name of registry>
#
# DEFINE <name of service point>
# /* <comment lines in standard C format describing the
#     registry. These will be reformatted unless they are
#     in the comment bar format> */
# DATA
#    <Lines of text to be copied from the input to the
#     between the comment and the function declaration>
# END DATA
#    <type of service> := LIST | LOOP | STUB | CASE | RETVAL | VALUE
#    <type declaration of value returned by called function>
#              must be void for LIST and CASE, boolean
#              for LOOP, and ulong for VALUE.
#    <prototype list for called function>
#    <number of cases for case service>
#    <type for case statement>
# END
#
# END REGISTRY
#
#

BEGIN REGISTRY SYS

DEFINE	send_quench 
/*
 * Summary:  Send a quench message, for example, an ICMP source quench.
 * Input: Indexed by linktype.
 *	Packet to use for quench message.
 * Returns: NULL.
 */
	CASE
	void
	paktype	 *pak
	0
	int linktype
END


DEFINE	send_unreach 
/*
 * Summary: Send a message that the packet destination was unreachable.
 * Input: Indexed by linktype.
 *	Packet to use for unreachable message.
 * Returns: NULL.
 */
	CASE
	void
	paktype *pak
	0
	int linktype
END


DEFINE	keepalive_changed 
/*
 * Summary:  Notify subsystems that the keepalive value has been changed.
 * Input: Indexed by encapsulation type.
 *	IDB on which keepalive value was changed.
 * Returns: NULL
 */
	CASE
	void
	hwidbtype *hwidb
	0
	int enctype
END


DEFINE	bandwidth_changed 
/*
 * Summary: Notify subsystems that bandwidth values have been changed.
 * Input: IDB on which bandwidth values were changed.
 * Returns:  NULL
 * Comments: A typical response to this is to recalculate a spanning 
 *		tree topology.
 */
	LIST
	void
	idbtype *swidb
END

DEFINE	delay_changed 
/*
 * Summary: Notify subsystems that delay values have been changed.
 * Input: IDB on which delay values were changed.
 * Returns:  NULL
 * Comments: A typical response to this is to recalculate a spanning 
 *		tree topology.
 */
	LIST
	void
	idbtype *swidb
END

DEFINE	pre_cstate 
/*
 * Summary: Notify subsystems that an interface is about to change state.
 * Input: IDB of interest.
 *	New state to which the interface will move.
 * Returns: TRUE if the generic state change mechanism should not be run;
 *		FALSE otherwise.
 */
	LOOP
	boolean
	hwidbtype *hwidb, int newstate
END

DEFINE	net_cstate 
/*
 * Summary: Notify subsystems that an interface state has just changed.
 * Input:  IDB on which state has changed.
 * Returns: NULL.
 * Comments:  Functions added to this service are ones that need to be 
 *	executed immediately after an interface changes state.	For example, 
 *	flicker an LED on the Cisco 4000 or signal TCP header compression
 *      to start dropping datagrams. Functions that can wait until the line is 
 *	declared stone-cold dead should use hwif_state_change.
 */
	LIST
	void
	hwidbtype *hwidb
END


DEFINE	bump_cache_version 
/*
 * Summary: Bump fast-switching cache version numbers.
 * Input:  Hardware IDB of interest.
 *	   Software IDB of interest.
 *	   Boolean that is TRUE if cache changes are to happen immediately.
 * Returns: NULL
 * Comments: This service calls protocol-specific routines such as
 *	increment_ipcache_version() to bump the fast-switching cache version 
 *	number.
 *
 *	If the hardware IDB is NULL, all caches are bumped.  If the 
 *	hardware IDB is not null, the cache is bumped only if the given 
 *	protocol is running on the IDB.
 *
 * 	If the boolean is TRUE, an an immediate cache flush is forced.
 *	Otherwise, the handler can choose to delay the flush.
 *
 *	The software IDB gives the capability to invalidate caches on 
 *	a swidb basis.
 */
	LIST
	void
	hwidbtype *hwidb, idbtype *swidb, boolean immediately 
END



DEFINE	reset_if 
/*
 * Summary: Clear an interface.
 * Input:  IDB to be cleared.
 * Returns: NULL.
 * Comments: Functions are usually protocol-specific routines, for example,
 *	atalkif_clear().
 */
	LIST
	void
	idbtype *swidb
END



DEFINE	raw_enqueue 
/*
 * Summary: Enqueue a packet on a protocal input queue.
 * Input: Indexed by linktype.
 *	Packet to enqueue.
 * Returns: NULL.
 * Comments:  Called by interrupt-level input in raw_enqueue() to enqueue 
 *	a packet onto the appropriate protocol specific input queue, for
 *	example, internet_enqueue().
 */
	CASE
	void
	paktype *pak
	LINK_MAXLINKTYPE
	int linktype
END



DEFINE	route_adjust 
/*
 * Summary: Adjust routes to matching interface status.
 * Input: IDB of interest.
 * Returns: NULL.
 * Comments: Called when an interface changes state or periodically by
 *	net_periodic() to bring protocol-specific routing table into alignment
 *	with the current interface status.
 */
	LIST
	void
	idbtype *swidb
END



DEFINE  route_adjust_msg
/*
 * Summary: Inform routing protocols of a change in IDB status.
 * Input: Software IDB of interest.
 * Returns: NULL
 * Comments: This service is called whenever an interface changes state 
 *	and periodically by net_periodic() to bring protocol-specific routing 
 *	tables into alignment with the current interface up/down status.
 */
        PID_LIST
        void
	idbtype *swidb
	MSG_ROUTE_ADJUST
END



DEFINE	loop_enqueue 
/*
 * Summary: Enqueue a packet with a media handler for loopback/keepalive
 *		processing.
 * Input: Switched by media type.
 *	Packet to process.
 * Returns: NULL
 */
	CASE
	void
	paktype *pak
	0
	ulong code
END



DEFINE	fast_setup 
/*
 * Summary: Initialize fast-switching settings.
 * Input:  IDB of interest.
 * Returns: NULL
 * Comments: This service is called when the interface encapsulation type is 
 *	changed, among other places.
 */
	LIST
	void
	hwidbtype *hwidb
END



DEFINE	ar_cache_clear 
/*
 * Summary: Clear address resolution caches (such as ARP, AARP, 
 *		and ICMP redirects)
 * Input: IDB of interest.
 * Returns: NULL.
 */
	LIST
	void
	idbtype *idb
END

DEFINE arp_refresh
/*
 * Summary: Age out an ARP table entry.
 * Input: Switched by link type.
 *	Pointer to ARP entry.
 * Returns: NULL
 * Comments: Protocols may wish to send a unicast ARP request to the station.
 */
	CASE
	void
	arptype *ptr
	LINK_MAXLINKTYPE
	int index
END

DEFINE arp_fscache_invalidate
/*
 * Summary: Delete an ARP table entry.
 * Input: Switched by link type.
 *	Pointer to ARP entry.
 * Returns: TRUE if enter cache needs to be flushed.
 * Comments: This service signals protocol stacks to flush appropriate 
 *	fast-switching entries.
 */
	RETVAL
	boolean
	arptype *ptr
	LINK_MAXLINKTYPE
	int index
END

DEFINE arp_sendreq
/*
 * Summary: Format an ARP packet.
 * Input:  ARP packet.
 *	Address we are attempting to resolve.
 *	IDB on which address resolution is taking place.
 *	Address to which to send resolution request.  If NULL, send a broadcast.
 * Returns: NULL.
 * Comments: Each protocol has different formatting characteristics
 */
	CASE
	void
	paktype *pak, ipaddrtype addr, idbtype *idb, hwaddrtype *dest
	ET_MAX
	int index
END

DEFINE arp_getphysaddr
/*
 * Summary:  Retrieve a physical address from an ARP entry.  
 * Input: IDB of interest.
 *	Pointer to hardware address in ARP entry.
 * Returns: Physical adress.
 * Comments:  For ATM SVCs, this address is the called party address.
 */
	STUB
	hwaddrtype *
	idbtype *idb, uchar *hardware
END	

DEFINE	encap_fixup 
/*
 * Summary: Do encapsulation-dependent fixes of network-level protocols.
 * Input: IDB of interest.
 *	Old encapsulation type.
 * Returns: NULL.
 * Comments: Called when the interface encapsulation changes.
 */
	LIST
	void
	idbtype *swidb, int old_encap
END



DEFINE	compress_header
/*
 * Summary:  Perform protocol-specific compression on the protocol header.
 * Input: Switched on linktype.
 *	Packet of interest.
 * Returns: Packet with protocol header compressed.
 */
	RETVAL
	paktype *
	paktype *pak
	0
	int linktype
END

DEFINE  compress_tcpip_header
/*
 * Summary: Perform generic TCP header compression.
 * Input: Switched on linktype, for no apparent reason.
 *	IDB of interest.
 *	Packet to have header compressed.
 *	Boolean that is TRUE if CID is to be compressed.
 *	Compression record.
 * Returns: Packet with TCP/IP header compressed.
 * Comments: List registry not chosen because return value is nonvoid.
 */
	RETVAL
	paktype *
	hwidbtype *idb, paktype *pak, boolean compress_cid, thcdbtype *thcdb
	0
	int linktype
END


DEFINE  uncompress_tcpip_header
/*
 * Summary: Perform generic uncompression of compressed TCP headers.
 * Input: Switched on linktype, for no apparent reason.
 *	Packet of interest.
 *	IDB of interest.
 *	Compression record.
 * Returns: Packet with TCP/IP header uncompressed.
 * Comments: List registry not chosen because return value is nonvoid.
 */

	RETVAL
	paktype *
	paktype *pak, hwidbtype *idb, thcdbtype *thcdb
	0
	int linktype
END


DEFINE  hdr_compress_init
/*
 * Summary: Initialize the compression parameters.
 * Input: Compression record.
 *	Maximum number of states allowed.
 * Returns: TRUE if initialization was successful.
 */

	RETVAL
	boolean
	thcdbtype *thcdb, int states
	0
	int linktype
END


DEFINE  show_compression_stats
/*
 * Summary: Display the compression statistics.
 * Input: IDB of interest.
 *	Compression record.
 * Returns: NULL.
 */

	RETVAL
	void
	hwidbtype *idb, thcdbtype *thcdb
	0
	int linktype
END


DEFINE  fr_tcpip_header_compression_command
/*
 * Summary: Set up header compression over FR using the "ip tcp ..." command
 * Input: Parser CSB.
 * Returns: NULL.
 */

	LIST
	void
	parseinfo *csb
END

DEFINE  show_fr_tcpip_header_compression
/*
 * Summary: Show header compression over FR when the "ip tcp ..."
 * 	command is entered.
 * Input: Parser CSB.
 * Returns: NULL.
 */

	LIST
	void
	parseinfo *csb
END


DEFINE	create_idb 
/*
 * Indexed figuratively by IFTYPE_xxx parser code.
 */
        LOOP
        boolean
        uint64 *ifcode, parseinfo *csb
END



DEFINE	swif_goingdown 
/*
 * Summary: Inform subsystems that a software interface is being shut down.
 * Input: IDB of interest.
 * Returns: NULL.
 */
	LIST
	void
	idbtype *swidb
END

DEFINE	swif_comingup 
/*
 * Summary: Inform subsystems that a software interface is being brought up.
 * Input: IDB of interest.
 * Returns: NULL.
 */
	LIST
	void
	idbtype *swidb
END



DEFINE	hwif_goingdown 
/*
 * Summary: Inform subsystems that a hardware interface is being shut down.
 * Input: IDB of interest.
 * Returns: NULL.
 */
	LIST
	void
	hwidbtype *hwidb
END



DEFINE	hwif_comingup 
/*
 * Summary: Inform subsystems that a hardware interface is being brought up.
 * Input: IDB of interest.
 * Returns: NULL.
 */
	LIST 
	void
	hwidbtype *hwidb
END



DEFINE	hwif_state_change 
/*
 * Summary: Inform subsystems that an interface has changed states.
 * Input: IDB of interest.
 * Returns: NULL.
 */
	LIST
	void
	hwidbtype *hwidb
END

DEFINE	swif_erase 
/*
 * Summary: Notify subsystems that an interface has been removed from the
 *		configuration.
 * Input: IDB of interest.
 * Returns: NULL.
 * Comments:   By convention, an interface keeps its configuration even
 *	though the interface itself never shows up in the configuration.
 *	If the interface is brought back, its configuration should be there too.
 */
	LIST
	void
	idbtype *idb
END



DEFINE	if_onesec 
/*
 * Summary: Perform interface-specific actions once per second.
 * Input: IDB of interest.
 * Returns: NULL.
 */
	LIST
	void
	hwidbtype *hwidb
END



DEFINE	onesec 
/*
 * Summary: Perfom generic system actions once per second.
 * Input: NULL.
 * Returns: NULL.
 */
	LIST
	void
	-
END



DEFINE	onemin 
/*
 * Summary: Perfom generic system actions once per minute.
 * Input: NULL.
 * Returns: NULL.
 */
	LIST
	void
	-
END



DEFINE	sw_idb_init 
/*
 * Summary: Initialize protocols on a software IDB.
 * Input: IDB of interest.
 * 	Boolean that is TRUE if we want to initialize associated 
 *	 hardware data structures.
 * Returns: NULL.
 */
	LIST
	void
	idbtype *swidb, boolean setup_hwidb
END


DEFINE	sw_idb_encaps_init
/*
 * Summary: Initialize encapsulations on a software IDB.
 * Input: Switched on encapsulation type.
 *	IDB of interest.
 * 	Boolean that is TRUE if we want to initialize associated 
 *	 hardware data structures.
 * Returns: NULL.
 */
	CASE
	void
	idbtype *swidb, boolean setup_hwidb
	ET_MAX	
	int enctype
END



DEFINE	hw_idb_init 
/*
 * Summary: Initialize hardware fields in a new IDB.
 * Input: IDB of interest.
 * Returns: NULL.
 * Comments: A number of fields here need to be moved into the
 * 	software IDB.
 */
	LIST
	void
	hwidbtype *hwidb
END



DEFINE	restarted 
/*
 * Summary: Inform subsystems that the system just restarted.
 * Input: NULL.
 * Returns: NULL.
 * Comments: Does things like send a spray of gratuituous ARPs and 
 *	some SNMP cold restart messages.
 */
	LIST
	void
	-
END



DEFINE	will_reload 
/*
 * Summary: Inform subsystems that the system is about to reload.
 * Input: NULL.
 * Returns: NULL.
 */
	LIST
	void
	-
END


DEFINE	hardware_shutdown
/*
 * Summary: Inform subsystems that the system will be going into ROM monitor
 *		mode.
 * Input: NULL.
 * Returns: NULL.
 * Comments: Functions are expected to shut down any hardware, for 
 *	example, interfaces or disk drives.
 */
	LIST
	void
	-
END


DEFINE  snapshot_update_denied
/*
 * Summary: Query the snapshot code to see whether a routing update should 
 *		be sent.
 * Input: IDB of interest.
 *	Boolean that is set if this is a Flash memory update.
 * Returns: TRUE if update should not be sent.
 */
	STUB
	boolean
	idbtype *idb, boolean flash_update
END

DEFINE snapshot_dialer_update_denied
/*
 * Summary: Query the snapshot code to see whether a dialer update should 
 *		be sent.
 * Input: IDB of interest.
 * Return: TRUE if dialer update should not be sent.
 * Comments: Before sending a routing protocol update packet (which is a
 *	packet with the SNAPSHOT_PAK_IS_UPDATE bit set) out a physical
 *	interface associated with a snapshot interface, the dialer code 
 *	calls this routine to ensure that the packet should go out this
 *	physical interface. Snapshot verifies that this physical interface is in
 *	its list of known physical interfaces that are attached to an SAB in
 *	the active state. This guarantees that, because one 'dialer remote
 *	site' is ACTIVE active with snapshot, we do not try to send packets 
 *	to other remote sites that are not active but are members of the same
 *	dialer hunt group.
 */
	STUB
	boolean
	hwidbtype *hwidb
END

DEFINE  snapshot_notice_update_pak
/*
 * Summary: Inform the snapshot subsystem that a routing update is being sent.
 * Input: Packet containing routing update.
 *	IDB that the update is being sent from.
 * Returns: NULL.
 * Comments: Snapshot subsystem may work with packet before returning.
 */
	STUB
	void
	paktype *pak, idbtype *idb
END

DEFINE snapshot_aging_denied
/*
 * Summary: Find out if snapshot is denying the aging of routes.
 * Input: IDB of interest.
 * Returns: TRUE if snapshot is denying the aging of routes.
 */
	STUB
	boolean
	idbtype *idb
END

DEFINE snapshot_enabled
/* 
 * Summary: Find out whether snapshot is enabled on an IDB.
 * Input: IDB of interest.
 * Returns: TRUE if snapshot is enabled.
 */
	STUB
	boolean	
	idbtype *idb
END

DEFINE snapshot_state_change
/*
 * Summary: Inform other subsystems that snapshot has changed state.
 * Input: IDB of interest.
 *	Boolean that is TRUE if snapshot is being enabled; FALSE otherwise.
 * Returns: NULL.
 */
	LIST
	void
	idbtype *idb, boolean enabled
END

DEFINE snapshot_update_received
/*
 * Summary: Inform snapshot that a routing update has been received.
 * Input: IDB of interest.
 *	Packet containing routing update.
 * Returns: NULL.
 */
	STUB
	void
	idbtype *idb, paktype *pak
END

DEFINE	snapshot_start_aging_routes
/*
 * Summary: Inform subsystems that a snapsot update has been received.
 * Input:  Switched on link type.
 *	IDB update was received on.
 *	Packet that was received.
 * Returns: NULL.
 * Comments: This is intended to tell subsystems to start aging routes 
 *	associated with this IDB and this protocol, and from this address.
 */
	CASE
	void
	idbtype *idb, paktype *pak
	LINK_MAXLINKTYPE
	int linktype
END

DEFINE	clear_counters 
/*
 * Summary: Inform subsystems that it is time to clear all counters.
 * Input: IDB of interest.
 * Returns: NULL.
 */
	LIST
	void
	hwidbtype *hwidb
END

DEFINE	consolidate_counters 
/*
 * Summary: Consolidate counters from hidden internal interfaces
 * 	into visible interface.
 * Input:  IDB of interest.
 * Returns: NULL.
 */
	LIST
	void
	hwidbtype *hwidb
END

DEFINE	proto_on_swidb 
/*
 * Summary: Detect whether a protocol is running on an IDB.
 * Input: Switched on linktype.
 *	IDB of interest.
 * Returns: Return TRUE if a protocol is active on an IDB.
 */
	RETVAL
	boolean
	idbtype *swidb
	LINK_MAXLINKTYPE
	int linktype
END

DEFINE	routed_proto_on_swidb 
/*
 * Summary: Detect whether a protocol is routed and active on an IDB.
 * Input: Switched on linktype.
 *	IDB of interest.
 * Returns: Return TRUE if a protocol is routed and active on an IDB.
 */
	RETVAL
	boolean
	idbtype *swidb
	LINK_MAXLINKTYPE
	int linktype
END


DEFINE	proto_running 
/*
 * Summary:  Detect whether a protocol is running on the router.
 * Input:  Link type.
 * Returns: Returns TRUE if a protocol is enabled in the router.
 */
  	RETVAL
	boolean
	-
	LINK_MAXLINKTYPE
	int linktype
END

DEFINE	proto_bridging_on_swidb
/*
 * Summary: Detect whether a protocol is enabled for bridging on an IDB.
 * Input: Switched on linktype.
 *	IDB of interest.
 * Returns: TRUE if protocol is enabled for bridging.
 * Comments:  Default is to return FALSE. See the BRIDGING_IF macro.  
 *	Protocols do not have to check whether bridging is enabled on the IDB.
 */
	RETVAL
	boolean
	idbtype *swidb
	LINK_MAXLINKTYPE
	int linktype
END

DEFINE	proto_routing_on_swidb
/*
 * Summary: Detect whether a protocol is routing on an IDB.
 * Input: Switched on linktype.
 *	IDB of interest.
 * Returns: TRUE if protocol is routing.
 * Comments:  See the ROUTING_IF macro.  
 */
  	RETVAL
	boolean
	idbtype *swidb
	LINK_MAXLINKTYPE
	int linktype
END


DEFINE	printf 
/*
 * Summary: Print a printf-style Cisco-specific conversion sequence.
 * Input: Pointer to printf format string.
 *	  Pointer to current position in output string.
 *	  TTY on which to printf, if any.
 *	  List of arguments passed to printf.
 *	  Text justification.
 *	  Text width.
 *	  Size of arguments.
 *	  Hash argument to tell us whether to print 0 or 0x.
 *	  Precision of arguments.
 * Returns: Returns the count of bytes printed.
 * Comments:  Used for registering printf extensions such as %i and %z.
 *		See examples in code.
 */
	RETVAL
	int 
	const char **fmt, char **cp, tt_soc *tty, va_list *argp, int rjust, \
	int width, int size, int hash, int precision
 	0
	char fmtchar
END



DEFINE	ping_parse 
/*
 * Summary: Ask subsystems whether they recognize an address given to the ping
 *		command.
 * Input: Argument passed on the ping command line.
 *	Any hint the parser may have about the protocol.
 *	Pointer to index to be filled in with protocol type.
 *	Pointer to position in argument string.
 *	Pointer to boolean that will be TRUE if the protocol is
 *		the correct one, and it is running.
 * Returns: Returns TRUE if the input was parsed as a recognizable address.
 * Comments: Used to automatically discover what protocol an address
 *	is supposed to be in PING and TRACE.
 */
	LOOP
	boolean
	char *args, int hint,\
	int *index, char **cp, boolean *running 
END



DEFINE	ping_run 
/*
 * Summary: Execute the protocol-specific ping routine.
 * Input: Switched on link type.
 *	Arguments to "ping" command.
 * Returns: NULL.
 */
	CASE
	void
	char *args
	0
	int index
END



DEFINE	trace_run 
/*
 * Summary: Execute the protocol-specific trace routine.
 * Input: Switched on link type.
 *	Arguments to "trace" command.
 * Returns: NULL.
 */
	CASE
	void
	char *args
	0
	int index
END



DEFINE	stay_shutdown 
/*
 * Summary: Check whether an interface should remain shut down.
 * Input: IDB of interest.
 * Returns: TRUE if the IDB should remain shut down because of its 
 *	configuration.
 */
	LOOP
	boolean
	idbtype *swidb
END



DEFINE	clear_routes 
/*
 * Summary: Totally reinitialize protocol specific routing tables.  
 * Input:  NULL.
 * Returns: NULL.
 * Comments: This is used (for example) when the hotswap code notices
 *	the physical MTU has changed.  Different protocols (notably IGRP) want
 *	to know about this change.  Clearing the routing table causes the new
 *	information to be used.
 */
	LIST
	void
	-
END



DEFINE	clear_idb_routes 
/*
 * Summary: Remove all entries for an interface from all routing tables.
 * Input:  IDB of interest.
 * Returns: NULL.
 * Comments: Different protocols (notably IGRP) want to know about
 * 	this change.  Clearing the routing table causes the new information 
 * 	to be used.
 */
	LIST
	void
	idbtype *swidb
END



DEFINE	critical_background 
/*
 * Summary: Call from the Critical Background process.
 * Input: NULL
 * Returns: NULL.
 * Comments: In general this should be used by an interrupt level routine
 *	that needs for resources to be created at process level.  
 *	RIF buffers, NETBIOS name cache, and queueing elements use 
 *	this facility.
 *
 *	NOTE:  Nothing should be added to this registry without review
 *		from senior engineers.
 */
	LIST
	void
	-
END



DEFINE	fs_cache_update 
/*
 * Summary: Populate the fast switching cache.
 * Input: Switched on linktype.
 *	Packet of interest.
 *	Address of packet if called from vencap, 0 otherwise.
 * Returns: NULL.
 * Comments: Mostly called by idb->encap and idb->vencap routines.
 */
	CASE
	void
	paktype *pak, ulong address
	LINK_MAXLINKTYPE
	int linktype
END

DEFINE	access_show 
/*
 * Summary: Display access information.
 * Input: List number to show, or 0L
 * Returns: NULL.
 * Comments: Called by the "show access" command.
 */
	LIST
	void
	int listnumber
END

DEFINE	access_named_show 
/*
 * Summary: Display access information.
 * Input: Pointer to access list header.
 * Returns: NULL.
 * Comments: Called by the "show access" command.
 */
	LIST
	void
	acl_headertype *acl
END

DEFINE	access_clear
/*
 * Summary: Clear access list statistics.
 * Input: Pointer to access list header.
 * Returns: NULL.
 * Comments: Called by the "clear access" command.
 */
	LIST
	void
	acl_headertype *acl
END

DEFINE	arp_enq 
/*
 * Summary: Give an ARP packet to correct protocol specific code.
 * Input: Switched on Ethernet type code.
 * Returns: NULL.
 */
	CASE
	void
	paktype *pak
	0
	ushort protocol_type
END



DEFINE	arp_reload 
/*
 * Summary: Insert interface entries into the ARP cache.
 * Input: IDB of interest.
 * Returns: NULL.
 */
	LIST
	void
	idbtype *swidb
END



DEFINE	no_rif 
/*
 * Summary: Called when no rif is found for an address
 * Input: Switched on link type.
 *	Interface of interest.
 *	Address being looked up.
 * Returns: NULL.
 */
	CASE
	void
	idbtype *interface, ipaddrtype address
	LINK_MAXLINKTYPE
	int linktype
END



DEFINE	showproto 
/*
 * Summary: Print out protocol information.
 * Input: IDB of interest (or NULL).
 * Returns: NULL.
 * Comments: Used by "show protocols" command.  If called with NULL as 
 *	the argument, print out global information.  Otherwise print out 
 *	interface specific information. 
 */
	LIST
	void
	idbtype *swidb
END

DEFINE	showproto_brief
/*
 * Summary:  Display brief protocol information about an interface.
 * Input: IDB of interest.
 * Returns: NULL.
 * Comments: If called with NULL as argument, print out global 
 *	information, otherwise * print out interface specific information. 
 */
	LIST
	void
	idbtype *swidb
END

DEFINE	set_hostname 
/*
 * Summary: Inform subsystems that our hostname has changed.
 * Input: NULL.
 * Returns: NULL.
 * Comments: Functions look in "hostname" to find the new name string.
 */
	LIST
	void
	-
END



DEFINE	debug_all 
/*
 * Summary: Set every debugging flag on the box.
 * Input:  Boolean to set the flags equal to.
 * Returns: NULL.
 * Comments:   Voted most pointless command for a large router, 1996.
*/
	LIST
	void
	boolean debug_all_flag
END



DEFINE	debug_show 
/*
 * Summary: Show what debugging flags are set.
 * Input: NULL.
 * Returns: NULL.
*/
	LIST
	void
	-
END

DEFINE	debug_standard
/*
 * Summary: Set a list of debugging flags.
 * Input: Boolean that the flags should be set equal to.
 * Returns: NULL.
 * Comments:  Used by HTTP configuration
 */
	LIST
	void
	boolean sense
END


DEFINE	log_config 
/*
 * Summary: Configure logging protocol.
 * Input: Parser CSB.
 * Returns: NULL.
 * Comments:  This is used to configure syslog.
 */
	STUB
	void
	parseinfo *csb
END



DEFINE	log_send 
/*
 * Summary: Send logging datagram (syslog) with special header.
 * Input: Buffer containing message.
 *	Length of buffer.
 *	Buffer containing header.
 *	Length of header.
 *	Level of logging.
 * Returns: NULL.
 */
	STUB
	void
	char *buffer, uint buflen, char *msgp, uint msglen, int lvl
END



DEFINE	log_show 
/*
 * Summary: Display logging statistics.
 * Input: NULL.
 * Returns: NULL.
 * Comments:  This registry is used by syslog.
 *
 */
	STUB
	void
	-
END

DEFINE syslogEvent
/*
 * Summary: Inform other registries when a syslogEvent occurs.
 * Input: Pointer to event record.
 * Returns: NULL.
 */
        LIST
        void
        sysloghistoryentry_t* entry_ptr
END

DEFINE syslog_history_event
/*
 * Summary: Record a syslog message in a history table and 
 *	send trap if requested.
 * Input: Pointer to message.
 *	List of arguments.
 */
        LIST
        void
        const message *msg, va_list args
END

DEFINE	autoaddr_okay 
/*
 * Summary: Check whether we have resolved all IP interfaces.
 * Input: NULL.
 * Returns: Boolean that is TRUE if automatic address configuration is
 *		not necessary.
 * Comments: Basically a call to ipisresolved().
 */
	STUB
	boolean
	-
END


DEFINE	ip_forus
/*
 * Summary: Detect whether an IP packet is addressed to an internal address.
 * Input: Packet of interest.
 * Returns: Returns TRUE if the packet is directed to us.
 */
	STUB
	boolean
	paktype *pak
END

DEFINE	mop_forus
/*
 * Summary: Detect whether a MOP packet is addressed to an internal address.
 * Input: Packet of interest.
 * Returns: Returns TRUE if the packet is directed to us.
 */
	STUB
	boolean
	paktype *pak
END

DEFINE	autoaddr_load 
/*
 * Summary: Invoke automatic address determination functions.
 * Input: NULL.
 * Returns: NULL.
 * Comments: Basically a call to ip_setaddresses.
 */
	STUB
	void
	-
END

DEFINE	autoaddr_stop
/*
 * Summary: Stop automatic address determination.
 * Input: Boolean that is TRUE if we should be quiet about it.
 * Returns: NULL.
 * Comments: Basically a call to ip_dns_killproc.
 */
	STUB
	void
	boolean silent
END


DEFINE name_lookup_number
/*
 * Summary: Look up an address name using its address.
 * Input: Switched by address type.
 *	Pointer to address to be revolved.
 * Returns: Pointer to nametype structure if address was resolved.
 * Comments: Uses both name cache as well as name servers.
 */
	RETVAL
	nametype *
	addrtype *address
	0
	uchar addr_type
END



DEFINE name_lookup_string
/*
 * Summary: Look up host name using string.
 * Input: String to use for lookup.
 *	Bitmask containing information about name.
 *	Pointer to be filled in with name information if found.
 *	Pointer to be filled in with error code if required.
 * Returns: TRUE if lookup was successful.
 * Comments: Name lookup using only name servers.
 */
	LOOP
	boolean
	char *name, int name_kind, nametype *revalid, nametype **ptr,\
	int *errcode
END



DEFINE FQDN_lookup_string
/*
 * Summary: Fully qualified domain name lookup by string.
 * Input: String to use for lookup. 
 *	Bitmask containing information about name.
 *	Pointer to be filled in with name information if found.
 * Returns: TRUE if lookup is successful.
 * Comments: This is used for FQDN lookup using only name servers.
 */
	LOOP
	boolean
	char *name, int name_kind, nametype **ptr
END



DEFINE name_lookup_self
/*
 * Summary: Determine system name if address can be resolved.
 * Input: Buffer in which to place system name.
 *	Maximum size of buffer.
 * Returns: TRUE if buffer is filled in.
 * Comments: Uses both name cache as well as name servers.
 */
	LOOP
	boolean
	char *buffer, int size
END


DEFINE name_show_servers
/*
 * Summary: Display configuration of name servers.
 * Input: NULL.
 * Returns: NULL.
 */
	LIST
	void
	-
END



DEFINE name_show_hosts
/* 
 * Summary: Print hostname-specific information for the output of the
 *	"show hosts" command.
 * Input:  Switched by name type.
 *	Pointer to name information.
 *	Text to be printed for continuation of display.
 * Returns: NULL.
 */
	CASE
	void
	nametype *ptr, char *continue_text
	0
	long flags
END



DEFINE name_match_number
/*
 * Summary: Discover if numeric address matches that of the nametype * pointer.
 * Input:  Switched on address type.
 *	Name information.
 *	Address of interest.
 * Returns: TRUE if address matches.
 */
	RETVAL
	boolean
	nametype *ptr, addrtype *address
	0
	uchar addr_type
END


DEFINE name_validate_addr
/*
 * Summary: Determine whether the given address has a valid DNS entry.
 * Input: Address of interest.
 * Returns: TRUE if address is valid.
 * Comments: This function uses the address that we have from the 
 *	TCP connection to ask the name cache/DNS for a router name.  It
 *	then clears that entry from the name cache, forces a DNS query 
 *	for a address from the name, and checks whether the IP 
 *	address that we originally had is valid for that string.
 *
 *       This was not named rcmd_validate_addr() because someday,
 *       someone else might need this functionality.
 */
	STUB
	boolean
	addrtype *addr
END


DEFINE name_match_string
/*
 * Summary:  Check whether one of the hostname string matching routines
 * 	matches the given string.
 * Input: String we are trying to match.   
 *	String we are matching.
 * Returns: TRUE if a match occurs.
 */
	LOOP
	boolean
	char *ptr_name, char *name
END



DEFINE name_parse_hostname
/*
 * Summary: Resolve a hostname into an address.
 * Input: Switched on address type.
 *	Pointer to host name.
 *	Pointer to address to be filled if name can be resolved.
 * Returns: TRUE if address is filled in.
 */
	RETVAL
	boolean
	char *ptr, addrtype *address
	0
	uchar addr_type
END


DEFINE name_martian
/*
 * Summary: Determine whether the address is even possible for a protocol.
 * Input:  Switched on address type.
 *	Address of interest.
 *	TRUE if we are checking a host address; FALSE if we are
 * 	 checking a network address (host portion not to be looked at).
 * Returns: TRUE if address is not valid in the protocol numbering scheme.
 */
	RETVAL
	boolean
	addrtype *address, boolean hostflag
	0
	uchar addr_type
END



DEFINE	setup_init 
/*
 * Summary: Initialize setup variables.
 * Input: Pointer to structure carrying setup values.
 * Returns: NULL.
 */
	LIST
	void
	setup_struct *ss
END



DEFINE	setup_common 
/*
 * Summary: Run the common setup routines (such as password, snmp, and XRemote).
 * Input: Pointer to structure carrying setup values.
 * Returns: NULL.
 */
	LIST
	void
	setup_struct *ss
END



DEFINE	setup_global 
/*
 * Summary: Run the global setup routines.
 * Input: Pointer to structure carrying setup values.
 * Returns: NULL.
 */
	LIST
	void
	setup_struct *sp
END



DEFINE	setup_global2 
/*
 * Summary: Run the second round of global setup routines.
 * Input: Pointer to structure carrying setup values.
 * Returns: NULL.
 */
	LIST
	void
	setup_struct *sp
END


DEFINE alllines_setup
/*
 * Summary: Run setup functions for all async lines during global setup.
 * Input: Pointer to structure carrying setup values.
 * Returns: NULL.
 */
	LIST
	void
	setup_struct *ss
END


DEFINE	setup_int 
/*
 * Summary: Run the interface setup routines.
 * Input: Pointer to structure carrying setup values.
 * Returns: NULL.
 */
	LIST
	void
	setup_struct *sp
END



DEFINE	setup_int2 
/*
 * Summary: Run the second round of interface setup routines.
 * Input: Pointer to structure carrying setup values.
 * Returns: NULL.
 */
	LIST
	void
	setup_struct *sp
END


DEFINE	setup_hub 
/*
 * Summary: Run the hub setup routines.
 * Input: Pointer to structure carrying setup values.
 * Returns: NULL.
 */
	LIST
	void
	setup_struct *sp
END


DEFINE	setup_end 
/*
 * Summary: Clean up after setup finishes.
 * Input: Pointer to structure carrying setup values.
 * Returns: NULL.
 */
	LIST
	void
	setup_struct *ss
END

DEFINE setup_ephemeral_int
/*
 * Summary: Run the ephermeral interface setup routines.
 * Input: Pointer to structure carrying setup values.
 * Returns: NULL.
 * Comments: Ephemeral interfaces do not exist until referenced,
 * 	so the normal setup code does not notice them. The intent is that
 * 	subsystems that use ephemeral interfaces register a routine that loops
 * 	through them here. This routine then invokes yet another registration 
 *	point (perhaps setup_int, but perhaps something special like 
 *	setup_async_int) for each interface that it might create.
 */
	LIST
	void
	setup_struct *sp
END


DEFINE setup_async_int
/*
 * Summary: Set up async interfaces that are created during configuration.
 * Input: Pointer to structure carrying setup values.
 * Returns: NULL.
 */
	LIST
	void
	setup_struct *sp
END

DEFINE	death 
/*
 * Summary:  Cleanup after a TTY session exits.
 * Input: TTY of interest.
 * Returns: NULL.
 */
	LIST
	void
	tt_soc *tty
END


DEFINE	kfork 
/*
 * Summary: Cleanup after a TTY process exits, but do not hang up modem.
 * Input: TTY of interest.
 * Returns: NULL.
 */
	LIST
	void
	tt_soc *tty
END


DEFINE	file_read 
/*
 * Summary: Read a file specified in a filetype data structure into the system.
 * Input: Switched on file access protocol.
 *	File pointer.
 *	Buffer to read into.
 *	Maximum size of buffer.
 *	Boolean which is TRUE if we should be verbose about failures.
 *	Function to call when finished.
 *	Arguments for callback function.
 * Returns: An ERROR_xxx code.
 */
DATA
typedef boolean (*callback_function) (uchar **buf, long *bytesleft, long len,
				       void *opaque_args);
END DATA
	RETVAL
	int
	filetype *file, uchar *buff, ulong *buffersize, boolean verbose,\
 	callback_function function_called, void *func_arg
	0
	int file_proto
#	file_access_protocol file_proto
END


DEFINE	file_write 
/*
 * Summary: Write a file specified in a filetype data structure.
 * Input: Switched on file access protocol.
 *	Pointer to file.
 *	Buffer to take data from.
 *	Size of buffer.
 * Returns:  TRUE if write is successful.
 */
	RETVAL
	boolean
	filetype *cfg, char *curcfg, uint size
	0
	int file_proto
#	file_access_protocol file_proto
END


DEFINE	file_match 
/*
 * Summary: Determine whether two file specifications match.
 * Input:  Switched on file access protocol.
 *	Two file pointers.
 * Returns: TRUE if the two file specifications match.
 */
	RETVAL
	boolean
	filetype *cfg1, filetype *cfg2
	0
	int file_proto
#	file_access_protocol file_proto
END


DEFINE	file_exists
/*
 * Summary: Determine whether a file exists.
 * Input: Switched on the file access protocol.
 *	String containing file name.
 * Returns: TRUE if the file exists.
 */
	RETVAL
	boolean
	const char *filename
	0
	int file_proto
#	file_access_protocol file_proto
END

DEFINE	file_source 
/*
 * Summary: Determine the source of a file.
 * Input: Switched on file access protocol. 
 *	Pointer to file information.
 *	Pointer to be filled in with string identifying the source of the file.
 * Returns: NULL.
 */
	CASE
	void
	filetype *confg, uchar *source
	0
	int file_proto
#	file_access_protocol file_proto
END

DEFINE	file_parse 
/*
 * Summary: Parse protocol-specific file information when booting 
 *	from configuration information.
 * Input: Switched on file access protocol.
 *	File pointer.
 *	Parseinfo structure.
 * Returns: NULL.
 */
	CASE
	void
	filetype *ourcfg, parseinfo *csb
	0
	int file_proto
#	file_access_protocol file_proto
END

DEFINE	bootinfo_get 
/*
 * Summary: Get protocol-specific information about the file
 *	from which we booted.
 * Input:  Switched on file access protocol.
 *	Boot information.
 *	Pointer to be filled in with file information.
 * Returns: NULL.
 */
	CASE
	void
	bootinfo_t *bootinfo, filetype *sysconfg
	0
	int protocol
END



DEFINE	bootinfo_set 
/*
 * Summary:  Set protocol-specific information about the file from which
 *	we booted.
 * Input:  Switched on file access protocol.
 *	Boot information.
 *	Pointer to be filled in with file information.
 * Returns: NULL.
 */
	CASE
	void
	bootinfo_t *bootinfo, filetype *sysconfg
	0
	int file_proto
#	file_access_protocol file_proto	
END


DEFINE	bootfile_parse 
/*
 * Summary: Parse protocol-specific file information when booting manually.
 * Input: File pointer.
 *	Protocol to use if available.
 *	String containing hostname if available.
 *	Any additional argument on boot line.
 * Returns: TRUE if a parsing match is made.
 */
	LOOP
	boolean
	filetype *cfg, char *protoptr, char *hostname, char *argument
END


DEFINE	get_remote_username
/*
 * Summary: Get protocol-specific remote username.
 * Input:  Switched on file access protocol.
 * Returns: Pointer to user name.
 */
	RETVAL
	char *
	-
	0
	int file_proto
#	file_access_protocol file_proto	
END


DEFINE	bridge_enqueue 
/*
 * Summary: Pass a packet to the bridging code.
 * Input: Packet of interest.
 *	Boolean which is true if bridging code should make a copy of packet.
 *	Boolean which is true if bridging code should accept unicast traffic.
 * Returns: NULL.
 */
	STUB
	void
	paktype *pak, boolean copyflag, boolean unicast_ok
END

DEFINE  bridge_address_check
/*
 * Summary: Check the MAC-level address against the access lists.
 * Input: MAC address.
 * Returns: NULL.
 * Comments: This service is called from interrupt level immediately after 
 *	a new station address has been learned.
 */
	STUB
	void
	btetype *mac
END


DEFINE	bridge_clear_interface
/*
 * Summary: Remove entries in the forwarding database associated with 
 *	the interface and possibly recompute the spanning-tree topology.
 * Input: IDB of interest.
 * Returns: NULL.
 * Comments: This works only if transparent bridging is enabled on 
 *	the interface.
 */
	STUB
	void
	idbtype *idb
END


DEFINE	bridge_adjust 
/*
 * Summary: Perform bridging-related fixes if there has been a change 
 *	in the state of the IDB.
 * Input: IDB of interest.
 * Returns: NULL.
 * Comments: ROUTE_ADJUST is called periodically, but BRIDGE_ADJUST is 
 *	called only when necessary.
 */
	LIST
	void
	idbtype *swidb
END

DEFINE	vlan_adjust 
/*
 * Summary: Perform VLAN related fixes if there has been a change 
 *	in the state of the IDB.
 * Input: IDB of interest.
 * Returns: NULL.
 * Comments: Called only when necessary.
 */
	LIST
	void
	idbtype *swidb
END

DEFINE	deconfigure_vlan_switching 
/*
 * Summary: Remove VLAN attributes associated with a subinterface.
 * Input: IDB of interest.
 * Returns: NULL.
 */
	STUB
	void
	idbtype *swidb
END


DEFINE	rxtypes_update
/*
 * Summary: Maintain the table of rxtypes.
 * Input: IDB of interest.
 * Returns: NULL.
 * Comments: The table of rxtypes indicates which rxtypes are being 
 *	routed and which are being bridged on a given interface.
 */
	LIST
	void
	idbtype *swidb
END


DEFINE sbridge_smf_update
/*
 * Summary: Inform source-route bridging that it should consider a
 *	new address in its MAC filtering.
 * Input: Address of interest.
 *	IDB of filter.
 *	Code indicating the type of address and action to be taken on a match.
 * Returns: TRUE if successful.
 * Comments: If source-route bridging is configured on the given
 * 	(sub)interface, the given address is inserted into the software
 * 	MAC filter, with "result" indicating the type of address and the 
 *	action to be taken upon a match. Otherwise, the given address is
 *	deleted from the software MAC filter.
 */
	STUB
	boolean
	uchar *addr, idbtype *swidb, ulong result
END


DEFINE tbridge_smf_update
/*
 * Summary: Inform Transparent Bridging that it should consider a
 *	new address in its MAC filtering.
 * Input: Address of interest.
 *	IDB of filter.
 *	Code indicating the type of address and action to be taken on a match.
 * Returns: TRUE if successful.
 * Comments: If Transparent Bridging is configured on the given
 * 	(sub)interface, the given address will be inserted in the software
 * 	MAC filter with "result" indicating the type of address and the 
 *	action to be taken upon a match.  Otherwise, the given address will
 *	be deleted from the software MAC filter.
 */
	STUB
	boolean
	uchar *addr, idbtype *swidb, ulong result
END


DEFINE tbridge_smf_delete
/*
 * Summary: Delete the given address from the software MAC filter.
 * Input: Address of interest.
 *	IDB of filter.
 *	Code indicating the type of address and action to be taken on a match.
 * Returns: TRUE if deletion is successful.
 */
	STUB
	boolean
	uchar *addr, idbtype *swidb, ulong result
END


DEFINE tbridge_smf_delete_by_result
/*
 * Summary: Delete the all addresses from the software MAC filter
 * 	that match the given result.
 * Input: IDB of filter.
 *	"result" (action to be taken on address match) code.
 * Returns: TRUE if successful.
 */
	STUB
	boolean
	idbtype *swidb, ulong result
END


DEFINE tbridge_smf_show
/*
 * Summary:  Show the software MAC filter for the given interface.
 * Input: IDB of interest.
 * Returns: NULL.
 */
	STUB
	void
	idbtype *swidb
END


DEFINE bridge_entry_global_remove
/*
 * Summary: Remove the address from all bridge tables.
 * Input: Address to be removed.
 * Returns: NULL.
 */
        STUB
        void
        uchar const *addr
END



DEFINE  bridge_setup
/* 
 * Summary: Perform noninterface-dependent bridging fixes.
 * Input: NULL.
 * Returns: NULL.
 */
	LIST
	void
	-
END


DEFINE  srb_setup
/* 
 * Summary: Perform source-route bridging fixes.
 * Input: NULL.
 * Returns: NULL.
 * Comments: Usually called after a configuration change.
 */
	LIST 
	void
	-
END

DEFINE  srb_enabled
/* 
 * Summary: Discover whether source-route bridging is running.
 * Input: NULL.
 * Returns: TRUE if source-route bridging is running.
 */
	STUB
	boolean
	-
END

DEFINE bridge_set_shifa
/*
 * Summary: NOT USED
 * Input: NULL.
 * Returns: NULL.
 */
	STUB
	void
	boolean newstate
END


DEFINE bridge_circuit_remove
/*
 * Summary: Remove an IDB from its bridging circuit group.
 * Input: IDB of interest
 * Returns: NULL.
 * Comments:  Frame Relay and X.25 require this when changing changing
 * 	the encapsulation of a serial interface.
 */
	STUB
	void
	idbtype *swidb
END


DEFINE	config_read 
/*
 * Summary: Load configuration information.
 * Input: Switched on file access protocol.
 *	Parseinfo structure.
 *	Boolean that is TRUE if data should be written directly to NVRAM.
 * Returns: NULL. 
 */
	CASE
	void
	parseinfo *csb, boolean direct_to_nv
	0
	long FILE_ACCESS_TFTP
END

DEFINE  config_history_event
/*
 * Summary: Inform subsystems that a configuration event has occurred.
 * Input: A token telling how the command was entered.
 *	A token telling where the command text was retrieved from.
 *	A token telling where command text was destined for.
 *	IP address from which command text was retrieved, or 0.
 *	Name of file that command text was retrieved from, or NULL.
 *	Username used to retrieve command text, or NULL.
 * Returns: NULL.
 */
	LIST
	void
	int command_source, int data_source, int data_destination, \
	ipaddrtype server_ip, char *config_file, char *rcp_user
END

DEFINE	noninteractive_config_read 
/*
 * Summary: Load configuration information without asking questions.
 * Input: Switched on file access type.
 *	Name of file to read.
 *	IP address to read file from.
 * 	Boolean that is TRUE if writing information directly to NVRAM.
 * Returns: TRUE if read is successful.
 * Comments: Used for Autoinstall over WAN links.
 */
	RETVAL
	boolean
	char *filename, addrtype *server_ip_addr, boolean direct_to_nv
	0
	long FILE_ACCESS_TFTP
END

DEFINE	ok_to_write_nv_check
/*
 * Summary: Determine whether writing NVRAM is allowable.
 * Input: NULL.
 * Returns: FALSE if it is okay to write NVRAM.
 */
	STUB
	boolean
	-
END

DEFINE bridge_poll_interface_stats
/*
 * Summary: Update the count of autonomously switched datagrams.
 * Input: IDB to do update on.
 * Returns: NULL.
 */
    LIST
    void
    idbtype* idb
END

DEFINE access_batch_cmd
/*
 * Summary: Determine (or set) whether the system is currently accepting
 *	a batch of commands.
 * Input: Token telling whether to check or set the batch flag.
 *	Value to which to set the batch flag, if we are setting it.
 * Returns: TRUE if the system is currently executing a batch of commands.
 * Comments: See ip_tftp_state_access.
 */
DATA
	typedef enum access_batch_type_ {
	    ACCESS_BATCH_CHECK,
	    ACCESS_BATCH_SET
	} access_batch_type;
END DATA
        LOOP
        boolean
        access_batch_type access_flag, boolean value
END

DEFINE show_auxiliary_switch_counts
/*
 * Summary: Display the counts of auxiliary switch counts. 
 * Input: IDB of interest.
 * Returns: NULL.
 * Comments: Used for the "show interface statistics" command.
 */
    LIST
    void
    hwidbtype* hwidb
END


DEFINE	config_write 
/*
 * Summary: Write configuration information to a file.
 * Input: Switched on file access protocol.
 *	Pointer to parser command.
 * Returns: NULL.
 */
	CASE
	void
	parseinfo *csb
	0
	long FILE_ACCESS_TFTP
END


DEFINE	core_dump
/*
 * Summary: Write a core file.
 * Input: Switched on file access protocol.
 *	Pointer to memory to dump.
 *	Pointer to size of memory.
 *	Name of file to dump.
 *	IP address to dump to.
 *	IP socket to use for the dump.
 * Returns: TRUE if dump is successful.
 */
	RETVAL
	boolean
	uchar *mem, ulong size, \
	const char *filename, ipaddrtype host, ipsocktype *soc
	0
	int file_proto
#	file_access_protocol file_proto
END

DEFINE  slave_core_dump
/*
 * Summary: Write a slave core file, or change the slave core socket.
 * Input: Switched on file access protocol.
 *	Pointer to memory to dump.
 *	Pointer to size of memory.
 *	Name of file to dump.
 *	IP address to dump to.
 *	IP socket to use for the dump.
 *	Slave core socket maintainance token.
 * Returns: TRUE if dump is successful.
 */
        RETVAL
        boolean
        uchar *mem, ulong size, \
        const char *filename, ipaddrtype host, char flags
        0
        int file_proto
#       file_access_protocol file_proto
END
 
DEFINE	time_set 
/*
 * Summary: Notify subsystems when the local clock changes.
 * Input: Boolean that is TRUE if the source is NTP.
 * Returns: NULL.
 */
	LIST
	void
	boolean source_is_ntp
END

DEFINE	hw_clock_set
/*
 * Summary: Notify subsystems when the hardware clock rate changes.
 * Input: Clock frequency, expressed as the numerator and denominator
 *		of a fraction.
 * Returns: NULL.
 */
	LIST
	void
	ulong freq_numerator, ulong freq_denominator
END

DEFINE  cpu_supports_calendar
/*
 * Summary: Determine whether this platform has a hardware clock/calendar.
 * Input: NULL.
 * Returns: TRUE if this platform has a hardware clock/calendar.
 */
	STUB
	boolean
	-
END

DEFINE  ntp_read_calendar	
/*
 * Summary: Read calendar function for NTP.
 * Input: Pointer to a timeval structure to be filled in.
 * Returns: NULL.
 */
	STUB
	void
	timeval* tv
END

DEFINE  ntp_write_calendar
/* 
 * Summary: Write calendar function for NTP.
 * Input: Point to a timeval structure containing calendar information.
 * Returns: NULL.
 */
	STUB
	void
	timeval* tv
END
	

DEFINE parse_address
/*
 * Summary: Let subsystems attempt to parse an address.
 * Input:  Switched by address type. 
 *	String with proposed address.
 *	Pointer to be filled in with address type.
 * Returns: TRUE if function was able to fill the address pointer.
 */
	RETVAL
	boolean
	char *str, addrtype *address
	ADDR_MAX
	uchar addr_type
END


DEFINE	proto_address 
/*
 * Summary: Place a protocol address into an addrtype structure.
 * Input: Switched on protocol type.
 *	IDB to get address from.
 *	Packet containing alternate IDB information.
 *	Pointer to address to be filled in.
 * Returns: NULL.
 * Comments: See novell_build_address for an example of how the 
 *	packet may be used.
 */
	CASE
	void
	idbtype *swidb, paktype *pak, addrtype  *source
	0
	uint protocol
END


DEFINE	sprintf_address_link 
/*
 * Summary: Print a network-layer protocol address into a string.
 * Input: Switched on link type.
 *	String to place address into.
 *	Addrtype structure containing the address.
 * Returns: NULL.
 */
	CASE
	void
	char *buffer, addrtype *proto_addr
	LINK_MAXLINKTYPE
	int link
END


DEFINE sprintf_address_addr
/*
 * Summary: Print a network-layer protocol address into a string.
 * Input: Switched on address type.
 *	String to place address into.
 *	Addrtype structure containing the address.
 */
	CASE
	void
	char *buffer, addrtype *address
	ADDR_MAX
	uchar addr_type
END


DEFINE	line_handoff 
/*
 * Summary: Turn over control of an async line.
 * Input: NULL.
 * Returns: NULL.
 * Comments: Called only by processes associated with TTYs.
 */
	STUB
	void
	-
END


DEFINE	build_packet_address
/*
 * Summary: Take the address from a packet and place it into an addrtype.
 * Input: Switched on link type.
 *	Packet to take address from.
 *	Pointer to fill with address.
 *	Token to tell whether to copy the source or destination address.
 * Returns: NULL.
 */
	CASE
	void
	paktype *pak, addrtype *addr, enum SRCDST which
	0
	uint link
END

DEFINE	sprintf_src_dst 
/*
 * Summary: Print the address from a packet into a string.
 * Input: Switched on link type.
 *	String to fill.
 *	Packet to get address from.
 *	Token to tell whether to copy the source or destination address.
 * Returns: NULL.
 */
	CASE
	void
	char *source, paktype *pak, enum SRCDST which
	0
	uint link
END


DEFINE	access_check 
/*
 * Summary: Check whether the packet matches an access list.
 * Input: Switched on link type.
 *	Packet of interest.
 *	Access list number to test against.
 * Returns: TRUE if packet should be allowed.
 */
	RETVAL
	boolean
	paktype *pak, int testlist
	LINK_MAXLINKTYPE
	ushort linktype
END



DEFINE	valid_access_list 
/*
 * Summary: Check whether an access list number is valid.
 * Input:  Switched on link type.
 * 	Access list number.
 * Returns: TRUE if this is a valid access list number.
 */
	RETVAL
	boolean
	int testlist
	0
	ushort linktype
END


DEFINE	extract_typecode 
/*
 * Summary:  Extract the typecode from a packet.
 * Input: Packet of interest.
 * Returns: Type code.
 */
	STUB
	ushort
	paktype *pak
END


DEFINE	interface_cfg_modified 
/*
 * Summary: Inform subsystems when an interface configuration is modified.
 * Input: IDB of interest.
 * Returns: NULL.
 */
	LIST
	void
	hwidbtype *hwidb
END


DEFINE encaps_queuing_allowed
/*
 * Summary: Determine whether this encapsulation allows this type of queueing.
 * Input: Switched on encapsulation type.
 *	IDB of interest.
 *	Queueing type.
 * Returns: Return TRUE if queue_type queuing (that is, 
 *	QUEUE_{CUSTOM, PRIORITY,...}) is allowed for this 
 *	interface/encapsulation combination. The default case 
 *	returns TRUE. FALSE means that the queuing algorithm is not supported.
 */
	RETVAL
	boolean
	hwidbtype *hwidb, ulong queue_type
	ET_MAX	
	int enctype	
END


DEFINE	rlogin_supported
/*
 * Summary: Determine whether rlogin is supported in this image.
 * Input: NULL.
 * Returns: TRUE if rlogin is supported; FALSE otherwise.
 * Comments: NULL.
 */
	STUB
	boolean
	-
END

DEFINE sum_region
/*
 * Summary: Calculate the checksum of a region of memory.
 * Input: Type of checksum required.
 *	Pointer to beginning of region.
 *	Length of region.
 *	Boolean that is TRUE if the process should suspend while summing.
 * Returns: Checksum.
 */
	STUB
	ulong
	int cksum_type, uchar *buff, int bufflen, int suspend_flag
END

DEFINE sum_values
/*
 * Summary: Calculate the checksum on two specified values.
 * Input: Type of checksum required.
 *	Two values to be checksummed.
 * Returns: Checksum.
 */
	STUB
	ulong
	int cksum_type, ulong value1, ulong value2
END



DEFINE	rlogin_connect
/*
 * Summary: Handle the "connect" command for rlogin.
 * Input: Pointer to parser information.
 * Returns: NULL.
 */
	STUB
	void
	parseinfo *csb
END



DEFINE  rsh_support
/*
 * Summary: Unused.  ***
 * Input: NULL.
 * Returns: NULL.
 */
        LIST
        void
        parseinfo *csb
END

DEFINE tty_show
/*
 * Summary: Display protocol-specific information for the "show line" command.
 * Input: TTY of interest.
 * Returns: NULL.
 * Comments: This includes LAT, SLIP, header compression, and so on.
 */
	LIST
	void
	tt_soc *tty
END

DEFINE tty_xon
/*
 * Summary:  Do device-dependent XON.
 * Input: TTY of interest.
 * Returns: TRUE if XON was sent.
 * Comments: XON may not be sent if one has already been sent.
 */
	STUB
	boolean
	tt_soc *tty
END


DEFINE proto_send_message
/*
 * Summary: Send a text message on a line in a protocol-specific manner.
 * Input: TTY of interest.
 *	Packet containing message.
 * Returns: TRUE if message was sent.
 * Comments: This is called before the TTY text message code in case
 *	something like AppleTalk Remote Access is running on the line.
 */
	LOOP
	boolean
	tt_soc *tty, paktype *pak
END


DEFINE exec_process
/*
 * Summary: Create a process controlling an async line.
 * Input: TTY of interest.
 *	Sample of data coming in on the tty.
 * Returns: TRUE if a process was started.
 * Comments: Used by autoselect.
 */
	LOOP
	boolean
	tt_soc *tty, uint sample
END



DEFINE stun_prioritization
/*
 * Summary: Determine whether the IBM serial tunnel code wants this packet
 *	prioritized.
 * Input: Priority list.
 *	Packet of interest.
 *	IDB packet will be output on.
 * Returns: TRUE if the IBM serial tunnel code believes this packet 
 *	should get priority.
 */
	STUB
	boolean
	plisttype *plist, paktype *pak, hwidbtype *output
END


DEFINE bstun_prioritization
/*
 * Summary: Determine whether the block serial tunnel code wants this packet
 *	prioritized.
 * Input: Priority list.
 *	Packet of interest.
 *	IDB packet will be output on.
 * Returns: TRUE if the block serial tunnel code believes this packet 
 *	should get priority.
 */
	STUB
	boolean
	plisttype *plist, paktype *pak, hwidbtype *output
END



DEFINE priority_parse
/*
 * Summary: Parse priority commands.
 * Input: Switched on priority command type.
 *	Parser information for this command.
 *	Access list number.
 *	Priority information to be filled in.
 *	Current list of priority structures.
 * Returns: NULL.
 */
	CASE
	void
	parseinfo *csb, int listnum, pritype *p, plisttype *plist
	0
	int pricmd_qcustom
END	

DEFINE priority_show
/*
 * Summary: Print priority queueing information.
 * Input: Priority list.
 *	Boolean that is true if this is a custom queue.
 *	Number of the priority list in which we are interested.
 * Returns: TRUE if printing was done.
 */
	LOOP
	boolean
	plisttype *plist, boolean custom, int i
END

DEFINE priority_protocol_nv_add
/*
 * Summary: Add information to the end of a priority list command.
 * Input: Switched on link type.
 * Returns: NULL.
 */
	CASE
	void
	plisttype *plist
	LINK_MAXLINKTYPE
	int link
END

DEFINE priority_protocol_compare
/*
 * Summary: Compare two priority list structures.
 * Input: Switched on link type.
 *	Pointer to first priority list structure.
 *	Pointer to second priority list structure.
 * Returns: TRUE if they are similar.
 */
	RETVAL
	boolean
	plisttype *itema, plisttype *itemb
	LINK_MAXLINKTYPE
	int link
END

DEFINE priority_protocol_parse
/*
 * Summary: Parse the protocol-specific portions of a priority list.
 * Input: Switched on link type.
 *	Pointer to parseinfo structure.
 *	Pointer to priority list structure to be filled in.
 * Returns: TRUE if information was successfully parsed.
 */
	RETVAL
	boolean
	parseinfo *csb, plisttype *ptmp
	LINK_MAXLINKTYPE
	int link
END

DEFINE if_final_init
/*
 * Summary: Complete product/interface-specific initialization.
 * Input: NULL.
 * Returns: NULL.
 * Comments: Called from if_final_init(). 
 */
	LIST
	void
	-
END


DEFINE bad_nvram_if
/*
 * Summary: Bring up interfaces that were waiting for the NVRAM, if we have
 *	discovered that the NVRAM is bad.
 * Input: NULL.
 * Returns: NULL.
 */
	LIST
	void
	-
END


DEFINE netbios_acl_get
/*
 * Summary: Retrieve a named NetBIOS access list.
 * Input: Access expression code.
 *	Access list identifier.
 * Returns: Pointer to a NetBIOS access list, or NULL.
 */
DATA
	typedef struct netbios_acclisttype_ netbios_acl_;
END DATA
	STUB
	netbios_acl_ *
	int typecode, char *identifier
END


DEFINE netbios_acl_check
/*
 * Summary: Check whether this NetBIOS packet should be permitted.
 * Input: Access expression code.
 *	Pointer to packet datagramstart.
 *	Packet datagramsize.
 *	RIF length.
 *	Pointer to the ExpressionTree Symbol node whose
 *               value is to be determined.
 *	Pointer to a boolean that should be filled with TRUE if NetBIOS
 *		successfully parses the packet.
 * Returns: TRUE if packet should be permitted.
 * Comments: See expr_determine_symbol_value() for more information.
 */
	STUB
	boolean
	int typecode, uchar *dgstart, ulong dgsize, int riflen, \
		expr_tree_entry_t *symbol_node, boolean *ignored
END

DEFINE transmit_frames_protocol
/*
 * Summary: Build headers for the test transmit command.
 * Input:  Switched on a character representing the protocol type.
 *	IDB on which the packet will be sent.
 *	Pointer to pointer to packet that should have header added.
 *	Encapsulation type to use;  see code in functions for values.
 *	Size of test frame.
 * Returns: NULL.
 */
	CASE
	void
	idbtype *idb, paktype **pak, int encap, ulong testframesize
	0
	int c
END

DEFINE	transmit_frames_protocol_print
/*
 * Summary: Print the protocol options for the test transmit command.
 * Input: Switched on character representing protocol type.
 * Returns: NULL.
 */
	CASE
	void
	-
	0
	int c
END

DEFINE decnet_convert
/*
 * Summary: Convert a packet from DECnet to CLNS, or vice versa.
 * Input: Switched on original link protocol of datagram. 
 *	Packet to be converted.
 * 	Pointer to DECnet data.
 * 	Boolean used by CLNS, which is FALSE only for ES-IS types of datagrams.
 * Returns: TRUE if packet accepted and absorbed.
 */
	RETVAL
	boolean
	paktype *pak, uchar *data, boolean addresscheck
        0
        int linktype
END

DEFINE decnet_dn2clns_neighbor
/*
 * Summary: From DECnet, add or delete a neighbor in the CLNS database
 * Input: Packet containing neighbor information.
 *	Neighbor's area.
 *	Neighbor's node.
 *	Hello time.
 * Returns: NULL.
 */
	STUB
	void
	paktype *pak, int herarea, int hernode,  ulong time
END

DEFINE dn_inform_clns
/*
 * Summary: Inform CLNS about topology change in L2 DECnet routing table.
 * Input: DECnet area of interest.
 *	Boolean that is TRUE if route should be changed to UP, and FALSE if
 *	  it should be moved to DOWN.
 * Returns: NULL.
 */
 	STUB
	void
	uchar ivarea, uchar new_state
END

DEFINE dn_add_phaseIVroute
/*
 * Summary: Add a Phase IV route to DECnet routing table.
 * Input: Pointer to net to add.
 *	Area of net.
 *	Hops to net.
 *	Cost to get there.
 * Returns: NULL.
 */
 	STUB
	void
	dnnet *net, uchar area, int hops, int cost
END

DEFINE dn_reinstate_adv_routes
/*
 * Summary: Reinstate DEC advertised routes.
 * Input: DECnet net of interest.
 * Returns: NULL.
 */
 	STUB
	void
	dnnet *net
END

DEFINE dn_check_clns_prefix
/*
 * Summary: Check whether a CLNS prefix matchs the given DECnet Phase IV area. 
 * Input: DECnet IV area of interest.
 * Returns: TRUE if area exists.
 */
 	STUB
	boolean
	uchar ivarea
END

DEFINE dn_clear_discard_routes
/*
 * Summary: Clear all CLNS discard routes created by DECnet Phase IV.
 * Input: NULL.
 * Returns: NULL.
 */
 	STUB
	void
	-
END


DEFINE decnet_clns2dn_neighbor
/*
 * Summary: From CLNS, add or delete a neighbor in the DECnet database.
 * Input: Boolean that is TRUE if neighbor should be added.
 *	NSAP key to file neighbor under.
 *	IDB that neighbor was received on.
 *	Hello time to neighbor.
 * Returns: NULL.
 */
DATA
	typedef uchar nsap_t_[];
END DATA
	STUB
	void
	boolean addflag, nsap_t_ nsap, idbtype *swidb, ulong time
END


DEFINE nv_decnet
/*
 * Summary: Do DECnet global configuration.
 * Input: Buffer containing command.
 *	DECnet net.
 * Returns: NULL.
 */
	LIST
	void
	char *nv_command, dnnet *net
END

DEFINE decnet_hello_version
/*
 * Summary: Get DECnet version number.
 * Input: IDB of interest.
 * Returns: Version number.
 */
	STUB
	uchar
	idbtype *idb
END

DEFINE	decnet_show
/*
 * Summary: Show DECnet configuration.
 * Input: Net of interest.
 * Returns: NULL.
 */
	LIST
	void
	dnnet *net
END

DEFINE  dnconversion_report
/*
 * Summary: Discover if dn_conversion is set.
 * Input: NULL.
 * Returns: Boolean value of dn_conversion.
 */
        LOOP
        boolean
        -
END

DEFINE  decnet_trigger_L2_routes
/*
 * Summary: Cause a DECnet L2 triggered update.
 * Input: NULL.
 * Returns: NULL.
 * Comments: Called when CLNS prefix route table changes
 */
        LIST
        void
        -
END

DEFINE	bridge_address
/*
 * Summary: Parse the "bridge <group> address <address> <action>" command.
 * Input:  Parseinfo structure.
 *	Span information.
 *	Pointer to a boolean that should be set to FALSE if this bridge
 *		is invalid.
 * Returns: NULL.
 */
	LIST
	void
	parseinfo *csb, spantype *span, boolean *success
END

DEFINE	clns_parse_addr_map
/*
 * Summary: Parse a CLNS address.
 * Input: Switched on link type.
 *	Parseinfo structure.
 *	Addresses to be filled in.
 * Returns: TRUE if addresses were filled in.
 */
	RETVAL
	boolean
	parseinfo *csb, hwaddrtype *snpa, addrtype *addrs
	0
	int linktype
END

DEFINE	clns_delete_addr_map
/*
 * Summary: Delete a CLNS address map.
 * Input: Parseinfo structure.
 *	Address to be deleted.
 * Returns: NULL.
 */
	LIST
	void
	parseinfo *csb, addrtype *addrs
END

DEFINE	clns_discard_route_adjust
/*
 * Summary: Bring CLNS discard route up or down.
 * Input: Prefix of discard route.
 *	State to move discard route to.
 * Returns: NULL.
 */
	LIST
	void
	uchar *prefix, boolean new_state
END

DEFINE	clns_route_search
/*
 * Summary: Determine whether a CLNS route exists.
 * Input: CLNS prefix.
 * Returns: TRUE if route exists.
 */
	LOOP
	boolean
	uchar *prefix
END

DEFINE	clns_nv_addr_map
/*
 * Summary: Do NV generation of a CLNS address.
 * Input: Parseinfo structure.
 *	CLNS adjacency.
 * Returns: NULL.
 */
	LIST
	void
	parseinfo *csb, clns_adjtype *adj
END

DEFINE	clns_pak_duplicate
/*
 * Summary: Duplicate a CLNS packet and set up CLNS-related information in 
 *	packet header.
 * Input: Pointer to original packet.
 *	Pointer to pointer to be filled in with new packet.
 *	Address of packet.
 * Returns: NULL.
 */
	STUB
	void
	paktype *old_pak, paktype **new_pak, long *addr
END

DEFINE	encaps_nvram_write
/*
 * Summary: Do NVRAM generation for the "encapsulate" command.
 * Input: Switched on encapsulation type.
 *	Parseinfo structure.
 * Returns: NULL.
 */
	CASE
	void
	parseinfo *csb
	ET_MAX
	int enctype
END

DEFINE  lex_bind_bymac
/*
 * Summary: Bind a lex interface to a serial interface.
 * Input:  IDB of interest.
 *	MAC address.
 * Returns: NULL.
 */
	STUB
	void
	idbtype *serial, uchar *macaddr
END

DEFINE  lex_unbind_byidb
/*
 * Summary: Unbind a lex interface from a serial interface.
 * Input: IDB of interest.
 * Returns: NULL.
 */
	STUB
	void
	idbtype *lex_swidb
END

DEFINE  lex_find_free_bymac
/*
 * Summary: Find a lex IDB in the free queue.
 * Input: MAC address to search by.
 * Returns:  TRUE if such an IDB exists.
 */
	STUB
	boolean
	uchar *mac_addr
END

DEFINE	encaps_show_protocol_attr
/*
 * Summary: Show a protocol-specific attribute.
 * Input: Switched on encapsulation type.
 *	IDB of interest.
 * Returns: NULL.
 * Comments:  Useful when the "show interface" command is called.
 */
	CASE
	void
	idbtype *swidb
	ET_MAX
	int enctype
END

DEFINE	encaps_set_protocol_attr
/*
 * Summary:  Set a protocol-specific attribute.
 * Input:  Switched on encapsulation type.
 *	IDB of interest.
 * Returns: NULL.
 */
	CASE
	void
	idbtype *swidb
	ET_MAX
	int enctype
END

DEFINE  idb_get_keep_default
/*
 * Summary: Determine whether an IDB has a default keepalive period.
 * Input: IDB of interest.
 *	Pointer to be filled in with the default keepalive period.
 * Returns: TRUE if default keepalive period is filled in.
 */
	LOOP
	boolean
	hwidbtype *hwidb, short *def_keep_period
END

DEFINE	emergency_message
/*
 * Summary: Display an emergency message, if necessary.
 * Input: Emergency message type.
 * Returns: NULL.
 * Comments: Called at system startup, in the output of the "show version"
 *	command, and in the "exec banner" and "banner incoming" commands.
 */
DATA
	typedef enum emergency_msg_time_type_ {
	    EMERGENCY_SYS_STARTUP,
	    EMERGENCY_SHOW_VERSION,
	    EMERGENCY_LINE_BANNER
	} emergency_msg_time_type;
END DATA
	LIST
	void
	emergency_msg_time_type emergency_msg_time
END

DEFINE  staticmap_nvgen
/*
 * Summary: Do NV generation for static maps.
 * Input: Switched on encapsulation type.
 *	Static map to NVGEN.
 * Returns: NULL.
 */
        CASE
        void
        staticmap_type *map
        ET_MAX
        int enctype
END

DEFINE  mapclass_nvgen
/*
 * Summary: Do NV generation for static map classes.
 * Input: Switched on encapsulation type.
 *	Map class of interest.
 * Returns: NULL.
 */
        CASE
        void
        mapclass_type *class
        ET_MAX
        int enctype
END

DEFINE  mapclass_remove
/*
 * Summary: Inform subsystems when a map class is deleted.
 * Input: Class that is being deleted.
 * Returns: NULL.
 */
        LIST
        void
        mapclass_type *class

END

DEFINE  is_map_broadcast
/*
 * Summary: Determine whether a static map is defined as broadcast.
 * Input: Switched on encapsulation type.
 *	Map we wish to know about.
 * Returns: TRUE if map is defined as broadcast.
 */
        RETVAL
        boolean
        staticmap_type *map
        ET_MAX
        int enctype

END

DEFINE  ext_staticmap_delete
/*
 * Summary:  Inform subsystems that a static map is being deleted.
 * Input: Map that is being deleted.
 * Returns: NULL.
 * Comments: This service is invoked by generic static-map code when 
 *	deleting a static map, and informs any provider of service (such as ATM 
 *	signalling) that a map is being deleted. This service is intended to 
 *	allow freeing of memory in the structures not directly specified by 
 *	staticmap_type, any other action not common to all maps. The map 
 *	itself and its directly attached structures are freed in common 
 *	static map code. The provider of service is responsible for 
 *	determining that the map pertains to it. This service is called 
 *	before the static map is unlinked.
 */
        LIST
        void
        staticmap_type *map
END

DEFINE  ext_mapgroup_delete
/*
 * Summary: Inform subsystems that a map group is being deleted from
 *	and interface.
 * Input: IDB of interest.
 *	Map group of interest.
 * Returns: NULL.
 * Comments: Invoked by generic static-map code, just before group is unlinked.
 */
        LIST
        void
        idbtype *idb, maplist_type *list_ptr
END

DEFINE  ext_staticmap_update
/*
 * Summary: Inform subsystems that a static map is being updated.
 * Input:  List of maps.
 *	Map of interest.
 *	Pointer to hardware configuration.
 *	Name of map.
 * Returns: NULL.
 * Comments: This allows for the update of data structures not directly 
 *	specified by staticmap_type, any other action not common to all maps. 
 */
        LIST
        void
        maplist_type *list_ptr, staticmap_type *map_ptr,\
	hwaddrtype *hwconf_ptr, char *name 
END

DEFINE	line_init
/*
 * Summary: Initialize line driver code.
 * Input: NULL.
 * Returns: NULL.
 * Comments: Called from line_init().
 */
	LIST
	void
	-
END

DEFINE        monvar_get
/*
 * Summary: Get the ROM monitor variable specified by MONVAR_TYPE.
 * Input: Switched on MONVAR_TYPE.
 * Returns: Pointer to variable value.
 */
DATA
END DATA
      RETVAL
      char *
      -
      0
      int vartype
END

DEFINE        monvar_set
/*
 * Summary: Set the ROM monitor variable specified by MONVAR_TYPE.
 * Input: Switched on MONVAR_TYPE
 *	Boolean that is TRUE if services should print error messages.
 * Returns: Bytes left for Monitor variables.
 */
DATA
END DATA
      RETVAL
      int
      boolean vocal
      0
      int vartype
END

DEFINE        monvar_open
/*
 * Summary: Initialize the ROM monitor variable specified by MONVAR_TYPE.
 * Input: Switched on MONVAR_TYPE.
 * Returns: NULL.
 */
DATA
END DATA
      RETVAL
      void
      -
      0
      int vartype
END

DEFINE        monvar_add
/*
 * Summary: Adds a value to the ROM monitor variable specified by MONVAR_TYPE.
 * Input: Value to add.
 * Returns: NULL.
 */
DATA
END DATA
      RETVAL
      void
      char *val
      0
      int vartype
END

DEFINE        monvar_buff
/*
 * Summary: Get buffer for the ROM monitor variable specified by MONVAR_TYPE.
 * Input: Switched on MONVAR_TYPE.
 * Returns: Buffer for ROM monitor variable.
 */
DATA
END DATA
      RETVAL
      char *
      -
      0
      int vartype
END

DEFINE        config_register_read
/*
 * Summary: Read configuration register for platform.
 * Input: Index is not used.
 * Returns: Configuration register.
 * Comments: This should be a stub. On the other hand, no one calls it.
 */

      RETVAL
      ushort
      -
      0
      int dummy
END

DEFINE master_slave_set
/*
 * Summary: Setu p hardware/ROM registers on both master and slave.
 * Input: Boolean that is TRUE if errors should be printed.
 * Returns: NULL.
 * Comments: This is used to allow the freshly written configuration to take 
 *	effect on the next boot.
 */
        STUB
        void
        boolean vocal
END

DEFINE        analyze_interface
/*
 * Summary: Analyze the interface for the given index ID and slot.
 * Input: Switched on interface type.
 *	Slot number.
 * Returns: NULL.
 */
      CASE
      void
      int slot
      0
      int type
END

DEFINE		subsys_init_class
/*
 * Summary: Initialize subsystem class.
 * Input: Subsystem class.
 * Returns: NULL.
 */
	LIST
	void
	ushort class
END

DEFINE		hostname_changed
/*
 * Summary:  Inform subsystems that the routers hostname has changed.
 * Input: Boolean that is TRUE if the name has been changed to a nondefault one.
 * Returns: NULL.
 */
	LIST
	void
	boolean non_default
END

DEFINE	if_statechange_complete 
/*
 * Summary:  Inform subsystems when an interface state change is completed.
 * Input: Either a software IDB or a hardware IDB, with the other being NULL.
 * Returns: NULL.
 */
	LIST
	void
	idbtype *swidb, hwidbtype *hwidb
END

DEFINE  slarp_extended_type
/*
 * Summary: Process SLARP special request.
 * Input: Switched on SLARP code. 
 *	Packet of interest.
 * Returns: TRUE if the packet was handled.
 */
        RETVAL
        boolean
        paktype *pak
        0
        long code
END

DEFINE	show_int
/*
 * Summary: Show information about an interface.
 * Input: IDB of interest.
 * Returns: NULL.
 * Comments:  Invoked in network.c:show_idb().
 */
	LIST
	void
	hwidbtype *hwidb
END

DEFINE is_config_dirty
/*
 * Summary: Determine whether the configuration has been modified but not saved.
 * Input: NULL.
 * Returns: TRUE if users has modified the configuration but not saved it.
 */
	STUB
	boolean
	-
END

DEFINE        analyze_mcn_port_adaptor
/*
 * Summary: Analyze an MCN port adaptor.
 * Input: Switched on MCN type.
 *	Slot number.
 *	Sub-controller number.
 *	Total controllers on the unit.
 * Returns: NULL.
 */
      CASE
      void
      int slot, int subcont, int total_ctrlr_unit
      0
      uint type
END

DEFINE        csm_interface_init
/*
 * Summary: Initial call-switching module interface structures.
 * Input: Switch by CSM type.
 *	Slot of module.
 *	Type-specific parameters.
 * Returns: NULL.
 */
      CASE
      void
      int slot, int para1, int para2
      0
      uint type
END

DEFINE	test_specific_interface 
/*
 * Summary: Test an interface to see whether the hardware is functional.
 * Input: Switched on IDB type.
 *	IDB to test.
 *	Pointer to be filled with number of tests failed.
 *	Pointer to be filled with number of tests passed.
 *	Pointer to be filled with number of tests skipped.
 * Returns: NULL.
 */
	CASE
	void
	hwidbtype *idb, int *fail, int *pass, int *skip
	0
	int type
END

DEFINE	test_interfaces_setup 
/*
 * Summary: Prepare an interface for testing.
 * Input: Switched by IDB type.
 *	IDB of interest.
 * Returns: -1 if preparation failed.
 * Comments: This is required before testing.
 */
	RETVAL
	char
	hwidbtype *idb
	0
	int type
END

DEFINE parse_cli_cmd
/*
 * Summary: Parse a command.
 * Input: Switched on parser type.
 * Returns: Error code or 0 if none.
 */
	RETVAL
	int
	parseinfo *csb
	0
	int parse_cli_type
END

DEFINE parse_cli_quit
/*
 * Summary: Tell parser subsystem that the "exit" command has been entered.
 * Input: NULL.
 * Returns: NULL.
 * Comments: Called before "exit" command to free alternate CLI structures.
 */
	LIST
	void
	-
END

DEFINE parse_cli_prompt
/*
 * Summary: Change the prompt depending on parser.
 * Input: Switched on parser type.
 *	Parseinfo structure.
 *	Pointer to string to be filled with new prompt.
 *	Pointer to be filled in with length of new prompt.
 * Returns: Adjustment of length before and after.
 */
	RETVAL
	int
	parseinfo *csb, char *dst, int *prompt_length
	0
	int parser_cli_type
END

DEFINE async_protocol_mode
/*
 * Summary: Invoke the required protocol mode for the async interface.
 * Input: TTY attached to interface.
 *	Address to use when starting protocol.
 * Returns: TRUE if successful.
 * Comments: Currently SLIP/PPP are the intended users.
 */
	STUB
	boolean
	tt_soc *tty, addrtype *proto_addr

END

DEFINE	system_configured
/*
 * Summary: Inform subsystems that we are done parsing the configuration.
 * Input: NULL.
 * Returns: NULL.
 * Comments: This service is a collection of routines to call after 
 *	configuration is parsed
 */
	LIST
	void
	-
END

DEFINE print_network_header
/*
 * Summary: Print the network-layer header.
 * Input: Switched by link type.
 *	Packet to get header from.
 *	Pointer to be filled with header information.
 * Returns: NULL.
 */

       CASE
       void
       paktype *pak, ushort **data_ptr
       LINK_MAXLINKTYPE
       int linktype

END

DEFINE 	extract_l3pid_value
/*
 * Summary: Extract the Level 3 PID from a packet.
 * Input: Packet of interest.
 * Returns: Level 3 PID.
 * Comments: Used for  LLC2 over Frame Relay. 
 */
	STUB
	uchar
	paktype *pak
END

DEFINE  mac_address_change
/*
 * Summary: Inform subsystems that a MAC address has changed.
 * Input: IDB on which the address changed.
 * Returns: NULL.
 */
        LIST
        void
        hwidbtype *hwidb
END

DEFINE mci_expl_vectors
/*
 * Summary: Set up the ciscoBus fast explorer vector.
 * Input: IDB of interest.
 * Returns: NULL.
 */
    STUB
    void
    hwidbtype* idb
END

DEFINE les_expl_vectors
/*
 * Summary: Set up the LES fast explorer vector.
 * Input: IDB of interest.
 * Returns: NULL.
 */
    STUB
    void
    hwidbtype* idb
END

DEFINE if_pcbus_with_tr
/*
 * Summary: Called to see we are a FIJI that has a Token Ring interface
 * Input: NULL.
 * Returns: TRUE if we are a FIJI with a Token Ring interface.
 */
	LOOP
	boolean
        -
END

DEFINE if_pcbus_down
/*
 * Summary: Inform subsystems that the PCBus interface went down.
 * Input: IDB of interest.
 * Returns: NULL.
 * Comments: Called by the driver.
 */
        LIST
        void
        hwidbtype *hwidb
END

DEFINE  print_copyright
/*
 * Summary: Print the various copyrights.
 * Input: NULL.
 * Returns: NULL.
 * Comments: Called in Print_Hardware().
 */
        LIST
        void
        -
END

DEFINE  print_features
/*
 * Summary: Print the various enabled features.
 * Input: NULL.
 * Returns: NULL.
 * Comments: Called in Print_Hardware().
 */
        LIST
        void
        -
END

DEFINE  print_controllers
/*
 * Summary: Print platform-specific controllers.
 * Input: NULL.
 * Returns: NULL.
 * Comments: Called in Print_Hardware().
 *
 */
        LIST
        void
        -
END

DEFINE  print_memory
/*
 * Summary: Print platform-specific memory.
 * Input: NULL.
 * Returns: NULL.
 * Comments: Called in Print_Hardware().
 *
 */
        LIST
        void
        -
END

DEFINE	config_changed
/*
 * Summary: Inform subsystems that a configuration command has been entered.
 * Input: Parseinfo structure.
 * Returns: NULL.
 * Comments:  Primarily used by subsystems that to track interface
 *	configuration commands.
 */
    LIST
    void
    parseinfo *csb
END

DEFINE	parser_preparse_filtered
/*
 * Summary: Check command line before starting the parse.
 * Input: Parseinfo structure.
 * Returns: TRUE if command is disallowed.
 * Comments: Used by CiscoPro to filter out disallowed commands.
 */
	STUB
	boolean
	parseinfo *csb
END

DEFINE	parser_short_help_filtered
/*
 * Summary: Check command line before saving short help.
 * Input: Parseinfo structure.
 *	Help string.
 * Returns: TRUE if command is disallowed.
 * Comments: Used by CiscoPro to filter out disallowed commands.
 */
	STUB
	boolean
	parseinfo *csb, const char *help
END

DEFINE	parser_long_help_filtered
/*
 * Summary: Check command line before saving long help.
 * Input: Parseinfo structure.
 *	Help string.
 * Returns: TRUE if command is disallowed.
 * Comments: Used by CiscoPro to filter out disallowed commands.
 */
	STUB
	boolean
	parseinfo *csb, const char *help
END

DEFINE pci_device_init
/*
 * Summary: Configure a PCI device on a PCI bus.
 * Input: Switched on device vendor ID.
 *	Context (slot number).
 *	Device number.
 * Returns: TRUE if device as successfully configured.
 */

       RETVAL
       boolean
       uint context, uint device_no
       0
       uint device_vendor_id
END

DEFINE pci_bridge_init
/*
 * Summary: NOT USED.
 * Input: NULL.
 * Returns: NULL.
 */
        CASE
       void
       uint pa_bay
       0
       uint device_vendor_id
END

DEFINE check_memory_region
/*
 * Summary: Check the integrity of blocks of platform-specific memory that 
 *	are not normal heaps.
 * Input: NULL.
 * Returns: NULL.
 */
       LIST
       void
       -
END

DEFINE extra_vtylines
/* 
 * Summary: Notify subsystems that extra VTY lines have been created.
 * Input: New total number of lines on system.
 * Returns: NULL.
 * Comments: Used by protocol translation.
 */
        LIST
        void
        int maxlines
END

DEFINE	 abort_reload
/*
 * Summary: Query subsystems to find out whether a reload should be aborted.
 * Input: NULL.
 * Returns: TRUE if reload needs to be aborted.
 */
	LOOP
	boolean
	-
END

DEFINE	show_int_enhanced
/*
 * Summary: Displays additional interface information.
 * Input: NULL.
 * Returns: NULL.
 * Comments:  For example, on BRI interfaces, this service would inform the 
 * 	user whether there was an integrated NT1.  This is called from 
 *	Print_Hardware().
 */
	LIST
	void
	-
END

DEFINE stun_trap
/*
 * Summary: Generate peer state change trap for serial tunnel.
 * Input: STUN information.
 * Returns: NULL.
 */
        STUB
        void
        stunpeertype *stp
END

DEFINE send_ipc_eoir_signal
/*
 * Summary:  Send a message to IPC zone manager to reinitialize its IPC slaves.
 * Input: Controller slot.
 * Returns: NULL.
 */
        STUB
        void
        ulong slot_num
END

DEFINE ipc_reset_seq_nums
/*
 * Summary: Reset the sequence numbers expeected and last sent for this seat.
 * Input: Controller slot.
 * Returns: NULL.
 */
        STUB
        void
        ulong slot_num
END

DEFINE ipc_send_message_async
/*
 * Summary: Send an IPC message to a remote destination and return immediately.
 * Input: IPC message to send.
 *	Context for callback.
 *	Routine to call to indicate success/failure when finished.
 * Returns: IPC error code.
 */
        STUB
        ipc_error_code
		ipc_message *message, void *callback_context, ipc_callback routine
END

DEFINE ipc_send_message
/*
 * Summary: Send a message to a remote destination.
 * Input: IPC message to send.
 * Returns: IPC error code.
 */
        STUB
        ipc_error_code
		ipc_message *message
END

DEFINE ipc_send_pak_async
/*
 * Summary: Send a pak to a remote destination.
 * Input: Packet to send.
 *	IPC destination port.
 *	IPC message type.
 *	Context for callback.
 *	Routine to call to indicate success/failure when finished.
 * Returns: IPC error code.
 */
        STUB
        ipc_error_code
		paktype *pak, ipc_port_id dest_port, ipc_message_type type, \
			void *callback_context, ipc_callback routine
END

DEFINE ipc_send_opaque
/*
 * Summary: Send an opaque message to a remote destination.
 * Input: Pointer to message to send.
 *	Size of message.
 *	IPC destination port.
 *	IPC message type.
 * Returns: IPC error code.
 */
        STUB
        ipc_error_code
		void *message_data, ipc_size message_size, ipc_port_id dest_port, \
			ipc_message_type type
END

DEFINE ipc_send_opaque_async
/*
 * Summary: Send an opaque IPC message to a remote destination and 
 *	return immediately.
 * Input: Pointer to message to send.
 *	Size of message.
 *	IPC destination port.
 *	IPC message type.
 *	Context for callback.
 *	Routine to call to indicate success/failure when finished.
 * Returns: IPC error code.
 */
        STUB
        ipc_error_code
		void *message_data, ipc_size message_size, ipc_port_id dest_port, \
			ipc_message_type type, void *callback_context, ipc_callback routine
END

DEFINE ipc_send_rpc
/*
 * Summary: Send a remote procedure call message and block until a reply.
 * Input: IPC message containing remote procedure call.
 *	Pointer to be filled in with the IPC error code.
 * Returns: IPC reply message.
 */
        STUB
        ipc_message *
		ipc_message *message, ipc_error_code *error
END

DEFINE ipc_send_rpc_reply_async
/*
 * Summary: Reply to a remote procedure call and return immedately.
 * Input: Original IPC message.
 * 	Reply IPC message.
 *	Context for callback.
 *	Routine to call to indicate success/failure when finished.
 * Returns: IPC error code.
 */
        STUB
        ipc_error_code
		ipc_message *original_message, ipc_message *reply_message, \
			void *callback_context, ipc_callback routine
END

DEFINE ipc_send_rpc_reply
/*
 * Summary: Reply to a remote procedure call and block until the reply 
 *	arrives at the original caller.
 * Input: Original IPC message.
 * 	Reply IPC message.
 * Returns: IPC error code.
 */
        STUB
        ipc_error_code
		ipc_message *original_message, ipc_message *reply_message
END

DEFINE ipc_locate_port
/*
 * Summary: Find a port's ID by name.
 * Input: Name of IPC port.
 * Returns: IPC port ID.
 */
        STUB
        ipc_port_id
		char *name
END

DEFINE ipc_create_named_port
/*
 * Summary: Create a port in the local namespace.
 * Input: Name of port to create.
 *	Pointer to be filled in with assigned port.
 *	IPC flags describing port to be created.
 * Returns: IPC error code.
 */
        STUB
        ipc_error_code
		char *name, ipc_port_id *port, ushort flags
END

DEFINE ipc_register_port
/*
 * Summary: Register a port with the IPC master server.
 * Input: Port to register.
 * Returns: IPC error code.
 */
        STUB
        ipc_error_code
		ipc_port_id port
END

DEFINE ipc_close_port
/*
 * Summary: Close an IPC port.
 * Input: Port to close.
 * Returns: IPC error code.
 */
        STUB
        ipc_error_code
		ipc_port_id port
END

DEFINE ipc_set_receive_callback
/*
 * Summary: Set the routine called when processing queued received messages.
 * Input: IPC port of interest.
 *	Context for callback.
 *	Routine to call.
 * Returns: IPC error code.
 */
        STUB
        ipc_error_code
		ipc_port_id port, void *callback_context, ipc_callback callback_routine
END

DEFINE ipc_set_receive_fast_callback
/*
 * Summary: Set the routine called immediately when port receives a message.
 * Input: IPC port of interest.
 *	Context for callback.
 *	Routine to call.
 * Returns: IPC error code.
 */
        STUB
        ipc_error_code
		ipc_port_id port, void *callback_context, ipc_callback callback_routine
END

DEFINE ipc_get_message
/*
 * Summary: Get an IPC message element.
 * Input: Requested size of message.
 *	Requested destination port of message.
 *	Requested type of message.
 * Returns: New IPC message, or NULL.
 */
        STUB
        ipc_message *
		ipc_size size, ipc_port_id dest_port, ipc_message_type type
END

DEFINE ipc_return_message
/*
 * Summary: Return an IPC message to the free pool.
 * Input: IPC message to return.
 * Returns: NULL.
 */
        STUB
        void
		ipc_message *message
END

DEFINE ipc_set_rpc_timeout
/*
 * Summary: Set the timeout for an IPC Remote Procedure Call.
 * Input: Message to set timeout in.
 *	Number of seconds to set timeout to.
 * Returns: NULL.
 */
        STUB
        void
		ipc_message *message, int seconds
END

DEFINE print_slave_info
/*
 * Summary: Print version and hardware information about the 
 *	slave processor on dual-processor systems.
 * Input: NULL.
 * Returns: NULL.
 */
        STUB
        void
        -
END

DEFINE slave_stack_whyreload
/*
 * Summary: Print any stack crash details stored on the slave.
 * Input: NULL.
 * Returns: NULL.
 */
        STUB
        void
        -
END

DEFINE	open_slave_config
/*
 * Summary: Open configuration file on slave.
 * Input: Force the opening, even if the user is against it.
 * Returns: TRUE if the configuration file could be opened.
 */
	STUB
	boolean
	boolean force
END

DEFINE	close_slave_config
/*
 * Summary: Close configuration file on slave.
 * Input: NULL.
 * Returns: TRUE if close was successful.
 */
	STUB
	boolean
	-
END

DEFINE	write_slave_config
/*
 * Summary: Write a buffer to a configuration file on the slave.
 * Input: Buffer containing information to write.
 *	Size of buffer.
 * Returns: TRUE if write was successful.
 */
	STUB
	boolean
	char *buf, int size
END

DEFINE	sync_slave_config
/*
 * Summary: Synchronize configuration between master and slave.
 * Input: Boolean that is TRUE if the configuration should be forced.
 *	Pointer to buffer containing configuration text.
 *	Length of buffer.
 * Returns: NULL.
 */
	STUB
	void
	boolean force, char *buf, int size
END

DEFINE	sync_slave_private_config
/*
 * Summary: Synchronize private configuration between master and slave.
 * Input: Boolean that is TRUE if the configuration should be forced.
 *	Pointer to buffer containing configuration text.
 *	Length of buffer.
 * Returns: NULL.
 */
	STUB
	void
	boolean force, char *buf, int size
END

DEFINE	set_slave_monvar
/*
 * Summary: Set monvar values on the slave.
 * Input: Pointer to buffer containing new monvar values.
 * Returns: NULL.
 * Comments: Called if auto-sync is enabled.
 */
	STUB
	void
	char *buf, boolean vocal
END

DEFINE show_slave_boot
/*
 * Summary: Print "show boot" command information about the slave processor
 * 	on dual-processor systems.
 * Input: NULL.
 * Returns: NULL.
 */
        STUB
        void
        -
END

DEFINE	write_slave_calendar
/*
 * Summary: Issue a write_calendar() call on the slave.
 * Input: Structure containing calendar information.
 * Returns: NULL.
 * Comments: Ignores auto-sync mode.
 */
	STUB
	void
	calendar_t *cal
END

DEFINE  serial_physical_layer
/*
 * This is a LOOP registry that will be used to set the physical layer
 * on serial interfaces capable of supporting both sync and async
 * protocols to the requested one.  Note that csb->interface may change
 * if this is handled by swapping idb data structures.
 * Input:
 *	IDB of interest.
 *	Parseinfo structure.
 *	Desired physical mode
 * Returns: TRUE if the interface laying was successfully changed.
 * 
 */
	LOOP
	boolean
	hwidbtype *idb, parseinfo *csb, int layertype
END

DEFINE invalid_line_specified
/*
 * Summary: Determine whether the line specified in the line command is 
 *	invalid. 
 * Input: Line number.
 *	Boolean that is TRUE if functions should print failure reasons.
 * Returns: TRUE if the line is invalid.
 * Comments: A line specification is invalid if the corresponding
 * 	interface is not in the async mode. This applies only to those serial
 * 	interfaces that are capable of supporting bit sync and async modes.
 */
	LOOP
	boolean
	int line, boolean verbose
END

DEFINE async_int_base_unit
/*
 * Summary: Get the base unit number for the asynchronous interfaces.
 * Input: NULL.
 * Returns: Base unit number for asynchronous interfaces.
 */
	STUB
	int
	-
END

DEFINE if_group_first_member
/*
 * Summary: Get the first member from a group interface.
 * Input: Switched on IDB type
 *	IDB of group interface.
 *	Pointer to be filled in with first member.
 * Returns: NULL.
 */
	CASE
	void
	idbtype *idb, hwidbtype **first_member
	0
	int idb_type
END

DEFINE key_get_live_keys
/*
 * Summary: Get list of live keys.
 * Input: Name of key chain.
 *	Time that the keys should be live for (NULL means now).
 *	Pointer to be filled in with list of keys.
 *	Number of keys requested.
 *	Type of keys requested.
 * Returns: Number of keys returned.
 */
	STUB
	int
	char *name, void *when, char **textptrs, int num, int type
END

DEFINE key_free_keys
/*
 * Summary: Free keys returned by key_get_live_keys.
 * Input: Pointer to list of keys.
 *	Number of keys in list.
 * Returns: NULL.
 */
	STUB
	void
	char **textptrs, int num
END

DEFINE key_get_next_live_key
/*
 * Summary: Get next live key from list.
 * Input: Key chain to search.
 *	Pointer to ID of current key, to be filled in with new ID.
 *	Time key should be live for (NULL means now).
 *	Type of key.
 *	Area to store key in.
 *	Maximum size of storage.
 * Returns: Pointer to storage, or NULL.
 */
	STUB
	char *
	char *name, int *id, void *when, int type, char *storage, int size
END

DEFINE key_get_key_id
/*
 * Summary: Find the ID of a key, given the key chain and key text.
 * Input: Key chain.
 *	Key text.
 * Returns: Key ID.
 */
	STUB
	int
	char *chain_name, char *key_text
END

DEFINE key_text
/*
 * Summary: Find the text of a key, given a key chain and key ID.
 * Input: Key chain.
 *	Key ID.
 *	Pointer to be filled in with key text.
 * Returns: Pointer to key text, or NULL.
 */
	STUB
        char *
        char *name, int id, char **textptr
END

DEFINE key_text_free
/*
 * Summary: Free key text.
 * Input: Pointer to pointer to text to be freed.
 * Returns: NULL.
 */
        STUB
        void
        char **textptr
END

DEFINE key_alive_now
/*
 * Summary: Check whether the given key is alive now.
 * Input: Name of key.
 *	ID number of key.
 *	key_lifetime_type of key.
 * Returns: TRUE if the key is currently alive.
 */
	STUB
        boolean
        char *name, int id, int type
END

DEFINE match_group_name
/*
 * Summary: Parser match check for lat group name.
 * Input: Pointer to string passed from the parser.
 *	Pointer to be filled with index of the last byte of buffer.
 *	Array to be filled with group information.
 *	Pointer to actual group name.
 * Returns: TRUE if group was found.
 */
	STUB
	boolean
	char *buf, int *i, char *num, char* name
END

DEFINE	interface_command_ok
/*
 * Summary: Discover whether a command is valid for given interface type.
 * Input: Switched on IDB type.
 * Returns: TRUE if command is valid.
 */
	RETVAL
	boolean
	parseinfo *csb
	0
	int idbtype_val
END


DEFINE  process_death
/*
 * Summary: Inform subsystems that a process is dying.
 * Input: PID of dying process.
 * Returns: NULL.
 * Comments:  Used by async.c to clean up any attached TTY.
 */
	LIST
	void
	pid_t pid
END


DEFINE  flush_logging
/*
 * Summary: Push out logging information before a core dump.
 * Input: NULL.
 * Returns: NULL.
 * Comments: Called by GDB immediately before it tries to write a core file.
 */
	LIST
	void
	-
END

DEFINE fs_low_mem
/*
 * Summary: Check whether we are running low on memory.
 * Input: NULL.
 * Returns: TRUE if we are running low on memory.
 * Comments: Called by the IP fast-switching code.
 */
	LOOP
	boolean
	-
END

DEFINE slave_test
/*
 * Summary: Check whether the current processor is a slave.
 * Input: NULL.
 * Returns: TRUE if processor is a slave.
 * Comments: Used to form different parse chain for slave image.
 */
	STUB
	boolean
	-
END

DEFINE	show_techsupport
/*
 * Summary: Display technical support inforamtion.
 * Input: Parseinfo structure.
 * Returns: NULL.
 * Comments: Called for the "show techsupport" command.
 */
	LIST
	void
	parseinfo *csb
END

DEFINE	show_techsupport_protocol
/*
 * Summary: Show protocol-specific technical support information.
 * Input: Switched on protocol type.
 *	Parseinfo structure.
 * Returns: NULL.
 */
	CASE
	void
	parseinfo *csb
	0
	int index
END

DEFINE translate_before_routing
/*
 * Summary: Perform translation of packet header before routing has occurred.
 * Input: Switched on link type.
 *	Packet of interest.
 *	Pointer to boolean that should be set to TRUE packet should be dropped.
 * Returns: Translated packet.
 */
	RETVAL
	paktype *
	paktype *pak, boolean *drop
	0
	int linktype
END

DEFINE translate_after_routing
/*
 * Summary: Perform translation of packet header after routing has occurred.
 * Input: Switched on link type.
 *	Packet of interest.
 *	Pointer to boolean that should be set to TRUE packet should be dropped.
 * Returns: Translated packet.
 */
	RETVAL
	paktype *
	paktype *pak, boolean *drop
	0
	int linktype
END

DEFINE queue_reset
/*
 * Summary: Reset a holdq.
 * Input: List number.
 * Returns: NULL.
 */
        LIST
        void
        int list_no
END

DEFINE rsvp_fixup_wfq
/*
 * Summary: Inform subsystems that queueing system configuration has changed.
 * Input: IDB of interest.
 * Returns: NULL.
 */
        LIST
        void
        hwidbtype *hwidb
END

DEFINE set_protocol_encaps
/*
 * Summary: Set encapsulation for IDB.
 * Input: Switched on link type.
 *	IDB of interest.
 *	New encapsulation type.
 * Returns: NULL.
 */
	CASE
	void
	idbtype *idb, int encaps
	0
	int linktype
END

DEFINE shape_cache
/*
 * Summary: Inform subsystems when configuration of traffic shaping changes.
 * Input: IDB of interest.
 * Returns: NULL.
 * Comments: Currently used to allow 7000 and RSP to turn off 
 *	unsupported modes.
 */
        LIST
        void
        hwidbtype *hwidb
END

DEFINE  generic_shaping_becn_received
/*
 * Summary: Indicate to traffic shaping that a BECN has been received.
 * Input: IDB of interest.
 * Returns: NULL.
 */
        STUB
        void
        idbtype *idb, fr_pvc_info_type *fr_pvc
END
 
DEFINE  generic_shaping_fecn_received
/*
 * Summary: Indicate to traffic shaping that a FECN has been received.
 * Input: IDB it was received on.
 *	Q.922 Header.
 * Returns: TRUE if a test response containing a BECN is generated.
 */
        STUB
        boolean
        idbtype *idb, ushort q922_header
END

DEFINE	cdp_reset
/*
 * Summary: Set cdp_enabled to the default value.
 * Input: IDBs of interest.
 * Returns: NULL.
 * Comments:  Called whenever a new IDB is created or encapsulation changed.
 */
	STUB
	void
	hwidbtype *hwidb, idbtype *swidb
END

DEFINE priority_list_changed
/*
 * Priority list changed
 */
        LIST
        void
        ulong priority_list_number, uchar linktype, boolean pri_list_csb_sense
END

END REGISTRY SYS
