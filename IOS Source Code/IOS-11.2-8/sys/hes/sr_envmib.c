/* $Id: sr_envmib.c,v 3.9.20.2 1996/07/03 20:41:39 thille Exp $
 * $Source: /release/112/cvs/Xsys/hes/sr_envmib.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * October 1994, Sandra Durham (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1995-1997 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_envmib.c,v $
 * Revision 3.9.20.2  1996/07/03  20:41:39  thille
 * CSCdi61860: Implement Jeffs glass of slim-fast for snmp
 * Branch: California_branch
 * Take hunk of common code from many mib files, make it a procedure in
 * snmp_util.c and call it from the mibs.  Save 1640 bytes.
 *
 * Revision 3.9.20.1  1996/04/19  17:58:16  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.9  1996/02/02  02:55:03  jjohnson
 * CSCdi47892:  SNMP oid translation table needs to be modularized
 * modularize the envmon and ds1 mib translation tables
 *
 * Revision 3.8  1996/01/24  22:03:02  anke
 * CSCdi47169:  Remove snmp from mibs as a required subsystem
 *
 * Revision 3.7  1996/01/22  01:59:27  sdurham
 * CSCdi47252:  Envmon traps enabled on any use of snmp-server enable trap
 * command
 *         need to check the subsys before checking trap-type
 *
 * Revision 3.6  1996/01/18  15:45:43  anke
 * CSCdi46969:  Change empty req and/or seq strings in SUBSYS_HEADERs to
 *              NULL
 *              Five bytes saved is five bytes earned
 *
 * Revision 3.5  1995/12/14  08:24:01  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.4  1995/12/01  19:03:39  sdurham
 * CSCdi44362:  envmon is non-modular w.r.t envmon mib.
 *   Remove direct calls from envmon code to mib code. Use service points.
 *
 * Revision 3.3  1995/11/22  23:41:59  sdurham
 * CSCdi35282:  Need command to configure envmon trap enables
 *      add individual trap options in separate parser-mib file
 *      envmon_mib_chain.
 *
 * Revision 3.2  1995/11/17  09:20:09  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  11:42:18  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.3  1995/06/28  21:16:51  sdurham
 * CSCdi36261:  CISCO-ENVMON-MIB and OLD-CISCO-ENV-MIB being loaded on ags
 *              improperly.
 *
 * Revision 2.2  1995/06/28  09:24:53  smackie
 * Repair widespread subsystem header braindamage. (CSCdi23568)
 *
 *   o Fix subsystem entry points to be foo(subsystype *) not foo(void)
 *   o Repair nonsensical and redundant subsystem sequences
 *   o Use NULL where no property is required
 *
 * Revision 2.1  1995/06/07  20:43:59  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1995 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include "config.h"
#include "subsys.h"
#include "../snmp/snmp_api.h"
#include "sr_envmib.h"
#include "sr_envmib-mib.h"
#include "../snmp/snmp_registry.h"
#include "../parser/parser_defs_snmp.h"
#include "../hes/env_api.h"
#include "../hes/envmib_registry.h"

ciscoEnvMonMIBNotificationEnables_t envmon_globalsData;

static const char env_shutdown_trap_oid[] = "ciscoEnvMonMIBNotifications.1";
static const char env_voltage_trap_oid[] = "ciscoEnvMonMIBNotifications.2";
static const char env_temperature_trap_oid[] = "ciscoEnvMonMIBNotifications.3";
static const char env_fan_trap_oid[] = "ciscoEnvMonMIBNotifications.4";
static const char env_redundantSupply_trap_oid[] = 
                                               "ciscoEnvMonMIBNotifications.5";
    

static void env_trap_cfg_set( boolean enable, uint subsys, uint traps);
static void env_trap_cfg_nvwrt(parseinfo *csb);
static void envmib_shutdown_trap(void);
static void envmib_voltage_trap(int);
static void envmib_temperature_trap(int);

void
init_envmib (subsystype * subsys)
{

    if (envmib_load != TRUE) 
	return;

    /*
     * default value is to disable Notifications
     */
    envmon_globalsData.ciscoEnvMonEnableShutdownNotification = 
	D_ciscoEnvMonEnableShutdownNotification_false;

    envmon_globalsData.ciscoEnvMonEnableVoltageNotification =
	D_ciscoEnvMonEnableVoltageNotification_false;

    envmon_globalsData.ciscoEnvMonEnableTemperatureNotification = 
	D_ciscoEnvMonEnableTemperatureNotification_false;

    envmon_globalsData.ciscoEnvMonEnableFanNotification = 
	D_ciscoEnvMonEnableFanNotification_false;

    
    envmon_globalsData.ciscoEnvMonEnableRedundantSupplyNotification = 
	D_ciscoEnvMonEnableRedundantSupplyNotification_false;


    load_mib(envmib_OidList, envmib_OidListNum);
    load_oid(envmib_oid_table);


    /*
     * register the envmon Notifications
     */
    register_snmp_trap(TRAP_ENVMON, env_shutdown_trap_oid);
    register_snmp_trap(TRAP_ENVMON, env_voltage_trap_oid);
    register_snmp_trap(TRAP_ENVMON, env_temperature_trap_oid);
    register_snmp_trap(TRAP_ENVMON, env_fan_trap_oid);
    register_snmp_trap(TRAP_ENVMON, env_redundantSupply_trap_oid);

    reg_add_Trap_cfg_set(env_trap_cfg_set, "env_trap_cfg_set");
    reg_add_Trap_cfg_nvwrt(env_trap_cfg_nvwrt, "env_trap_cfg_nvwrt");
    
    reg_add_envmib_shutdown_trap(envmib_shutdown_trap,"envmib_shutdown_trap");
    reg_add_envmib_temperature_trap(envmib_temperature_trap,
				    "envmib_temperature_trap");
    reg_add_envmib_voltage_trap(envmib_voltage_trap,"envmib_voltage_trap");

    /*
     * need to see if other init required based on ags or 7000/rsp
     * platform.
     */
    envmib_platform_specific_init();

    envmon_mib_parser_init();




}









/*---------------------------------------------------------------------
 * Retrieve data from the ciscoEnvMonObjects family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ciscoEnvMonObjects_get (
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             arg;
    void           *dp;
    ciscoEnvMonObjects_t *data = NULL;


    arg = snmp_scalar_instance(incoming, object, searchType);

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ciscoEnvMonObjects_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ciscoEnvMonPresent
      case I_ciscoEnvMonPresent:
	dp = &data->ciscoEnvMonPresent;
	break;
#endif				       /* I_ciscoEnvMonPresent */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the ciscoEnvMonVoltageStatusEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ciscoEnvMonVoltageStatusEntry_get (
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ciscoEnvMonVoltageStatusEntry_t *data = NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            ciscoEnvMonVoltageStatusIndex;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &ciscoEnvMonVoltageStatusIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ciscoEnvMonVoltageStatusEntry_get(serialNum, contextInfo, arg, searchType, ciscoEnvMonVoltageStatusIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->ciscoEnvMonVoltageStatusIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ciscoEnvMonVoltageStatusDescr
      case I_ciscoEnvMonVoltageStatusDescr:
	dp = MakeOctetString(data->ciscoEnvMonVoltageStatusDescr->octet_ptr, data->ciscoEnvMonVoltageStatusDescr->length);
	break;
#endif				       /* I_ciscoEnvMonVoltageStatusDescr */

#ifdef I_ciscoEnvMonVoltageStatusValue
      case I_ciscoEnvMonVoltageStatusValue:
	dp = &data->ciscoEnvMonVoltageStatusValue;
	break;
#endif				       /* I_ciscoEnvMonVoltageStatusValue */

#ifdef I_ciscoEnvMonVoltageThresholdLow
      case I_ciscoEnvMonVoltageThresholdLow:
	dp = &data->ciscoEnvMonVoltageThresholdLow;
	break;
#endif				       /* I_ciscoEnvMonVoltageThresholdLow */

#ifdef I_ciscoEnvMonVoltageThresholdHigh
      case I_ciscoEnvMonVoltageThresholdHigh:
	dp = &data->ciscoEnvMonVoltageThresholdHigh;
	break;
#endif				       /* I_ciscoEnvMonVoltageThresholdHigh */

#ifdef I_ciscoEnvMonVoltageLastShutdown
      case I_ciscoEnvMonVoltageLastShutdown:
	dp = &data->ciscoEnvMonVoltageLastShutdown;
	break;
#endif				       /* I_ciscoEnvMonVoltageLastShutdown */

#ifdef I_ciscoEnvMonVoltageState
      case I_ciscoEnvMonVoltageState:
	dp = &data->ciscoEnvMonVoltageState;
	break;
#endif				       /* I_ciscoEnvMonVoltageState */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the ciscoEnvMonTemperatureStatusEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ciscoEnvMonTemperatureStatusEntry_get (
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ciscoEnvMonTemperatureStatusEntry_t *data=NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            ciscoEnvMonTemperatureStatusIndex;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &ciscoEnvMonTemperatureStatusIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ciscoEnvMonTemperatureStatusEntry_get(serialNum, contextInfo, arg, searchType, ciscoEnvMonTemperatureStatusIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->ciscoEnvMonTemperatureStatusIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ciscoEnvMonTemperatureStatusDescr
      case I_ciscoEnvMonTemperatureStatusDescr:
	dp = MakeOctetString(data->ciscoEnvMonTemperatureStatusDescr->octet_ptr, data->ciscoEnvMonTemperatureStatusDescr->length);
	break;
#endif				       /* I_ciscoEnvMonTemperatureStatusDescr */

#ifdef I_ciscoEnvMonTemperatureStatusValue
      case I_ciscoEnvMonTemperatureStatusValue:
	dp = &data->ciscoEnvMonTemperatureStatusValue;
	break;
#endif				       /* I_ciscoEnvMonTemperatureStatusValue */

#ifdef I_ciscoEnvMonTemperatureThreshold
      case I_ciscoEnvMonTemperatureThreshold:
	dp = &data->ciscoEnvMonTemperatureThreshold;
	break;
#endif				       /* I_ciscoEnvMonTemperatureThreshold */

#ifdef I_ciscoEnvMonTemperatureLastShutdown
      case I_ciscoEnvMonTemperatureLastShutdown:
	dp = &data->ciscoEnvMonTemperatureLastShutdown;
	break;
#endif				       /* I_ciscoEnvMonTemperatureLastShutdown
				        *  */

#ifdef I_ciscoEnvMonTemperatureState
      case I_ciscoEnvMonTemperatureState:
	dp = &data->ciscoEnvMonTemperatureState;
	break;
#endif				       /* I_ciscoEnvMonTemperatureState */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the ciscoEnvMonFanStatusEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ciscoEnvMonFanStatusEntry_get (
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ciscoEnvMonFanStatusEntry_t *data = NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            ciscoEnvMonFanStatusIndex;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &ciscoEnvMonFanStatusIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ciscoEnvMonFanStatusEntry_get(serialNum, contextInfo, arg, searchType, ciscoEnvMonFanStatusIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->ciscoEnvMonFanStatusIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ciscoEnvMonFanStatusDescr
      case I_ciscoEnvMonFanStatusDescr:
	dp = MakeOctetString(data->ciscoEnvMonFanStatusDescr->octet_ptr, data->ciscoEnvMonFanStatusDescr->length);
	break;
#endif				       /* I_ciscoEnvMonFanStatusDescr */

#ifdef I_ciscoEnvMonFanState
      case I_ciscoEnvMonFanState:
	dp = &data->ciscoEnvMonFanState;
	break;
#endif				       /* I_ciscoEnvMonFanState */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the ciscoEnvMonSupplyStatusEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ciscoEnvMonSupplyStatusEntry_get (
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ciscoEnvMonSupplyStatusEntry_t *data = NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            ciscoEnvMonSupplyStatusIndex;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &ciscoEnvMonSupplyStatusIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ciscoEnvMonSupplyStatusEntry_get(serialNum, contextInfo, arg, searchType, ciscoEnvMonSupplyStatusIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->ciscoEnvMonSupplyStatusIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ciscoEnvMonSupplyStatusDescr
      case I_ciscoEnvMonSupplyStatusDescr:
	dp = MakeOctetString(data->ciscoEnvMonSupplyStatusDescr->octet_ptr, data->ciscoEnvMonSupplyStatusDescr->length);
	break;
#endif				       /* I_ciscoEnvMonSupplyStatusDescr */

#ifdef I_ciscoEnvMonSupplyState
      case I_ciscoEnvMonSupplyState:
	dp = &data->ciscoEnvMonSupplyState;
	break;
#endif				       /* I_ciscoEnvMonSupplyState */

#ifdef I_ciscoEnvMonSupplySource
      case I_ciscoEnvMonSupplySource:
	dp = &data->ciscoEnvMonSupplySource;
	break;
#endif				       /* I_ciscoEnvMonSupplySource */
      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}



/*---------------------------------------------------------------------
 * Retrieve data from the ciscoEnvMonMIBNotificationEnables family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ciscoEnvMonMIBNotificationEnables_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
    int             arg;
    void           *dp;
    ciscoEnvMonMIBNotificationEnables_t *data = NULL;


    arg = snmp_scalar_instance(incoming, object, searchType);

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ciscoEnvMonMIBNotificationEnables_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {
#ifdef I_ciscoEnvMonEnableShutdownNotification
      case I_ciscoEnvMonEnableShutdownNotification:
	dp = &data->ciscoEnvMonEnableShutdownNotification;
	break;
#endif				       /* I_ciscoEnvMonEnableShutdownNotification */

#ifdef I_ciscoEnvMonEnableVoltageNotification
      case I_ciscoEnvMonEnableVoltageNotification:
	dp = &data->ciscoEnvMonEnableVoltageNotification;
	break;
#endif				       /* I_ciscoEnvMonEnableVoltageNotification */

#ifdef I_ciscoEnvMonEnableTemperatureNotification
      case I_ciscoEnvMonEnableTemperatureNotification:
	dp = &data->ciscoEnvMonEnableTemperatureNotification;
	break;
#endif				       /* I_ciscoEnvMonEnableTemperatureNotification */

#ifdef I_ciscoEnvMonEnableFanNotification
      case I_ciscoEnvMonEnableFanNotification:
	dp = &data->ciscoEnvMonEnableFanNotification;
	break;
#endif				       /* I_ciscoEnvMonEnableFanNotification */

#ifdef I_ciscoEnvMonEnableRedundantSupplyNotification
      case I_ciscoEnvMonEnableRedundantSupplyNotification:
	dp = &data->ciscoEnvMonEnableRedundantSupplyNotification;
	break;
#endif			       /* I_ciscoEnvMonEnableRedundantSupplyNotification */


      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the ciscoEnvMonMIBNotificationEnables data object.
 *---------------------------------------------------------------------*/
void
ciscoEnvMonMIBNotificationEnables_free( ciscoEnvMonMIBNotificationEnables_t *data)

{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after ciscoEnvMonMIBNotificationEnables set/undo
 *---------------------------------------------------------------------*/
static int
ciscoEnvMonMIBNotificationEnables_cleanup(doList_t  *trash)
{
    ciscoEnvMonMIBNotificationEnables_free(trash->data);
#ifdef SR_SNMPv2
    ciscoEnvMonMIBNotificationEnables_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
ciscoEnvMonMIBNotificationEnables_test(incoming, object, value, doHead, doCur, contextInfo)
    OID            *incoming;
    ObjectInfo     *object;
    ObjectSyntax   *value;
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int             found;

    /*
     * Validate the object instance: 1) It must be of length 1  2) and the
     * instance must be 0.
     */
    if (instLength != 1 || incoming->oid_ptr[incoming->length - 1] != 0) {
	return (NO_CREATION_ERROR);
    }
    found = 0;

    if (!found) {
	dp = doCur;
	if ((dp->data = (void *)
	     malloc(sizeof(ciscoEnvMonMIBNotificationEnables_t))) 
	    == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(ciscoEnvMonMIBNotificationEnables_t));

	dp->setMethod = ciscoEnvMonMIBNotificationEnables_set;
	dp->cleanupMethod = ciscoEnvMonMIBNotificationEnables_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

    }
    switch (object->nominator) {

#ifdef I_ciscoEnvMonEnableShutdownNotification
      case I_ciscoEnvMonEnableShutdownNotification:
	if ((value->sl_value < D_ciscoEnvMonEnableShutdownNotification_true) ||
	    (value->sl_value > D_ciscoEnvMonEnableShutdownNotification_false))
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_ciscoEnvMonEnableShutdownNotification, 
		  ((ciscoEnvMonMIBNotificationEnables_t *) (dp->data))->valid);

	((ciscoEnvMonMIBNotificationEnables_t *)
	 (dp->data))->ciscoEnvMonEnableShutdownNotification = value->sl_value;
	break;
#endif				       /* I_ciscoEnvMonEnableShutdownNotification */

#ifdef I_ciscoEnvMonEnableVoltageNotification
      case I_ciscoEnvMonEnableVoltageNotification:
	if ((value->sl_value < D_ciscoEnvMonEnableVoltageNotification_true) ||
	    (value->sl_value > D_ciscoEnvMonEnableVoltageNotification_false))
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_ciscoEnvMonEnableVoltageNotification, 
		  ((ciscoEnvMonMIBNotificationEnables_t *) (dp->data))->valid);

	((ciscoEnvMonMIBNotificationEnables_t *) 
	 (dp->data))->ciscoEnvMonEnableVoltageNotification = value->sl_value;
	break;
#endif				       /* I_ciscoEnvMonEnableVoltageNotification */

#ifdef I_ciscoEnvMonEnableTemperatureNotification
      case I_ciscoEnvMonEnableTemperatureNotification:
	if ((value->sl_value < D_ciscoEnvMonEnableTemperatureNotification_true) ||
	    (value->sl_value > D_ciscoEnvMonEnableTemperatureNotification_false))
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_ciscoEnvMonEnableTemperatureNotification,
		  ((ciscoEnvMonMIBNotificationEnables_t *) (dp->data))->valid);

	((ciscoEnvMonMIBNotificationEnables_t *)
	 (dp->data))->ciscoEnvMonEnableTemperatureNotification = value->sl_value;
	break;
#endif				       /* I_ciscoEnvMonEnableTemperatureNotification */

#ifdef I_ciscoEnvMonEnableFanNotification
      case I_ciscoEnvMonEnableFanNotification:
	if ((value->sl_value < D_ciscoEnvMonEnableFanNotification_true) ||
	    (value->sl_value > D_ciscoEnvMonEnableFanNotification_false))
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_ciscoEnvMonEnableFanNotification,
		  ((ciscoEnvMonMIBNotificationEnables_t *) (dp->data))->valid);

	((ciscoEnvMonMIBNotificationEnables_t *)
	 (dp->data))->ciscoEnvMonEnableFanNotification = value->sl_value;
	break;
#endif				       /* I_ciscoEnvMonEnableFanNotification */

#ifdef I_ciscoEnvMonEnableRedundantSupplyNotification
      case I_ciscoEnvMonEnableRedundantSupplyNotification:
	if ((value->sl_value < D_ciscoEnvMonEnableRedundantSupplyNotification_true) ||
	    (value->sl_value > D_ciscoEnvMonEnableRedundantSupplyNotification_false))
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_ciscoEnvMonEnableRedundantSupplyNotification, 
		  ((ciscoEnvMonMIBNotificationEnables_t *) (dp->data))->valid);

	((ciscoEnvMonMIBNotificationEnables_t *)
	 (dp->data))->ciscoEnvMonEnableRedundantSupplyNotification = value->sl_value;
	break;
#endif			       /* I_ciscoEnvMonEnableRedundantSupplyNotification */


      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in ciscoEnvMonMIBNotificationEnables_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;
    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
ciscoEnvMonMIBNotificationEnables_set(doHead, doCur, contextInfo)
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    return
	(k_ciscoEnvMonMIBNotificationEnables_set((ciscoEnvMonMIBNotificationEnables_t *)
			 (doCur->data),contextInfo, doCur->state));
}

#endif				       /* SETS */



ciscoEnvMonMIBNotificationEnables_t *
k_ciscoEnvMonMIBNotificationEnables_get(serialNum, contextInfo, nominator)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
{
    return (&envmon_globalsData);
}

#ifdef SETS
int
k_ciscoEnvMonMIBNotificationEnables_set(data, contextInfo, function)
    ciscoEnvMonMIBNotificationEnables_t *data;
    ContextInfo    *contextInfo;
    int             function;
{

#ifdef I_ciscoEnvMonEnableShutdownNotification
	if (VALID(I_ciscoEnvMonEnableShutdownNotification, data->valid)) {
	    envmon_globalsData.ciscoEnvMonEnableShutdownNotification = 
		data->ciscoEnvMonEnableShutdownNotification;
	}
#endif				       /* I_ciscoEnvMonEnableShutdownNotification */

#ifdef I_ciscoEnvMonEnableVoltageNotification
	if (VALID(I_ciscoEnvMonEnableVoltageNotification, data->valid)) {
	    envmon_globalsData.ciscoEnvMonEnableVoltageNotification = 
		data->ciscoEnvMonEnableVoltageNotification;
	}
#endif				       /* I_ciscoEnvMonEnableVoltageNotification */

#ifdef I_ciscoEnvMonEnableTemperatureNotification
	if (VALID(I_ciscoEnvMonEnableTemperatureNotification, data->valid)) {
	    envmon_globalsData.ciscoEnvMonEnableTemperatureNotification = 
		data->ciscoEnvMonEnableTemperatureNotification;
	}
#endif			       /* I_ciscoEnvMonEnableTemperatureNotification */

#ifdef I_ciscoEnvMonEnableFanNotification
	if (VALID(I_ciscoEnvMonEnableFanNotification, data->valid)) {
	    envmon_globalsData.ciscoEnvMonEnableFanNotification = 
		data->ciscoEnvMonEnableFanNotification;
	}
#endif			       /* I_ciscoEnvMonEnableFanNotification */

#ifdef I_ciscoEnvMonEnableRedundantSupplyNotification
	if (VALID(I_ciscoEnvMonEnableRedundantSupplyNotification, data->valid)) {
	    envmon_globalsData.ciscoEnvMonEnableRedundantSupplyNotification = 
		data->ciscoEnvMonEnableRedundantSupplyNotification;
	}
#endif			       /* I_ciscoEnvMonEnableRedundantSupplyNotification */
	return (NO_ERROR);

}

#endif				       /* SETS */


/*
  ciscoEnvMonShutdownNotification NOTIFICATION-TYPE
	-- no OBJECTS
	STATUS	current
	DESCRIPTION
		"A ciscoEnvMonShutdownNotification is sent if the environmental
		monitor detects a testpoint reaching a critical state
		and is about to initiate a shutdown.  This Notification contains
		no objects so that it may be encoded and sent in the
		shortest amount of time possible.  Even so, management
		applications should not rely on receiving such a Notification
		as it may not be sent before the shutdown completes."
	::= { ciscoEnvMonMIBNotifications 1 }
*/
#define ENV_TRAP_NUMBER 1
#define TRAP_VARBIND_COUNT 0

static const OID envShutdownOID = {LNciscoEnvMonShutdownNotification,
					(ulong *)IDciscoEnvMonShutdownNotification};
/*
 * The OID that identifies the SNMPv1 enterprise. This is identical to the
 * SNMPv2 trap OID with the last two subidentifiers removed
 */
static const OID enterpriseShutdownOID =
    {LNciscoEnvMonShutdownNotification - 2, (ulong *)IDciscoEnvMonShutdownNotification};

static void
envmib_shutdown_trap (void)
{
    OID	       *vbList[TRAP_VARBIND_COUNT+1];
    char	trapoid_str[80];

    /*
     * For some unknown reason, SNMP Research made all the object
     * identifier parameters (OID *) *except* for the SNMPv2
     * trap identifier which is (char *).  It is much easier for
     * us to use the mib-compiler generate OID structure, so
     * we'll just convert that into a string.
     */

    if (MakeDotFromOID((OID *)&envShutdownOID, trapoid_str) == -1) {
	return;
    }	
    /*
     * don't do anything if envmon traps are disabled
     */
    if (envmon_globalsData.ciscoEnvMonEnableShutdownNotification ==
	D_ciscoEnvMonEnableShutdownNotification_false)
	return;

    /*
     * create the varbind list
     */
    vbList[0] = NULL;

    /*
     * tell snmp to do something
     */
    snmp_trap(ENTERPRISE_TRAP, ENV_TRAP_NUMBER, vbList,
		 (OID *)&enterpriseShutdownOID, trapoid_str);
}




/*
  ciscoEnvMonVoltageNotification NOTIFICATION-TYPE
	OBJECTS	{
		ciscoEnvMonVoltageStatusDescr,
		ciscoEnvMonVoltageStatusValue,
		ciscoEnvMonVoltageState
		}
	STATUS	current
	DESCRIPTION
		"A ciscoEnvMonVoltageNotification is sent if the voltage measured
		at a given testpoint is outside the normal range for the
		testpoint (i.e. is at the warning, critical, or shutdown
		stage).  Since such a Notification is usually generated before
		the shutdown state is reached, it can convey more data
		and has a better chance of being sent than does the
		ciscoEnvMonShutdownNotification."
	::= { ciscoEnvMonMIBNotifications 2 }

*/
#undef ENV_TRAP_NUMBER
#define ENV_TRAP_NUMBER 2

#undef TRAP_VARBIND_COUNT
#define TRAP_VARBIND_COUNT 3

static const OID envVoltageOID = {LNciscoEnvMonVoltageNotification,
					(ulong *)IDciscoEnvMonVoltageNotification};
/*
 * The OID that identifies the SNMPv1 enterprise. This is identical to the
 * SNMPv2 trap OID with the last two subidentifiers removed
 */
static const OID enterpriseVoltOID =
    {LNciscoEnvMonVoltageNotification - 2, (ulong *)IDciscoEnvMonVoltageNotification};

static const OID envVoltage_varbinds[TRAP_VARBIND_COUNT] = {
   {LNciscoEnvMonVoltageStatusDescr, (ulong *)IDciscoEnvMonVoltageStatusDescr},
   {LNciscoEnvMonVoltageStatusValue, (ulong *)IDciscoEnvMonVoltageStatusValue},
   {LNciscoEnvMonVoltageState, (ulong *)IDciscoEnvMonVoltageState}};

static void
envmib_voltage_trap (int indx)
{
    int		vbIndex, snmpidx;
    OID	       *vbList[TRAP_VARBIND_COUNT+1];
    OID         instanceOID;
    ulong       instance[1];
    char	trapoid_str[80];

    /*
     * For some unknown reason, SNMP Research made all the object
     * identifier parameters (OID *) *except* for the SNMPv2
     * trap identifier which is (char *).  It is much easier for
     * us to use the mib-compiler generate OID structure, so
     * we'll just convert that into a string.
     */

    if (MakeDotFromOID((OID *)&envVoltageOID,
				trapoid_str) == -1) {  
	return;
    }	

    /*
     * All the trap varbind objects have an instance described by
     * INDEX { ciscoEnvMonVoltageIndex }
     */
    snmpidx = getEnvVoltToSnmpIndex(indx);
    instance[0] = snmpidx;
    instanceOID.oid_ptr = instance;
    instanceOID.length = 1;


    /*
     * don't do anything if envmon traps are disabled
     */
    if (envmon_globalsData.ciscoEnvMonEnableVoltageNotification ==
	D_ciscoEnvMonEnableVoltageNotification_false)
	return;

    /*
     * create the varbind list
     */

    for (vbIndex = 0; vbIndex < TRAP_VARBIND_COUNT; vbIndex++) {
        vbList[vbIndex] = CatOID((OID *) &envVoltage_varbinds[vbIndex],
				 &instanceOID);
    }
    vbList[vbIndex] = NULL;

    /*
     * tell snmp to do something
     */
    snmp_trap(ENTERPRISE_TRAP, ENV_TRAP_NUMBER, vbList,
		 (OID *)&enterpriseVoltOID, trapoid_str);


    /*
     * free data allocated by the CatOID service
     */
    for (vbIndex = 0; vbIndex < TRAP_VARBIND_COUNT; vbIndex++) {
	FreeOID(vbList[vbIndex]);
    }


}


/*
 
  ciscoEnvMonTemperatureNotification NOTIFICATION-TYPE
	OBJECTS	{
		ciscoEnvMonTemperatureStatusDescr,
		ciscoEnvMonTemperatureStatusValue,
		ciscoEnvMonTemperatureState
		}
	STATUS	current
	DESCRIPTION
		"A ciscoEnvMonTemperatureNotification is sent if the temperature
		measured at a given testpoint is outside the normal range
		for the testpoint (i.e. is at the warning, critical, or
		shutdown stage).  Since such a Notification is usually generated
		before the shutdown state is reached, it can convey more
		data and has a better chance of being sent than does the
		ciscoEnvMonShutdownNotification."
	::= { ciscoEnvMonMIBNotifications 3 }
*/

#undef  ENV_TRAP_NUMBER
#define ENV_TRAP_NUMBER 3

#undef  TRAP_VARBIND_COUNT 
#define TRAP_VARBIND_COUNT 3

static const OID envTemperatureOID = {LNciscoEnvMonTemperatureNotification,
					(ulong *)IDciscoEnvMonTemperatureNotification};

/*
 * The OID that identifies the SNMPv1 enterprise. This is identical to the
 * SNMPv2 trap OID with the last two subidentifiers removed
 */
static const OID enterpriseTempOID =
    {LNciscoEnvMonTemperatureNotification - 2, (ulong *)IDciscoEnvMonTemperatureNotification};

static const OID envTemp_varbinds[TRAP_VARBIND_COUNT] = {
   {LNciscoEnvMonTemperatureStatusDescr, 
	(ulong *)IDciscoEnvMonTemperatureStatusDescr},
   {LNciscoEnvMonTemperatureStatusValue,
	(ulong *)IDciscoEnvMonTemperatureStatusValue},
   {LNciscoEnvMonTemperatureState, (ulong *)IDciscoEnvMonTemperatureState}};


static void
envmib_temperature_trap (int indx)
{
    int		vbIndex, snmpidx;
    OID	       *vbList[TRAP_VARBIND_COUNT+1];
    OID         instanceOID;
    ulong       instance[1];
    char	trapoid_str[80];

    /*
     * For some unknown reason, SNMP Research made all the object
     * identifier parameters (OID *) *except* for the SNMPv2
     * trap identifier which is (char *).  It is much easier for
     * us to use the mib-compiler generate OID structure, so
     * we'll just convert that into a string.
     */
    if (MakeDotFromOID((OID *)&envTemperatureOID, trapoid_str) == -1) {
	return;
    }	

    /*
     * All the trap varbind objects have an instance described by
     * INDEX { ciscoEnvMonTempIndex }
     */
    snmpidx = getEnvTempToSnmpIndex(indx);
    instance[0] = snmpidx;
    instanceOID.oid_ptr = instance;
    instanceOID.length = 1;


    /*
     * don't do anything if envmon traps are disabled
     */
    if (envmon_globalsData.ciscoEnvMonEnableTemperatureNotification ==
	D_ciscoEnvMonEnableTemperatureNotification_false) 
	return;
    

    for (vbIndex = 0; vbIndex < TRAP_VARBIND_COUNT; vbIndex++) {
        vbList[vbIndex] = CatOID((OID *) &envTemp_varbinds[vbIndex],
				 &instanceOID);

    }
    vbList[vbIndex] = NULL;

    /*
     * tell snmp to do something
     */
    snmp_trap(ENTERPRISE_TRAP, ENV_TRAP_NUMBER, vbList,
		 (OID *)&enterpriseTempOID, trapoid_str);

    /*
     * free data allocated by the CatOID service
     */
    for (vbIndex = 0; vbIndex < TRAP_VARBIND_COUNT; vbIndex++) {
	FreeOID(vbList[vbIndex]);
    }
}


/*
 * env_trap_cfg_nvwrt -- set the TrapState through config cmd, nvgen
 */
static void
env_trap_cfg_nvwrt (parseinfo *csb)
{

    if((envmon_globalsData.ciscoEnvMonEnableFanNotification == 
       D_ciscoEnvMonEnableFanNotification_true) && 
       (envmon_globalsData.ciscoEnvMonEnableShutdownNotification == 
       D_ciscoEnvMonEnableShutdownNotification_true) &&
       (envmon_globalsData.ciscoEnvMonEnableRedundantSupplyNotification == 
       D_ciscoEnvMonEnableRedundantSupplyNotification_true) &&
       (envmon_globalsData.ciscoEnvMonEnableTemperatureNotification == 
	D_ciscoEnvMonEnableTemperatureNotification_true) &&
       (envmon_globalsData.ciscoEnvMonEnableVoltageNotification ==
	D_ciscoEnvMonEnableVoltageNotification_true)) {

	nv_write(TRUE, "%s traps envmon", csb->nv_command); 
	return;

    } else  if((envmon_globalsData.ciscoEnvMonEnableFanNotification == 
       D_ciscoEnvMonEnableFanNotification_true) || 
       (envmon_globalsData.ciscoEnvMonEnableShutdownNotification == 
       D_ciscoEnvMonEnableShutdownNotification_true) ||
       (envmon_globalsData.ciscoEnvMonEnableRedundantSupplyNotification == 
       D_ciscoEnvMonEnableRedundantSupplyNotification_true) ||
       (envmon_globalsData.ciscoEnvMonEnableTemperatureNotification == 
	D_ciscoEnvMonEnableTemperatureNotification_true) ||
       (envmon_globalsData.ciscoEnvMonEnableVoltageNotification ==
	D_ciscoEnvMonEnableVoltageNotification_true)) {

	nv_write(TRUE, "%s traps envmon", csb->nv_command);
    
	if(envmon_globalsData.ciscoEnvMonEnableFanNotification == 
	   D_ciscoEnvMonEnableFanNotification_true) {
	    nv_add(TRUE, " fan");
	}
	
	if( envmon_globalsData.ciscoEnvMonEnableShutdownNotification == 
	   D_ciscoEnvMonEnableShutdownNotification_true) {
	    nv_add(TRUE, " shutdown");
	}
	if(envmon_globalsData.ciscoEnvMonEnableRedundantSupplyNotification == 
	   D_ciscoEnvMonEnableRedundantSupplyNotification_true) {
	    nv_add(TRUE, " supply");
	}
	if(envmon_globalsData.ciscoEnvMonEnableTemperatureNotification == 
	   D_ciscoEnvMonEnableTemperatureNotification_true) {
	    nv_add(TRUE, " temperature");
	}
	if(envmon_globalsData.ciscoEnvMonEnableVoltageNotification ==
	   D_ciscoEnvMonEnableVoltageNotification_true) {
	    nv_add(TRUE, " voltage");
	}
    }
}

/*
 * env_trap_cfg_set -- set the TrapState through config cmd
 */
static void
env_trap_cfg_set (
    boolean	enable,
    uint	subsys,
    uint	traps)
{
    if ((subsys & (1<< TRAP_ENVMON))) {
	if ((traps & (1 << TRAP_ENVMON_SHUTDOWN))) {
	    envmon_globalsData.ciscoEnvMonEnableShutdownNotification =
		enable ?
		    D_ciscoEnvMonEnableShutdownNotification_true : 
			D_ciscoEnvMonEnableShutdownNotification_false;
	}
	if ((traps & (1 << TRAP_ENVMON_VOLT))) {
	    envmon_globalsData.ciscoEnvMonEnableVoltageNotification =
		enable ?
		    D_ciscoEnvMonEnableVoltageNotification_true : 
			D_ciscoEnvMonEnableVoltageNotification_false;
	}
	if ((traps & (1 << TRAP_ENVMON_TEMP))) {
	    envmon_globalsData.ciscoEnvMonEnableTemperatureNotification =
		enable ?
		    D_ciscoEnvMonEnableTemperatureNotification_true : 
			D_ciscoEnvMonEnableTemperatureNotification_false;
	}
	if ((traps & (1 << TRAP_ENVMON_FAN))) {
	    envmon_globalsData.ciscoEnvMonEnableFanNotification =
		enable ?
		    D_ciscoEnvMonEnableFanNotification_true : 
			D_ciscoEnvMonEnableFanNotification_false;
	}
	if ((traps & (1 << TRAP_ENVMON_SUPPLY))) {
	    envmon_globalsData.ciscoEnvMonEnableRedundantSupplyNotification =
		enable ?
		    D_ciscoEnvMonEnableRedundantSupplyNotification_true : 
			D_ciscoEnvMonEnableRedundantSupplyNotification_false;
	}
    }
}


/*
 * envmib subsystem header
 */

#define MAJVERSION_envmib 1
#define MINVERSION_envmib 0
#define EDITVERSION_envmib 0

SUBSYS_HEADER(envmib,
              MAJVERSION_envmib,
              MINVERSION_envmib,
              EDITVERSION_envmib,
              init_envmib,
              SUBSYS_CLASS_MANAGEMENT,
              NULL,
              NULL);

      
