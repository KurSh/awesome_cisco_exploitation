/* $Id: sr_atmib2.c,v 3.5.10.5 1996/07/06 05:54:00 thille Exp $
 * $Source: /release/112/cvs/Xsys/ip/sr_atmib2.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * February 1994, Jeffrey T. Johnson (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1994-1996 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_atmib2.c,v $
 * Revision 3.5.10.5  1996/07/06  05:54:00  thille
 * CSCdi62136:  seq: iphost and req: iphost duplicated and waste memory
 * Branch: California_branch
 * Put copies of the strings in common_strings.c/h and reference them
 * instead of having multiple copies of the literals.  Save 660 bytes.
 *
 * Revision 3.5.10.4  1996/07/01  18:44:45  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.5.10.3  1996/06/25  01:36:20  sdurham
 * CSCdi59866:  ARP learned over a LEC ATM-subinterface IfIndex pointing
 * ATM
 * Branch: California_branch
 * clean up all ifIndex use in MIB-II mibs for swidb-based subinterfaces
 *
 * Revision 3.5.10.2  1996/04/19  17:59:14  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.5.10.1  1996/04/15  21:16:51  bcole
 * CSCdi54649:  IP Host Modularity, IP Automatic Stub Routing feature
 * commit
 * Branch: California_branch
 *
 * Revision 3.5  1996/02/22  20:26:08  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.4  1996/01/18  15:48:29  anke
 * CSCdi46969:  Change empty req and/or seq strings in SUBSYS_HEADERs to
 *              NULL
 *              Five bytes saved is five bytes earned
 *
 * Revision 3.3  1995/12/14  08:25:02  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.2  1995/11/17  09:36:24  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  11:58:16  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.5  1995/10/17  02:25:40  jjohnson
 * CSCdi42267:  arp mib has zeros MAC address when pinging non-existant IP
 * address.  don't report arp records which are invalid or which have a
 * resolution pending
 *
 * Revision 2.4  1995/08/15  00:20:08  bcole
 * CSCdi38170:  Ping to HSRP IP address causes ICMP echo request storm
 *
 * Add notion of dynamic IP aliases, so that HSRP virtual IP address is
 * now pingable.  Eliminate packet forwarding problem for this virtual
 * IP address as a side effect.
 *
 * Revision 2.3  1995/07/17  07:32:35  bchan
 * CSCdi34760:  Ifindex usage incorrect
 *
 * Revision 2.2  1995/06/28  09:26:51  smackie
 * Repair widespread subsystem header braindamage. (CSCdi23568)
 *
 *   o Fix subsystem entry points to be foo(subsystype *) not foo(void)
 *   o Repair nonsensical and redundant subsystem sequences
 *   o Use NULL where no property is required
 *
 * Revision 2.1  1995/06/07  21:00:49  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1993 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include "../ui/common_strings.h"
#include "subsys.h"
#include "../snmp/snmp_api.h"
#include "sr_atmib2.h"
#include "sr_atmib2-mib.h"

#include "linktype.h"
#include "interface_private.h"
#include "packet.h"
#include "ip.h"
#include "../if/arp.h"
#include "../ip/ip_registry.h"
#include "ipaddress.h"
#include "../iprouting/route.h"


atEntry_t    atEntryData;
OctetString  atPhysAddress;
OctetString  atNetAddress;
uchar        atNetAddressBuffer[5];   /* must hold netType and netAddress */

void
init_atmib2 (subsystype *subsys)
{
    load_mib(atmib2_OidList, atmib2_OidListNum);
    load_oid(atmib2_oid_table);

    atEntryData.atPhysAddress = &atPhysAddress;
    atEntryData.atNetAddress = &atNetAddress;

}


static boolean
convert_net_address (OctetString *netaddress, long *nettype, ulong *netaddr)
{
    int idx;

    if (netaddress->length != 5)
	return (FALSE);

    *nettype = (long) netaddress->octet_ptr[0];
    *netaddr = 0;

    for (idx = 1; idx < 5; idx++) {
	/* check for octet overflow */
	if (netaddress->octet_ptr[idx] > 255)
	    return (FALSE);
	*netaddr <<= 8;
	*netaddr += (ulong) netaddress->octet_ptr[idx];
    }
    return (TRUE);
}


static long
net_to_arp(long nettype)
{
    switch (nettype) {
    case SNMP_IP_NET:
	return (LINK_IP);
    case SNMP_AT_NET:
	return(LINK_APPLETALK);
    default:
	return 0;
    }
}

static long
arp_to_net(long nettype)
{
    switch (nettype) {
    case LINK_IP:
	return (SNMP_IP_NET);
    case LINK_APPLETALK:
	return (SNMP_AT_NET);
    default:
	return 0;
    }
}

/*---------------------------------------------------------------------
 * Retrieve data from the atEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *
atEntry_get(
    OID             *incoming,
    ObjectInfo      *object,
    int             searchType,
    ContextInfo     *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void            *dp;
    atEntry_t       *data = NULL;
    unsigned long   buffer[6];
    OID             inst;
    int             carry;
    long            atIfIndex;
    OctetString *   atNetAddress;


    /*
     * Check the object instance.
     *
     * An EXACT search requires that the instance be of length 6 
     *
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 6) {
	    return((VarBind *) NULL);
        }
        carry = 0;
    } else {
        carry = 1;
    }

    if ( (InstToFixedOctetString(incoming, 1 + object->oid.length, &atNetAddress, searchType, &carry, 5)) < 0 ) {
	arg = -1;
    }

    if ( (InstToInt(incoming, 0 + object->oid.length, &atIfIndex, searchType, &carry)) < 0 ) {
	arg = -1;
    }

    if (carry) {
	arg = -1;
    }

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ( (arg == -1) || (data = k_atEntry_get(serialNum, contextInfo, arg ,searchType, atIfIndex, atNetAddress)) == NULL) {
        arg = -1;
    } else {
	/*
	 * Build instance information
	 */
        inst.oid_ptr = buffer;
        inst.length = 6;
        inst.oid_ptr[0] = data->atIfIndex;
        inst.oid_ptr[1] = (unsigned long) data->atNetAddress->octet_ptr[0];
	inst.oid_ptr[2] = (unsigned long) data->atNetAddress->octet_ptr[1];
	inst.oid_ptr[3] = (unsigned long) data->atNetAddress->octet_ptr[2];
        inst.oid_ptr[4] = (unsigned long) data->atNetAddress->octet_ptr[3];
        inst.oid_ptr[5] = (unsigned long) data->atNetAddress->octet_ptr[4];
    }

    if(atNetAddress != NULL) {
        FreeOctetString(atNetAddress);
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_atIfIndex
    case I_atIfIndex:
	dp = &data->atIfIndex;
	break;
#endif /* I_atIfIndex */

#ifdef I_atPhysAddress
    case I_atPhysAddress:
	dp = MakeOctetString(data->atPhysAddress->octet_ptr, data->atPhysAddress->length);
	break;
#endif /* I_atPhysAddress */

#ifdef I_atNetAddress
    case I_atNetAddress:

	/*
	 * the atNetAddress has the nettype prefix which needs to be ignored.
	 * we ignore it by advancing the pointer and decrementing the count.
	 */
	dp = MakeOctetString(data->atNetAddress->octet_ptr+1, data->atNetAddress->length-1);
	break;
#endif /* I_atNetAddress */

    default:
	return ((VarBind *) NULL);

    }      /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS 

/*----------------------------------------------------------------------
 * Free the atEntry data object.
 *---------------------------------------------------------------------*/
void
atEntry_free(atEntry_t *data)
{
    if (data != NULL) {
	if (data->atPhysAddress != NULL) {
	    FreeOctetString(data->atPhysAddress);
	}
	if (data->atNetAddress != NULL) {
	    FreeOctetString(data->atNetAddress);
	}
	free ((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after atEntry set/undo
 *---------------------------------------------------------------------*/
static int
atEntry_cleanup(doList_t *trash)
{
    atEntry_free(trash->data);
#ifdef SR_SNMPv2
    atEntry_free(trash->undodata);
#endif /* SR_SNMPv2 */
    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Undo a previous set of the atEntry family.
 *---------------------------------------------------------------------*/
#ifdef SR_SNMPv2
int
atEntry_undo(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return UNDO_FAILED_ERROR;
}
#endif SR_SNMPv2

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int 
atEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    doList_t       *dp;
    int            found;
    int            carry = 0;
    atEntry_t     *atEntry;
    long           atIfIndex;
    OctetString *  atNetAddress;

    /*
     * Validate the object instance
     *
     */

    if ( (InstToInt(incoming, 0 + object->oid.length, &atIfIndex, EXACT, &carry)) < 0 ) {
	return(NO_CREATION_ERROR);
    }

    if ( (InstToFixedOctetString(incoming, 1 + object->oid.length, &atNetAddress, EXACT, &carry, 5)) < 0 ) {
	return(NO_CREATION_ERROR);
    }

    atEntry = k_atEntry_get(-1, contextInfo, object->nominator, EXACT, atIfIndex, atNetAddress);

#ifndef atEntry_READ_CREATE

    if (atEntry == NULL) {
	return (NO_ACCESS_ERROR); 
    }
#endif /* atEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) { 
	if ( (dp->setMethod == atEntry_set) &&
            (((atEntry_t *) (dp->data)) != NULL) &&
            (((atEntry_t *) (dp->data))->atIfIndex == atIfIndex) &&
            (((atEntry_t *) (dp->data))->atNetAddress == atNetAddress) ) {

            found = 1;
            break; 
        }
    }

    if (!found) {
        dp = doCur;
        if ( (dp->data = malloc(sizeof(atEntry_t))) == NULL) { 
            DPRINTF((0, "snmpd: Cannot allocate memory\n"));
            return (GEN_ERROR);
        }
        memset(dp->data, 0, sizeof(atEntry_t));

        dp->setMethod = atEntry_set;
        dp->cleanupMethod = atEntry_cleanup;
#ifdef SR_SNMPv2
        dp->undoMethod = atEntry_undo;
#endif /* SR_SNMPv2 */ 
        dp->state = UNKNOWN;

        SET_VALID(I_atIfIndex, ((atEntry_t *) (dp->data))->valid);
        ((atEntry_t *) (dp->data))->atIfIndex = atIfIndex;

        SET_VALID(I_atNetAddress, ((atEntry_t *) (dp->data))->valid);
        ((atEntry_t *) (dp->data))->atNetAddress = atNetAddress;

#ifdef atEntry_READ_CREATE 

        /*
         * Try to fill in reasonable default values for this new entry.
         */

	if (atEntry != NULL) {
            /* use existing values as default values */
            memcpy(dp->data, atEntry, sizeof(atEntry_t));

            SET_ALL_VALID(((atEntry_t *) (dp->data))->valid);

            ((atEntry_t *) (dp->data))->atPhysAddress = 
		CloneOctetString(value->os_value);


            ((atEntry_t *) (dp->data))->atNetAddress = 
		CloneOctetString(value->os_value);


	} else {


            /* Fill in default values here */


	}
#endif /* atEntry_READ_CREATE */
    }

    switch (object->nominator) {

#ifdef I_atIfIndex
    case I_atIfIndex:

	SET_VALID(I_atIfIndex, ((atEntry_t *) (dp->data))->valid);

	((atEntry_t *) (dp->data))->atIfIndex = value->sl_value;
	break;
#endif /* I_atIfIndex */

#ifdef I_atPhysAddress
    case I_atPhysAddress:

	SET_VALID(I_atPhysAddress, ((atEntry_t *) (dp->data))->valid);

	if (((atEntry_t *) (dp->data))->atPhysAddress != NULL) {
	    FreeOctetString(((atEntry_t *) (dp->data))->atPhysAddress);
	}

	((atEntry_t *) (dp->data))->atPhysAddress = 
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif /* I_atPhysAddress */

#ifdef I_atNetAddress
    case I_atNetAddress:

	SET_VALID(I_atNetAddress, ((atEntry_t *) (dp->data))->valid);

	if (((atEntry_t *) (dp->data))->atNetAddress != NULL) {
	    FreeOctetString(((atEntry_t *) (dp->data))->atNetAddress);
	}

	((atEntry_t *) (dp->data))->atNetAddress = 
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif /* I_atNetAddress */

    default:
	DPRINTF((0, "snmpd: Internal error (invalid nominator in atEntry)\n"));
	return (GEN_ERROR);

    }        /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int 
atEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_atEntry_set((atEntry_t *) (doCur->data),
			  contextInfo, doCur->state));
}

#endif /* SETS */

/* given an ip_address, find an idb for it */
static idbtype *
find_best_idb (ipaddrtype ipaddr) {
    idbtype *currentidb;
    
    /* 
     * See if ip address is on a directly connected net.
     * If not, get desparate - any interface will do 
     */
    currentidb = samecable(ipaddr);
    if (currentidb == NULL) {
        currentidb = pick_defaultidb(ipaddr);
    }
    return(currentidb);
}

/*
 * in MIB-II, the arp table is indexed by ifIndex.[type].address
 * the type is present in the atTable and not in the ipNetToMediaTable
 *
 * this function will return the arp table entry that is greater than or
 * equal to the arp indicies specified.  if the "locktype" flag is TRUE,
 * only entires which match the indicated linktype will be considered,
 * otherwise, everything will be considered
 */

arptype *
find_best_arp(long ifIndex, ulong netaddr, long linktype, boolean locktype)
{
    int bucket;
    arptype *ptr;
    arptype *best;
    long     currentif;
    long     currentnet;
    long     bestif = MAX_INTERFACES;
    ulong    bestaddr = 0;
    long     bestnet = 0;
    long     basenet;
    idbtype *currentidb;

    best = NULL;
    basenet = arp_to_net(linktype);
    for (bucket = 0; bucket < NETHASHLEN; bucket++) {
	for (ptr = arptable[bucket]; ptr; ptr = ptr->next) {

	    /* reject this entry if there is a linktype mismatch */
	    if ((ptr->type != linktype) && (locktype == TRUE))
		continue;

            /*
             * reject this entry if there is no interface information.
             * However, static arp entries may not have interface info,
             * so we need to find an appropriate interface idb for them.
             */
            currentidb = ptr->idb;
            if ((currentidb == NULL) || (currentidb->hwptr == NULL)) {
                if (ptr->mode == ARP_STATIC) {
                    currentidb = find_best_idb(ptr->address);
                    if ((currentidb == NULL) || (currentidb->hwptr == NULL)) {
                        continue;
                    }
                } else {
                    continue;
                } 
            }

	    /* reject this entry if it is a null or incomplete entry */
	    if ((ptr->mode == ARP_NULL) || (ptr->mode == ARP_INCOMPLETE))
		continue;

	    /* 
	     * only registered subinterfaces have swidb->snmp_if_index set
	     */
    
	    if (currentidb->snmp_if_index) {
		currentif = currentidb->snmp_if_index;
	    } else {
		currentif = currentidb->hwptr->snmp_if_index;
	    }
	    currentnet = arp_to_net(ptr->type);

	    /* reject this entry if its index is "less than" the input index */
	    if (currentif < ifIndex)
		continue;
	    if (currentif == ifIndex) {
		if (currentnet < basenet)
		    continue;
		if (currentnet == basenet) {
		    if (ptr->address < netaddr)
			continue;
		}
	    }

	    /* reject this entry if its index is "greater than" the best index */
	    if (currentif > bestif)
		continue;
	    if (currentif == bestif) {
		if (currentnet > bestnet)
		    continue;
		if (currentnet == bestnet) {
		    if (ptr->address > bestaddr)
			continue;
		}
	    }

	    /* this entry is the best so far */
	    best = ptr;
	    bestif = currentif;
	    bestaddr = ptr->address;
	    bestnet = currentnet;
	}
    }
    return (best);
}


arptype *
find_exact_arp(long ifIndex, ulong netaddr, long linktype)
{
    int bucket;
    arptype *ptr;
    idbtype *currentidb;
    /* grab the hwidb for this interface */
    if (ifIndex > nnets)
	return (NULL);

    bucket = nethash(netaddr);
    for (ptr = arptable[bucket]; ptr; ptr = ptr->next) {
        if ((ptr->address == netaddr) && (ptr->type == linktype) &&
	    (ptr->mode != ARP_NULL) && (ptr->mode != ARP_INCOMPLETE)) {

            currentidb = ptr->idb;
            if ((currentidb == NULL) || (currentidb->hwptr == NULL)) {
	        if (ptr->mode == ARP_STATIC) {
                    currentidb = find_best_idb(ptr->address);
                }
                if ((currentidb == NULL) || (currentidb->hwptr == NULL)) {
                    continue;
                }
            }

	    /* 
	     * only registered subinterfaces have swidb->snmp_if_index set
	     */
	    if (currentidb->snmp_if_index == ifIndex) {
		/*
		 * must be subinterface
		 */
		break;

	    } else if (currentidb->hwptr->snmp_if_index == ifIndex ) {
		break;
	    }
	}
    }
    return (ptr);
}


/*
 * remove_exact_arp:
 * removes the arp entry associated with the given parameters
 */
void
remove_exact_arp(long ifIndex, ulong netaddr, long linktype)
{
    arptype *arp;

    arp = find_exact_arp(ifIndex, netaddr, linktype);
    if (arp) {
	if (ip_staticaliasaddr(arp->address))
	    reg_invoke_ipalias_delete(arp->address);
	arp_table_remove(arp->address, linktype);
    }
}


atEntry_t *
k_atEntry_get(
   int serialNum,
   ContextInfo *contextInfo,
   int nominator,
   int searchType,
   long atIfIndex,
   OctetString * atNetAddress)
{
    ulong    netvalue;
    ulong    netaddr;
    ulong    arpvalue;
    arptype *arp;
    idbtype *idb;
    int      idx;

    /*
     * convert the atNetAddress structure into its component elements.
     * the conversion should never fail since the calling routine has
     * zero-padded the atNetAddress
     */
    if (!convert_net_address(atNetAddress, &netvalue, &netaddr))
	return(NULL);

    if (searchType == EXACT) {
	arpvalue = net_to_arp(netvalue);
	if (arpvalue == 0)
	    return(NULL);
	arp = find_exact_arp(atIfIndex, netaddr, arpvalue);
    } else {
	if (netvalue < SNMP_MIN_NET) {
	    /*
	     * advance indices to first possible value
	     */
	    netvalue = SNMP_MIN_NET;
	    netaddr = 0;
	} else if (netvalue > SNMP_MAX_NET) {
	    return(NULL);
	}
	arpvalue = net_to_arp(netvalue);
	arp = find_best_arp(atIfIndex, netaddr, arpvalue, FALSE);
    }
    if (arp == NULL)
	return(NULL);
    idb = arp->idb;
    if (idb == NULL) {
	idb = find_best_idb(arp->address);
	if (idb == NULL)
	    return(NULL);
    }
    /* 
     * only registered subinterfaces have swidb->snmp_if_index set
     */
    if (idb->snmp_if_index) {
	atEntryData.atIfIndex = idb->snmp_if_index;
    } else {
	atEntryData.atIfIndex = idb->hwptr->snmp_if_index;
    }
    atEntryData.atPhysAddress->length = IEEEBYTES;
    atEntryData.atPhysAddress->octet_ptr = arp->hardware;
    atEntryData.atNetAddress->octet_ptr = atNetAddressBuffer;
    atEntryData.atNetAddress->length = 5;
    netaddr = arp->address;
    atNetAddressBuffer[0] = (uchar) arp_to_net(arp->type);
    for (idx = 4; idx; idx--) {
	atNetAddressBuffer[idx] = (uchar) netaddr & 0xFF;
	netaddr >>= 8;
    }

    return(&atEntryData);
}

int
k_atEntry_set(
   atEntry_t *data,
   ContextInfo *contextInfo,
   int function)
{
    ulong    netvalue;
    ulong    netaddr;
    ulong    arpvalue;

    /*
     * convert the atNetAddress structure into its component elements.
     * the conversion should never fail since the "test" routine has
     * already tested the atNetAddress previously
     */
    if (!convert_net_address(data->atNetAddress, &netvalue, &netaddr))
	return(GEN_ERROR);
    arpvalue = net_to_arp(netvalue);
    if (arpvalue == 0)
	return(GEN_ERROR);

    if (function == DELETE) {
	remove_exact_arp(data->atIfIndex, netaddr, arpvalue);
    } else {
	/*
	 * must be add/modify
	 */
	return(GEN_ERROR);
    }
    return(NO_ERROR);

}


/*
 * atmib2 subsystem header
 */


#define MAJVERSION_atmib2 1
#define MINVERSION_atmib2 0
#define EDITVERSION_atmib2 0

SUBSYS_HEADER(atmib2,
              MAJVERSION_atmib2,
              MINVERSION_atmib2,
              EDITVERSION_atmib2,
              init_atmib2,
              SUBSYS_CLASS_MANAGEMENT,
              subsys_req_iphost,
              NULL);
      
