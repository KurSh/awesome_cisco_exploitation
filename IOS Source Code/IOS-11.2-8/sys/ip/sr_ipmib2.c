/* $Id: sr_ipmib2.c,v 3.7.10.5 1996/07/01 18:44:47 hampton Exp $
 * $Source: /release/112/cvs/Xsys/ip/sr_ipmib2.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * February 1994, Jeffrey T. Johnson (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1994-1996 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_ipmib2.c,v $
 * Revision 3.7.10.5  1996/07/01  18:44:47  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.7.10.4  1996/06/25  01:36:22  sdurham
 * CSCdi59866:  ARP learned over a LEC ATM-subinterface IfIndex pointing
 * ATM
 * Branch: California_branch
 * clean up all ifIndex use in MIB-II mibs for swidb-based subinterfaces
 *
 * Revision 3.7.10.3  1996/06/18  01:46:10  hampton
 * Split the monolithic traffic array into smaller per-protocol traffic
 * arrays.  [CSCdi59224]
 * Branch: California_branch
 *
 * Revision 3.7.10.2  1996/04/19  17:59:16  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.7.10.1  1996/03/29  18:14:34  sdurham
 * CSCdi51162:  ipAddrTable should track supported subinterfaces
 * Branch: California_branch
 * check for snmp registered subinterface for ifIndex value
 *
 * Revision 3.7  1996/02/22  21:40:16  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.6  1996/02/13  08:13:45  dstine
 * CSCdi48797:  Extraneous definitions in interface_private.h
 *
 * Revision 3.5  1996/01/18  15:48:32  anke
 * CSCdi46969:  Change empty req and/or seq strings in SUBSYS_HEADERs to
 *              NULL
 *              Five bytes saved is five bytes earned
 *
 * Revision 3.4  1995/12/20  08:54:06  jenny
 * CSCdi45367:  Wrong ipRouteType implemention for static routes
 *
 * Revision 3.3  1995/12/14  08:25:04  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.2  1995/11/17  09:36:32  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  11:58:24  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.6  1995/11/08  21:05:15  shaker
 * Merge Arkansas_branch into 11.1 mainline.
 *
 * Revision 2.5  1995/09/23  21:39:26  dkatz
 * CSCdi38306:  ISIS shouldnt run SPF on leaf route changes
 * Reference renamed fields.
 *
 * Revision 2.4  1995/07/17  07:32:37  bchan
 * CSCdi34760:  Ifindex usage incorrect
 *
 * Revision 2.3  1995/06/28  09:26:56  smackie
 * Repair widespread subsystem header braindamage. (CSCdi23568)
 *
 *   o Fix subsystem entry points to be foo(subsystype *) not foo(void)
 *   o Repair nonsensical and redundant subsystem sequences
 *   o Use NULL where no property is required
 *
 * Revision 2.2  1995/06/28  03:20:36  hampton
 * Use the passive timer macros instead of direct references to the system
 * clock.  [CSCdi36502]
 *
 * Revision 2.1  1995/06/07 21:01:00  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1993 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include <ciscolib.h>
#include "subsys.h"
#include "interface_private.h"
#include "packet.h"
#include "ip.h"
#include "ieee.h"
#include "../iprouting/route.h"
#include "../os/buffers.h"
#include "../if/arp.h"
#include "../snmp/snmp_api.h"
#include "sr_ipmib2.h"
#include "sr_ipmib2-mib.h"
#include "sr_old_lipmib.h"
#include "sr_atmib2.h"
#include "registry.h"
#include "sys_registry.h"
#include "../snmp/snmp_registry.regh"
#include "../ip/ip_registry.h"
#include "../iprouting/igrp.h"
#include "../iprouting/route.h"

/* define minimum and maximum values for default ttl */
#define MIN_DEFAULT_TTL   0
#define MAX_DEFAULT_TTL 255

ipAddrEntry_t ipAddrEntryData;
ipRouteEntry_t ipRouteEntryData;
ipNetToMediaEntry_t ipNetToMediaEntryData;
OctetString         ipNetToMediaPhysAddress;

void
init_ipmib2 (subsystype *subsys)
{
    memset(&ipAddrEntryData, 0, sizeof(ipAddrEntryData));
    memset(&ipRouteEntryData, 0, sizeof(ipRouteEntryData));
    memset(&ipNetToMediaEntryData, 0, sizeof(ipNetToMediaEntryData));
    load_mib(ipmib2_OidList, ipmib2_OidListNum);
    load_oid(ipmib2_oid_table);
    init_old_lipmib();
}


/*---------------------------------------------------------------------
 * Retrieve data from the ip family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *
ip_get (
    OID             *incoming,
    ObjectInfo      *object,
    int             searchType,
    ContextInfo     *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = -1;
    ip_t            *data = NULL;
    
    
    /*
     * Check the object instance.
     *
     * An EXACT search requires that the instance be of length 1 and the single
     * instance element be 0.
     *
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */
    
    switch (searchType) {
    case EXACT:
        if (instLength == 1 && incoming->oid_ptr[incoming->length - 1] == 0) {
	    arg = object->nominator;
        }
        break;
	
    case NEXT:
        if (instLength <= 0) {
	    arg = object->nominator;
        }
        break;
	
    }
    
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if (arg != -1) {
	data = k_ip_get(serialNum, contextInfo, arg);
	if (data == NULL) {
	    arg = -1;
	}
    }
    
    /*
     * Build the the variable binding for the variable that will be returned.
     */
    if (arg == -1) {
        return ((VarBind *) NULL);
    }
    else {
        return (MakeVarBind(object, &ZeroOid, SR_OFFSET(data, arg)));
    }
    
    
}

#ifdef SETS 

/*----------------------------------------------------------------------
 * Free the ip data object.
 *---------------------------------------------------------------------*/
void
ip_free (ip_t *data)
{
    if (data != NULL) {
	free ((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after ip set/undo
 *---------------------------------------------------------------------*/
static int
ip_cleanup (doList_t *trash)
{
    ip_free(trash->data);
#ifdef SR_SNMPv2
    ip_free(trash->undodata);
#endif /* SR_SNMPv2 */
    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Undo a previous set of the ip family.
 *---------------------------------------------------------------------*/
#ifdef SR_SNMPv2
int
ip_undo (
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return UNDO_FAILED_ERROR;
}
#endif SR_SNMPv2

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int 
ip_test (
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int            instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int            found;
    
    /*
     * Validate the object instance: 1) It must be of length 1  2) and the
     * instance must be 0.
     */
    if (instLength != 1 || incoming->oid_ptr[incoming->length - 1] != 0) {
        return (NO_CREATION_ERROR); 
    }
    
    found = 0;
    
    if (!found) {
        dp = doCur;
        if ( (dp->data = malloc(sizeof(ip_t))) == NULL) { 
            DPRINTF((0, "snmpd: Cannot allocate memory\n"));
            return (RESOURCE_UNAVAILABLE_ERROR);
        }
        memset(dp->data, 0, sizeof(ip_t));
	
        dp->setMethod = ip_set;
        dp->cleanupMethod = ip_cleanup;
#ifdef SR_SNMPv2
        dp->undoMethod = ip_undo;
#endif /* SR_SNMPv2 */ 
        dp->state = UNKNOWN;
	
    }
    
    switch (object->nominator) {
	
#ifdef I_ipForwarding
    case I_ipForwarding:
	
	if ((value->sl_value != D_ipForwarding_forwarding) &&
	    (value->sl_value != D_ipForwarding_not_forwarding))
	    return(WRONG_VALUE_ERROR);
	
	if (!router_enable)
	    return(INCONSISTENT_VALUE_ERROR);
	
	SET_VALID(I_ipForwarding, ((ip_t *) (dp->data))->valid);
	
	((ip_t *) (dp->data))->ipForwarding = value->sl_value;
	break;
#endif /* I_ipForwarding */
	
#ifdef I_ipDefaultTTL
    case I_ipDefaultTTL:
	
	if ((value->sl_value < MIN_DEFAULT_TTL) ||
	    (value->sl_value > MAX_DEFAULT_TTL))
	    return(WRONG_VALUE_ERROR);
	
	SET_VALID(I_ipDefaultTTL, ((ip_t *) (dp->data))->valid);
	
	((ip_t *) (dp->data))->ipDefaultTTL = value->sl_value;
	break;
#endif /* I_ipDefaultTTL */
	
    default:
	DPRINTF((0, "snmpd: Internal error (invalid nominator in ip)\n"));
	return (GEN_ERROR);
	
    }        /* switch */
    dp->state = ADD_MODIFY;
    
    return (NO_ERROR);
    
}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int 
ip_set (
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_ip_set((ip_t *) (doCur->data), contextInfo, doCur->state));
}

#endif /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the ipAddrEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *
ipAddrEntry_get (
    OID             *incoming,
    ObjectInfo      *object,
    int             searchType,
    ContextInfo     *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void            *dp;
    ipAddrEntry_t   *data = NULL;
    unsigned long   buffer[4];
    OID             inst;
    int             carry;
    unsigned long   ipAdEntAddr;
    
    
    /*
     * Check the object instance.
     *
     * An EXACT search requires that the instance be of length 4 
     *
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */
    
    if (searchType == EXACT) {
	if (instLength != 4) {
	    return((VarBind *) NULL);
        }
        carry = 0;
    } else {
        carry = 1;
    }
    
    if ( (InstToIP(incoming, 0 + object->oid.length, &ipAdEntAddr, searchType, &carry)) < 0 ) {
	arg = -1;
    }
    
    if (carry) {
	arg = -1;
    }
    
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if (arg != -1) {
	data = k_ipAddrEntry_get(serialNum, contextInfo, arg ,searchType, ipAdEntAddr);
	if (data == NULL)
	    arg = -1;
    }
    
    /*
     * Build the the variable binding for the variable that will be returned.
     */
    
    switch (arg) {
	
#ifdef I_ipAdEntAddr
    case I_ipAdEntAddr:
	dp = MakeOctetString((unsigned char *) &data->ipAdEntAddr, 4L);
	break;
#endif /* I_ipAdEntAddr */
	
#ifdef I_ipAdEntIfIndex
    case I_ipAdEntIfIndex:
	dp = &data->ipAdEntIfIndex;
	break;
#endif /* I_ipAdEntIfIndex */
	
#ifdef I_ipAdEntNetMask
    case I_ipAdEntNetMask:
	dp = MakeOctetString((unsigned char *) &data->ipAdEntNetMask, 4L);
	break;
#endif /* I_ipAdEntNetMask */
	
#ifdef I_ipAdEntBcastAddr
    case I_ipAdEntBcastAddr:
	dp = &data->ipAdEntBcastAddr;
	break;
#endif /* I_ipAdEntBcastAddr */
	
#ifdef I_ipAdEntReasmMaxSize
    case I_ipAdEntReasmMaxSize:
	dp = &data->ipAdEntReasmMaxSize;
	break;
#endif /* I_ipAdEntReasmMaxSize */
	
    default:
	return ((VarBind *) NULL);
	
    }      /* switch */
    
    /*
     * Build instance information
     */
    inst.oid_ptr = buffer;
    inst.length = 4;
    inst.oid_ptr[0] = (data->ipAdEntAddr >> 24) & 0xff;
    inst.oid_ptr[1] = (data->ipAdEntAddr >> 16) & 0xff;
    inst.oid_ptr[2] = (data->ipAdEntAddr >> 8) & 0xff;
    inst.oid_ptr[3] = (data->ipAdEntAddr >> 0) & 0xff;
    
    return (MakeVarBind(object, &inst, dp));
    
}

/*---------------------------------------------------------------------
 * Retrieve data from the ipRouteEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *
ipRouteEntry_get (
    OID             *incoming,
    ObjectInfo      *object,
    int             searchType,
    ContextInfo     *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void            *dp;
    ipRouteEntry_t  *data = NULL;
    unsigned long   buffer[4];
    OID             inst;
    int             carry;
    unsigned long   ipRouteDest;
    
    
    /*
     * Check the object instance.
     *
     * An EXACT search requires that the instance be of length 4 
     *
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */
    
    if (searchType == EXACT) {
	if (instLength != 4) {
	    return((VarBind *) NULL);
        }
        carry = 0;
    } else {
        carry = 1;
    }
    
    if ( (InstToIP(incoming, 0 + object->oid.length, &ipRouteDest, searchType, &carry)) < 0 ) {
	arg = -1;
    }
    
    if (carry) {
	arg = -1;
    }
    
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if (arg != -1) {
	data = k_ipRouteEntry_get(serialNum, contextInfo, arg ,searchType, ipRouteDest);
	if (data == NULL)
	    arg = -1;
    }
    
    /*
     * Build the the variable binding for the variable that will be returned.
     */
    
    switch (arg) {
	
#ifdef I_ipRouteDest
    case I_ipRouteDest:
	dp = MakeOctetString((unsigned char *) &data->ipRouteDest, 4L);
	break;
#endif /* I_ipRouteDest */
	
#ifdef I_ipRouteIfIndex
    case I_ipRouteIfIndex:
	dp = &data->ipRouteIfIndex;
	break;
#endif /* I_ipRouteIfIndex */
	
#ifdef I_ipRouteMetric1
    case I_ipRouteMetric1:
	dp = &data->ipRouteMetric1;
	break;
#endif /* I_ipRouteMetric1 */
	
#ifdef I_ipRouteMetric2
    case I_ipRouteMetric2:
	dp = &data->ipRouteMetric2;
	break;
#endif /* I_ipRouteMetric2 */
	
#ifdef I_ipRouteMetric3
    case I_ipRouteMetric3:
	dp = &data->ipRouteMetric3;
	break;
#endif /* I_ipRouteMetric3 */
	
#ifdef I_ipRouteMetric4
    case I_ipRouteMetric4:
	dp = &data->ipRouteMetric4;
	break;
#endif /* I_ipRouteMetric4 */
	
#ifdef I_ipRouteNextHop
    case I_ipRouteNextHop:
	dp = MakeOctetString((unsigned char *) &data->ipRouteNextHop, 4L);
	break;
#endif /* I_ipRouteNextHop */
	
#ifdef I_ipRouteType
    case I_ipRouteType:
	dp = &data->ipRouteType;
	break;
#endif /* I_ipRouteType */
	
#ifdef I_ipRouteProto
    case I_ipRouteProto:
	dp = &data->ipRouteProto;
	break;
#endif /* I_ipRouteProto */
	
#ifdef I_ipRouteAge
    case I_ipRouteAge:
	dp = &data->ipRouteAge;
	break;
#endif /* I_ipRouteAge */
	
#ifdef I_ipRouteMask
    case I_ipRouteMask:
	dp = MakeOctetString((unsigned char *) &data->ipRouteMask, 4L);
	break;
#endif /* I_ipRouteMask */
	
#ifdef I_ipRouteMetric5
    case I_ipRouteMetric5:
	dp = &data->ipRouteMetric5;
	break;
#endif /* I_ipRouteMetric5 */
	
#ifdef I_ipRouteInfo
    case I_ipRouteInfo:
	dp = MakeOID(data->ipRouteInfo->oid_ptr, data->ipRouteInfo->length);
	break;
#endif /* I_ipRouteInfo */
	
    default:
	return ((VarBind *) NULL);
	
    }      /* switch */
    
    /*
     * Build instance information
     */
    inst.oid_ptr = buffer;
    inst.length = 4;
    inst.oid_ptr[0] = (data->ipRouteDest >> 24) & 0xff;
    inst.oid_ptr[1] = (data->ipRouteDest >> 16) & 0xff;
    inst.oid_ptr[2] = (data->ipRouteDest >> 8) & 0xff;
    inst.oid_ptr[3] = (data->ipRouteDest >> 0) & 0xff;
    
    return (MakeVarBind(object, &inst, dp));
    
}

#ifdef SETS 

/*----------------------------------------------------------------------
 * Free the ipRouteEntry data object.
 *---------------------------------------------------------------------*/
void
ipRouteEntry_free (ipRouteEntry_t  *data)
{
    if (data != NULL) {
	free ((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after ipRouteEntry set/undo
 *---------------------------------------------------------------------*/
static int
ipRouteEntry_cleanup (doList_t *trash)
{
    ipRouteEntry_free(trash->data);
#ifdef SR_SNMPv2
    ipRouteEntry_free(trash->undodata);
#endif /* SR_SNMPv2 */
    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Undo a previous set of the ipRouteEntry family.
 *---------------------------------------------------------------------*/
#ifdef SR_SNMPv2
int
ipRouteEntry_undo (
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return UNDO_FAILED_ERROR;
}
#endif SR_SNMPv2

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int 
ipRouteEntry_test (
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    doList_t       *dp;
    int            found;
    int            carry = 0;
    ipRouteEntry_t     *ipRouteEntry;
    unsigned long  ipRouteDest;
    unsigned long  tmp_ip_addr;
    
    /*
     * Validate the object instance
     *
     */
    
    if ( (InstToIP(incoming, 0 + object->oid.length, &ipRouteDest, EXACT, &carry)) < 0 ) {
	return(NO_CREATION_ERROR);
    }
    
    
    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;
    
    for (dp = doHead; dp != NULL; dp = dp->next) { 
	if ( (dp->setMethod == ipRouteEntry_set) &&
            (((ipRouteEntry_t *) (dp->data)) != NULL) &&
            (((ipRouteEntry_t *) (dp->data))->ipRouteDest == ipRouteDest) ) {
	    
            found = 1;
            break; 
        }
    }
    
    if (found) {
	ipRouteEntry = dp->data;
    } else {
        dp = doCur;
        if ( (dp->data = malloc(sizeof(ipRouteEntry_t))) == NULL) { 
            DPRINTF((0, "snmpd: Cannot allocate memory\n"));
            return (GEN_ERROR);
        }
        memset(dp->data, 0, sizeof(ipRouteEntry_t));
	
        dp->setMethod = ipRouteEntry_set;
        dp->cleanupMethod = ipRouteEntry_cleanup;
#ifdef SR_SNMPv2
        dp->undoMethod = ipRouteEntry_undo;
#endif /* SR_SNMPv2 */ 
        dp->state = UNKNOWN;
	
	ipRouteEntry = k_ipRouteEntry_get(-1, contextInfo, object->nominator,
					  EXACT, ipRouteDest);
	
        /*
         * Try to fill in reasonable default values for this new entry.
         */
	
	if (ipRouteEntry != NULL) {
            /* use existing values as default values */
            memcpy(dp->data, ipRouteEntry, sizeof(ipRouteEntry_t));
	    ipRouteEntry = (ipRouteEntry_t *) dp->data;
            SET_ALL_VALID(ipRouteEntry->valid);
	    
	} else {
	    /* create default values */
	    ipRouteEntry = (ipRouteEntry_t *) dp->data;

	    SET_VALID(I_ipRouteDest, ipRouteEntry->valid);
	    ipRouteEntry->ipRouteDest = ipRouteDest;
	    
#ifndef SUPPORT_ROUTE_METRIC_1
	    SET_VALID(I_ipRouteMetric1, ipRouteEntry->valid);
	    ipRouteEntry->ipRouteMetric1 = -1;
#endif
	    
#ifndef SUPPORT_ROUTE_METRIC_2
	    SET_VALID(I_ipRouteMetric2, ipRouteEntry->valid);
	    ipRouteEntry->ipRouteMetric2 = -1;
#endif
	    
#ifndef SUPPORT_ROUTE_METRIC_3
	    SET_VALID(I_ipRouteMetric3, ipRouteEntry->valid);
	    ipRouteEntry->ipRouteMetric3 = -1;
#endif
	    
#ifndef SUPPORT_ROUTE_METRIC_4
	    SET_VALID(I_ipRouteMetric4, ipRouteEntry->valid);
	    ipRouteEntry->ipRouteMetric4 = -1;
#endif
	    
	    SET_VALID(I_ipRouteMask, ipRouteEntry->valid);
	    ipRouteEntry->ipRouteMask = get_majormask(ipRouteDest);
	    
#ifndef SUPPORT_ROUTE_METRIC_5
	    SET_VALID(I_ipRouteMetric5, ipRouteEntry->valid);
	    ipRouteEntry->ipRouteMetric5 = -1;
#endif

	    /*
	     * we currently don't support the creation of new ip route
	     * table entries
	     */
	    return (NO_CREATION_ERROR);
	}
	
    }
    

    switch (object->nominator) {
	
#ifdef I_ipRouteDest
    case I_ipRouteDest:
	
	/*
	 * NOTE: This variable must be supported.
	 * 
	 * For compatibility with MIB-I managers, if the length of ipRouteDest
	 * is 0 delete the row. Otherwise, insure the value matches the
	 * instance.
	 */

	if (value->os_value->length == 0) {	/* delete ? */
	    if (dp->state == ADD_MODIFY) {
		/* cannot delete a row that is being added or modified */
		return(INCONSISTENT_VALUE_ERROR);
	    }
	    dp->state = DELETE;
	    return (NO_ERROR);
	}

	if (value->os_value->length != 4) {	/* not IP ? */
	    return (WRONG_LENGTH_ERROR);
	}

	tmp_ip_addr = OctetStringToIP(value->os_value);

	if (tmp_ip_addr != ipRouteDest) {
	    return (WRONG_VALUE_ERROR);
	}

	/*
	 * no need to put the value in dp->data since, as the index,
	 * it has already been put there
	 */
	break;
#endif /* I_ipRouteDest */
	
#ifdef I_ipRouteIfIndex
    case I_ipRouteIfIndex:

	/*
	 * until we support creation, the new value must match the
	 * exisiting value
	 */
	if (ipRouteEntry->ipRouteIfIndex != value->sl_value)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_ipRouteIfIndex, ipRouteEntry->valid);
	
	ipRouteEntry->ipRouteIfIndex = value->sl_value;
	break;
#endif /* I_ipRouteIfIndex */
	
#ifdef I_ipRouteMetric1
    case I_ipRouteMetric1:

	/*
	 * until we support creation, the new value must match the
	 * exisiting value
	 */
	if (ipRouteEntry->ipRouteMetric1 != value->sl_value)
	    return (WRONG_VALUE_ERROR);

	/*
	 * The hop count, ipRouteMetric1, must be positive, zero if a
	 * direct-connection or non-zero otherwise.
	 */

#ifdef LATER
	val = value->sl_value;
	if (val < 0L) {
	    return (WRONG_VALUE_ERROR);
	}
	if ((route_type(ip_addr) == D_ipRouteType_direct && val != 0L) ||
	    (route_type(ip_addr) != D_ipRouteType_direct && val == 0L)) {

	    return (INCONSISTENT_VALUE_ERROR);
	}
#endif
	SET_VALID(I_ipRouteMetric1, ipRouteEntry->valid);
	
	ipRouteEntry->ipRouteMetric1 = value->sl_value;
	break;
#endif /* I_ipRouteMetric1 */
	
#ifdef I_ipRouteMetric2
    case I_ipRouteMetric2:
	
	/*
	 * until we support creation, the new value must match the
	 * exisiting value
	 */
	if (ipRouteEntry->ipRouteMetric2 != value->sl_value)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_ipRouteMetric2, ipRouteEntry->valid);
	
	ipRouteEntry->ipRouteMetric2 = value->sl_value;
	break;
#endif /* I_ipRouteMetric2 */
	
#ifdef I_ipRouteMetric3
    case I_ipRouteMetric3:
	
	/*
	 * until we support creation, the new value must match the
	 * exisiting value
	 */
	if (ipRouteEntry->ipRouteMetric3 != value->sl_value)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_ipRouteMetric3, ipRouteEntry->valid);
	
	ipRouteEntry->ipRouteMetric3 = value->sl_value;
	break;
#endif /* I_ipRouteMetric3 */
	
#ifdef I_ipRouteMetric4
    case I_ipRouteMetric4:
	
	/*
	 * until we support creation, the new value must match the
	 * exisiting value
	 */
	if (ipRouteEntry->ipRouteMetric4 != value->sl_value)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_ipRouteMetric4, ipRouteEntry->valid);
	
	ipRouteEntry->ipRouteMetric4 = value->sl_value;
	break;
#endif /* I_ipRouteMetric4 */
	
#ifdef I_ipRouteNextHop
    case I_ipRouteNextHop:
	
	/*
	 * For compatibility with MIB-I managers, If this value is 0 or of
	 * length 0, it is deleted. Otherwise it must be of length 4.
	 */

	if (value->os_value->length == 0) {	/* delete ? */
	    if (dp->state == ADD_MODIFY) {
		/* cannot delete a row that is being added or modified */
		return(INCONSISTENT_VALUE_ERROR);
	    }
	    dp->state = DELETE;
	    return (NO_ERROR);
	}

	if (value->os_value->length != 4) {	/* not IP ? */
	    return (WRONG_LENGTH_ERROR);
	}

	tmp_ip_addr = OctetStringToIP(value->os_value);

	if (tmp_ip_addr == 0L) {
	    if (dp->state == ADD_MODIFY) {
		/* cannot delete a row that is being added or modified */
		return(INCONSISTENT_VALUE_ERROR);
	    }
	    dp->state = DELETE;
	    return (NO_ERROR);
	}

	/*
	 * until we support creation, the new value must match the
	 * exisiting value
	 */
	if (ipRouteEntry->ipRouteNextHop != tmp_ip_addr)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_ipRouteNextHop, ipRouteEntry->valid);
	
	ipRouteEntry->ipRouteNextHop = tmp_ip_addr;
	break;
#endif /* I_ipRouteNextHop */
	
#ifdef I_ipRouteType
    case I_ipRouteType:
	
	/*
	 * If "invalid" then delete this row. Otherwise it must be
	 * "indirect."
	 */
	if (value->sl_value == D_ipRouteType_invalid) {
	    if (dp->state == ADD_MODIFY) {
		/* cannot delete a row that is being added or modified */
		return(INCONSISTENT_VALUE_ERROR);
	    }
	    dp->state = DELETE;
	    return (NO_ERROR);
	}

	/*
	 * until we support creation, the new value must match the
	 * exisiting value
	 */
	if (ipRouteEntry->ipRouteType != value->sl_value)
	    return (WRONG_VALUE_ERROR);


#ifdef LATER
	if (value->sl_value != D_ipRouteType_indirect) {
	    return (WRONG_VALUE_ERROR);
	}
#endif
	SET_VALID(I_ipRouteType, ipRouteEntry->valid);
	
	ipRouteEntry->ipRouteType = value->sl_value;
	break;
#endif /* I_ipRouteType */
	
#ifdef I_ipRouteAge
    case I_ipRouteAge:
	
	/*
	 * until we support creation, the new value must match the
	 * exisiting value
	 */
	if (ipRouteEntry->ipRouteAge != value->sl_value)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_ipRouteAge, ipRouteEntry->valid);
	
	ipRouteEntry->ipRouteAge = value->sl_value;
	break;
#endif /* I_ipRouteAge */
	
#ifdef I_ipRouteMask
    case I_ipRouteMask:
	
	if (value->os_value->length != 4) {
	    return (WRONG_LENGTH_ERROR);
	}

	tmp_ip_addr = OctetStringToIP(value->os_value);

	if (!good_route_mask(ipRouteDest, tmp_ip_addr, subnetzero_enable))
	    return(WRONG_VALUE_ERROR);

	/*
	 * until we support creation, the new value must match the
	 * exisiting value
	 */
	if (ipRouteEntry->ipRouteMask != tmp_ip_addr)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_ipRouteMask, ipRouteEntry->valid);
	ipRouteEntry->ipRouteMask = tmp_ip_addr;
	break;
#endif /* I_ipRouteMask */
	
#ifdef I_ipRouteMetric5
    case I_ipRouteMetric5:
	
	/*
	 * until we support creation, the new value must match the
	 * exisiting value
	 */
	if (ipRouteEntry->ipRouteMetric5 != value->sl_value)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_ipRouteMetric5, ipRouteEntry->valid);
	
	ipRouteEntry->ipRouteMetric5 = value->sl_value;
	break;
#endif /* I_ipRouteMetric5 */
	
    default:
	DPRINTF((0, "snmpd: Internal error (invalid nominator in ipRouteEntry)\n"));
	return (GEN_ERROR);
	
    }        /* switch */

    if (dp->state == DELETE) {
	/* hey, you can't modify a route that's being deleted */
	return (INCONSISTENT_VALUE_ERROR);
    }

    dp->state = ADD_MODIFY;
    
    return (NO_ERROR);
    
}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int 
ipRouteEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_ipRouteEntry_set((ipRouteEntry_t *) (doCur->data),
			       contextInfo, doCur->state));
}

#endif /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the ipNetToMediaEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *
ipNetToMediaEntry_get (
    OID             *incoming,
    ObjectInfo      *object,
    int             searchType,
    ContextInfo     *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void            *dp;
    ipNetToMediaEntry_t *data = NULL;
    unsigned long   buffer[5];
    OID             inst;
    int             carry;
    long            ipNetToMediaIfIndex;
    unsigned long   ipNetToMediaNetAddress;
    
    
    /*
     * Check the object instance.
     *
     * An EXACT search requires that the instance be of length 5 
     *
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */
    
    if (searchType == EXACT) {
	if (instLength != 5) {
	    return((VarBind *) NULL);
        }
        carry = 0;
    } else {
        carry = 1;
    }
    
    if ( (InstToIP(incoming, 1 + object->oid.length, &ipNetToMediaNetAddress, searchType, &carry)) < 0 ) {
	arg = -1;
    }
    
    if ( (InstToInt(incoming, 0 + object->oid.length, &ipNetToMediaIfIndex, searchType, &carry)) < 0 ) {
	arg = -1;
    }
    
    if (carry) {
	arg = -1;
    }
    
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ( (arg == -1) || (data = k_ipNetToMediaEntry_get(serialNum, contextInfo, arg ,searchType, ipNetToMediaIfIndex, ipNetToMediaNetAddress)) == NULL) {
        arg = -1;
    }
    
    else {
	/*
	 * Build instance information
	 */
        inst.oid_ptr = buffer;
        inst.length = 5;
        inst.oid_ptr[0] = data->ipNetToMediaIfIndex;
        inst.oid_ptr[1] = (data->ipNetToMediaNetAddress >> 24) & 0xff;
        inst.oid_ptr[2] = (data->ipNetToMediaNetAddress >> 16) & 0xff;
        inst.oid_ptr[3] = (data->ipNetToMediaNetAddress >> 8) & 0xff;
        inst.oid_ptr[4] = (data->ipNetToMediaNetAddress >> 0) & 0xff;
    }
    
    /*
     * Build the the variable binding for the variable that will be returned.
     */
    
    switch (arg) {
	
#ifdef I_ipNetToMediaIfIndex
    case I_ipNetToMediaIfIndex:
	dp = &data->ipNetToMediaIfIndex;
	break;
#endif /* I_ipNetToMediaIfIndex */
	
#ifdef I_ipNetToMediaPhysAddress
    case I_ipNetToMediaPhysAddress:
	dp = MakeOctetString(data->ipNetToMediaPhysAddress->octet_ptr, data->ipNetToMediaPhysAddress->length);
	break;
#endif /* I_ipNetToMediaPhysAddress */
	
#ifdef I_ipNetToMediaNetAddress
    case I_ipNetToMediaNetAddress:
	dp = MakeOctetString((unsigned char *) &data->ipNetToMediaNetAddress, 4L);
	break;
#endif /* I_ipNetToMediaNetAddress */
	
#ifdef I_ipNetToMediaType
    case I_ipNetToMediaType:
	dp = &data->ipNetToMediaType;
	break;
#endif /* I_ipNetToMediaType */
	
    default:
	return ((VarBind *) NULL);
	
    }      /* switch */
    
    return (MakeVarBind(object, &inst, dp));
    
}

#ifdef SETS 

/*----------------------------------------------------------------------
 * Free the ipNetToMediaEntry data object.
 *---------------------------------------------------------------------*/
void
ipNetToMediaEntry_free (ipNetToMediaEntry_t *data)
{
    if (data != NULL) {
	if (data->ipNetToMediaPhysAddress != NULL) {
	    FreeOctetString(data->ipNetToMediaPhysAddress);
	}
	free ((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after ipNetToMediaEntry set/undo
 *---------------------------------------------------------------------*/
static int
ipNetToMediaEntry_cleanup (doList_t *trash)
{
    ipNetToMediaEntry_free(trash->data);
#ifdef SR_SNMPv2
    ipNetToMediaEntry_free(trash->undodata);
#endif /* SR_SNMPv2 */
    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Undo a previous set of the ipNetToMediaEntry family.
 *---------------------------------------------------------------------*/
#ifdef SR_SNMPv2
int
ipNetToMediaEntry_undo (
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return UNDO_FAILED_ERROR;
}
#endif SR_SNMPv2

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int 
ipNetToMediaEntry_test (
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    doList_t       *dp;
    int            found;
    int            carry = 0;
    ipNetToMediaEntry_t     *ipNetToMediaEntry;
    long           ipNetToMediaIfIndex;
    unsigned long  ipNetToMediaNetAddress;
    unsigned long  tmp_ip_addr;

    /*
     * Validate the object instance
     *
     */
    
    if ( (InstToInt(incoming, 0 + object->oid.length, &ipNetToMediaIfIndex, EXACT, &carry)) < 0 ) {
	return(NO_CREATION_ERROR);
    }
    
    if ( (InstToIP(incoming, 1 + object->oid.length, &ipNetToMediaNetAddress, EXACT, &carry)) < 0 ) {
	return(NO_CREATION_ERROR);
    }

    if (ipNetToMediaIfIndex > nnets)
        return (WRONG_VALUE_ERROR);

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;
    
    for (dp = doHead; dp != NULL; dp = dp->next) { 
	if ( (dp->setMethod == ipNetToMediaEntry_set) &&
            (((ipNetToMediaEntry_t *) (dp->data)) != NULL) &&
            (((ipNetToMediaEntry_t *) (dp->data))->ipNetToMediaIfIndex == ipNetToMediaIfIndex) &&
            (((ipNetToMediaEntry_t *) (dp->data))->ipNetToMediaNetAddress == ipNetToMediaNetAddress) ) {
	    
            found = 1;
            break; 
        }
    }
    
    if (found) {
	ipNetToMediaEntry = dp->data;
    } else {
        dp = doCur;
        if ( (dp->data = malloc(sizeof(ipNetToMediaEntry_t))) == NULL) { 
            DPRINTF((0, "snmpd: Cannot allocate memory\n"));
            return (GEN_ERROR);
        }
        memset(dp->data, 0, sizeof(ipNetToMediaEntry_t));
	
        dp->setMethod = ipNetToMediaEntry_set;
        dp->cleanupMethod = ipNetToMediaEntry_cleanup;
#ifdef SR_SNMPv2
        dp->undoMethod = ipNetToMediaEntry_undo;
#endif /* SR_SNMPv2 */ 
        dp->state = UNKNOWN;
	
        /*
         * Try to fill in reasonable default values for this new entry.
         */
	
	ipNetToMediaEntry = k_ipNetToMediaEntry_get(-1, contextInfo, object->nominator, EXACT, ipNetToMediaIfIndex, ipNetToMediaNetAddress);

	if (ipNetToMediaEntry != NULL) {
            /* use existing values as default values */
            memcpy(dp->data, ipNetToMediaEntry, sizeof(ipNetToMediaEntry_t));
	    
            ((ipNetToMediaEntry_t *) (dp->data))->ipNetToMediaPhysAddress = 
		CloneOctetString(ipNetToMediaEntry->ipNetToMediaPhysAddress);
	    
	    ipNetToMediaEntry = dp->data;

            SET_ALL_VALID(ipNetToMediaEntry->valid);
	    
	}
	else {
	    ipNetToMediaEntry = dp->data;

	    SET_VALID(I_ipNetToMediaIfIndex, ipNetToMediaEntry->valid);
	    ipNetToMediaEntry->ipNetToMediaIfIndex = ipNetToMediaIfIndex;
	
	    SET_VALID(I_ipNetToMediaNetAddress, ipNetToMediaEntry->valid);
	    ipNetToMediaEntry->ipNetToMediaNetAddress = ipNetToMediaNetAddress;
	
	    /* we currently don't allow new rows to be created */
	    return (NO_CREATION_ERROR);
	}
    }
    
    switch (object->nominator) {
	
#ifdef I_ipNetToMediaIfIndex
    case I_ipNetToMediaIfIndex:

	if (value->sl_value != ipNetToMediaIfIndex)
	    return (WRONG_VALUE_ERROR);

	/*
	 * no need to put the value in dp->data since, as an index,
	 * it has already been put there
	 */

	break;
#endif /* I_ipNetToMediaIfIndex */
	
#ifdef I_ipNetToMediaPhysAddress
    case I_ipNetToMediaPhysAddress:
	/*
	 * until we support creation, the new value must match the
	 * existing value
	 */
	if (bcmp(value->os_value->octet_ptr,
		  ipNetToMediaEntry->ipNetToMediaPhysAddress->octet_ptr,
		  value->os_value->length) != 0)
	    return (WRONG_VALUE_ERROR);

#ifdef LATER
the following code will be required if we ever allow creation or modification

	SET_VALID(I_ipNetToMediaPhysAddress, ipNetToMediaEntry->valid);
	
	if (ipNetToMediaEntry->ipNetToMediaPhysAddress != NULL) {
	    FreeOctetString(ipNetToMediaEntry->ipNetToMediaPhysAddress);
	}
	
	ipNetToMediaEntry->ipNetToMediaPhysAddress = 
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);
#endif
	
	break;
#endif /* I_ipNetToMediaPhysAddress */
	
#ifdef I_ipNetToMediaNetAddress
    case I_ipNetToMediaNetAddress:

	if (value->os_value->length != 4) {	/* not IP ? */
	    return (WRONG_LENGTH_ERROR);
	}

	tmp_ip_addr = OctetStringToIP(value->os_value);

	if (tmp_ip_addr != ipNetToMediaNetAddress) {
	    return (WRONG_VALUE_ERROR);
	}

	/*
	 * no need to put the value in dp->data since, as an index,
	 * it has already been put there
	 */
	break;
#endif /* I_ipNetToMediaNetAddress */
	
#ifdef I_ipNetToMediaType
    case I_ipNetToMediaType:
        if (value->sl_value == D_ipNetToMediaType_invalid) {
            dp->state = DELETE;
            return (NO_ERROR);
        }

        if (value->sl_value != D_ipNetToMediaType_dynamic &&
            value->sl_value != D_ipNetToMediaType_static) {
            return (WRONG_VALUE_ERROR);
        }

	SET_VALID(I_ipNetToMediaType, ipNetToMediaEntry->valid);
	
	ipNetToMediaEntry->ipNetToMediaType = value->sl_value;
	break;
#endif /* I_ipNetToMediaType */
	
    default:
	DPRINTF((0, "snmpd: Internal error (invalid nominator in ipNetToMediaEntry)\n"));
	return (GEN_ERROR);
	
    }        /* switch */
    if (VALID(I_ipNetToMediaPhysAddress, ipNetToMediaEntry->valid))
	dp->state = ADD_MODIFY;
    
    return (NO_ERROR);
    
}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int 
ipNetToMediaEntry_set (
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_ipNetToMediaEntry_set((ipNetToMediaEntry_t *) (doCur->data),
				    contextInfo, doCur->state));
}

#endif /* SETS */






ip_t *
k_ip_get (
   int serialNum,
   ContextInfo *contextInfo,
   int nominator)
{
    static ip_t ipData;
    
    if (router_enable && ip_router_running)
	ipData.ipForwarding = D_ipForwarding_forwarding;
    else
	ipData.ipForwarding = D_ipForwarding_not_forwarding;
    
    ipData.ipDefaultTTL = ipdefaultparams.ttl;
    ipData.ipInReceives = ip_traffic.inputs;
    ipData.ipInHdrErrors = ip_traffic.formaterr + ip_traffic.checksumerr +
	ip_traffic.hopcount + ip_traffic.badsecure + ip_traffic.badoption;
    ipData.ipInAddrErrors = ip_traffic.notgateway;
    ipData.ipForwDatagrams = ip_traffic.forwarded;
    ipData.ipInUnknownProtos = ip_traffic.noprotocol;
    ipData.ipInDiscards = 0;
    ipData.ipInDelivers = ip_traffic.localdest;
    ipData.ipOutRequests = ip_traffic.outputs;
    ipData.ipOutDiscards = ip_traffic.encapsfailed;
    ipData.ipOutNoRoutes = ip_traffic.noroute;
    ipData.ipReasmTimeout = RATIMEOUT / ONESEC;
    ipData.ipReasmReqds = ip_traffic.rainputs;
    ipData.ipReasmOKs = ip_traffic.reassembled;
    ipData.ipReasmFails = ip_traffic.rafailed + ip_traffic.ratimeout;
    ipData.ipFragOKs = ip_traffic.fragged;
    ipData.ipFragFails = ip_traffic.fragfailed;
    ipData.ipFragCreates = ip_traffic.fragcount;
    ipData.ipRoutingDiscards = 0;
    
    return(&ipData);
}

int
k_ip_set (
   ip_t *data,
   ContextInfo *contextInfo,
   int function)
{
    if (VALID(I_ipForwarding, data->valid)) {
	switch (data->ipForwarding) {
	case D_ipForwarding_forwarding:
	    if (!ip_router_running)
		ip_routing(TRUE, FALSE);
	case D_ipForwarding_not_forwarding:
	    if (ip_router_running)
		ip_routing(FALSE, FALSE);
	}
    }
    
    if (VALID(I_ipDefaultTTL, data->valid)) {
	ipdefaultparams.ttl = data->ipDefaultTTL;
    }
    
    return (NO_ERROR);
    
}


idbtype *snmp_best_ip_idb(ulong *best_addr, 
			  ulong *best_mask,
			  int    searchType,
			  ulong  ipAdEntAddr)
{
    
    idbtype         *idb;
    idbtype         *best_idb;
    ipaddtype       *secondary_list_ptr;
    
    best_idb = NULL;
    *best_addr = 0;
    *best_mask = 0;
    
    FOR_ALL_SWIDBS(idb) {
	
	/*
	 * ignore if not an ip address
	 */
	if (!idb->ip_enabled || idb->ip_unnumbered)
	    continue;
	
	/*
	 * see if we've found the correct ip address (either request)
	 * or if we've found a candidate ip address (get-next request)
	 */

	if (((searchType == NEXT) && (idb->ip_address >= ipAdEntAddr)) ||
	    (idb->ip_address == ipAdEntAddr)) {

	    /*
	     * We want to save this match IFF
	     *     1)  this address is lower than previous candidate.
	     *     2)  best_idb is NULL (we don't already have a candidate)
	     * or  3)  It is GET request (then it must be an exact match)
	     */

	    if ((idb->ip_address < *best_addr) ||
		(searchType == EXACT) ||
		(best_idb == NULL)) {

		best_idb = idb;
		*best_addr = idb->ip_address;
		*best_mask = idb->ip_nets_mask;

		/*
		 * If we have an exact match, we are done.
		 */
		if (*best_addr == ipAdEntAddr)
		    return(best_idb);
	    }
	}

	/*
	 * scan the secondary addresses for a better match
	 */
        for (secondary_list_ptr = (ipaddtype *)idb->ip_addressQ.qhead;
	     secondary_list_ptr; 
	     secondary_list_ptr = secondary_list_ptr->next) { 
	    /*
	     * see if we've found the correct ip address (get request)
	     * or if we've found a candidate ip address (get-next request)
	     */
	    if (((searchType == NEXT) && 
		 (secondary_list_ptr->address >= ipAdEntAddr)) ||
		(secondary_list_ptr->address == ipAdEntAddr)) {
		/*
		 * We want to save this match if any of reasons 1, 2,
		 * or 3 above hold true.
		 */
		if ((secondary_list_ptr->address < *best_addr) ||
		    (searchType == EXACT) ||
		    (best_idb == NULL)) {
		    best_idb = idb;
		    *best_addr = secondary_list_ptr->address;
		    *best_mask = secondary_list_ptr->mask;
		    /*
		     * we can stop looking now if we have an exact match
		     * (this will only 'break' out of the secondary address
		     * lookup, hence must also check for an exact match upon
		     * exit from the loop)
		     * See above comment on why this test is same as:
		     * 	       if (*best_addr == ipAdEntAddr)
		     */
		    if (*best_addr == ipAdEntAddr)
			return(best_idb);
		}
	    }
	}
    }
    return(best_idb);
}


ipAddrEntry_t *
k_ipAddrEntry_get (
     int serialNum,
     ContextInfo *contextInfo,
     int nominator,
     int searchType,
     unsigned long ipAdEntAddr)
{
    
    idbtype         *best_idb;
    unsigned long    best_addr;
    unsigned long    best_mask;

    best_idb = snmp_best_ip_idb(&best_addr, &best_mask, searchType,
				ipAdEntAddr); 
    
    /*
     * return Mr. Null if we didn't find anything
     */
    if (best_idb == NULL)
	return(NULL);

    /*
     * otherwise fill out the entry data and return it
     */
    ipAddrEntryData.ipAdEntAddr = best_addr;
    if (best_idb->snmp_if_index) {
	ipAddrEntryData.ipAdEntIfIndex = best_idb->snmp_if_index;
    } else {
	ipAddrEntryData.ipAdEntIfIndex = best_idb->hwptr->snmp_if_index;
    }
    ipAddrEntryData.ipAdEntNetMask = best_mask;
    ipAddrEntryData.ipAdEntBcastAddr =
	best_idb->ip_broadcast & 1 ? TRUE : FALSE;
    ipAddrEntryData.ipAdEntReasmMaxSize = RABUFFERSIZE;
    
    return(&ipAddrEntryData);
}


ipRouteEntry_t *
k_ipRouteEntry_get (
   int serialNum,
   ContextInfo *contextInfo,
   int nominator,
   int searchType,
   unsigned long ipRouteDest)
{
    ndbtype  *ndb;
    rdbtype  *rdb;
    ulong     proctype;
    ulong     nexthop;
    boolean   default_route = FALSE;
    boolean   found;
    boolean   found_lexnext;

    found_lexnext = FALSE;

    /* no routes if we aren't routing */
    if (!ip_router_running)
	return (NULL);

    /* find the requested route */
    if (searchType == EXACT) {
	found = reg_invoke_iprouting_snmp_rtlookup_exact(ipRouteDest, &ndb,
							 &proctype,
							 &default_route);
    } else {
	ndb = malloc(sizeof(ndbtype));
	if (ndb == NULL)
	    return(NULL);
	found = reg_invoke_iprouting_snmp_rtlookup_lexnext(ipRouteDest, ndb,
							   &proctype,
							   &default_route);
	if (!found) {
	    free(ndb);
	} else {
	    found_lexnext = TRUE;
	}
    }
    if (!found)
	return (NULL);

    if (ndb->routecount != 0)
	rdb = ndb->rdb[0];
    else
	rdb = NULL;

    if (default_route) {
	ipRouteEntryData.ipRouteDest = 0;
	ipRouteEntryData.ipRouteMask = 0;
    } else {
	ipRouteEntryData.ipRouteDest = ndb->netnumber;
	ipRouteEntryData.ipRouteMask = ndb->netsmask;
    }

    if (rdb && rdb->idb) {
/*
 * Revisit this to fix the bug in recursive lookups of static routes.
 * NMT - 5/12/94
 */
	if (rdb->idb->snmp_if_index) {
	    ipRouteEntryData.ipRouteIfIndex = rdb->idb->snmp_if_index;
	} else {
	    ipRouteEntryData.ipRouteIfIndex = rdb->idb->hwptr->snmp_if_index;
	}

    } else if (ndb->lastinterface) {
	if (ndb->lastinterface->snmp_if_index) {
	    ipRouteEntryData.ipRouteIfIndex = 
		ndb->lastinterface->snmp_if_index;
	} else {
	    ipRouteEntryData.ipRouteIfIndex = 
		ndb->lastinterface->hwptr->snmp_if_index;
	}
    } else {
	ipRouteEntryData.ipRouteIfIndex = 0;
    }

    ipRouteEntryData.ipRouteMetric1 = ndb->metric;


    if ((proctype & PROC_IGRP) && rdb) {
	if (rdb->rdb_bandwidth !=0)
	    ipRouteEntryData.ipRouteMetric2 =
		SCALED_BANDWIDTH(rdb->rdb_bandwidth);
	else
	    ipRouteEntryData.ipRouteMetric2 = -1;
	ipRouteEntryData.ipRouteMetric3 = rdb->rdb_delay * 10;
	ipRouteEntryData.ipRouteMetric4 = rdb->hopcount;
	ipRouteEntryData.ipRouteMetric5 = rdb->reliability;
    } else {
	ipRouteEntryData.ipRouteMetric2 = -1;
	ipRouteEntryData.ipRouteMetric3 = -1;
	ipRouteEntryData.ipRouteMetric4 = -1;
	ipRouteEntryData.ipRouteMetric5 = -1;
    }
    if (rdb) {
	nexthop = rdb->gateway;
	if (nexthop == 0)
	    nexthop = rdb->idb->ip_address;
    } else if (ndb->lastgateway != 0L) {
	nexthop = ndb->lastgateway;
	if (nexthop == 0)
	    nexthop = ndb->lastinterface->ip_address;
    } else {
	nexthop = 0;
    }
    ipRouteEntryData.ipRouteNextHop = nexthop;

    if (ndb->attrflags & NET_ATTACHED)
	ipRouteEntryData.ipRouteType = D_ipRouteType_direct;
    else if (ndb->routecount == 0)
	ipRouteEntryData.ipRouteType = D_ipRouteType_invalid;
    else
	ipRouteEntryData.ipRouteType = D_ipRouteType_indirect;

    if (proctype & (PROC_CONNECTED | PROC_STATIC))
	ipRouteEntryData.ipRouteProto = D_ipRouteProto_local;
    else if (proctype & PROC_EGP)
	ipRouteEntryData.ipRouteProto = D_ipRouteProto_egp;
    else if (proctype & PROC_RIP)
	ipRouteEntryData.ipRouteProto = D_ipRouteProto_rip;
    else if (proctype & PROC_IGRP2)
	ipRouteEntryData.ipRouteProto = D_ipRouteProto_ciscoIgrp;
    else if (proctype & PROC_IGRP)
	ipRouteEntryData.ipRouteProto = D_ipRouteProto_ciscoIgrp;
    else if (proctype & PROC_BGP)
	ipRouteEntryData.ipRouteProto = D_ipRouteProto_bgp;
    else if (proctype & PROC_OSPF)
	ipRouteEntryData.ipRouteProto = D_ipRouteProto_ospf;
    else if (proctype & PROC_ISIS)
        ipRouteEntryData.ipRouteProto = D_ipRouteProto_is_is;
    else
	ipRouteEntryData.ipRouteProto = D_ipRouteProto_other;

    if (ndb->lastgateway)
	ipRouteEntryData.ipRouteAge = ELAPSED_TIME(ndb->nettimer) / ONESEC;
    else
	ipRouteEntryData.ipRouteAge = 0;

    ipRouteEntryData.ipRouteInfo = &nullOID;

    if (found_lexnext)
	free(ndb);

    return(&ipRouteEntryData);
}

int
k_ipRouteEntry_set (
   ipRouteEntry_t *data,
   ContextInfo *contextInfo,
   int function)
{
    if (function == DELETE) {
	if (!reg_invoke_iprouting_delete_route(data->ipRouteDest, 0))
	    return(GEN_ERROR);
    } else {
	/*
	 * must be add/modify which we currently don't support
	 * the test code has prevented this, so we just fall thru
	 */
    }
    return(NO_ERROR);
}


ipNetToMediaEntry_t *
k_ipNetToMediaEntry_get (
   int serialNum,
   ContextInfo *contextInfo,
   int nominator,
   int searchType,
   long ifIndex,
   unsigned long netAddress)
{
    arptype *arp;
    hwaddrtype *hwaddr;
    idbtype *currentidb;
    
    /* find the requested route */
    if (searchType == EXACT) {
	arp = find_exact_arp(ifIndex, netAddress, LINK_IP); 
    } else {
	arp = find_best_arp(ifIndex, netAddress, LINK_IP, TRUE);
    }
    if (arp == NULL)
	return (NULL);

    /* arp entry might be static - check if arp->idb is NULL */

    currentidb = arp->idb;
    if ((currentidb == NULL) || (currentidb->hwptr == NULL)) {
        if (arp->mode == ARP_STATIC) {
            /* 
             * See if ip address is on a directly connected net.
             * If not, get desparate - any interface will do 
             */
            currentidb = samecable(arp->address);
            if (currentidb == NULL) {
                currentidb = pick_defaultidb(arp->address);
            }
            if ((currentidb == NULL) || (currentidb->hwptr == NULL)) {
                return(NULL);
            }
        } else {
            return(NULL);
        }
    }

    if (currentidb->snmp_if_index) {
	ipNetToMediaEntryData.ipNetToMediaIfIndex = 
	    currentidb->snmp_if_index;
    } else {
	ipNetToMediaEntryData.ipNetToMediaIfIndex = 
	    currentidb->hwptr->snmp_if_index;
    }
    ipNetToMediaEntryData.ipNetToMediaPhysAddress =
	&ipNetToMediaPhysAddress;
    if (arp->hwtype == STATION_ATMVC) {
	hwaddr = reg_invoke_arp_getphysaddr(currentidb, arp->hardware);
	if (!hwaddr) {
	    ipNetToMediaPhysAddress.length = IEEEBYTES;
	    ipNetToMediaPhysAddress.octet_ptr = arp->hardware;
	} else {
	    ipNetToMediaPhysAddress.length = hwaddr->length;
	    ipNetToMediaPhysAddress.octet_ptr = hwaddr->addr;
	}
    } else {
	ipNetToMediaPhysAddress.length = IEEEBYTES;
	ipNetToMediaPhysAddress.octet_ptr = arp->hardware;
    }

    ipNetToMediaEntryData.ipNetToMediaNetAddress = arp->address;
    switch (arp->mode) {
    case ARP_DYNAMIC:
	ipNetToMediaEntryData.ipNetToMediaType = D_ipNetToMediaType_dynamic;
	break;
    case ARP_STATIC:
	ipNetToMediaEntryData.ipNetToMediaType = D_ipNetToMediaType_static;
	break;
    default:
	ipNetToMediaEntryData.ipNetToMediaType = D_ipNetToMediaType_other;
	break;
    }

    return(&ipNetToMediaEntryData);
}

int
k_ipNetToMediaEntry_set (
   ipNetToMediaEntry_t *data,
   ContextInfo *contextInfo,
   int function)
{
    if (function == DELETE) {
	remove_exact_arp(data->ipNetToMediaIfIndex,
			 data->ipNetToMediaNetAddress,
			 LINK_IP);
    } else {
	/*
	 * must be add/modify
	 * the test code has prevented this, so we just fall thru
	 */
    }
    return(NO_ERROR);
}


/*
 * ipmib2 subsystem header
 */

#define MAJVERSION_ipmib2 1
#define MINVERSION_ipmib2 0
#define EDITVERSION_ipmib2 0

SUBSYS_HEADER(ipmib2,
              MAJVERSION_ipmib2,
              MINVERSION_ipmib2,
              EDITVERSION_ipmib2,
              init_ipmib2,
              SUBSYS_CLASS_MANAGEMENT,
              "req: iphost atmib2",
              NULL);
      
