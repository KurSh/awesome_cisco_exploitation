/* $Id: sr_old_lipmib.c,v 3.4.10.4 1996/07/03 20:42:02 thille Exp $
 * $Source: /release/112/cvs/Xsys/ip/sr_old_lipmib.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * April 1994, Nicholas Thille (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1996-1997 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_old_lipmib.c,v $
 * Revision 3.4.10.4  1996/07/03  20:42:02  thille
 * CSCdi61860: Implement Jeffs glass of slim-fast for snmp
 * Branch: California_branch
 * Take hunk of common code from many mib files, make it a procedure in
 * snmp_util.c and call it from the mibs.  Save 1640 bytes.
 *
 * Revision 3.4.10.3  1996/07/01  18:44:50  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.4.10.2  1996/04/19  17:59:18  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.4.10.1  1996/04/04  05:33:47  mordock
 * CSCdi51613:  incorrect locIfReason in linkUp trap
 * Branch: California_branch
 * avoid consulting mib cache if request serialNum == -1, else cache might
 * be used when it really shouldn't be.
 *
 * Revision 3.4  1996/02/20  22:47:39  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.3  1995/12/14  08:25:05  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.2  1995/11/17  09:36:36  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  11:58:28  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.3  1995/09/11  23:49:35  hampton
 * Convert IP host and IP routing to fully use the passive timers macros
 * instead of referencing the system clock directly.  [CSCdi40085]
 *
 * Revision 2.2  1995/06/09 00:30:17  thille
 * CSCdi35549:  IP accounting entry caching for SNMP not working
 * Fix caching of IP accounting entries for both the current and
 * checkpoint tables.
 *
 * Revision 2.1  1995/06/07  21:01:06  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include "interface_private.h"
#include "packet.h"
#include "ip.h"
#include "ipaccount.h"
#include "../iprouting/route.h"

#include "../snmp/snmp_api.h"
#include "sr_old_lipmib.h"
#include "sr_old_lipmib-mib.h"

#include "sr_ipmib2.h"
#include "../ip/ip_registry.h"


void init_old_lipmib (void)
{
    load_mib(old_lipmib_OidList, old_lipmib_OidListNum);
    load_oid(old_lipmib_oid_table);
}








/*---------------------------------------------------------------------
 * Retrieve data from the lip family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *lip_get (OID         *incoming,
		  ObjectInfo  *object,
		  int          searchType,
		  ContextInfo *contextInfo,
		  int          serialNum)
{
    int    arg;
    void  *dp;
    lip_t *data = NULL;


    arg = snmp_scalar_instance(incoming, object, searchType);

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_lip_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_actThresh
      case I_actThresh:
	dp = &data->actThresh;
	break;
#endif				       /* I_actThresh */

#ifdef I_actLostPkts
      case I_actLostPkts:
	dp = &data->actLostPkts;
	break;
#endif				       /* I_actLostPkts */

#ifdef I_actLostByts
      case I_actLostByts:
	dp = &data->actLostByts;
	break;
#endif				       /* I_actLostByts */

#ifdef I_actAge
      case I_actAge:
	dp = &data->actAge;
	break;
#endif				       /* I_actAge */

#ifdef I_ckactAge
      case I_ckactAge:
	dp = &data->ckactAge;
	break;
#endif				       /* I_ckactAge */

#ifdef I_actCheckPoint
      case I_actCheckPoint:
	dp = &data->actCheckPoint;
	break;
#endif				       /* I_actCheckPoint */

#ifdef I_ipNoaccess
      case I_ipNoaccess:
	dp = &data->ipNoaccess;
	break;
#endif				       /* I_ipNoaccess */

      default:
	return (NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the lip data object.
 *---------------------------------------------------------------------*/
void lip_free (lip_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after lip set/undo
 *---------------------------------------------------------------------*/
static int lip_cleanup (doList_t *trash)
{
    lip_free(trash->data);
#ifdef SR_SNMPv2
    lip_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int lip_test(OID          *incoming,
	     ObjectInfo   *object,
	     ObjectSyntax *value,
	     doList_t     *doHead,
	     doList_t     *doCur,
	     ContextInfo  *contextInfo)
{
    int             instLength;
    doList_t       *dp;
    VarBind        *vb;
    int             found;
    int             carry;

    instLength = incoming->length - object->oid.length;
    vb = NULL;
    carry = 0;



    /*
     * Validate the object instance: 1) It must be of length 1  2) and the
     * instance must be 0.
     */
    if (instLength != 1 || incoming->oid_ptr[incoming->length - 1] != 0) {
	return (NO_CREATION_ERROR);
    }
    found = 0;

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(lip_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(lip_t));

	dp->setMethod = lip_set;
	dp->cleanupMethod = lip_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

    }
    switch (object->nominator) {

#ifdef I_actCheckPoint

      case I_actCheckPoint:

	if (value->sl_value != ip_checkpointvalue)
	    return(WRONG_VALUE_ERROR);

	SET_VALID(I_actCheckPoint, ((lip_t *) (dp->data))->valid);

	((lip_t *) (dp->data))->actCheckPoint = value->sl_value;
	break;
#endif				       /* I_actCheckPoint */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in lip_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int lip_set (doList_t    *doHead,
	     doList_t    *doCur,
	     ContextInfo *contextInfo)
{
    return (k_lip_set((lip_t *) (doCur->data),
		      contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the lipAddrEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *lipAddrEntry_get (OID         *incoming,
			   ObjectInfo  *object,
			   int          searchType,
			   ContextInfo *contextInfo,
			   int          serialNum)
{
    int             instLength;
    int             arg;
    void           *dp;
    lipAddrEntry_t *data;
    unsigned long   buffer[4];
    OID             inst;
    int             carry;
    unsigned long   ipAdEntAddr;

    instLength = incoming->length - object->oid.length;
    arg = object->nominator;
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 4
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 4) {
	    return (NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToIP(incoming, 0 + object->oid.length, &ipAdEntAddr, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_lipAddrEntry_get(serialNum, contextInfo, arg, searchType, ipAdEntAddr)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 4;
	inst.oid_ptr[0] = (data->ipAdEntAddr >> 24) & 0xff;
	inst.oid_ptr[1] = (data->ipAdEntAddr >> 16) & 0xff;
	inst.oid_ptr[2] = (data->ipAdEntAddr >> 8) & 0xff;
	inst.oid_ptr[3] = (data->ipAdEntAddr >> 0) & 0xff;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_locIPHow
      case I_locIPHow:
	dp = MakeOctetString(data->locIPHow->octet_ptr, data->locIPHow->length);
	break;
#endif				       /* I_locIPHow */

#ifdef I_locIPWho
      case I_locIPWho:
	dp = IPToOctetString(data->locIPWho);
	break;
#endif				       /* I_locIPWho */

#ifdef I_locIPHelper
      case I_locIPHelper:
	dp = IPToOctetString(data->locIPHelper);
	break;
#endif				       /* I_locIPHelper */

#ifdef I_locIPSecurity
      case I_locIPSecurity:
	dp = &data->locIPSecurity;
	break;
#endif				       /* I_locIPSecurity */

#ifdef I_locIPRedirects
      case I_locIPRedirects:
	dp = &data->locIPRedirects;
	break;
#endif				       /* I_locIPRedirects */

#ifdef I_locIPUnreach
      case I_locIPUnreach:
	dp = &data->locIPUnreach;
	break;
#endif				       /* I_locIPUnreach */

      default:
	return (NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the lipRouteEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *lipRouteEntry_get (OID         *incoming,
			    ObjectInfo  *object,
			    int          searchType,
			    ContextInfo *contextInfo,
			    int          serialNum)
{
    int             instLength;
    int             arg;
    void           *dp;
    lipRouteEntry_t *data;
    unsigned long   buffer[4];
    OID             inst;
    int             carry;
    unsigned long   ipRouteDest;

    instLength = incoming->length - object->oid.length;
    arg = object->nominator;
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 4
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 4) {
	    return (NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToIP(incoming, 0 + object->oid.length, &ipRouteDest, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_lipRouteEntry_get(serialNum, contextInfo, arg, searchType, ipRouteDest)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 4;
	inst.oid_ptr[0] = (data->ipRouteDest >> 24) & 0xff;
	inst.oid_ptr[1] = (data->ipRouteDest >> 16) & 0xff;
	inst.oid_ptr[2] = (data->ipRouteDest >> 8) & 0xff;
	inst.oid_ptr[3] = (data->ipRouteDest >> 0) & 0xff;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_locRtMask
      case I_locRtMask:
	dp = IPToOctetString(data->locRtMask);
	break;
#endif				       /* I_locRtMask */

#ifdef I_locRtCount
      case I_locRtCount:
	dp = &data->locRtCount;
	break;
#endif				       /* I_locRtCount */

#ifdef I_locRtUses
      case I_locRtUses:
	dp = &data->locRtUses;
	break;
#endif				       /* I_locRtUses */

      default:
	return (NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the lipAccountEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *lipAccountEntry_get (OID         *incoming,
			      ObjectInfo  *object,
			      int          searchType,
			      ContextInfo *contextInfo,
			      int          serialNum)
{
    int             instLength;
    int             arg;
    void           *dp;
    lipAccountEntry_t *data;
    unsigned long   buffer[8];
    OID             inst;
    int             carry;
    unsigned long   actSrc;
    unsigned long   actDst;

    instLength = incoming->length - object->oid.length;
    arg = object->nominator;
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 8
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 8) {
	    return (NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToIP(incoming, 4 + object->oid.length, &actDst, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToIP(incoming, 0 + object->oid.length, &actSrc, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_lipAccountEntry_get(serialNum, contextInfo, arg, searchType, actSrc, actDst)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 8;
	inst.oid_ptr[0] = (data->actSrc >> 24) & 0xff;
	inst.oid_ptr[1] = (data->actSrc >> 16) & 0xff;
	inst.oid_ptr[2] = (data->actSrc >> 8) & 0xff;
	inst.oid_ptr[3] = (data->actSrc >> 0) & 0xff;
	inst.oid_ptr[4] = (data->actDst >> 24) & 0xff;
	inst.oid_ptr[5] = (data->actDst >> 16) & 0xff;
	inst.oid_ptr[6] = (data->actDst >> 8) & 0xff;
	inst.oid_ptr[7] = (data->actDst >> 0) & 0xff;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_actSrc
      case I_actSrc:
	dp = IPToOctetString(data->actSrc);
	break;
#endif				       /* I_actSrc */

#ifdef I_actDst
      case I_actDst:
	dp = IPToOctetString(data->actDst);
	break;
#endif				       /* I_actDst */

#ifdef I_actPkts
      case I_actPkts:
	dp = &data->actPkts;
	break;
#endif				       /* I_actPkts */

#ifdef I_actByts
      case I_actByts:
	dp = &data->actByts;
	break;
#endif				       /* I_actByts */

#ifdef I_actViolation
      case I_actViolation:
	dp = &data->actViolation;
	break;
#endif				       /* I_actViolation */

      default:
	return (NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the lipCkAccountEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *lipCkAccountEntry_get (OID         *incoming,
				ObjectInfo  *object,
				int          searchType,
				ContextInfo *contextInfo,
				int          serialNum)
{
    int             instLength;
    int             arg;
    void           *dp;
    lipCkAccountEntry_t *data;
    unsigned long   buffer[8];
    OID             inst;
    int             carry;
    unsigned long   ckactSrc;
    unsigned long   ckactDst;

    instLength = incoming->length - object->oid.length;
    arg = object->nominator;
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 8
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 8) {
	    return (NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToIP(incoming, 4 + object->oid.length, &ckactDst, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToIP(incoming, 0 + object->oid.length, &ckactSrc, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_lipCkAccountEntry_get(serialNum, contextInfo, arg, searchType, ckactSrc, ckactDst)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 8;
	inst.oid_ptr[0] = (data->ckactSrc >> 24) & 0xff;
	inst.oid_ptr[1] = (data->ckactSrc >> 16) & 0xff;
	inst.oid_ptr[2] = (data->ckactSrc >> 8) & 0xff;
	inst.oid_ptr[3] = (data->ckactSrc >> 0) & 0xff;
	inst.oid_ptr[4] = (data->ckactDst >> 24) & 0xff;
	inst.oid_ptr[5] = (data->ckactDst >> 16) & 0xff;
	inst.oid_ptr[6] = (data->ckactDst >> 8) & 0xff;
	inst.oid_ptr[7] = (data->ckactDst >> 0) & 0xff;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ckactSrc
      case I_ckactSrc:
	dp = IPToOctetString(data->ckactSrc);
	break;
#endif				       /* I_ckactSrc */

#ifdef I_ckactDst
      case I_ckactDst:
	dp = IPToOctetString(data->ckactDst);
	break;
#endif				       /* I_ckactDst */

#ifdef I_ckactPkts
      case I_ckactPkts:
	dp = &data->ckactPkts;
	break;
#endif				       /* I_ckactPkts */

#ifdef I_ckactByts
      case I_ckactByts:
	dp = &data->ckactByts;
	break;
#endif				       /* I_ckactByts */

#ifdef I_ckactViolation
      case I_ckactViolation:
	dp = &data->ckactViolation;
	break;
#endif				       /* I_ckactViolation */

      default:
	return (NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}


/*
 **********************************************************************
 *
 * KERNEL CODE begins here.  Above is all generated by SNMP Research
 * compiler.  Below code does the real work in getting the router
 * information.  
 *
 * First come the utility helper routines.
 *
 **********************************************************************
 */

/*
 * greater_acctg_entry - returns TRUE if src1,dst1 is greater than
 * src2,dst2. 
 */

static inline boolean greater_acctg_entry (ulong src1, 
				    ulong dst1, 
				    ulong src2, 
				    ulong dst2)
{
    if (src1 > src2)
	return(TRUE);

    if ((src1 == src2) &&
	(dst1 > dst2))
	return(TRUE);

    return(FALSE);
}

/*
 * lesser_acctg_entry - returns TRUE if src1,dst1 is less than
 * src2,dst2. 
 */

static inline boolean lesser_acctg_entry (ulong src1,
				   ulong dst1,
				   ulong src2, 
				   ulong dst2)
{
    if (src1 < src2)
	return(TRUE);

    if ((src1 == src2) &&
	(dst1 < dst2))
	return(TRUE);

    return(FALSE);
}

/*
 * snmp_ip_acct_get
 * Get an IP accounting entry 
 *
 * Takes pointer to ip accounting database, src & dst for indices, and
 * next to tell whether getnext or get.  
 * Returns NULL if ip accounting is not enabled, the ip accounting
 * database passed in is NULL, or no matching entry is found.
 */

static ip_acctg_entry_type *snmp_ip_acctg_get (ip_acctg_data_type *ip_acctg_db,
				        ulong               actSrc,
				        ulong               actDst,
				        boolean             next)

{
    ipaddrtype src, dst;
    ip_acctg_entry_type *tmp_entry, *best_entry;
    long i;

    if ((!ip_acctg_on) || (ip_acctg_db == NULL))
	return(NULL);

    src = (ipaddrtype)actSrc;
    dst = (ipaddrtype)actDst;
    tmp_entry = NULL;
    best_entry = NULL;

    if (!next) {
	i = src;
	i ^= dst;
	i ^= (i >> 16);
	i ^= (i >> 8);
	i &= 0xff;
    } else
	i = 0;

    for ( ; i < IPACCTGARRAYSIZE; i++) {
	tmp_entry = ip_acctg_db->store[i];
	while (tmp_entry) {
	    if ((tmp_entry->srcadr == src) && (tmp_entry->dstadr == dst)) {
		return(tmp_entry);
	    } else {
		if (next) {
		    if (best_entry == NULL) {
			if (greater_acctg_entry(tmp_entry->srcadr,
						tmp_entry->dstadr, src, dst))
			    best_entry = tmp_entry;
		    } else {
			if (greater_acctg_entry(tmp_entry->srcadr,
						tmp_entry->dstadr, src,
						dst) &&
			    lesser_acctg_entry(tmp_entry->srcadr,
					       tmp_entry->dstadr,
					       best_entry->srcadr,  
					       best_entry->dstadr))
			    best_entry = tmp_entry;
		    }
		}
	    }
	    tmp_entry = tmp_entry->next;
	}
    }
    return(best_entry);
}

lip_t *k_lip_get (int             serialNum,
		  ContextInfo    *contextInfo,
		  int             nominator)
{
    static lip_t    lipData;

    lipData.actThresh = ip_acctg_info.threshold;
    if (ip_acctg_info.current == NULL) {
	lipData.actLostPkts = 0;
	lipData.actLostByts = 0;
	lipData.actAge = 0;
    } else {
	lipData.actLostPkts = ip_acctg_info.current->packets_tossed;
	lipData.actLostByts = ip_acctg_info.current->bytes_tossed;
	lipData.actAge = ELAPSED_TIME(ip_acctg_info.current->when)/10;
    }
    if (ip_acctg_info.backup == NULL) {
	lipData.ckactAge = 0;
    } else {
	lipData.ckactAge = ELAPSED_TIME(ip_acctg_info.backup->when)/10;
    }
    lipData.actCheckPoint = ip_checkpointvalue;
    lipData.ipNoaccess = accessfailcnt;

    return (&lipData);
}


#ifdef SETS

int k_lip_set(lip_t       *data,
	      ContextInfo *contextInfo,
	      int          function)
{
    if (VALID(I_actCheckPoint, data->valid)) {
	    ip_checkpointvalue++;
	    clear_ip_accounting_func(FALSE);
        }
    return (NO_ERROR);
}

#endif				       /* SETS */


lipAddrEntry_t *k_lipAddrEntry_get (int            serialNum,
				    ContextInfo   *contextInfo,
				    int            nominator,
				    int            searchType,
				    unsigned long  ipAdEntAddr)
{
    static lipAddrEntry_t lipAddrEntryData;
    static OctetString    locIPHow;

    idbtype         *best_idb;
    unsigned long    best_addr;
    unsigned long    best_mask;
    ipaddtype       *ptr;

    best_idb = snmp_best_ip_idb(&best_addr, &best_mask, searchType,
				ipAdEntAddr); 

    if (best_idb == NULL)
	return(NULL);

    lipAddrEntryData.locIPHow = &locIPHow;
    lipAddrEntryData.locIPHow->octet_ptr = (uchar *)ip_resolvestr(best_idb);
    lipAddrEntryData.locIPHow->length = 
            strlen((char*)lipAddrEntryData.locIPHow->octet_ptr); 

    lipAddrEntryData.locIPWho = (ulong)best_idb->ip_resolvehost;
    if (best_idb->ip_helpernetQ.qhead) {
	ptr = (ipaddtype *) best_idb->ip_helpernetQ.qhead;
	lipAddrEntryData.locIPHelper = ptr->address;
    } else {
	lipAddrEntryData.locIPHelper = 0L;
    }
    lipAddrEntryData.locIPSecurity = (!best_idb->ip_sec_default);
    lipAddrEntryData.locIPRedirects = best_idb->ip_redirect;
    lipAddrEntryData.locIPUnreach = best_idb->ip_unreach;
    lipAddrEntryData.locIPUnreach = best_idb->ip_unreach;
    lipAddrEntryData.ipAdEntAddr = best_addr;

    return (&lipAddrEntryData);
}


lipRouteEntry_t *k_lipRouteEntry_get (int            serialNum,
				      ContextInfo   *contextInfo,
				      int            nominator,
				      int            searchType,
				      unsigned long  ipRouteDest)
{
    ulong proctype;
    static lipRouteEntry_t lipRouteEntryData;
    boolean found;
    boolean found_lexnext;

    ndbtype *ndb;
    boolean  default_route = FALSE;

    /* no routes if we aren't routing */
    if (!ip_router_running)
	return (NULL);

    found_lexnext = FALSE;

    /* find the requested route */
    if (searchType == EXACT) {
	found = reg_invoke_iprouting_snmp_rtlookup_exact(ipRouteDest, &ndb,
							 &proctype,
							 &default_route);
    } else {
	ndb = malloc(sizeof(ndbtype));
	if (ndb == NULL)
	    return(NULL);
	found = reg_invoke_iprouting_snmp_rtlookup_lexnext(ipRouteDest, ndb,
							   &proctype,
							   &default_route);
	if (!found) {
	    free(ndb);
	} else {
	    found_lexnext = TRUE;
	}
    }
    if (!found)
	return (NULL);

    if (default_route)
	lipRouteEntryData.locRtMask = 0L;
    else
	lipRouteEntryData.locRtMask = ndb->netsmask;

    lipRouteEntryData.locRtCount = ndb->routecount;

    lipRouteEntryData.locRtUses = 0L;

    if (default_route) {
        lipRouteEntryData.ipRouteDest = 0;
    } else {
        lipRouteEntryData.ipRouteDest = ndb->netnumber;
    }

    if (found_lexnext)
	free(ndb);

    return (&lipRouteEntryData);
}


lipAccountEntry_t *k_lipAccountEntry_get (int            serialNum,
					  ContextInfo   *contextInfo,
					  int            nominator,
					  int            searchType,
					  unsigned long  actSrc,
					  unsigned long  actDst)
{
/*
 * this isn't the most optimal way to do this, but it most easily fits in
 * the framework of the SR mib compiler.  I'll probably optimize this at
 * a later date  --jeff
 *
 * Above comment stolen from ifmib2, along with the way the code is
 * implemented.  I'll need to steal the optimization as well.  -Nick
 */
    static int lastserial = MAXINT;
    static long lastactSrc = MAXLONG;
    static long lastactDst = MAXLONG;
    static lipAccountEntry_t  lipAccountEntryData;

    ip_acctg_entry_type      *acctg_entry;
    leveltype status;

   /*
    * See if we got a cache hit.
    */
   if ((serialNum != -1) && (serialNum == lastserial) &&
       (lastactSrc == actSrc) && (lastactDst == actDst)) {
       /* hit cache */
       return(&lipAccountEntryData);
   }

    /* missed cache, store info for next cache hit */
    lastserial = serialNum;
    lastactSrc = actSrc;
    lastactDst = actDst;

    acctg_entry = snmp_ip_acctg_get(ip_acctg_info.current, actSrc,
				    actDst, (searchType == NEXT));

    if (acctg_entry == NULL)
	return(NULL);

    /* 
     * Okay, we have an accounting entry.  Turn off interrupts while
     * copying values so it is consistent.
     */
    status = raise_interrupt_level(NETS_DISABLE);
    lipAccountEntryData.actSrc = acctg_entry->srcadr;
    lipAccountEntryData.actDst = acctg_entry->dstadr;
    lipAccountEntryData.actPkts = acctg_entry->packets;
    lipAccountEntryData.actByts = acctg_entry->bytes;
    lipAccountEntryData.actViolation = acctg_entry->access_violation;
    reset_interrupt_level(status);

    return (&lipAccountEntryData);
}


lipCkAccountEntry_t *k_lipCkAccountEntry_get (int            serialNum,
					      ContextInfo   *contextInfo,
					      int            nominator,
					      int            searchType,
					      unsigned long  ckactSrc,
					      unsigned long  ckactDst)
{

/*
 * this isn't the most optimal way to do this, but it most easily fits in
 * the framework of the SR mib compiler.  I'll probably optimize this at
 * a later date  --jeff
 *
 * Above comment stolen from ifmib2, along with the way the code is
 * implemented.  I'll need to steal the optimization as well.  -Nick
 */
    static int lastserial = MAXINT;
    static long lastckactSrc = MAXLONG;
    static long lastckactDst = MAXLONG;
    static lipCkAccountEntry_t  lipCkAccountEntryData;

    ip_acctg_entry_type        *acctg_entry;

    /*
     * See if we got a cache hit.
     */
    
    if ((serialNum != -1) && (serialNum == lastserial) &&
	(lastckactSrc == ckactSrc) && (lastckactDst == ckactDst)) {
	/* hit cache */
	return(&lipCkAccountEntryData);
    }

    /* missed cache, store info for next cache hit */
    lastserial = serialNum;
    lastckactSrc = ckactSrc;
    lastckactDst = ckactDst;

    acctg_entry = snmp_ip_acctg_get(ip_acctg_info.backup, ckactSrc,
				    ckactDst, (searchType == NEXT));

    if (acctg_entry == NULL)
	return(NULL);

    lipCkAccountEntryData.ckactSrc = acctg_entry->srcadr;
    lipCkAccountEntryData.ckactDst = acctg_entry->dstadr;
    lipCkAccountEntryData.ckactPkts = acctg_entry->packets;
    lipCkAccountEntryData.ckactByts = acctg_entry->bytes;
    lipCkAccountEntryData.ckactViolation = acctg_entry->access_violation;

    return (&lipCkAccountEntryData);
}
      
