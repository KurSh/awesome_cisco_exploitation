/* $Id: sr_igmpmib.c,v 3.6.8.5 1996/08/13 14:52:56 tylin Exp $
 * $Source: /release/112/cvs/Xsys/ipmulticast/sr_igmpmib.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * November 1994, Dino Farinacci (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1994-1997 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_igmpmib.c,v $
 * Revision 3.6.8.5  1996/08/13  14:52:56  tylin
 * CSCdi61338:  ATM LEC sub-interf missing from PIM-MIB
 *    Incorporate with new ifmib_swidb_get() supporting function.
 * Branch: California_branch
 *
 * Revision 3.6.8.4  1996/07/01  18:44:53  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.6.8.3  1996/05/21  09:52:23  thille
 * CSCdi51599:  multiple /interface/ literals bloat code.
 * Branch: California_branch
 * Save another 392 bytes by doing away with duplicate literals.
 *
 * Revision 3.6.8.2  1996/05/21  06:33:05  mordock
 * Branch: California_branch
 * Improve snmp modularity via creating services to register interfaces
 * and chassis cards.
 * Add syslog mib.
 *
 * Revision 3.6.8.1  1996/04/19  18:40:35  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.6  1996/02/29  20:43:18  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.5  1996/01/18  15:49:12  anke
 * CSCdi46969:  Change empty req and/or seq strings in SUBSYS_HEADERs to
 *              NULL
 *              Five bytes saved is five bytes earned
 *
 * Revision 3.4  1995/12/14  08:25:31  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.3  1995/11/30  04:42:18  mleelani
 * CSCdi44573:  IGMP doesnt process leave messages
 * o Add support for leave messages.
 * o Create idb sub-block for IGMP; use managed timers for IGMP timers.
 *
 * Revision 3.2  1995/11/17  17:30:25  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  12:01:56  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.4  1995/07/24  07:33:54  hampton
 * Transition IP Multicast support to use the passive timer macros for all
 * its timers.  It no longer references the system clock directly.
 * [CSCdi37539]
 *
 * Revision 2.3  1995/07/17 07:32:52  bchan
 * CSCdi34760:  Ifindex usage incorrect
 *
 * Revision 2.2  1995/06/28  09:27:13  smackie
 * Repair widespread subsystem header braindamage. (CSCdi23568)
 *
 *   o Fix subsystem entry points to be foo(subsystype *) not foo(void)
 *   o Repair nonsensical and redundant subsystem sequences
 *   o Use NULL where no property is required
 *
 * Revision 2.1  1995/06/07  21:04:34  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include "../h/mgd_timers.h"
#include "../ui/common_strings.h"
#include "subsys.h"
#include "packet.h"
#include "interface_private.h"
#include "../snmp/snmp_api.h"
#include "sr_igmpmib.h"
#include "sr_igmpmib-mib.h"
#include "../ip/ip.h"
#include "snmp_interface.h"
#include "../ipmulticast/igmp.h"
#include "../snmp/ifmibapi.h"

void
init_igmpmib (subsystype *subsys)
{
    load_mib(igmpmib_OidList, igmpmib_OidListNum);
    load_oid(igmpmib_oid_table);
}









/*---------------------------------------------------------------------
 * Retrieve data from the igmpInterfaceEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
igmpInterfaceEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    igmpInterfaceEntry_t *data = NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            igmpInterfaceIfIndex;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &igmpInterfaceIfIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_igmpInterfaceEntry_get(serialNum, contextInfo, arg, searchType, igmpInterfaceIfIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->igmpInterfaceIfIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_igmpInterfaceQueryInterval
      case I_igmpInterfaceQueryInterval:
	dp = &data->igmpInterfaceQueryInterval;
	break;
#endif				       /* I_igmpInterfaceQueryInterval */

#ifdef I_igmpInterfaceStatus
      case I_igmpInterfaceStatus:
	dp = &data->igmpInterfaceStatus;
	break;
#endif				       /* I_igmpInterfaceStatus */

#ifdef I_igmpInterfaceVersion
    case I_igmpInterfaceVersion:
       dp = &data->igmpInterfaceVersion;
       break;
#endif /* I_igmpInterfaceVersion */

#ifdef I_igmpInterfaceQuerier
    case I_igmpInterfaceQuerier:
       dp = IPToOctetString(data->igmpInterfaceQuerier);
       break;
#endif /* I_igmpInterfaceQuerier */

#ifdef I_igmpInterfaceQueryMaxResponseTime
    case I_igmpInterfaceQueryMaxResponseTime:
       dp = &data->igmpInterfaceQueryMaxResponseTime;
       break;
#endif /* I_igmpInterfaceQueryMaxResponseTime */

#ifdef I_igmpInterfaceQuerierPresentTimeout
    case I_igmpInterfaceQuerierPresentTimeout:
       dp = &data->igmpInterfaceQuerierPresentTimeout;
       break;
#endif /* I_igmpInterfaceQuerierPresentTimeout */

#ifdef I_igmpInterfaceLeaveEnabled
    case I_igmpInterfaceLeaveEnabled:
       dp = &data->igmpInterfaceLeaveEnabled;
       break;
#endif /* I_igmpInterfaceLeaveEnabled */

#ifdef I_igmpInterfaceVersion1QuerierTimer
    case I_igmpInterfaceVersion1QuerierTimer:
       dp = &data->igmpInterfaceVersion1QuerierTimer;
       break;
#endif /* I_igmpInterfaceVersion1QuerierTimer */

#ifdef I_igmpInterfaceWrongVersionQueries
    case I_igmpInterfaceWrongVersionQueries:
       dp = &data->igmpInterfaceWrongVersionQueries;
       break;
#endif /* I_igmpInterfaceWrongVersionQueries */

#ifdef I_igmpInterfaceJoins
    case I_igmpInterfaceJoins:
       dp = &data->igmpInterfaceJoins;
       break;
#endif /* I_igmpInterfaceJoins */

#ifdef I_igmpInterfaceLeaves
    case I_igmpInterfaceLeaves:
       dp = &data->igmpInterfaceLeaves;
       break;
#endif /* I_igmpInterfaceLeaves */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the igmpInterfaceEntry data object.
 *---------------------------------------------------------------------*/
void
igmpInterfaceEntry_free(igmpInterfaceEntry_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after igmpInterfaceEntry set/undo
 *---------------------------------------------------------------------*/
static int
igmpInterfaceEntry_cleanup(doList_t *trash)
{
    igmpInterfaceEntry_free(trash->data);
#ifdef SR_SNMPv2
    igmpInterfaceEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
igmpInterfaceEntry_test(incoming, object, value, doHead, doCur, contextInfo)
    OID            *incoming;
    ObjectInfo     *object;
    ObjectSyntax   *value;
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int             found;
    int             carry = 0;
    igmpInterfaceEntry_t *igmpInterfaceEntry;
    long            igmpInterfaceIfIndex;

    /*
     * Validate the object instance
     * 
     */
    if (instLength != 1) {
	return NO_CREATION_ERROR;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &igmpInterfaceIfIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    igmpInterfaceEntry = k_igmpInterfaceEntry_get(-1, contextInfo, object->nominator, EXACT, igmpInterfaceIfIndex);

#ifndef igmpInterfaceEntry_READ_CREATE

    if (igmpInterfaceEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* igmpInterfaceEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == igmpInterfaceEntry_set) &&
	    (((igmpInterfaceEntry_t *) (dp->data)) != NULL) &&
	    (((igmpInterfaceEntry_t *) (dp->data))->igmpInterfaceIfIndex == igmpInterfaceIfIndex)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(igmpInterfaceEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(igmpInterfaceEntry_t));

	dp->setMethod = igmpInterfaceEntry_set;
	dp->cleanupMethod = igmpInterfaceEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_igmpInterfaceIfIndex, ((igmpInterfaceEntry_t *) (dp->data))->valid);
	((igmpInterfaceEntry_t *) (dp->data))->igmpInterfaceIfIndex = igmpInterfaceIfIndex;

#ifdef igmpInterfaceEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (igmpInterfaceEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, igmpInterfaceEntry, sizeof(igmpInterfaceEntry_t));

	    SET_ALL_VALID(((igmpInterfaceEntry_t *) (dp->data))->valid);

	} else {


	    /* Fill in default values here */


	}
#endif				       /* igmpInterfaceEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_igmpInterfaceQueryInterval
      case I_igmpInterfaceQueryInterval:

	SET_VALID(I_igmpInterfaceQueryInterval, ((igmpInterfaceEntry_t *) (dp->data))->valid);

	((igmpInterfaceEntry_t *) (dp->data))->igmpInterfaceQueryInterval = value->sl_value;
	break;
#endif				       /* I_igmpInterfaceQueryInterval */

#ifdef I_igmpInterfaceStatus
      case I_igmpInterfaceStatus:

	SET_VALID(I_igmpInterfaceStatus, ((igmpInterfaceEntry_t *) (dp->data))->valid);

	((igmpInterfaceEntry_t *) (dp->data))->igmpInterfaceStatus = value->sl_value;
	break;
#endif				       /* I_igmpInterfaceStatus */

#ifdef I_igmpInterfaceVersion
   case I_igmpInterfaceVersion:

     if ((value->sl_value < 1) || (value->sl_value > 2)) {
         return WRONG_VALUE_ERROR;
     }

     ((igmpInterfaceEntry_t *) (dp->data))->igmpInterfaceVersion = value->sl_value;
     break;
#endif /* I_igmpInterfaceVersion */

#ifdef I_igmpInterfaceQueryMaxResponseTime
   case I_igmpInterfaceQueryMaxResponseTime:

     ((igmpInterfaceEntry_t *) (dp->data))->igmpInterfaceQueryMaxResponseTime = value->sl_value;
     break;
#endif /* I_igmpInterfaceQueryMaxResponseTime */

#ifdef I_igmpInterfaceQuerierPresentTimeout
   case I_igmpInterfaceQuerierPresentTimeout:

     ((igmpInterfaceEntry_t *) (dp->data))->igmpInterfaceQuerierPresentTimeout = value->sl_value;
     break;
#endif /* I_igmpInterfaceQuerierPresentTimeout */

#ifdef I_igmpInterfaceLeaveEnabled
   case I_igmpInterfaceLeaveEnabled:

     if ((value->sl_value < 1) || (value->sl_value > 2)) {
         return WRONG_VALUE_ERROR;
     }

     ((igmpInterfaceEntry_t *) (dp->data))->igmpInterfaceLeaveEnabled = value->sl_value;
     break;
#endif /* I_igmpInterfaceLeaveEnabled */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in igmpInterfaceEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
igmpInterfaceEntry_set(doHead, doCur, contextInfo)
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    return (k_igmpInterfaceEntry_set((igmpInterfaceEntry_t *) (doCur->data),
				     contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the igmpCacheEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
igmpCacheEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    igmpCacheEntry_t *data = NULL;
    unsigned long   buffer[5];
    OID             inst;
    int             carry;
    unsigned long   igmpCacheAddress;
    long            igmpCacheIfIndex;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 5
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 5) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 4 + object->oid.length, &igmpCacheIfIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToIP(incoming, 0 + object->oid.length, &igmpCacheAddress, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_igmpCacheEntry_get(serialNum, contextInfo, arg, searchType, igmpCacheAddress, igmpCacheIfIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 5;
	inst.oid_ptr[0] = (data->igmpCacheAddress >> 24) & 0xff;
	inst.oid_ptr[1] = (data->igmpCacheAddress >> 16) & 0xff;
	inst.oid_ptr[2] = (data->igmpCacheAddress >> 8) & 0xff;
	inst.oid_ptr[3] = (data->igmpCacheAddress >> 0) & 0xff;
	inst.oid_ptr[4] = data->igmpCacheIfIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_igmpCacheSelf
      case I_igmpCacheSelf:
	dp = &data->igmpCacheSelf;
	break;
#endif				       /* I_igmpCacheSelf */

#ifdef I_igmpCacheLastReporter
      case I_igmpCacheLastReporter:
	dp = IPToOctetString(data->igmpCacheLastReporter);
	break;
#endif				       /* I_igmpCacheLastReporter */

#ifdef I_igmpCacheUpTime
      case I_igmpCacheUpTime:
	dp = &data->igmpCacheUpTime;
	break;
#endif				       /* I_igmpCacheUpTime */

#ifdef I_igmpCacheExpiryTime
      case I_igmpCacheExpiryTime:
	dp = &data->igmpCacheExpiryTime;
	break;
#endif				       /* I_igmpCacheExpiryTime */

#ifdef I_igmpCacheStatus
      case I_igmpCacheStatus:
	dp = &data->igmpCacheStatus;
	break;
#endif				       /* I_igmpCacheStatus */

#ifdef I_igmpCacheVersion1HostTimer
    case I_igmpCacheVersion1HostTimer:
       dp = &data->igmpCacheVersion1HostTimer;
       break;
#endif /* I_igmpCacheVersion1HostTimer */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the igmpCacheEntry data object.
 *---------------------------------------------------------------------*/
void
igmpCacheEntry_free(igmpCacheEntry_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after igmpCacheEntry set/undo
 *---------------------------------------------------------------------*/
static int
igmpCacheEntry_cleanup(doList_t *trash)
{
    igmpCacheEntry_free(trash->data);
#ifdef SR_SNMPv2
    igmpCacheEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
igmpCacheEntry_test(incoming, object, value, doHead, doCur, contextInfo)
    OID            *incoming;
    ObjectInfo     *object;
    ObjectSyntax   *value;
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int             found;
    int             carry = 0;
    igmpCacheEntry_t *igmpCacheEntry;
    unsigned long   igmpCacheAddress;
    long            igmpCacheIfIndex;

    /*
     * Validate the object instance
     * 
     */
    if (instLength != 5) {
	return NO_CREATION_ERROR;
    }
    if ((InstToIP(incoming, 0 + object->oid.length, &igmpCacheAddress, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, 4 + object->oid.length, &igmpCacheIfIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    igmpCacheEntry = k_igmpCacheEntry_get(-1, contextInfo, object->nominator, EXACT, igmpCacheAddress, igmpCacheIfIndex);

#ifndef igmpCacheEntry_READ_CREATE

    if (igmpCacheEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* igmpCacheEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == igmpCacheEntry_set) &&
	    (((igmpCacheEntry_t *) (dp->data)) != NULL) &&
	    (((igmpCacheEntry_t *) (dp->data))->igmpCacheAddress == igmpCacheAddress) &&
	    (((igmpCacheEntry_t *) (dp->data))->igmpCacheIfIndex == igmpCacheIfIndex)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(igmpCacheEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(igmpCacheEntry_t));

	dp->setMethod = igmpCacheEntry_set;
	dp->cleanupMethod = igmpCacheEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_igmpCacheAddress, ((igmpCacheEntry_t *) (dp->data))->valid);
	((igmpCacheEntry_t *) (dp->data))->igmpCacheAddress = igmpCacheAddress;

	SET_VALID(I_igmpCacheIfIndex, ((igmpCacheEntry_t *) (dp->data))->valid);
	((igmpCacheEntry_t *) (dp->data))->igmpCacheIfIndex = igmpCacheIfIndex;

#ifdef igmpCacheEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (igmpCacheEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, igmpCacheEntry, sizeof(igmpCacheEntry_t));

	    SET_ALL_VALID(((igmpCacheEntry_t *) (dp->data))->valid);

	} else {


	    /* Fill in default values here */


	}
#endif				       /* igmpCacheEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_igmpCacheSelf
      case I_igmpCacheSelf:

	SET_VALID(I_igmpCacheSelf, ((igmpCacheEntry_t *) (dp->data))->valid);

	((igmpCacheEntry_t *) (dp->data))->igmpCacheSelf = value->sl_value;
	break;
#endif				       /* I_igmpCacheSelf */

#ifdef I_igmpCacheStatus
      case I_igmpCacheStatus:

	SET_VALID(I_igmpCacheStatus, ((igmpCacheEntry_t *) (dp->data))->valid);

	((igmpCacheEntry_t *) (dp->data))->igmpCacheStatus = value->sl_value;
	break;
#endif				       /* I_igmpCacheStatus */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in igmpCacheEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
igmpCacheEntry_set(doHead, doCur, contextInfo)
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    return (k_igmpCacheEntry_set((igmpCacheEntry_t *) (doCur->data),
				 contextInfo, doCur->state));
}

#endif				       /* SETS */

/*
 * igmp_enabled_test
 *
 * Called by snmp_swidb_get().
 */
static boolean igmp_enabled_test (idbtype *swidb, long* index2)
{
    return(swidb->igmp_enabled);
}
igmpInterfaceEntry_t *
k_igmpInterfaceEntry_get(serialNum, contextInfo, nominator, searchType, igmpInterfaceIfIndex)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
    int             searchType;
    long            igmpInterfaceIfIndex;
{
    
    idbtype *swidb;
    igmpidbtype *igmpidb;
    
    static igmpInterfaceEntry_t igmpInterfaceEntryData;

    swidb = ifmib_swidb_get(serialNum, searchType,
			    igmpInterfaceIfIndex,
			    igmp_enabled_test, NULL);
    if (!swidb) return(NULL);

    igmpidb = igmp_getidb(swidb);
    igmpInterfaceEntryData.igmpInterfaceIfIndex = swidb->snmp_if_index;
    igmpInterfaceEntryData.igmpInterfaceStatus = (swidb->igmp_enabled) ?
	D_igmpInterfaceStatus_active : D_igmpInterfaceStatus_notInService;
    if (igmpidb) {
	igmpInterfaceEntryData.igmpInterfaceQueryInterval =
	    igmpidb->query_interval / ONESEC;
	igmpInterfaceEntryData.igmpInterfaceVersion =
	    (igmpidb->version == IGMP_VERSION1) ?
		D_igmpInterfaceVersion_version1 :
		D_igmpInterfaceVersion_version2;
	igmpInterfaceEntryData.igmpInterfaceQuerier = igmpidb->querier_address;
	igmpInterfaceEntryData.igmpInterfaceQueryMaxResponseTime =
	    (igmpidb->version == IGMP_VERSION1) ?
		IGMP_MAX_QUERY_RESPONSE_VALUE / 10 :
		igmpidb->query_resp_value / 10;
	igmpInterfaceEntryData.igmpInterfaceQuerierPresentTimeout =
	    igmpidb->querier_timeout ?
		igmpidb->querier_timeout / ONESEC :
		(igmpidb->query_interval * IGMP_QR_PRESENT_MULT) / ONESEC;
	igmpInterfaceEntryData.igmpInterfaceLeaveEnabled =
	    igmpidb->version == IGMP_VERSION1 ?
		D_igmpInterfaceLeaveEnabled_false :
		D_igmpInterfaceLeaveEnabled_true;
	igmpInterfaceEntryData.igmpInterfaceVersion1QuerierTimer =
	    mgd_timer_left_sleeping(&igmpidb->older_router_timer) / ONESEC;
	igmpInterfaceEntryData.igmpInterfaceWrongVersionQueries =
	    igmpidb->wrong_versions;
	igmpInterfaceEntryData.igmpInterfaceJoins = igmpidb->group_joins;
	igmpInterfaceEntryData.igmpInterfaceLeaves = igmpidb->group_leaves;
    } else {
	igmpInterfaceEntryData.igmpInterfaceQueryInterval =
	    IGMP_QUERY_INTERVAL / ONESEC;
	igmpInterfaceEntryData.igmpInterfaceVersion =
	    D_igmpInterfaceVersion_version2;
	igmpInterfaceEntryData.igmpInterfaceQuerier = 0;
	igmpInterfaceEntryData.igmpInterfaceQueryMaxResponseTime =
	    IGMP_MAX_QUERY_RESPONSE_VALUE / 10;
	igmpInterfaceEntryData.igmpInterfaceQuerierPresentTimeout = 
	    IGMP_QR_PRESENT_INTERVAL;
	igmpInterfaceEntryData.igmpInterfaceLeaveEnabled =
	    D_igmpInterfaceLeaveEnabled_true;
	igmpInterfaceEntryData.igmpInterfaceVersion1QuerierTimer = 0;
	igmpInterfaceEntryData.igmpInterfaceWrongVersionQueries = 0;
	igmpInterfaceEntryData.igmpInterfaceJoins = 0;
	igmpInterfaceEntryData.igmpInterfaceLeaves = 0;
    }

    return (&igmpInterfaceEntryData);
}

#ifdef SETS
int
k_igmpInterfaceEntry_set(data, contextInfo, function)
    igmpInterfaceEntry_t *data;
    ContextInfo    *contextInfo;
    int             function;
{

    return (GEN_ERROR);
}

#endif				       /* SETS */

/*
 * snmp_best_igmp_cache
 *
 * Get next lexigraphical IGMP cache entry based on IP group address.
 */
static igmp_cachetype *snmp_best_igmp_cache(int searchType, ulong group, 
				     ulong ifIndex)
{

    igmp_cachetype *igmp, *best_igmp;
    int            i;
    ulong          index, best_index = 0;

    best_igmp = NULL;
    for (i = 0; i < NETHASHLEN; i++) {
	for (igmp = igmp_cache[i]; igmp; igmp = igmp->next) {
	    if (igmp->group < group)
		continue;

	    index = igmp->idb->snmp_if_index ? igmp->idb->snmp_if_index :
					       igmp->idb->hwptr->snmp_if_index;

	    /*
	     * Do exact match and exit.
	     */
	    if (searchType == EXACT) {
		if (igmp->group == group && index == ifIndex)
		    return(igmp);
	    } else {

		/*
		 * Do get-next search, traverse entire cache. Index using
		 * group address and ifIndex. When a group matches, use
		 * ifIndex as is, don't get the next one. The calling function
		 * does the increment for the least significant key.
		 */
		if (igmp->group > group || index >= ifIndex) {
		    if (!best_igmp || igmp->group < best_igmp->group ||
			(igmp->group == best_igmp->group && 
			 index < best_index)) {
			best_igmp = igmp;
			best_index = index;
		    }
		}
	    }
	}
    }
    return(best_igmp);
}
igmpCacheEntry_t *
k_igmpCacheEntry_get(serialNum, contextInfo, nominator, searchType, igmpCacheAddress, igmpCacheIfIndex)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
    int             searchType;
    unsigned long   igmpCacheAddress;
    long            igmpCacheIfIndex;
{

    igmp_cachetype *igmp;
    static igmpCacheEntry_t igmpCacheEntryData;

    igmp = snmp_best_igmp_cache(searchType, igmpCacheAddress, 
				igmpCacheIfIndex);
    if (!igmp) return(NULL);

    igmpCacheEntryData.igmpCacheAddress = igmp->group;
    igmpCacheEntryData.igmpCacheIfIndex = igmp->idb->snmp_if_index ?
	igmp->idb->snmp_if_index : igmp->idb->hwptr->snmp_if_index;
    igmpCacheEntryData.igmpCacheSelf = (igmp->flags & IGMP_LOCAL_FLAG) ?
	D_igmpCacheSelf_true : D_igmpCacheSelf_false;
    igmpCacheEntryData.igmpCacheLastReporter = igmp->last_reporter;
    igmpCacheEntryData.igmpCacheUpTime = ELAPSED_TIME(igmp->uptime) / 10;
    igmpCacheEntryData.igmpCacheExpiryTime =
	!TIMER_RUNNING(igmp->expire_time) ? 0 : 
	    TIME_LEFT_SLEEPING(igmp->expire_time) / 10;
    igmpCacheEntryData.igmpCacheStatus = D_igmpCacheStatus_active;
    igmpCacheEntryData.igmpCacheVersion1HostTimer =
	!TIMER_RUNNING(igmp->older_host_timer) ? 0 :
	    TIME_LEFT_SLEEPING(igmp->older_host_timer) / ONESEC;

    return (&igmpCacheEntryData);
}

#ifdef SETS
int
k_igmpCacheEntry_set(data, contextInfo, function)
    igmpCacheEntry_t *data;
    ContextInfo    *contextInfo;
    int             function;
{

    return (GEN_ERROR);
}

#endif				       /* SETS */



/*
 * igmpmib subsystem header
 */

#define MAJVERSION_igmpmib 1
#define MINVERSION_igmpmib 0
#define EDITVERSION_igmpmib 0

SUBSYS_HEADER(igmpmib,
              MAJVERSION_igmpmib,
              MINVERSION_igmpmib,
              EDITVERSION_igmpmib,
              init_igmpmib,
              SUBSYS_CLASS_MANAGEMENT,
              "req: ipmulticast",
              NULL);
      
