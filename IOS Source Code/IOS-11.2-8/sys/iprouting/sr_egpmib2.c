/* $Id: sr_egpmib2.c,v 3.5.10.3 1996/07/01 18:45:03 hampton Exp $
 * $Source: /release/112/cvs/Xsys/iprouting/sr_egpmib2.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * March 1994, Jeffrey T. Johnson (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1994-1997 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_egpmib2.c,v $
 * Revision 3.5.10.3  1996/07/01  18:45:03  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.5.10.2  1996/06/18  01:48:09  hampton
 * Split the monolithic traffic array into smaller per-protocol traffic
 * arrays.  [CSCdi59224]
 * Branch: California_branch
 *
 * Revision 3.5.10.1  1996/04/19  18:41:16  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.5  1996/02/23  16:08:11  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.4  1996/01/18  15:49:55  anke
 * CSCdi46969:  Change empty req and/or seq strings in SUBSYS_HEADERs to
 *              NULL
 *              Five bytes saved is five bytes earned
 *
 * Revision 3.3  1995/12/14  08:25:59  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.2  1995/11/17  17:37:24  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  12:10:43  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.2  1995/06/28  09:28:03  smackie
 * Repair widespread subsystem header braindamage. (CSCdi23568)
 *
 *   o Fix subsystem entry points to be foo(subsystype *) not foo(void)
 *   o Repair nonsensical and redundant subsystem sequences
 *   o Use NULL where no property is required
 *
 * Revision 2.1  1995/06/07  21:11:07  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1993 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include "subsys.h"
#include "../snmp/snmp_api.h"
#include "sr_egpmib2.h"
#include "sr_egpmib2-mib.h"
#include "interface_private.h"

#include "packet.h"
#include "login.h"
#include "neighbor.h"
#include "egp.h"
#include "route.h"
#include "../ip/ip.h"
#include "../ip/ip_registry.h"
#include "../parser/parser_defs_snmp.h"

static void generate_egpNeighborLoss_trap(ipaddrtype egpNeighAddr);

static const char egp_trap_oid[] = "snmpTraps.6";

static void
init_egpmib2 (subsystype *subsys)
{
    load_mib(egpmib2_OidList, egpmib2_OidListNum);
    load_oid(egpmib2_oid_table);
    register_snmp_trap(TRAP_SNMP, egp_trap_oid);
    reg_add_egp_neighbor_lost(generate_egpNeighborLoss_trap,
			      "generate_egpNeighborLoss_trap");
}








/*---------------------------------------------------------------------
 * Retrieve data from the egp family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
egp_get (
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = -1;
    void           *dp;
    egp_t          *data = NULL;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1 and the single
     * instance element be 0.
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    switch (searchType) {
      case EXACT:
	if (instLength == 1 && incoming->oid_ptr[incoming->length - 1] == 0) {
	    arg = object->nominator;
	}
	break;

      case NEXT:
	if (instLength <= 0) {
	    arg = object->nominator;
	}
	break;

    }

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_egp_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_egpInMsgs
      case I_egpInMsgs:
	dp = &data->egpInMsgs;
	break;
#endif				       /* I_egpInMsgs */

#ifdef I_egpInErrors
      case I_egpInErrors:
	dp = &data->egpInErrors;
	break;
#endif				       /* I_egpInErrors */

#ifdef I_egpOutMsgs
      case I_egpOutMsgs:
	dp = &data->egpOutMsgs;
	break;
#endif				       /* I_egpOutMsgs */

#ifdef I_egpOutErrors
      case I_egpOutErrors:
	dp = &data->egpOutErrors;
	break;
#endif				       /* I_egpOutErrors */

#ifdef I_egpAs
      case I_egpAs:
	dp = &data->egpAs;
	break;
#endif				       /* I_egpAs */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the egpNeighEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
egpNeighEntry_get (
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    egpNeighEntry_t *data = NULL;
    unsigned long   buffer[4];
    OID             inst;
    int             carry;
    unsigned long   egpNeighAddr;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 4
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 4) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToIP(incoming, 0 + object->oid.length, &egpNeighAddr, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_egpNeighEntry_get(serialNum, contextInfo, arg, searchType, egpNeighAddr)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 4;
	inst.oid_ptr[0] = (data->egpNeighAddr >> 24) & 0xff;
	inst.oid_ptr[1] = (data->egpNeighAddr >> 16) & 0xff;
	inst.oid_ptr[2] = (data->egpNeighAddr >> 8) & 0xff;
	inst.oid_ptr[3] = (data->egpNeighAddr >> 0) & 0xff;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_egpNeighState
      case I_egpNeighState:
	dp = &data->egpNeighState;
	break;
#endif				       /* I_egpNeighState */

#ifdef I_egpNeighAddr
      case I_egpNeighAddr:
	dp = MakeOctetString((unsigned char *) &data->egpNeighAddr, 4L);
	break;
#endif				       /* I_egpNeighAddr */

#ifdef I_egpNeighAs
      case I_egpNeighAs:
	dp = &data->egpNeighAs;
	break;
#endif				       /* I_egpNeighAs */

#ifdef I_egpNeighInMsgs
      case I_egpNeighInMsgs:
	dp = &data->egpNeighInMsgs;
	break;
#endif				       /* I_egpNeighInMsgs */

#ifdef I_egpNeighInErrs
      case I_egpNeighInErrs:
	dp = &data->egpNeighInErrs;
	break;
#endif				       /* I_egpNeighInErrs */

#ifdef I_egpNeighOutMsgs
      case I_egpNeighOutMsgs:
	dp = &data->egpNeighOutMsgs;
	break;
#endif				       /* I_egpNeighOutMsgs */

#ifdef I_egpNeighOutErrs
      case I_egpNeighOutErrs:
	dp = &data->egpNeighOutErrs;
	break;
#endif				       /* I_egpNeighOutErrs */

#ifdef I_egpNeighInErrMsgs
      case I_egpNeighInErrMsgs:
	dp = &data->egpNeighInErrMsgs;
	break;
#endif				       /* I_egpNeighInErrMsgs */

#ifdef I_egpNeighOutErrMsgs
      case I_egpNeighOutErrMsgs:
	dp = &data->egpNeighOutErrMsgs;
	break;
#endif				       /* I_egpNeighOutErrMsgs */

#ifdef I_egpNeighStateUps
      case I_egpNeighStateUps:
	dp = &data->egpNeighStateUps;
	break;
#endif				       /* I_egpNeighStateUps */

#ifdef I_egpNeighStateDowns
      case I_egpNeighStateDowns:
	dp = &data->egpNeighStateDowns;
	break;
#endif				       /* I_egpNeighStateDowns */

#ifdef I_egpNeighIntervalHello
      case I_egpNeighIntervalHello:
	dp = &data->egpNeighIntervalHello;
	break;
#endif				       /* I_egpNeighIntervalHello */

#ifdef I_egpNeighIntervalPoll
      case I_egpNeighIntervalPoll:
	dp = &data->egpNeighIntervalPoll;
	break;
#endif				       /* I_egpNeighIntervalPoll */

#ifdef I_egpNeighMode
      case I_egpNeighMode:
	dp = &data->egpNeighMode;
	break;
#endif				       /* I_egpNeighMode */

#ifdef I_egpNeighEventTrigger
      case I_egpNeighEventTrigger:
	dp = &data->egpNeighEventTrigger;
	break;
#endif				       /* I_egpNeighEventTrigger */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the egpNeighEntry data object.
 *---------------------------------------------------------------------*/
void
egpNeighEntry_free (egpNeighEntry_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after egpNeighEntry set/undo
 *---------------------------------------------------------------------*/
static int
egpNeighEntry_cleanup (doList_t *trash)
{
    egpNeighEntry_free(trash->data);
#ifdef SR_SNMPv2
    egpNeighEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Undo a previous set of the egpNeighEntry family.
 *---------------------------------------------------------------------*/
#ifdef SR_SNMPv2
int
egpNeighEntry_undo (
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return UNDO_FAILED_ERROR;
}

#endif	/* SR_SNMPv2 */

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
egpNeighEntry_test (
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    doList_t       *dp;
    int             found;
    int             carry = 0;
    egpNeighEntry_t *egpNeighEntry;
    unsigned long   egpNeighAddr;

    /*
     * Validate the object instance
     * 
     */

    if ((InstToIP(incoming, 0 + object->oid.length, &egpNeighAddr, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    egpNeighEntry = k_egpNeighEntry_get(-1, contextInfo, object->nominator, EXACT, egpNeighAddr);

#ifndef egpNeighEntry_READ_CREATE

    if (egpNeighEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* egpNeighEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == egpNeighEntry_set) &&
	    (((egpNeighEntry_t *) (dp->data)) != NULL) &&
	 (((egpNeighEntry_t *) (dp->data))->egpNeighAddr == egpNeighAddr)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(egpNeighEntry_t))) == NULL) {
	    DPRINTF((0, "snmpd: Cannot allocate memory\n"));
	    return (GEN_ERROR);
	}
	memset(dp->data, 0, sizeof(egpNeighEntry_t));

	dp->setMethod = egpNeighEntry_set;
	dp->cleanupMethod = egpNeighEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = egpNeighEntry_undo;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_egpNeighAddr, ((egpNeighEntry_t *) (dp->data))->valid);
	((egpNeighEntry_t *) (dp->data))->egpNeighAddr = egpNeighAddr;

#ifdef egpNeighEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (egpNeighEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, egpNeighEntry, sizeof(egpNeighEntry_t));

	    SET_ALL_VALID(((egpNeighEntry_t *) (dp->data))->valid);

	} else {


	    /* Fill in default values here */


	}
#endif				       /* egpNeighEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_egpNeighEventTrigger
      case I_egpNeighEventTrigger:

	SET_VALID(I_egpNeighEventTrigger, ((egpNeighEntry_t *) (dp->data))->valid);

	((egpNeighEntry_t *) (dp->data))->egpNeighEventTrigger = value->sl_value;
	break;
#endif				       /* I_egpNeighEventTrigger */

      default:
	DPRINTF((0, "snmpd: Internal error (invalid nominator in egpNeighEntry)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
egpNeighEntry_set (
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_egpNeighEntry_set((egpNeighEntry_t *) (doCur->data),
				contextInfo, doCur->state));
}

#endif				       /* SETS */




egp_t          *
k_egp_get (
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator)
{
    static egp_t    egpData;

    egpData.egpInMsgs = egp_traffic.inputs;
    egpData.egpInErrors = egp_traffic.formaterr + egp_traffic.checksumerr;
    egpData.egpOutMsgs = egp_traffic.outputs;
    egpData.egpOutErrors = 0;
    egpData.egpAs = egp_asystem;

    return (&egpData);
}


static neighbortype *
find_egp_neighbor (
    int             serialNum,
    int             searchType,
    unsigned long   egpNeighAddr)
{
    int      idx;
    neighbortype *ptr;
    neighbortype *best;

    best = NULL;

    for (idx = 0; idx < NETHASHLEN; idx++) {
	for (ptr = egp_neighbors[idx]; ptr; ptr = ptr->next) {

	    /*
	     * see if we have an address match.  if so, the we've found the
	     * exact match, which is also the best next match
	     */

	    if (ptr->address == egpNeighAddr)
		return (ptr);

	    /*
	     * if this is a get request, this record didn't match so proceed
	     */

	    if (searchType == EXACT)
		continue;

	    /*
	     * see if this is a better match for a get-next
	     */
	    if (ptr->address >= egpNeighAddr) {

		if ((best != NULL) && (best->address <= ptr->address))
		    continue;
	        /*
	         * the current guy is the best guy so far
	         */
	        best = ptr;
	    }

        }
    }

    return (best);
}



egpNeighEntry_t *
k_egpNeighEntry_get (
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    unsigned long   egpNeighAddr)
{
    static egpNeighEntry_t egpNeighEntryData;
    neighbortype *ptr;

    ptr = find_egp_neighbor(serialNum, searchType, egpNeighAddr);
    if (ptr == NULL)
	return (NULL);

    egpNeighEntryData.egpNeighState = ptr->state + 1;
    egpNeighEntryData.egpNeighAddr = ptr->address;
    egpNeighEntryData.egpNeighAs = ptr->yoursystem;
    egpNeighEntryData.egpNeighInMsgs = ptr->inmsgs;
    egpNeighEntryData.egpNeighInErrs = ptr->inerrs;
    egpNeighEntryData.egpNeighOutMsgs = ptr->outmsgs;
    egpNeighEntryData.egpNeighOutErrs = ptr->outerrs;
    egpNeighEntryData.egpNeighInErrMsgs = ptr->errsrcvd;
    egpNeighEntryData.egpNeighOutErrMsgs = ptr->errssent;
    egpNeighEntryData.egpNeighStateUps = ptr->cameup;
    egpNeighEntryData.egpNeighStateDowns = ptr->wentdn;
    egpNeighEntryData.egpNeighIntervalHello = ptr->hello_int/10;
    egpNeighEntryData.egpNeighIntervalPoll = ptr->poll_int/10;
    egpNeighEntryData.egpNeighMode = (ptr->mode == EGP_NAS_ACTIVE) ?
	D_egpNeighMode_active : D_egpNeighMode_passive;
    egpNeighEntryData.egpNeighEventTrigger = D_egpNeighEventTrigger_stop;

    return (&egpNeighEntryData);
}

int
k_egpNeighEntry_set (
    egpNeighEntry_t *data,
    ContextInfo    *contextInfo,
    int             function)
{

    return (GEN_ERROR);
}

/*
          egpNeighborLoss TRAP-TYPE
              ENTERPRISE  snmp
              VARIABLES   { egpNeighAddr }
              DESCRIPTION
                          "An egpNeighborLoss trap signifies that an EGP
                          neighbor for whom the sending protocol entity
                          was an EGP peer has been marked down and the
                          peer relationship no longer obtains."
              ::= 5
 */
#define SNMP_EGP_TRAP_VBCOUNT 1
#define SNMP_EGP_TRAP_NUMBER  5

static const OID trapVarBinds[SNMP_EGP_TRAP_VBCOUNT] = {
    {LNegpNeighAddr, (ulong *)IDegpNeighAddr}
};

static void
generate_egpNeighborLoss_trap (ipaddrtype egpNeighAddr)
{
    int		vbIndex;
    OID	       *vbList[SNMP_EGP_TRAP_VBCOUNT + 1];
    OID         instanceOID;
    ulong       instance[4];

    /*
     * All the trap varbind objects have an instance described by
     * INDEX { egpNeighAddr }
     */
    instance[0] = (egpNeighAddr >> 24) & 0xff;
    instance[1] = (egpNeighAddr >> 16) & 0xff;
    instance[2] = (egpNeighAddr >> 8) & 0xff;
    instance[3] = (egpNeighAddr >> 0) & 0xff;
    instanceOID.oid_ptr = instance;
    instanceOID.length = 4;

    /*
     * create the OID * array
     */
    for (vbIndex = 0; vbIndex < SNMP_EGP_TRAP_VBCOUNT; vbIndex++) {
	vbList[vbIndex] = CatOID((OID *) &trapVarBinds[vbIndex],
					    &instanceOID);
    }
    vbList[vbIndex] = NULL;

    /*
     * initiate the trap
     */
    snmp_trap(SNMP_EGP_TRAP_NUMBER, 0, vbList,
	      NULL, (char *)egp_trap_oid);

    /*
     * free any allocated data
     */
    for (vbIndex = 0; vbIndex < SNMP_EGP_TRAP_VBCOUNT; vbIndex++) {
        FreeOID(vbList[vbIndex]);
    }
}

/*
 * egpmib2 subsystem header
 */

#define MAJVERSION_egpmib2 1
#define MINVERSION_egpmib2 0
#define EDITVERSION_egpmib2 0

SUBSYS_HEADER(egpmib2,
              MAJVERSION_egpmib2,
              MINVERSION_egpmib2,
              EDITVERSION_egpmib2,
              init_egpmib2,
              SUBSYS_CLASS_MANAGEMENT,
              "req: egp",
              NULL);
      
