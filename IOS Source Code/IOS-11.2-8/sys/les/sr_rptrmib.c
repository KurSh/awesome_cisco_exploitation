/* $Id: sr_rptrmib.c,v 3.11.12.5 1996/08/28 12:59:50 thille Exp $
 * $Source: /release/112/cvs/Xsys/les/sr_rptrmib.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * November 1994, Steven Garcia (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1994-1996 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_rptrmib.c,v $
 * Revision 3.11.12.5  1996/08/28  12:59:50  thille
 * CSCdi67083: Message externs need a cleanup.
 * Branch: California_branch
 * Get rid of all extern msgsym()s in .c files, rework logger.h and
 * msg_foo.c files so they are included and provide the externs.  Clean up
 * other random externs in .c files.
 *
 * Revision 3.11.12.4  1996/08/07  09:01:24  snyder
 * CSCdi65343:  more things that should be declared const
 *              char * [] -> char *const []
 *              char *    -> const char []
 *              savings 17,496 data space, 1,852 image space
 * Branch: California_branch
 *
 * Revision 3.11.12.3  1996/07/03  20:43:08  thille
 * CSCdi61860: Implement Jeffs glass of slim-fast for snmp
 * Branch: California_branch
 * Take hunk of common code from many mib files, make it a procedure in
 * snmp_util.c and call it from the mibs.  Save 1640 bytes.
 *
 * Revision 3.11.12.2  1996/07/01  18:45:42  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.11.12.1  1996/04/19  18:42:03  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.11  1996/02/13  23:27:09  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.10  1996/02/01  06:06:56  hampton
 * Migrate files out of the parser directory.  [CSCdi47717]
 *   Step 2: Change all files which reference the moved parser files to
 *   point to their new locations.
 *
 * Revision 3.9  1996/01/22  06:37:55  mdb
 * CSCdi47065:  misuse of NULL macro in IOS sources
 *
 * Revision 3.8  1996/01/22  03:10:30  sdurham
 * CSCdi47252:  Envmon/Repeater traps enabled on any use of snmp-server
 * enable trap
 *          must check subsys before checking trap-type
 *
 * Revision 3.7  1996/01/18  15:51:24  anke
 * CSCdi46969:  Change empty req and/or seq strings in SUBSYS_HEADERs to
 *              NULL
 *              Five bytes saved is five bytes earned
 *
 * Revision 3.6  1995/12/16  00:14:17  sdurham
 * CSCdi44645:  MAC illegal address trap needs snmp-server host and enable
 * cli support.
 *    moved all parser commands related to mib to appropriate mib
 *    subsystem.
 *
 * Revision 3.5  1995/12/14  08:27:05  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.4  1995/11/24  16:39:47  jjohnson
 * CSCdi42637:  platform-specific code should be moved out of sub_snmp
 * Install an API for accessing platform-specific SNMP objects
 *
 * Revision 3.3  1995/11/17  17:42:31  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.2  1995/11/17  00:00:43  gstovall
 * Ladies and gentlemen, I introduce to you, the port ready commit.
 *
 * Revision 3.1  1995/11/09  12:34:23  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.4  1995/11/08  21:15:10  shaker
 * Merge Arkansas_branch into 11.1 mainline.
 *
 * Revision 2.3  1995/06/28  09:28:53  smackie
 * Repair widespread subsystem header braindamage. (CSCdi23568)
 *
 *   o Fix subsystem entry points to be foo(subsystype *) not foo(void)
 *   o Repair nonsensical and redundant subsystem sequences
 *   o Use NULL where no property is required
 *
 * Revision 2.2  1995/06/09  13:11:46  hampton
 * Rename old scheduler calls to fit the new naming convention.
 * [CSCdi35514]
 *
 * Revision 2.1  1995/06/07 21:39:41  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include "config.h"
#include "subsys.h"
#include "logger.h"
#include "../les/msg_hub.c"		/* Not a typo, see logger.h */
#include "../snmp/snmp_api.h"
#include "sr_rptrmib.h"
#include "sr_rptrmib-mib.h"
#include "../snmp/snmp_registry.h"
#include "../les/hub_registry.h"
#include "hub.h"
#include "hub_ether.h"
#include "if_les.h"
#include "parser_defs_hub.h"
#include "../snmp/snmp_platform_api.h"
#include "../snmp/sr_old_lchassismib.h"
#include "../parser/parser_defs_snmp.h"
#include "ieee.h"

/*
 * SNMP version 2 OID for the repeater
 */
static const char rptrHealth_trapOID_str[] = "snmpDot3RptrMgt.0.1";
static const char rptrResetEvent_trapOID_str[] = "snmpDot3RptrMgt.0.3";
static const char rptrIllegalAddr_trapOID_str[] = "ciscoRptrMIB.3.0.1";

static OID             _rptrGroupObjectID;
static OctetString     _rptrHealthText;
static OctetString     _rptrGroupDescr;
static OctetString     _rptrAddrTrackLastSourceAddress;
static OctetString     _ciscoRptrPortAllowedSrcAddr;
static OctetString     _ciscoRptrPortLastIllegalSrcAddr;
static uchar           source_addr_octet_str[IEEEBYTES];
static uchar           illegal_source_addr_octet_str[IEEEBYTES];
static int             snmp_rptr_reset_pid;
static int             snmp_rptr_nondisrupttest_pid;
#define RPTRRESETEVENT_TRAPNUM 3
#define RPTRHEALTH_TRAPNUM 1

static   rptrMIBNotificationEnable_t rptr_notificationEnables;


static void rptr_reset(int hub_type);
static void rptr_trap_cfg_set( boolean enable, uint subsys, uint traps);
static void rptr_trap_cfg_nvwrt(parseinfo *csb);
static void rptr_trap_freq_set( boolean enable, uint subsys, uint traps);
static void rptr_trap_freq_nvwrt(parseinfo *csb);
hub_t *
snmp_get_hub_group_port(int hub_type, int hub_number, boolean need_group,
			long *target_group, boolean need_port, 
			long *target_port, int searchType);


void
init_rptrmib (subsystype *subsys)
{
    int hub_number;
    hub_t *hub;

    /*
     * bail if we are not a hub
     */
    if (!hub_platform())
	return;
    /*
     * load the repeater mib
     */
    load_mib(rptrmib_OidList, rptrmib_OidListNum);
    load_oid(rptrmib_oid_table);

    /*
     * register the traps
     */
    register_snmp_trap(TRAP_REPEATER, rptrHealth_trapOID_str);
    register_snmp_trap(TRAP_REPEATER, rptrResetEvent_trapOID_str);
    register_snmp_trap(TRAP_REPEATER, rptrIllegalAddr_trapOID_str);

    /*
     * register for the hub reset service
     */
    reg_add_hub_reset(rptr_reset, "rptr_reset");
    reg_add_generate_illegal_addr_trap(generate_illegal_addr_trap,
				       "generate_illegal_addr_trap");

    reg_add_Trap_cfg_set(rptr_trap_cfg_set, "rptr_trap_cfg_set");
    reg_add_Trap_cfg_nvwrt(rptr_trap_cfg_nvwrt, "rptr_trap_cfg_nvwrt");

    /*
     * WARNING - These are ONLY for the mac security feature, and
     * should not be duplicated ANYWHERE ELSE!
     */
    reg_add_Trap_freq_set(rptr_trap_freq_set, "rptr_trap_freq_set");
    reg_add_Trap_freq_nvwrt(rptr_trap_freq_nvwrt, "rptr_trap_freq_nvwrt");

    /*
     * add parser links for hub mib controls
     */
    hub_mib_parser_init();
    rptr_notificationEnables.rptrMIBEnableHealthNotification = FALSE;
    rptr_notificationEnables.rptrMIBEnableResetNotification = FALSE;

    /*
     * Verify hub and get pointer to its structure.
     */
    hub_number = 0;  /* only a single hub in these products */
    hub = snmp_get_hub_group_port(HUB_ETHER, hub_number,
				  FALSE, NULL,
				  FALSE, NULL,
				  0);
    if (hub != NULL) {
	hub->management->illegal_addr_trap_algorithm = ONCE;
    }

}   /* init_rptrmib */


/*---------------------------------------------------------------------
 * Retrieve data from the rptrRptrInfo family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
rptrRptrInfo_get (OID *incoming,
		  ObjectInfo *object,
		  int searchType,
		  ContextInfo *contextInfo,
		  int serialNum)

{
    int             arg;
    void           *dp;
    rptrRptrInfo_t *data = NULL;


    arg = snmp_scalar_instance(incoming, object, searchType);

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_rptrRptrInfo_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_rptrGroupCapacity
      case I_rptrGroupCapacity:
	dp = &data->rptrGroupCapacity;
	break;
#endif				       /* I_rptrGroupCapacity */

#ifdef I_rptrOperStatus
      case I_rptrOperStatus:
	dp = &data->rptrOperStatus;
	break;
#endif				       /* I_rptrOperStatus */

#ifdef I_rptrHealthText
      case I_rptrHealthText:
	dp = MakeOctetString(data->rptrHealthText->octet_ptr, data->rptrHealthText->length);
	break;
#endif				       /* I_rptrHealthText */

#ifdef I_rptrReset
      case I_rptrReset:
	dp = &data->rptrReset;
	break;
#endif				       /* I_rptrReset */

#ifdef I_rptrNonDisruptTest
      case I_rptrNonDisruptTest:
	dp = &data->rptrNonDisruptTest;
	break;
#endif				       /* I_rptrNonDisruptTest */

#ifdef I_rptrTotalPartitionedPorts
      case I_rptrTotalPartitionedPorts:
	dp = &data->rptrTotalPartitionedPorts;
	break;
#endif				       /* I_rptrTotalPartitionedPorts */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the rptrRptrInfo data object.
 *---------------------------------------------------------------------*/
void
rptrRptrInfo_free (rptrRptrInfo_t *data)

{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after rptrRptrInfo set/undo
 *---------------------------------------------------------------------*/
static int
rptrRptrInfo_cleanup (doList_t *trash)

{
    rptrRptrInfo_free(trash->data);
#ifdef SR_SNMPv2
    rptrRptrInfo_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
rptrRptrInfo_test (OID *incoming,
		   ObjectInfo *object,
		   ObjectSyntax *value,
		   doList_t *doHead,
		   doList_t *doCur,
		   ContextInfo *contextInfo)

{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int             found;

    /*
     * Validate the object instance: 1) It must be of length 1  2) and the
     * instance must be 0.
     */
    if (instLength != 1 || incoming->oid_ptr[incoming->length - 1] != 0) {
	return (NO_CREATION_ERROR);
    }
    found = 0;

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(rptrRptrInfo_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(rptrRptrInfo_t));

	dp->setMethod = rptrRptrInfo_set;
	dp->cleanupMethod = rptrRptrInfo_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

    }
    switch (object->nominator) {

#ifdef I_rptrReset
      case I_rptrReset:

	/* verify supplied value */
	if ((value->sl_value != D_rptrReset_noReset) &&
	    (value->sl_value != D_rptrReset_reset))
	    return(WRONG_VALUE_ERROR);

	SET_VALID(I_rptrReset, ((rptrRptrInfo_t *) (dp->data))->valid);

	((rptrRptrInfo_t *) (dp->data))->rptrReset = value->sl_value;
	break;
#endif				       /* I_rptrReset */

#ifdef I_rptrNonDisruptTest
      case I_rptrNonDisruptTest:

	/* verify supplied value */
	if ((value->sl_value != D_rptrNonDisruptTest_noSelfTest) &&
	    (value->sl_value != D_rptrNonDisruptTest_selfTest))
	    return(WRONG_VALUE_ERROR);

	SET_VALID(I_rptrNonDisruptTest, ((rptrRptrInfo_t *) (dp->data))->valid);

	((rptrRptrInfo_t *) (dp->data))->rptrNonDisruptTest = value->sl_value;
	break;
#endif				       /* I_rptrNonDisruptTest */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in rptrRptrInfo_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
rptrRptrInfo_set (doList_t *doHead,
		  doList_t *doCur,
		  ContextInfo *contextInfo)
{
    return (k_rptrRptrInfo_set((rptrRptrInfo_t *) (doCur->data),
			       contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the rptrGroupEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
rptrGroupEntry_get (OID *incoming,
		    ObjectInfo *object,
		    int searchType,
		    ContextInfo *contextInfo,
		    int serialNum)

{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    rptrGroupEntry_t *data;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            rptrGroupIndex;


    /* initialize */
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &rptrGroupIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_rptrGroupEntry_get(serialNum, contextInfo, arg, searchType, rptrGroupIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->rptrGroupIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_rptrGroupIndex
      case I_rptrGroupIndex:
	dp = &data->rptrGroupIndex;
	break;
#endif				       /* I_rptrGroupIndex */

#ifdef I_rptrGroupDescr
      case I_rptrGroupDescr:
	dp = MakeOctetString(data->rptrGroupDescr->octet_ptr, data->rptrGroupDescr->length);
	break;
#endif				       /* I_rptrGroupDescr */

#ifdef I_rptrGroupObjectID
      case I_rptrGroupObjectID:
	dp = MakeOID(data->rptrGroupObjectID->oid_ptr, data->rptrGroupObjectID->length);
	break;
#endif				       /* I_rptrGroupObjectID */

#ifdef I_rptrGroupOperStatus
      case I_rptrGroupOperStatus:
	dp = &data->rptrGroupOperStatus;
	break;
#endif				       /* I_rptrGroupOperStatus */

#ifdef I_rptrGroupLastOperStatusChange
      case I_rptrGroupLastOperStatusChange:
	dp = &data->rptrGroupLastOperStatusChange;
	break;
#endif				       /* I_rptrGroupLastOperStatusChange */

#ifdef I_rptrGroupPortCapacity
      case I_rptrGroupPortCapacity:
	dp = &data->rptrGroupPortCapacity;
	break;
#endif				       /* I_rptrGroupPortCapacity */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the rptrPortEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
rptrPortEntry_get (OID *incoming,
		   ObjectInfo *object,
		   int searchType,
		   ContextInfo *contextInfo,
		   int serialNum)

{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    rptrPortEntry_t *data;
    unsigned long   buffer[2];
    OID             inst;
    int             carry;
    long            rptrPortGroupIndex;
    long            rptrPortIndex;


    /* initialize */
    data = NULL;
    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 2
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 2) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 1 + object->oid.length, &rptrPortIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &rptrPortGroupIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_rptrPortEntry_get(serialNum, contextInfo, arg, searchType, rptrPortGroupIndex, rptrPortIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 2;
	inst.oid_ptr[0] = data->rptrPortGroupIndex;
	inst.oid_ptr[1] = data->rptrPortIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_rptrPortGroupIndex
      case I_rptrPortGroupIndex:
	dp = &data->rptrPortGroupIndex;
	break;
#endif				       /* I_rptrPortGroupIndex */

#ifdef I_rptrPortIndex
      case I_rptrPortIndex:
	dp = &data->rptrPortIndex;
	break;
#endif				       /* I_rptrPortIndex */

#ifdef I_rptrPortAdminStatus
      case I_rptrPortAdminStatus:
	dp = &data->rptrPortAdminStatus;
	break;
#endif				       /* I_rptrPortAdminStatus */

#ifdef I_rptrPortAutoPartitionState
      case I_rptrPortAutoPartitionState:
	dp = &data->rptrPortAutoPartitionState;
	break;
#endif				       /* I_rptrPortAutoPartitionState */

#ifdef I_rptrPortOperStatus
      case I_rptrPortOperStatus:
	dp = &data->rptrPortOperStatus;
	break;
#endif				       /* I_rptrPortOperStatus */

#ifdef I_ciscoRptrPortMDIStatus
      case I_ciscoRptrPortMDIStatus:
        dp = &data->ciscoRptrPortMDIStatus;
        break;
#endif                                 /* I_ciscoRptrPortMDIStatus */

#ifdef I_ciscoRptrPortLinkTestEnabled
      case I_ciscoRptrPortLinkTestEnabled:
        dp = &data->ciscoRptrPortLinkTestEnabled;
        break;
#endif                                 /* I_ciscoRptrPortLinkTestEnabled */

#ifdef I_ciscoRptrPortLinkTestFailed
      case I_ciscoRptrPortLinkTestFailed:
        dp = &data->ciscoRptrPortLinkTestFailed;
        break;
#endif                                 /* I_ciscoRptrPortLinkTestFailed */

#ifdef I_ciscoRptrPortAutoPolarityEnabled
      case I_ciscoRptrPortAutoPolarityEnabled:
        dp = &data->ciscoRptrPortAutoPolarityEnabled;
        break;
#endif                                 /* I_ciscoRptrPortAutoPolarityEnabled */
#ifdef I_ciscoRptrPortAutoPolarityCorrected
      case I_ciscoRptrPortAutoPolarityCorrected:
        dp = &data->ciscoRptrPortAutoPolarityCorrected;
        break;
#endif                                 /* I_ciscoRptrPortAutoPolarityCorrected
                                        * */

#ifdef I_ciscoRptrPortSrcAddrCtrl
      case I_ciscoRptrPortSrcAddrCtrl:
        dp = &data->ciscoRptrPortSrcAddrCtrl;
        break;
#endif                                 /* I_ciscoRptrPortSrcAddrCtrl */

#ifdef I_ciscoRptrPortAllowedSrcAddr
      case I_ciscoRptrPortAllowedSrcAddr:
        dp = MakeOctetString(data->ciscoRptrPortAllowedSrcAddr->octet_ptr, data->ciscoRptrPortAllowedSrcAddr->length);
        break;
#endif                                 /* I_ciscoRptrPortAllowedSrcAddr */

#ifdef I_ciscoRptrPortAllowedSrcAddrStatus
      case I_ciscoRptrPortAllowedSrcAddrStatus:
        dp = &data->ciscoRptrPortAllowedSrcAddrStatus;
        break;
#endif                                 /* I_ciscoRptrPortAllowedSrcAddrStatus */

#ifdef I_ciscoRptrPortLastIllegalSrcAddr
      case I_ciscoRptrPortLastIllegalSrcAddr:
	dp = MakeOctetString(data->ciscoRptrPortLastIllegalSrcAddr->octet_ptr, data->ciscoRptrPortLastIllegalSrcAddr->length);
    break;
#endif                                /* I_ciscoRptrPortLastIllegalSrcAddr */

#ifdef I_ciscoRptrPortIllegalAddrTrapAcked
    case I_ciscoRptrPortIllegalAddrTrapAcked:
       dp = (&data->ciscoRptrPortIllegalAddrTrapAcked);
       break;
#endif /* I_ciscoRptrPortIllegalAddrTrapAcked */

#ifdef I_ciscoRptrPortIllegalAddrTrapEnabled
    case I_ciscoRptrPortIllegalAddrTrapEnabled:
       dp = (&data->ciscoRptrPortIllegalAddrTrapEnabled);
       break;
#endif /* I_ciscoRptrPortIllegalAddrTrapEnabled */

#ifdef I_ciscoRptrPortIllegalAddrFirstHeard
    case I_ciscoRptrPortIllegalAddrFirstHeard:
       dp = (&data->ciscoRptrPortIllegalAddrFirstHeard);
       break;
#endif /* I_ciscoRptrPortIllegalAddrFirstHeard */

#ifdef I_ciscoRptrPortIllegalAddrLastHeard
    case I_ciscoRptrPortIllegalAddrLastHeard:
       dp = (&data->ciscoRptrPortIllegalAddrLastHeard);
       break;
#endif /* I_ciscoRptrPortIllegalAddrLastHeard */

#ifdef I_ciscoRptrPortLastIllegalAddrCount
    case I_ciscoRptrPortLastIllegalAddrCount:
       dp = (&data->ciscoRptrPortLastIllegalAddrCount);
       break;
#endif /* I_ciscoRptrPortLastIllegalAddrCount */

#ifdef I_ciscoRptrPortIllegalAddrTotalCount
    case I_ciscoRptrPortIllegalAddrTotalCount:
       dp = (&data->ciscoRptrPortIllegalAddrTotalCount);
       break;
#endif /* I_ciscoRptrPortIllegalAddrTotalCount */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */
    return (MakeVarBind(object, &inst, dp));
}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the rptrPortEntry data object.
 *---------------------------------------------------------------------*/
void
rptrPortEntry_free (rptrPortEntry_t *data)

{
    if (data != NULL) {
	if (data->ciscoRptrPortAllowedSrcAddr != NULL) {
	    FreeOctetString(data->ciscoRptrPortAllowedSrcAddr);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after rptrPortEntry set/undo
 *---------------------------------------------------------------------*/
static int
rptrPortEntry_cleanup (doList_t *trash)

{
    rptrPortEntry_free(trash->data);
#ifdef SR_SNMPv2
    rptrPortEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
rptrPortEntry_test (OID *incoming,
		    ObjectInfo *object,
		    ObjectSyntax *value,
		    doList_t *doHead,
		    doList_t *doCur,
		    ContextInfo *contextInfo)

{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int             found;
    int             carry = 0;
    rptrPortEntry_t *rptrPortEntry;
    long            rptrPortGroupIndex;
    long            rptrPortIndex;

    /*
     * Validate the object instance
     * 
     */
    if (instLength != 2) {
	return NO_CREATION_ERROR;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &rptrPortGroupIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, 1 + object->oid.length, &rptrPortIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    rptrPortEntry = k_rptrPortEntry_get(-1, contextInfo, object->nominator, EXACT, rptrPortGroupIndex, rptrPortIndex);

#ifndef rptrPortEntry_READ_CREATE

    if (rptrPortEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* rptrPortEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == rptrPortEntry_set) &&
	    (((rptrPortEntry_t *) (dp->data)) != NULL) &&
	    (((rptrPortEntry_t *) (dp->data))->rptrPortGroupIndex == rptrPortGroupIndex) &&
	(((rptrPortEntry_t *) (dp->data))->rptrPortIndex == rptrPortIndex)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(rptrPortEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(rptrPortEntry_t));

	dp->setMethod = rptrPortEntry_set;
	dp->cleanupMethod = rptrPortEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_rptrPortGroupIndex, ((rptrPortEntry_t *) (dp->data))->valid);
	((rptrPortEntry_t *) (dp->data))->rptrPortGroupIndex = rptrPortGroupIndex;

	SET_VALID(I_rptrPortIndex, ((rptrPortEntry_t *) (dp->data))->valid);
	((rptrPortEntry_t *) (dp->data))->rptrPortIndex = rptrPortIndex;

#ifdef rptrPortEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (rptrPortEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, rptrPortEntry, sizeof(rptrPortEntry_t));

	    SET_ALL_VALID(((rptrPortEntry_t *) (dp->data))->valid);

	} else {


	    /* Fill in default values here */


	}
#endif				       /* rptrPortEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_rptrPortAdminStatus
      case I_rptrPortAdminStatus:

	/* verify supplied value */
	if ((value->sl_value != D_rptrPortAdminStatus_enabled) &&
	    (value->sl_value != D_rptrPortAdminStatus_disabled))
	    return(WRONG_VALUE_ERROR);

	SET_VALID(I_rptrPortAdminStatus, ((rptrPortEntry_t *) (dp->data))->valid);

	((rptrPortEntry_t *) (dp->data))->rptrPortAdminStatus = value->sl_value;
	break;
#endif				       /* I_rptrPortAdminStatus */

#ifdef I_ciscoRptrPortLinkTestEnabled
      case I_ciscoRptrPortLinkTestEnabled:

        /* verify supplied value */
        if ((value->sl_value != D_ciscoRptrPortLinkTestEnabled_true) &&
            (value->sl_value != D_ciscoRptrPortLinkTestEnabled_false))
            return(WRONG_VALUE_ERROR);

        SET_VALID(I_ciscoRptrPortLinkTestEnabled, ((rptrPortEntry_t *) (dp->data))->valid);

        ((rptrPortEntry_t *) (dp->data))->ciscoRptrPortLinkTestEnabled = value->sl_value;
        break;
#endif                                 /* I_ciscoRptrPortLinkTestEnabled */

#ifdef I_ciscoRptrPortAutoPolarityEnabled
      case I_ciscoRptrPortAutoPolarityEnabled:

        /* verify supplied value */
        if ((value->sl_value != D_ciscoRptrPortAutoPolarityEnabled_true) &&
            (value->sl_value != D_ciscoRptrPortAutoPolarityEnabled_false))
            return(WRONG_VALUE_ERROR);

        SET_VALID(I_ciscoRptrPortAutoPolarityEnabled, ((rptrPortEntry_t *)(dp->data))->valid);

        ((rptrPortEntry_t *) (dp->data))->ciscoRptrPortAutoPolarityEnabled = value->sl_value;
        break;
#endif                                 /* I_ciscoRptrPortAutoPolarityEnabled */
#ifdef I_ciscoRptrPortSrcAddrCtrl
      case I_ciscoRptrPortSrcAddrCtrl:

        /* verify supplied value */
        if ((value->sl_value != D_ciscoRptrPortSrcAddrCtrl_true) &&
            (value->sl_value != D_ciscoRptrPortSrcAddrCtrl_false))
            return(WRONG_VALUE_ERROR);

        SET_VALID(I_ciscoRptrPortSrcAddrCtrl, ((rptrPortEntry_t *) (dp->data))->valid);

        ((rptrPortEntry_t *) (dp->data))->ciscoRptrPortSrcAddrCtrl = value->sl_value;
        break;
#endif                                 /* I_ciscoRptrPortSrcAddrCtrl */

#ifdef I_ciscoRptrPortAllowedSrcAddr
      case I_ciscoRptrPortAllowedSrcAddr:

        /* verified supplied value */
        if ((value->os_value->length != 0) &&
            (value->os_value->length != IEEEBYTES)) {
            return(WRONG_VALUE_ERROR);
        }

        SET_VALID(I_ciscoRptrPortAllowedSrcAddr, ((rptrPortEntry_t *) (dp->data))->valid);

        if (((rptrPortEntry_t *) (dp->data))->ciscoRptrPortAllowedSrcAddr != NULL) {
            FreeOctetString(((rptrPortEntry_t *) (dp->data))->ciscoRptrPortAllowedSrcAddr);
        }
        ((rptrPortEntry_t *) (dp->data))->ciscoRptrPortAllowedSrcAddr =
            MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

        break;
#endif                                 /* I_ciscoRptrPortAllowedSrcAddr */

#ifdef I_ciscoRptrPortIllegalAddrTrapAcked
   case I_ciscoRptrPortIllegalAddrTrapAcked:

     if (!(value->sl_value == 1)) {
         return WRONG_VALUE_ERROR;
     }

     SET_VALID(I_ciscoRptrPortIllegalAddrTrapAcked, ((rptrPortEntry_t *) (dp->data))->valid);
 
    ((ciscoRptrPortEntry_t *) (dp->data))->ciscoRptrPortIllegalAddrTrapAcked = value->sl_value;
     break;
#endif /* I_ciscoRptrPortIllegalAddrTrapAcked */

#ifdef I_ciscoRptrPortIllegalAddrTrapEnabled
   case I_ciscoRptrPortIllegalAddrTrapEnabled:

     if ((value->sl_value < 1) || (value->sl_value > 2)) {
         return WRONG_VALUE_ERROR;
     }
     SET_VALID(I_ciscoRptrPortIllegalAddrTrapEnabled, ((rptrPortEntry_t *) (dp->data))->valid);

     ((ciscoRptrPortEntry_t *) (dp->data))->ciscoRptrPortIllegalAddrTrapEnabled = value->sl_value;
     break;
#endif /* I_ciscoRptrPortIllegalAddrTrapEnabled */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in rptrPortEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);
}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
rptrPortEntry_set (doList_t *doHead, doList_t *doCur, ContextInfo *contextInfo)

{
    return (k_rptrPortEntry_set((rptrPortEntry_t *) (doCur->data),
				contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the ciscoRptrMIBglobal family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *
ciscoRptrMIBglobal_get(OID             *incoming,
                       ObjectInfo      *object,
                       int             searchType,
                       ContextInfo     *contextInfo,
                       int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = -1;
    void            *dp;
    ciscoRptrMIBglobal_t *data;


    /*
     * Check the object instance.
     *
     * An EXACT search requires that the instance be of length 1 and
     * the single instance element be 0.
     *
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    switch (searchType) {
      case EXACT:
        if (instLength == 1 && incoming->oid_ptr[incoming->length - 1] == 0) {
          arg = object->nominator;
        }
        break;

      case NEXT:
        if (instLength <= 0) {
          arg = object->nominator;
        }
        break;

    }

    /*
     * Retrieve the data from the kernel-specific routine.
     */
     if ((data = k_ciscoRptrMIBglobal_get(serialNum, contextInfo, arg)) == NULL) {
        arg = -1;
     }

     /*
      * Build the variable binding for the variable that will be returned.
      */

     switch (arg) {

#ifdef I_ciscoRptrTrapAlgorithm
    case I_ciscoRptrTrapAlgorithm:
       dp = (void *) (&data->ciscoRptrTrapAlgorithm);
       break;
#endif /* I_ciscoRptrTrapAlgorithm */

    default:
       return ((VarBind *) NULL);

     }      /* switch */

     return (MakeVarBind(object, &ZeroOid, dp));

}

#ifdef SETS 

/*----------------------------------------------------------------------
 * Free the ciscoRptrMIBglobal data object.
 *---------------------------------------------------------------------*/
void
ciscoRptrMIBglobal_free(ciscoRptrMIBglobal_t *data)
{
   if (data != NULL) {

       free ((char *) data);
   }
}

/*----------------------------------------------------------------------
 * cleanup after ciscoRptrMIBglobal set/undo
 *---------------------------------------------------------------------*/
static int
ciscoRptrMIBglobal_cleanup(doList_t *trash)
{
   ciscoRptrMIBglobal_free(trash->data);
#ifdef SR_SNMPv2
   ciscoRptrMIBglobal_free(trash->undodata);
#endif /* SR_SNMPv2 */
   return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int 
ciscoRptrMIBglobal_test(incoming, object, value, doHead, doCur, contextInfo)
    OID            *incoming;
    ObjectInfo     *object;
    ObjectSyntax   *value;
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    int            instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int            found;
    int            error_status = NO_ERROR;

   /*
    * Validate the object instance: 1) It must be of length 1  2) and the
    * instance must be 0.
    */
    if (instLength != 1 || incoming->oid_ptr[incoming->length - 1] != 0) {
        return (NO_CREATION_ERROR); 
    }

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same family.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) { 
         if ( (dp->setMethod == ciscoRptrMIBglobal_set) &&
            (((ciscoRptrMIBglobal_t *) (dp->data)) != NULL) ) {

            found = 1;
            break; 
        }
    }

    if (!found) {
        dp = doCur;
        if ( (dp->data = malloc(sizeof(ciscoRptrMIBglobal_t))) == NULL) { 
            DPRINTF((APWARN, "snmpd: Cannot allocate memory\n"));
            return RESOURCE_UNAVAILABLE_ERROR;
        }
        memset(dp->data, 0, sizeof(ciscoRptrMIBglobal_t));
#ifdef SR_SNMPv2
        if ( (dp->undodata = malloc(sizeof(ciscoRptrMIBglobal_t))) == NULL) { 
            DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
            return RESOURCE_UNAVAILABLE_ERROR;
        }
        memset(dp->undodata, 0, sizeof(ciscoRptrMIBglobal_t));
#endif /* SR_SNMPv2 */

        dp->setMethod = ciscoRptrMIBglobal_set;
        dp->cleanupMethod = ciscoRptrMIBglobal_cleanup;
#ifdef SR_SNMPv2
#ifdef SR_ciscoRptrMIBglobal_UNDO
        dp->undoMethod = ciscoRptrMIBglobal_undo;
#else /* SR_ciscoRptrMIBglobal_UNDO */
        dp->undoMethod = NULL;
#endif /* SR_ciscoRptrMIBglobal_UNDO */
#endif /* SR_SNMPv2 */ 
        dp->state = UNKNOWN;

    }

    if (error_status != NO_ERROR) {
        return error_status;
    }

    switch (object->nominator) {

#ifdef I_ciscoRptrTrapAlgorithm
   case I_ciscoRptrTrapAlgorithm:

     if ((value->sl_value < 1) || (value->sl_value > 2)) {
         return WRONG_VALUE_ERROR;
     }

     ((ciscoRptrMIBglobal_t *) (dp->data))->ciscoRptrTrapAlgorithm = value->sl_value;
     break;
#endif /* I_ciscoRptrTrapAlgorithm */

   default:
       DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in ciscoRptrMIBglobal_test)\n"));
       return GEN_ERROR;

   }        /* switch */

   /* Do system dependent testing in k_ciscoRptrMIBglobal_test */
   error_status = k_ciscoRptrMIBglobal_test(object, value, dp, contextInfo);

   if (error_status == NO_ERROR) {
        SET_VALID(object->nominator, ((ciscoRptrMIBglobal_t *) (dp->data))->valid);
        error_status = k_ciscoRptrMIBglobal_ready(object, value, doHead, dp);
   }

   return (error_status);
}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int 
ciscoRptrMIBglobal_set(doHead, doCur, contextInfo)
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
  return (k_ciscoRptrMIBglobal_set((ciscoRptrMIBglobal_t *) (doCur->data),
            contextInfo, doCur->state));
}

#endif /* SETS */



/*---------------------------------------------------------------------
 * Retrieve data from the rptrMonitorRptrInfo family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
rptrMonitorRptrInfo_get (OID *incoming,
			 ObjectInfo *object,
			 int searchType,
			 ContextInfo *contextInfo,
			 int serialNum)

{
    int             arg;
    void           *dp;
    rptrMonitorRptrInfo_t *data = NULL;


    arg = snmp_scalar_instance(incoming, object, searchType);

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_rptrMonitorRptrInfo_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_rptrMonitorTransmitCollisions
      case I_rptrMonitorTransmitCollisions:
	dp = &data->rptrMonitorTransmitCollisions;
	break;
#endif				       /* I_rptrMonitorTransmitCollisions */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the rptrMonitorGroupEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
rptrMonitorGroupEntry_get (OID *incoming,
			   ObjectInfo *object,
			   int searchType,
			   ContextInfo *contextInfo,
			   int serialNum)

{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    rptrMonitorGroupEntry_t *data;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            rptrMonitorGroupIndex;


    /* initialize */
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &rptrMonitorGroupIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_rptrMonitorGroupEntry_get(serialNum, contextInfo, arg, searchType, rptrMonitorGroupIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->rptrMonitorGroupIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_rptrMonitorGroupIndex
      case I_rptrMonitorGroupIndex:
	dp = &data->rptrMonitorGroupIndex;
	break;
#endif				       /* I_rptrMonitorGroupIndex */

#ifdef I_rptrMonitorGroupTotalFrames
      case I_rptrMonitorGroupTotalFrames:
	dp = &data->rptrMonitorGroupTotalFrames;
	break;
#endif				       /* I_rptrMonitorGroupTotalFrames */

#ifdef I_rptrMonitorGroupTotalOctets
      case I_rptrMonitorGroupTotalOctets:
	dp = &data->rptrMonitorGroupTotalOctets;
	break;
#endif				       /* I_rptrMonitorGroupTotalOctets */

#ifdef I_rptrMonitorGroupTotalErrors
      case I_rptrMonitorGroupTotalErrors:
	dp = &data->rptrMonitorGroupTotalErrors;
	break;
#endif				       /* I_rptrMonitorGroupTotalErrors */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the rptrMonitorPortEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
rptrMonitorPortEntry_get (OID *incoming,
			  ObjectInfo *object,
			  int searchType,
			  ContextInfo *contextInfo,
			  int serialNum)

{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    rptrMonitorPortEntry_t *data;
    unsigned long   buffer[2];
    OID             inst;
    int             carry;
    long            rptrMonitorPortGroupIndex;
    long            rptrMonitorPortIndex;


    /* initialize */
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 2
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */
    
    if (searchType == EXACT) {
	if (instLength != 2) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 1 + object->oid.length, &rptrMonitorPortIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &rptrMonitorPortGroupIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if (arg != -1) {
	data = k_rptrMonitorPortEntry_get(serialNum, contextInfo, arg,
					  searchType,
					  rptrMonitorPortGroupIndex,
					  rptrMonitorPortIndex);
	if (data == NULL) {
	    arg = -1;
	}
    }

    if (arg != -1) {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 2;
	inst.oid_ptr[0] = data->rptrMonitorPortGroupIndex;
	inst.oid_ptr[1] = data->rptrMonitorPortIndex;
	/*
	 * Build the variable binding for the variable that will be returned.
	 */
	return (MakeVarBind(object, &inst, SR_OFFSET(data, arg)));

    }
    return ((VarBind *) NULL);

}

/*---------------------------------------------------------------------
 * Retrieve data from the rptrAddrTrackEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
rptrAddrTrackEntry_get (OID *incoming,
			ObjectInfo *object,
			int searchType,
			ContextInfo *contextInfo,
			int serialNum)

{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    rptrAddrTrackEntry_t *data;
    unsigned long   buffer[2];
    OID             inst;
    int             carry;
    long            rptrAddrTrackGroupIndex;
    long            rptrAddrTrackPortIndex;


    /* initialize */
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 2
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 2) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 1 + object->oid.length, &rptrAddrTrackPortIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &rptrAddrTrackGroupIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_rptrAddrTrackEntry_get(serialNum, contextInfo, arg, searchType, rptrAddrTrackGroupIndex, rptrAddrTrackPortIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 2;
	inst.oid_ptr[0] = data->rptrAddrTrackGroupIndex;
	inst.oid_ptr[1] = data->rptrAddrTrackPortIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_rptrAddrTrackGroupIndex
      case I_rptrAddrTrackGroupIndex:
	dp = &data->rptrAddrTrackGroupIndex;
	break;
#endif				       /* I_rptrAddrTrackGroupIndex */

#ifdef I_rptrAddrTrackPortIndex
      case I_rptrAddrTrackPortIndex:
	dp = &data->rptrAddrTrackPortIndex;
	break;
#endif				       /* I_rptrAddrTrackPortIndex */

#ifdef I_rptrAddrTrackLastSourceAddress
      case I_rptrAddrTrackLastSourceAddress:
	dp = MakeOctetString(
			 data->rptrAddrTrackLastSourceAddress->octet_ptr,
			 data->rptrAddrTrackLastSourceAddress->length );
	break;
#endif				       /* I_rptrAddrTrackLastSourceAddress */

#ifdef I_rptrAddrTrackSourceAddrChanges
      case I_rptrAddrTrackSourceAddrChanges:
	dp = &data->rptrAddrTrackSourceAddrChanges;
	break;
#endif				       /* I_rptrAddrTrackSourceAddrChanges */

#ifdef I_rptrAddrTrackNewLastSrcAddress
      case I_rptrAddrTrackNewLastSrcAddress:
	/* Note:
	 * using OctetString struct from rptrAddrTrackLastSourceAddress */
	dp = MakeOctetString(
			 data->rptrAddrTrackLastSourceAddress->octet_ptr,
			 data->rptrAddrTrackLastSourceAddress->length );
	break;
#endif				       /* I_rptrAddrTrackNewLastSrcAddress */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}


/*
 **********************************************************************
 *
 * KERNEL CODE begins here.  Above is all generated by SNMP Research
 * compiler.  Below code does the real work in getting the router
 * information.  
 *
 * First come the utility helper routines.
 *
 **********************************************************************
 */


/*
 * =====================================================================
 * hub_snmp_reset_process ()
 *
 * Description:
 * Background process to reset a hub, send the appropriate trap, and
 * then kill this process.
 *
 * NOTE: will default to the first hub in the box.  Okay, until our
 * products have multiple hubs.
 *
 * Parameters:  gee, I'd sure like to have a hub pointer here
 * None
 *
 * Returns:
 * None
 * =====================================================================
 */

forktype hub_snmp_reset_process(void)
{
    hub_t *hub;

    /* allow some time for a response to a set request which may
     * have asked for this reset to be sent.
     */
    process_sleep_for(ONESEC * 15);

    /* Now reset the puppy, send the required trap, and get out. */
    hub = hub_list;
    if (hub == NULL) {
	/* major screw up */

	/* errmsg(&msgsym(NOHUB, HUBSNMPRESETPROCESS), 0, 0);
	 */
    }
    else {
	hub_reset(hub);
	/* now generate the trap */
	generate_rptr_trap(RPTRRESETEVENT_TRAPNUM);
	/* Commit process suicide.  Free the pid first. */
	snmp_rptr_reset_pid = 0;
	process_kill(THIS_PROCESS);
    }

}  /* hub_snmp_reset_process */


/*
 * =====================================================================
 * hub_snmp_selftest_process ()
 *
 * Description:
 * Background process to execute a nondisruptive selftest upon the
 * hub, send the appropriate trap, and then kill this process.
 * Note that there is nothing to be done for a nondisruptive self
 * test for this platform that does not violate the object
 * requirements of rfc1516.
 *
 * Parameters:
 * None
 *
 * Returns:
 * None
 * =====================================================================
 */

forktype hub_snmp_selftest_process(void)
{
    hub_t *hub;

    /* Allow some time for a response to a set request which asked
     * for this selftest to be sent.
     */
    process_sleep_for(ONESEC * 15);

    /* Now do the self-test, send the required trap, and get out. */
    hub = hub_list;
    if (hub == NULL) {
	/* major screw up */

	/* errmsg(&msgsym(NOHUB, HUBSNMPRESETPROCESS), 0, 0);
	 */
    }
    else {
	/*
	 * [ repeater self test goes here :-) ]
	 */

	/* Update rptrOperStatus and oper status change,
	 * and update rptrHealthText.
	 */
	hub->management->oper_status = D_rptrOperStatus_ok;
	GET_TIMESTAMP(hub->management->grp_last_oper_stat_change);
	hub->management->health_text = HEALTHTEXT_OPERATIONAL;

	/* now generate the trap */
	generate_rptr_trap(RPTRHEALTH_TRAPNUM);
	/* free the process ID and commit process suicide. */
	snmp_rptr_nondisrupttest_pid = 0;
	process_kill (-1);
    }

}  /* hub_snmp_selftest_process */


/*
 * snmp_get_hub_group_port
 *
 * Make sure everything is cool with respect to the hub for an snmp request.
 * - verify hub is present
 * - if needed, verify request group number
 * - if needed, verify request port number
 * - return pointer to relevant hub structure
 *
 * Input:
 *    hub_type - (always ether for this mib)
 *    hub_number
 *    need_group - boolean indicating to verify group existance
 *    target_group - group number to verify if need_group is true
 *    need_port - boolean indicating to verify port existance
 *    target_port - port number to verify if need_port is true
 *    searchType - EXACT for snmp "get", NEXT for "getnext"
 *
 * Returns:
 *    ptr to relevant hub structure.  NULL if any validations fail.
 */

hub_t *
snmp_get_hub_group_port (int hub_type,
			 int hub_number,
			 boolean need_group,
			 long *target_group,
			 boolean need_port,
			 long *target_port,
			 int searchType)

{
    hub_t *hub;
    int port_count;

    /*
     * Verify that a hub is present and get pointer to its structure.
     */
    hub = hub_get_hub_ptr(hub_type, hub_number);
    if (hub == NULL) {
	/* then no hub is present */
	return (NULL);
    }

    if (need_group && need_port) {
	if (searchType == NEXT) {
	    if ( (*target_group) == 0 ) {
		/* increment to first port of only group */
		(*target_group) = 1;
		(*target_port) = 1;
	    }
	}

	/* verify requested group exists on this hub */
	if ( (*target_group) != 1 ) {
	    /* since only 1 group in these hubs, instance must = 1 */
	    return(NULL);
	}

	/* verify port exists on this hub */
	port_count = hub_count_ports(HUB_ETHER, hub_number);
	if ( ((*target_port) > port_count) || ((*target_port) == 0) ) {
	    return(NULL);
	}
	return (hub);
    }

    if (need_group) {
	if ((searchType == NEXT) && ((*target_group) == 0)) {
	    (*target_group) = 1;
	}
	/* verify requested group exists on this hub */
	if ((*target_group) != 1) {
	    /* since only 1 group in these hubs, instance must = 1 */
	    return(NULL);
	}
	return(hub);
    }

    return(hub);

}   /* snmp_get_hub_group_port */


/*
 * snmp_get_rptr_text
 *
 * Convert text enumeration to actual text string to return as part
 * of the snmp get response.
 *
 * Input:
 *    rptr_text_enum - enumerated value representing the needed text string
 *
 * Returns:
 *    ptr to needed text string.
 */

/*
 * The rptr_text array must match the enumerations for 
 * RPTR_SNMP_TEXT in sr_rptrmib.h
 */
static const uchar *const rptr_text[] = { "Initializing",
                                    "Operational",
                                    "Single group 8 port repeater -- cisco Systems 2505",
                                    "Single group 14 port repeater -- cisco Systems 2516",
                                    "Single group 16 port repeater -- cisco Systems 2507",
                                    "Invalid request" };


const uchar *
snmp_get_rptr_text (int rptr_text_enum)

{

    if (rptr_text_enum >= MAX_RPTR_SNMP_TEXT) {
	/* invalid input */
	rptr_text_enum = MAX_RPTR_SNMP_TEXT;
    }

    return(rptr_text[rptr_text_enum]);

}   /* snmp_get_rptr_text */


/*
 * get_TotalPartitionedPorts
 *
 * Calculate value to be returned for rptrTotalPartitionedPorts.
 * 
 * Input:
 *    hub - ptr to relevent hub structure
 *
 * Returns:
 *    ulong result of calculation
 */

unsigned long
get_TotalPartitionedPorts (hub_t *hub)
{
    hub_access_t access;
    int num_bytes;
    hub_device_t *cur_device;
    int port;
    ulong total;

    access.hub_number = hub->hub_number;
    access.hub_type = hub->hub_type;
    access.access_code = TP_PORT_PARTITIONING_STATUS_CODE;
    /*
     * Once per device, fetch partitioned port device status.
     * Sum the Return sum of counts.
     */
    total = 0;  /* initialize sum */
    cur_device = hub->hub_device;
    while (cur_device != NULL) {
        access.device = cur_device;
        num_bytes = hub_read_himib(&access);
        for (port = 0; port < cur_device->num_ports; port++) {
            /* 
             * Now count each partitioned port in this device.
             * In buffer[0], each 0 indicates a partitioned port.
             */
            if (~access.buffer[0] & GET_PORT_MASK(port)) {
                total++;
            }
        }
        cur_device = cur_device->next_hub_device;
    }

    return(total);

}   /* get_TotalPartitionedPorts */


/*
 * k_rptrRptrInfo_get
 *
 * Basic rptr info
 * 
 * Relevant Input:
 *
 */

rptrRptrInfo_t *
k_rptrRptrInfo_get (int serialNum, ContextInfo *contextInfo, int nominator)

{
    static rptrRptrInfo_t rptrRptrInfoData;
    int hub_number;
    hub_t *hub;

    /*
     * Verify hub and get pointer to its structure.
     */
    hub_number = 0;  /* only a single hub in these products */
    hub = snmp_get_hub_group_port(HUB_ETHER, hub_number,
				  FALSE, NULL,
				  FALSE, NULL,
				  0);
    if (hub == NULL) {
	return (NULL);
    }

    rptrRptrInfoData.rptrGroupCapacity = 1; /* current hubs have 1 group */

    rptrRptrInfoData.rptrOperStatus = hub->management->oper_status;

    /* rptrHealthText */
    rptrRptrInfoData.rptrHealthText = &_rptrHealthText;
    rptrRptrInfoData.rptrHealthText->octet_ptr =
	(uchar *)snmp_get_rptr_text(hub->management->health_text);
    rptrRptrInfoData.rptrHealthText->length =
	strlen(rptrRptrInfoData.rptrHealthText->octet_ptr);

    rptrRptrInfoData.rptrReset = D_rptrReset_noReset;

    rptrRptrInfoData.rptrNonDisruptTest = D_rptrNonDisruptTest_noSelfTest;

    rptrRptrInfoData.rptrTotalPartitionedPorts =
	get_TotalPartitionedPorts(hub);

    return (&rptrRptrInfoData);

}   /* k_rptrRptrInfo_get */


#ifdef SETS
/*
 * k_rptrRptrInfo_set
 *
 * Relevant Input:
 *
 */

int
k_rptrRptrInfo_set (rptrRptrInfo_t *data,
		    ContextInfo *contextInfo,
		    int function)

{
    hub_access_t access;

    /* 
     * Build up the access structure needed for low level hub functions,
     */
    access.hub_number = 0; /* only a single hub in these products */
    access.hub_type = HUB_ETHER;

    if (VALID(I_rptrReset, data->valid)) {
        switch (data->rptrReset) {
        case D_rptrReset_noReset:
            /*
             * noReset has no effect
             */
            break;
        case D_rptrReset_reset:
		/* Unless it's already happening, fork a process to reset
		 * this hub. */
		if (!(snmp_rptr_reset_pid)) {
		    snmp_rptr_reset_pid =
			cfork(hub_snmp_reset_process,
			      0L, 0, "Hub Reset", 0);
		}
            break;
        }
    }

    if (VALID(I_rptrNonDisruptTest, data->valid)) {
        switch (data->rptrNonDisruptTest) {
        case D_rptrNonDisruptTest_noSelfTest:
            /*
             * noSelfTest has no effect
             */
            break;
        case D_rptrNonDisruptTest_selfTest:
		/* Unless it's already happening, fork a process to reset
		 * this hub. */
		if (!(snmp_rptr_nondisrupttest_pid)) {
		    snmp_rptr_nondisrupttest_pid =
			cfork(hub_snmp_selftest_process,
			      0L, 0, "Hub Self Test", 0);
		}
            break;
        }
    }
 
    return (NO_ERROR);

}   /* k_rptrRptrInfo_set */
#endif				       /* SETS */


/*
 * k_rptrGroupEntry_get
 *
 * Basic port group table.
 * 
 * Relevant Input:
 *    searchType
 *    rptrGroupIndex
 */

rptrGroupEntry_t *
k_rptrGroupEntry_get (int serialNum,
		      ContextInfo *contextInfo,
		      int nominator,
		      int searchType,
		      long rptrGroupIndex)

{
    static rptrGroupEntry_t rptrGroupEntryData;
    int hub_number;
    hub_t *hub;

    /*
     * Verify hub and get pointer to its structure.
     */
    hub_number = 0;  /* only a single hub in these products */
    hub = snmp_get_hub_group_port(HUB_ETHER, hub_number,
				  TRUE, &rptrGroupIndex,
				  FALSE, NULL,
				  searchType);
    if (hub == NULL) {
	return (NULL);
    }

    rptrGroupEntryData.rptrGroupIndex = 1; /* current hubs have 1 group */

    /* rptrGroupDescr */
    rptrGroupEntryData.rptrGroupDescr = &_rptrGroupDescr;
    rptrGroupEntryData.rptrGroupDescr->octet_ptr =
	(uchar *)snmp_get_rptr_text(hub->management->grp_description);
    rptrGroupEntryData.rptrGroupDescr->length =
	strlen(rptrGroupEntryData.rptrGroupDescr->octet_ptr);

    /* rptrGroupObjectID */
    rptrGroupEntryData.rptrGroupObjectID = &_rptrGroupObjectID;
    switch (snmp_platform_get_value(SNMP_PLATFORM_CHASSIS_TYPE)) {
    case D_chassisType_c2505:
	rptrGroupEntryData.rptrGroupObjectID->oid_ptr =
	    (unsigned long *) IDcisco2505RptrGroup;
        rptrGroupEntryData.rptrGroupObjectID->length = LNcisco2505RptrGroup;
        break;
    case D_chassisType_c2507:
        rptrGroupEntryData.rptrGroupObjectID->oid_ptr =
	    (unsigned long *) IDcisco2507RptrGroup;
        rptrGroupEntryData.rptrGroupObjectID->length = LNcisco2507RptrGroup;
        break;
    case D_chassisType_c2516:
        rptrGroupEntryData.rptrGroupObjectID->oid_ptr =
            (unsigned long *) IDcisco2516RptrGroup;
        rptrGroupEntryData.rptrGroupObjectID->length = LNcisco2516RptrGroup;
        break;
    default:
        rptrGroupEntryData.rptrGroupObjectID->oid_ptr =
	    (unsigned long *) IDciscoUnknownRptrGroup;
        rptrGroupEntryData.rptrGroupObjectID->length = LNciscoUnknownRptrGroup;
        break;
    }

    rptrGroupEntryData.rptrGroupOperStatus = hub->management->oper_status;

    rptrGroupEntryData.rptrGroupLastOperStatusChange =
	SNMP_ABSOLUTE_TIME(hub->management->grp_last_oper_stat_change);

    rptrGroupEntryData.rptrGroupPortCapacity =
	hub_count_ports(hub->hub_type, hub->hub_number);

    return (&rptrGroupEntryData);

}   /* k_rptrGroupEntry_get */


/*
 * rptrPortEntry_get
 *
 * Basic port table.
 * 
 * Relevant Input:
 *   searchType
 *   rptrPortGroupIndex
 *   rptrPortIndex
 */

rptrPortEntry_t *
k_rptrPortEntry_get (int serialNum,
		     ContextInfo *contextInfo,
		     int nominator,
		     int searchType,
		     long rptrPortGroupIndex,
		     long rptrPortIndex)

{
    static rptrPortEntry_t rptrPortEntryData;
    int hub_number;
    hub_t *hub;
    hub_access_t access;
    boolean okay;
    uchar port_mask;
    hub_ether_t *hub_ether;
    himib_port_info_t port_info;
    ushort *hub_misc_reg_addr;
    ushort hub_misc_reg;
    uchar link_state;
    int num_bytes;

    /*
     * Verify hub and get pointer to its structure.
     */
    hub_number = 0;  /* only a single hub in these products */
    hub = snmp_get_hub_group_port(HUB_ETHER, hub_number,
				  TRUE, &rptrPortGroupIndex,
				  TRUE, &rptrPortIndex,
				  searchType);
    if (hub == NULL) {
	return (NULL);
    }

    /* Build up the access structure needed for low level hub functions,
     * and map logical hub port to a specific device within the hub.
     */
    access.hub_number = hub->hub_number;
    access.hub_type = hub->hub_type;
    okay = hub_map_port(rptrPortIndex, &access);
    if (!okay) {
        errmsg(&msgsym(BADUNIT, HUB), rptrPortIndex);
        return (NULL);
    }

    hub_ether = access.device->hub_ether;
    port_info = hub_ether->port_info[access.phys_port];
    port_mask = GET_PORT_MASK(access.phys_port);

    rptrPortEntryData.rptrPortGroupIndex = 1; /* current hubs have 1 group */

    rptrPortEntryData.rptrPortIndex = rptrPortIndex;

    /*
     * rptrPortAdminStatus: GET REQUEST
     */
    if (access.device->enabled & port_mask)
	rptrPortEntryData.rptrPortAdminStatus = D_rptrPortAdminStatus_enabled;
    else
	rptrPortEntryData.rptrPortAdminStatus = D_rptrPortAdminStatus_disabled;

    /*
     * rptrPortAutoPartitionState
     */
    if (hub_ether->partition_state & port_mask) {
	rptrPortEntryData.rptrPortAutoPartitionState =
	    D_rptrPortAutoPartitionState_autoPartitioned;
    } else {
	rptrPortEntryData.rptrPortAutoPartitionState =
	    D_rptrPortAutoPartitionState_notAutoPartitioned;
    }

    /*
     * rptrPortOperStatus
     */
    /* if port administratively disabled, then it's notOperational */
    if (!(access.device->enabled & port_mask)) {
	rptrPortEntryData.rptrPortOperStatus =
	    D_rptrPortOperStatus_notOperational;
	}
    else {
        /* get link status */
        access.access_code = TP_PORT_LINK_TEST_STATUS_CODE;
        hub_read_himib(&access);
        link_state = access.buffer[0] & port_mask;

        if ((hub_ether->link_test & port_mask) && !link_state) {
            /*
             * link test failed so port is notOperational
             */
            rptrPortEntryData.rptrPortOperStatus =
                D_rptrPortOperStatus_notOperational;
        } else if (hub_ether->source_addr_mismatch & port_mask) {
            /*
             * port is shutdown due to source address control mismatch
             * so port is notOperational
             */
            rptrPortEntryData.rptrPortOperStatus =
                D_rptrPortOperStatus_notOperational;
        } else {
            /*
             * else port is up and Operational
             */
            rptrPortEntryData.rptrPortOperStatus =
                D_rptrPortOperStatus_operational;
        }
    }

    /*
     * ciscoRptrPortMDIStatus
     */
    if ((cookie->interfaces == INTERFACE_1E2T1Bhub) && 
        (rptrPortIndex == MDI_SWITCHABLE_PORT)) {
        hub_misc_reg_addr = (ushort *)ADRSPC_GAL_HUB_MISC_REG;
        hub_misc_reg = *hub_misc_reg_addr;
        if (hub_misc_reg & ETHER_MDI_MODE) {
            rptrPortEntryData.ciscoRptrPortMDIStatus = 
                D_ciscoRptrPortMDIStatus_normal;
        } else {
            rptrPortEntryData.ciscoRptrPortMDIStatus = 
                D_ciscoRptrPortMDIStatus_crossover;
        }
    } else {
        rptrPortEntryData.ciscoRptrPortMDIStatus = 
            D_ciscoRptrPortMDIStatus_notSwitchable;
    }
           
    /*
     * ciscoRptrPortLinkTestEnabled
     */
    if (hub_ether->link_test & port_mask) {
        rptrPortEntryData.ciscoRptrPortLinkTestEnabled =
            D_ciscoRptrPortLinkTestEnabled_true;
    } else {
        rptrPortEntryData.ciscoRptrPortLinkTestEnabled =
            D_ciscoRptrPortLinkTestEnabled_false;
    }

    /*
     * ciscoRptrPortLinkTestFailed
     */
    access.access_code = TP_PORT_LINK_TEST_STATUS_CODE;
    hub_read_himib(&access);
    if (access.buffer[0] & port_mask) {
        rptrPortEntryData.ciscoRptrPortLinkTestFailed =
            D_ciscoRptrPortLinkTestFailed_false;
    } else {
        rptrPortEntryData.ciscoRptrPortLinkTestFailed =
            D_ciscoRptrPortLinkTestFailed_true;
    }

    /*
     * ciscoRptrPortAutoPolarityEnabled
     */
    if (hub_ether->automatic_polarity & port_mask) {
        rptrPortEntryData.ciscoRptrPortAutoPolarityEnabled =
            D_ciscoRptrPortAutoPolarityEnabled_true;
    } else {
        rptrPortEntryData.ciscoRptrPortAutoPolarityEnabled =
            D_ciscoRptrPortAutoPolarityEnabled_false;
    }

    /*
     * ciscoRptrPortAutoPolarityCorrected
     */
    access.access_code = TP_PORT_RECEIVE_POLARITY_STATUS_CODE;
    hub_read_himib(&access);
    if (access.buffer[0] & port_mask) {
        rptrPortEntryData.ciscoRptrPortAutoPolarityCorrected =
            D_ciscoRptrPortAutoPolarityCorrected_true;
    } else {
        rptrPortEntryData.ciscoRptrPortAutoPolarityCorrected =
            D_ciscoRptrPortAutoPolarityCorrected_false;
    }

    /*
     * ciscoRptrPortSrcAddrCtrl
     */
    if (hub_ether->source_addr_change_int & port_mask) {
        rptrPortEntryData.ciscoRptrPortSrcAddrCtrl =
            D_ciscoRptrPortSrcAddrCtrl_true;
    } else {
        rptrPortEntryData.ciscoRptrPortSrcAddrCtrl =
            D_ciscoRptrPortSrcAddrCtrl_false;
    }

    /*
     * ciscoRptrPortAllowedSrcAddrStatus
     * ciscoRptrPortAllowedSrcAddr
     */
    if (hub_ether->source_addr_config & port_mask) {
        ieee_copy(port_info.source_addr, source_addr_octet_str);
        num_bytes = IEEEBYTES;
        rptrPortEntryData.ciscoRptrPortAllowedSrcAddrStatus =
            D_ciscoRptrPortAllowedSrcAddrStatus_allowedSrcAddrConfig;
    } else if (hub_ether->source_addr_learn & port_mask) {
        ieee_copy(port_info.source_addr, source_addr_octet_str);
        num_bytes = IEEEBYTES;
        rptrPortEntryData.ciscoRptrPortAllowedSrcAddrStatus =
            D_ciscoRptrPortAllowedSrcAddrStatus_allowedSrcAddrLearn;
    } else {
        num_bytes = 0;
        rptrPortEntryData.ciscoRptrPortAllowedSrcAddrStatus =
            D_ciscoRptrPortAllowedSrcAddrStatus_allowedSrcAddrUndefined;
    }

    rptrPortEntryData.ciscoRptrPortAllowedSrcAddr =
        &_ciscoRptrPortAllowedSrcAddr; 
    rptrPortEntryData.ciscoRptrPortAllowedSrcAddr->octet_ptr =
        source_addr_octet_str;
    rptrPortEntryData.ciscoRptrPortAllowedSrcAddr->length =
        num_bytes;

    /*
     * ciscoRptrPortLastIllegalSrcAddr
     */
    if (hub_ether->source_addr_illegal & port_mask) {
        ieee_copy(port_info.current_illegal_source_addr, illegal_source_addr_octet_str);
        num_bytes = IEEEBYTES;
    } else {
        num_bytes = 0;
    }

    rptrPortEntryData.ciscoRptrPortLastIllegalSrcAddr = 
        &_ciscoRptrPortLastIllegalSrcAddr;  
    rptrPortEntryData.ciscoRptrPortLastIllegalSrcAddr->octet_ptr = 
        illegal_source_addr_octet_str;
    rptrPortEntryData.ciscoRptrPortLastIllegalSrcAddr->length = 
        num_bytes;
   rptrPortEntryData.ciscoRptrPortIllegalAddrTrapAcked = 
        port_info.illegal_addr_trap_acked;
   rptrPortEntryData.ciscoRptrPortIllegalAddrTrapEnabled =
        port_info.illegal_addr_trap_enabled;
   rptrPortEntryData.ciscoRptrPortIllegalAddrFirstHeard =
         port_info.illegal_addr_first_heard ;
   rptrPortEntryData.ciscoRptrPortIllegalAddrLastHeard =
         port_info.illegal_addr_last_heard ;
   rptrPortEntryData.ciscoRptrPortLastIllegalAddrCount = 
         port_info.last_illegal_addr_count ;
   rptrPortEntryData.ciscoRptrPortIllegalAddrTotalCount =
         port_info.illegal_addr_total_count;
   rptrPortEntryData.rptrPortGroupIndex = 1; /* current hubs have 1 group */
   rptrPortEntryData.rptrPortIndex = rptrPortIndex;

    return (&rptrPortEntryData);
}   /* k_rptrPortEntry_get */


/*
 * k_rptrPortEntry_set
 *
 * Relevant Input:
 *
 */

#ifdef SETS
int
k_rptrPortEntry_set (rptrPortEntry_t *data,
		     ContextInfo *contextInfo,
		     int function)

{
    int hub_number;
    hub_t *hub;
    hub_access_t access;
    boolean okay;
    hub_ether_t *hub_ether;
    himib_port_info_t *port_info;
    uchar port_mask;

    /* Get pointer to hub structure. */
    hub_number = 0;  /* only a single hub in these products */
    hub = hub_get_hub_ptr(HUB_ETHER, hub_number);
    if (hub == NULL) {
        return (0);
    }

    /* Build up the access structure needed for low level hub functions,
     * and map logical hub port to a specific device within the hub
     */
    access.hub_number = hub->hub_number;
    access.hub_type = hub->hub_type;
    okay = hub_map_port(data->rptrPortIndex, &access);
    if (!okay) {
	errmsg(&msgsym(BADUNIT, HUB), data->rptrPortIndex);
	return (0);
    }

    hub_ether = access.device->hub_ether;
    port_mask = GET_PORT_MASK(access.phys_port);
    port_info = &(hub_ether->port_info[access.phys_port]);

    /* 
     * rptrPortAdminStatus: SET REQUEST
     */
    if (VALID(I_rptrPortAdminStatus, data->valid)) {
        switch (data->rptrPortAdminStatus) {
        case D_rptrPortAdminStatus_enabled:
            hub_ether_config_port(FALSE, &access, HUB_SHUTDOWN);
            break;
        case D_rptrPortAdminStatus_disabled:
            hub_ether_config_port(TRUE, &access, HUB_SHUTDOWN);
            break;
        }
    }

    /* 
     * ciscoRptrPortLinkTestEnabled: SET REQUEST
     */
    if (VALID(I_ciscoRptrPortLinkTestEnabled, data->valid)) {
        switch (data->ciscoRptrPortLinkTestEnabled) {
        case D_ciscoRptrPortLinkTestEnabled_true:
            hub_ether_config_port(TRUE, &access, HUB_LINK_TEST);
            break;
        case D_ciscoRptrPortLinkTestEnabled_false:
            hub_ether_config_port(FALSE, &access, HUB_LINK_TEST);
            break;
        }
    }

    /* 
     * ciscoRptrPortAutoPolarityEnabled: SET REQUEST
     */
    if (VALID(I_ciscoRptrPortAutoPolarityEnabled, data->valid)) {
        switch (data->ciscoRptrPortAutoPolarityEnabled) {
        case D_ciscoRptrPortLinkTestEnabled_true:
            hub_ether_config_port(TRUE, &access, HUB_AUTOMATIC_POLARITY);
            break;
        case D_ciscoRptrPortLinkTestEnabled_false:
            hub_ether_config_port(FALSE, &access, HUB_AUTOMATIC_POLARITY);
            break;
        }
    }

    /* 
     * ciscoRptrPortSrcAddrCtrl: SET REQUEST
     */
    if (VALID(I_ciscoRptrPortSrcAddrCtrl, data->valid)) {
        switch (data->ciscoRptrPortSrcAddrCtrl) {
        case D_ciscoRptrPortSrcAddrCtrl_true:
            /* 
             * check if we have a pending source address from previous snmp
             * set request; if so, use the pending source address from snmp
             */
            if (hub_ether->source_addr_snmp_pending & port_mask) {
                ieee_copy(port_info->source_addr, access.buffer);
                hub_ether_src_addr_ctrl(TRUE, &access, TRUE);
            } else {
                hub_ether_src_addr_ctrl(TRUE, &access, FALSE);
            }
            break;
        case D_ciscoRptrPortSrcAddrCtrl_false:
            hub_ether_src_addr_ctrl(FALSE, &access, FALSE);
            break;
        }
    }

    /* 
     * ciscoRptrPortAllowedSrcAddr: SET REQUEST
     */
    if (VALID(I_ciscoRptrPortAllowedSrcAddr, data->valid)) {
        /*
         * need to check to see if source address control feature
         * is enabled; if so, use this as the new source address
         * else, save the address temporarily in a buffer until
         * source address is enabled.
         */
        if (hub_ether->source_addr_change_int & port_mask) {
            if (data->ciscoRptrPortAllowedSrcAddr->length == IEEEBYTES) {
                ieee_copy(data->ciscoRptrPortAllowedSrcAddr->octet_ptr,
                          access.buffer);
                hub_ether_src_addr_ctrl(TRUE, &access, TRUE);
            } else {
                hub_ether_src_addr_ctrl(TRUE, &access, FALSE);
            }
        } else {
            ieee_copy(data->ciscoRptrPortAllowedSrcAddr->octet_ptr,
                      port_info->source_addr);
            hub_ether->source_addr_snmp_pending |= port_mask;
        }
    }

    /* 
     * ciscoRptrPortIllegalAddrTrapEnabled: SET REQUEST
     */
    if (VALID(I_ciscoRptrPortIllegalAddrTrapEnabled, data->valid)) {
        port_info->illegal_addr_trap_enabled =
                     data->ciscoRptrPortIllegalAddrTrapEnabled;
    }
    if (port_info->illegal_addr_trap_enabled ==TRAP_ENABLED_TRUE)
	hub_illegal_addr_trap_process_creation();

    /* 
     * ciscoRptrPortIllegalAddrTrapAcked: SET REQUEST
     */
    if (VALID(I_ciscoRptrPortIllegalAddrTrapAcked, data->valid)) {
        port_info->illegal_addr_trap_acked =
                     data->ciscoRptrPortIllegalAddrTrapAcked;
    }
    
    return (NO_ERROR);

}   /* k_rptrPortEntry_set */

#endif				       /* SETS */


/*
 * k_rptrMonitorRptrInfo_get
 *
 * Repeater monitor information.
 * 
 * Relevant Input:
 *
 */

rptrMonitorRptrInfo_t *
k_rptrMonitorRptrInfo_get (int serialNum,
			   ContextInfo *contextInfo,
			   int nominator)

{
    static rptrMonitorRptrInfo_t rptrMonitorRptrInfoData;

    int hub_number;
    hub_t *hub;
    hub_access_t access;
    int iport;
    boolean okay;

    /*
     * Verify hub and get pointer to its structure.
     */
    hub_number = 0;  /* only a single hub in these products */
    hub = snmp_get_hub_group_port(HUB_ETHER, hub_number,
				  FALSE, NULL,
				  FALSE, NULL,
				  0);
    if (hub == NULL) {
	return (NULL);
    }

    /* Build up the access structure needed for low level hub functions,
     * and map logical hub port to a specific device within the hub
     */
    access.hub_number = hub->hub_number;
    access.hub_type = hub->hub_type;
    iport = 1;  /* pick any port just so map_port can work */
    okay = hub_map_port(iport, &access);
    if (!okay) {
	errmsg(&msgsym(BADUNIT, HUB), iport);
	return (NULL);
    }

    access.access_code = TRANSMIT_COLLISIONS_CODE;
    rptrMonitorRptrInfoData.rptrMonitorTransmitCollisions =
	hub_get_val_uint(&access);

    return (&rptrMonitorRptrInfoData);
}


/*
 * k_rptrMonitorGroupEntry_get
 *
 * Group monitor table.
 * 
 * Relevant Input:
 *
 */

rptrMonitorGroupEntry_t *
k_rptrMonitorGroupEntry_get (int serialNum,
			     ContextInfo *contextInfo,
			     int nominator,
			     int searchType,
			     long rptrMonitorGroupIndex)

{
    static rptrMonitorGroupEntry_t rptrMonitorGroupEntryData;

    int hub_number;
    hub_t *hub;
    hub_access_t access;
    hub_device_t *cur_device;
    int port;   
    uint sum;

    /*
     * Verify hub and get pointer to its structure.
     */
    hub_number = 0;  /* only a single hub in these products */
    hub = snmp_get_hub_group_port(HUB_ETHER, hub_number,
				  TRUE, &rptrMonitorGroupIndex,
				  FALSE, NULL,
				  searchType);
    if (hub == NULL) {
        return (NULL);
    }

    rptrMonitorGroupEntryData.rptrMonitorGroupIndex = rptrMonitorGroupIndex;

    /*
     * rptrMonitorGroupTotalFrames
     */
    access.access_code = READABLE_FRAMES_CODE;
    cur_device = hub->hub_device;
    sum = 0;
    while (cur_device) {
        for (port = 0; port < cur_device->num_ports; port++) {
            access.device = cur_device;
            access.phys_port = port;
            sum += hub_get_val_uint(&access);
        }
        cur_device = cur_device->next_hub_device;
    }
    rptrMonitorGroupEntryData.rptrMonitorGroupTotalFrames = sum;

    /* 
     * rptrMonitorGroupTotalOctets
     */
    /*
     * Don't use the HIMIB TotalOctets counter.  Here's the long
     * reason (paraphrased from Dennis Hee):
     * HIMIB implements IAW Novell's Hub Management Interface(HMI)
     * for repeaterTotalOctets, rather than the rfc1516 definition.
     * The HIMIB returns the total number of bytes for frames with
     * good and bad FCS, and adds 8 bytes per frame for preamble.
     * RFC 1516 wants
     *   "total number of octets contained in the valid frames [...]
     *    received on the ports in this group.  [Return the ] summation
     *    of the values of the rptrMonitorPortReadableOctets counters
     *    for all of the ports in the group..."
     */

    access.access_code = READABLE_OCTETS_CODE;
    cur_device = hub->hub_device;
    sum = 0; /* initialize */
    while (cur_device != NULL) {
        for (port = 0; port < cur_device->num_ports; port++) {
            access.device = cur_device;
            access.phys_port = port;
            sum += hub_get_val_uint(&access);
        }
        cur_device = cur_device->next_hub_device;
    }
    rptrMonitorGroupEntryData.rptrMonitorGroupTotalOctets = sum;

    /* 
     * rptrMonitorGroupTotalErrors
     */
    /* Sum together the needed values for all ports in this group. */
    sum = 0;
    cur_device = hub->hub_device;
    while (cur_device != NULL) {
        for (port = 0; port < cur_device->num_ports; port++) {
            access.device = cur_device;
            access.phys_port = port;
            /* add to sum the needed values for this port */
            access.access_code = FCS_ERR_CODE;
            sum += hub_get_val_uint(&access);
            access.access_code = ALIGNMENT_ERR_CODE;
            sum += hub_get_val_uint(&access);
            access.access_code = FRAMES_TOO_LONG_CODE;
            sum += hub_get_val_uint(&access);
            access.access_code = SHORT_EVENTS_CODE;
            sum += hub_get_val_uint(&access);
            access.access_code = LATE_EVENTS_CODE;
            sum += hub_get_val_uint(&access);
            access.access_code = VERY_LONG_EVENTS_CODE;
            sum += hub_get_val_uint(&access);
            access.access_code = DATA_RATE_MISMATCHES_CODE;
            sum += hub_get_val_uint(&access);
        }
        cur_device = cur_device->next_hub_device;
    }
    rptrMonitorGroupEntryData.rptrMonitorGroupTotalErrors = sum;

    return (&rptrMonitorGroupEntryData);

}   /* k_rptrMonitorGroupEntry_get */


/*
 * k_rptrMonitorPortEntry_get
 *
 * Port monitor table.
 * 
 * Relevant Input:
 *
 */

rptrMonitorPortEntry_t *
k_rptrMonitorPortEntry_get (int serialNum,
			    ContextInfo *contextInfo,
			    int nominator,
			    int searchType,
			    long rptrMonitorPortGroupIndex,
			    long rptrMonitorPortIndex)

{
    static rptrMonitorPortEntry_t rptrMonitorPortEntryData;

    int hub_number;
    hub_t *hub;
    hub_access_t access;
    boolean okay;
    uint result;
    uint total_err_sum;

    /*
     * Verify hub and get pointer to its structure.
     */
    hub_number = 0;  /* only a single hub in these products */
    hub = snmp_get_hub_group_port(HUB_ETHER, hub_number,
				  TRUE, &rptrMonitorPortGroupIndex,
				  TRUE, &rptrMonitorPortIndex,
				  searchType);
    if (hub == NULL) {
        return (NULL);
    }

    /* Build up the access structure needed for low level hub functions,
     * and map logical hub port to a specific device within the hub
     */
    access.hub_number = hub->hub_number;
    access.hub_type = hub->hub_type;
    okay = hub_map_port(rptrMonitorPortIndex, &access);
    if (!okay) {
	errmsg(&msgsym(BADUNIT, HUB), rptrMonitorPortIndex);
	return(NULL);
    }

    total_err_sum = 0;  /* initialize value for rptrMonitorPortTotalErrors */

    rptrMonitorPortEntryData.rptrMonitorPortGroupIndex =
	rptrMonitorPortGroupIndex;

    rptrMonitorPortEntryData.rptrMonitorPortIndex = rptrMonitorPortIndex;

    /*
     * rptrMonitorPortReadableFrames
     */
    access.access_code = READABLE_FRAMES_CODE;
    rptrMonitorPortEntryData.rptrMonitorPortReadableFrames =
	hub_get_val_uint(&access);

    /*
     * rptrMonitorPortReadableOctets
     */
    access.access_code = READABLE_OCTETS_CODE;
    rptrMonitorPortEntryData.rptrMonitorPortReadableOctets =
	hub_get_val_uint(&access);

    /*
     * rptrMonitorPortFCSErrors
     */
    access.access_code = FCS_ERR_CODE;
    result = hub_get_val_uint(&access);
    rptrMonitorPortEntryData.rptrMonitorPortFCSErrors = result;
    total_err_sum += result;

    /*
     * rptrMonitorPortAlignmentErrors
     */
    access.access_code = ALIGNMENT_ERR_CODE;
    result = hub_get_val_uint(&access);
    rptrMonitorPortEntryData.rptrMonitorPortAlignmentErrors = result;
    total_err_sum += result;

    /*
     * rptrMonitorPortFrameTooLongs
     */
    access.access_code = FRAMES_TOO_LONG_CODE;
    result = hub_get_val_uint(&access);
    rptrMonitorPortEntryData.rptrMonitorPortFrameTooLongs = result;
    total_err_sum += result;

    /*
     * rptrMonitorPortShortEvents
     */
    access.access_code = SHORT_EVENTS_CODE;
    result = hub_get_val_uint(&access);
    rptrMonitorPortEntryData.rptrMonitorPortShortEvents = result;
    total_err_sum += result;

    /*
     * rptrMonitorPortRunts
     */
    access.access_code = RUNTS_CODE;
    rptrMonitorPortEntryData.rptrMonitorPortRunts =
	hub_get_val_uint(&access);

    /*
     * rptrMonitorPortCollisions
     */
    access.access_code = COLLISIONS_CODE;
    rptrMonitorPortEntryData.rptrMonitorPortCollisions =
	hub_get_val_uint(&access);

    /*
     * rptrMonitorPortLateEvents
     */
    access.access_code = LATE_EVENTS_CODE;
    result = hub_get_val_uint(&access);
    rptrMonitorPortEntryData.rptrMonitorPortLateEvents = result;
    total_err_sum += result;

    /*
     * rptrMonitorPortVeryLongEvents
     */
    access.access_code = VERY_LONG_EVENTS_CODE;
    result = hub_get_val_uint(&access);
    rptrMonitorPortEntryData.rptrMonitorPortVeryLongEvents = result;
    total_err_sum += result;

    /*
     * rptrMonitorPortDataRateMismatches
     */
    access.access_code = DATA_RATE_MISMATCHES_CODE;
    result = hub_get_val_uint(&access);
    rptrMonitorPortEntryData.rptrMonitorPortDataRateMismatches = result;
    total_err_sum += result;

    /*
     * rptrMonitorPortAutoPartitions
     */
    access.access_code = AUTO_PARTITIONS_CODE;
    rptrMonitorPortEntryData.rptrMonitorPortAutoPartitions =
	hub_get_val_uint(&access);

    /*
     * rptrMonitorPortTotalErrors
     */
    rptrMonitorPortEntryData.rptrMonitorPortTotalErrors = total_err_sum;

    return (&rptrMonitorPortEntryData);

}   /* k_rptrMonitorPortEntry_get */


/*
 * k_rptrAddrTrackEntry_get
 *
 * Port address tracking table.
 * 
 * Relevant Input:
 *   rptrAddrTrackGroupIndex
 *   rptrAddrTrackPortIndex
 */

rptrAddrTrackEntry_t *
k_rptrAddrTrackEntry_get (int serialNum,
			  ContextInfo *contextInfo,
			  int nominator,
			  int searchType,
			  long rptrAddrTrackGroupIndex,
			  long rptrAddrTrackPortIndex)

{
    static rptrAddrTrackEntry_t rptrAddrTrackEntryData;

    int hub_number;
    hub_t *hub;
    int iport;
    hub_access_t access;
    boolean okay;
    int num_bytes;
    uchar port_mask;

    /*
     * Verify hub and get pointer to its structure.
     */
    hub_number = 0;  /* only a single hub in these products */
    hub = snmp_get_hub_group_port(HUB_ETHER, hub_number,
				  TRUE, &rptrAddrTrackGroupIndex,
				  TRUE, &rptrAddrTrackPortIndex,
				  searchType);
    if (hub == NULL) {
	return (NULL);
    }

    /* Build up the access structure needed for low level hub functions,
     * and map logical hub port to a specific device within the hub
     */
    access.hub_number = hub->hub_number;
    access.hub_type = hub->hub_type;
    iport = (int) rptrAddrTrackPortIndex;
    okay = hub_map_port(iport, &access);
    if (!okay) {
	errmsg(&msgsym(BADUNIT, HUB), iport);
	return(NULL);
    }

    port_mask = GET_PORT_MASK(access.phys_port);

    rptrAddrTrackEntryData.rptrAddrTrackGroupIndex = rptrAddrTrackGroupIndex;

    rptrAddrTrackEntryData.rptrAddrTrackPortIndex = rptrAddrTrackPortIndex;

    /*
     * rptrAddrTrackSourceAddrChanges
     */
    access.access_code = SOURCE_ADDR_CHANGES_CODE;
    rptrAddrTrackEntryData.rptrAddrTrackSourceAddrChanges =
	hub_get_val_uint(&access);

    /*
     * rptrAddrTrackLastSourceAddress (deprecated, but still supported)
     * rptrAddrTrackNewLastSrcAddress
     */
    /* if no frames have been received on this port, or if hardware
     * gives us weird stuff, return 0 len string.
     */
    if (access.device->hub_ether->LSA_correct & port_mask) {
	/* this port has received data. read LSA. */
	access.access_code = LAST_SOURCE_ADDR_CODE;
	num_bytes = hub_read_himib(&access);
	if (num_bytes == IEEEBYTES) {
	    /* got right number of bytes for MAC addr, so use them */
	    ieee_copy(access.buffer, source_addr_octet_str);
	}
	else {
	    num_bytes = 0;
	}
    }
    else {
	/* nothing received on this port */
	num_bytes = 0;
    }
    /*
     * fill in struct for rptrAddrTrackLastSourceAddress
     * fill in struct for rptrAddrTrackNewLastSrcAddress
     */
    rptrAddrTrackEntryData.rptrAddrTrackLastSourceAddress =
	&_rptrAddrTrackLastSourceAddress;
    rptrAddrTrackEntryData.rptrAddrTrackLastSourceAddress->octet_ptr =
	source_addr_octet_str;
    rptrAddrTrackEntryData.rptrAddrTrackLastSourceAddress->length =
	num_bytes;
    /*
     * use the same OctetString struct for rptrAddrTrackNewLastSrcAddress
     */
    rptrAddrTrackEntryData.rptrAddrTrackNewLastSrcAddress =
	&_rptrAddrTrackLastSourceAddress;

    return (&rptrAddrTrackEntryData);

}   /* k_rptrAddrTrackEntry_get */

ciscoRptrMIBglobal_t *
k_ciscoRptrMIBglobal_get(int serialNum, 
                         ContextInfo *contextInfo, 
                         int nominator)

{
   static ciscoRptrMIBglobal_t ciscoRptrMIBglobalData;
    int hub_number;
    hub_t *hub;

   /*
     * Verify hub and get pointer to its structure.
     */
    hub_number = 0;  /* only a single hub in these products */
    hub = hub_get_hub_ptr(HUB_ETHER, hub_number);

    if (hub == NULL) {
	return (NULL);
    }

   /*
    * put your code to retrieve the information here
    */

   ciscoRptrMIBglobalData.ciscoRptrTrapAlgorithm =
        hub->management->illegal_addr_trap_algorithm;

   return(&ciscoRptrMIBglobalData);
}

#ifdef SETS
int
k_ciscoRptrMIBglobal_test( ObjectInfo     *object,
                           ObjectSyntax   *value,
                           doList_t       *dp,
                           ContextInfo    *contextInfo)
{

    return NO_ERROR;
}

int
k_ciscoRptrMIBglobal_ready(ObjectInfo     *object,
                           ObjectSyntax   *value,
                           doList_t       *doHead,
                           doList_t       *dp)
{

    dp->state = ADD_MODIFY;
    return NO_ERROR;
}

int
k_ciscoRptrMIBglobal_set(ciscoRptrMIBglobal_t *data,
                         ContextInfo *contextInfo,
                         int function)
{
    int hub_number;
    hub_t *hub;

    /* Get pointer to hub structure. */
    hub_number = 0;  /* only a single hub in these products */
    hub = hub_get_hub_ptr(HUB_ETHER, hub_number);
    if (hub == NULL) {
        return (NO_ACCESS_ERROR);
    }     
    /* 
     * ciscoRptrTrapAlgorithm: SET REQUEST
     */
    if (VALID(I_ciscoRptrTrapAlgorithm, data->valid)) {
        hub->management->illegal_addr_trap_algorithm =
                     data->ciscoRptrTrapAlgorithm;
    }  
    return (NO_ERROR);
}
#endif /* SETS */

#ifdef SR_SNMPv2
#ifdef SR_ciscoRptrMIBglobal_UNDO
/* add #define SR_ciscoRptrMIBglobal_UNDO in rptrmib.h to
 * include the undo routine for the ciscoRptrMIBglobal family.
 */
int
ciscoRptrMIBglobal_undo(doHead, doCur, contextInfo)
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
   return UNDO_FAILED_ERROR;
}
#endif /* SR_ciscoRptrMIBglobal_UNDO */
#endif /* SR_SNMPv2 */



/*
 * Repeater trap support
 */

/*
   rptrHealth TRAP-TYPE
       ENTERPRISE  snmpDot3RptrMgt
       VARIABLES   { rptrOperStatus }
       DESCRIPTION
               "The rptrHealth trap conveys information related
               to the operational status of the repeater.  This
               trap is sent either when the value of
               rptrOperStatus changes, or upon completion of a
               non-disruptive test.

               The rptrHealth trap must contain the
               rptrOperStatus object.  The agent may optionally
               include the rptrHealthText object in the varBind
               list.  See the rptrOperStatus and rptrHealthText
               objects for descriptions of the information that
               is sent.

               The agent must throttle the generation of
               consecutive rptrHealth traps so that there is at
               least a five-second gap between traps of this
               type.  When traps are throttled, they are dropped,
               not queued for sending at a future time.  (Note
               that 'generating' a trap means sending to all
               configured recipients.)"
       REFERENCE
               "Reference IEEE 802.3 Rptr Mgt, 19.2.3.4,
               hubHealth notification."
       ::= 1

   rptrResetEvent TRAP-TYPE
       ENTERPRISE  snmpDot3RptrMgt
       VARIABLES   { rptrOperStatus }
       DESCRIPTION
               "The rptrResetEvent trap conveys information
               related to the operational status of the repeater.
               This trap is sent on completion of a repeater
               reset action.  A repeater reset action is defined
               as an a transition to the START state of Fig 9-2
               in section 9 [IEEE 802.3 Std], when triggered by a
               management command (e.g., an SNMP Set on the
               rptrReset object).

               The agent must throttle the generation of
               consecutive rptrResetEvent traps so that there is
               at least a five-second gap between traps of this
               type.  When traps are throttled, they are dropped,
               not queued for sending at a future time.  (Note
               that 'generating' a trap means sending to all
               configured recipients.)

               The rptrResetEvent trap is not sent when the agent
               restarts and sends an SNMP coldStart or warmStart
               trap.  However, it is recommended that a repeater
               agent send the rptrOperStatus object as an
               optional object with its coldStart and warmStart
               trap PDUs.

               The rptrOperStatus object must be included in the
               varbind list sent with this trap.  The agent may
               optionally include the rptrHealthText object as
               well."
       REFERENCE
               "Reference IEEE 802.3 Rptr Mgt, 19.2.3.4, hubReset
               notification."
       ::= 3
*/


/*
 * SNMP version 1 OID to identify the repeater traps.
 * From rfc1516, we know that the enterprise OID for this trap
 * is snmpDot3RptrMgt.
 */
static const OID enterpriseOID =
    { LNsnmpDot3RptrMgt, (ulong *)IDsnmpDot3RptrMgt };

/*
 * varbinds
 */

#define RPTR_TRAP_VBCOUNT 2

static const OID rptr_trap_varbinds[RPTR_TRAP_VBCOUNT] = {
    {LNrptrOperStatus, (ulong *)IDrptrOperStatus},
    {LNrptrHealthText, (ulong *)IDrptrHealthText} };

void
generate_rptr_trap (int trap_num)
{
    int         vbIndex;
    OID        *vbList[RPTR_TRAP_VBCOUNT + 1];
    OID         instanceOID;
    ulong       instance[1];


    /* 
     * See if notification is enabled via cli...
     */

    if ((trap_num == RPTRHEALTH_TRAPNUM) && 
	(rptr_notificationEnables.rptrMIBEnableHealthNotification == FALSE)) {
	    return;
	}

    if ((trap_num == RPTRRESETEVENT_TRAPNUM) && 
	(rptr_notificationEnables.rptrMIBEnableResetNotification == FALSE)) {
	    return; 
	}
    /*
     * Instance for trap varbind objects.
     * All varbinds in the rptr traps are scalars,
     * and snmp defines all scalars to have an instance of 0.
     */
    instance[0] = 0;
    instanceOID.oid_ptr = instance;
    instanceOID.length = 1;

    /*
     * Create the trap's varbind list.
     */
    for (vbIndex = 0; vbIndex < RPTR_TRAP_VBCOUNT; vbIndex++) {
        vbList[vbIndex] =
	    CatOID((OID *) &rptr_trap_varbinds[vbIndex],
			      &instanceOID);
    }
    vbList[vbIndex] = NULL;

    /*
     * Generate the trap.
     * If version 1 traps are needed, snmp_trap() will use the first
     * 4 parameters to generate a version 1 trap.  If version 2 traps
     * are needed, vbList and rptr<xxxx>_trapOID_str will be used to
     * generate the trap.
     */
    if (trap_num == RPTRHEALTH_TRAPNUM) {
	snmp_trap(ENTERPRISE_TRAP,
		  RPTRHEALTH_TRAPNUM,
		  vbList,
		  (OID *)&enterpriseOID,
		  (char *)rptrHealth_trapOID_str);
    } else {
	snmp_trap(ENTERPRISE_TRAP,
		  RPTRRESETEVENT_TRAPNUM,
		  vbList,
		  (OID *)&enterpriseOID,
		  (char *)rptrResetEvent_trapOID_str);
    }

    /*
     * free data allocated by the CatOID service
     */
    for (vbIndex = 0; vbIndex < RPTR_TRAP_VBCOUNT; vbIndex++) {
        FreeOID(vbList[vbIndex]);
    }

}   /* generate_rptr_trap */

/*
ciscoRptrMIBTrapPrefix OBJECT IDENTIFIER ::= { ciscoRptrMIB 3 }
ciscoRptrMIBTraps OBJECT IDENTIFIER ::= { ciscoRptrMIBTrapPrefix 0 }

ciscoRptrIllegalSrcAddrTrap  NOTIFICATION-TYPE 
             OBJECTS    { 
                        ciscoRptrPortLastIllegalSrcAddr
                        }
             STATUS     current
             DESCRIPTION
                "When the illegal MAC source address violation is 
                 detected, the port is partitioned.  
                 In addition, this notification is generated.
                 Note: rptrPortGroupIndex, and rptrPortIndex are
                    the instances of ciscoRptrPortLastIllegalSrcAddr."  
             ::= { ciscoRptrMIBTraps 1 }
*/



/*
 * SNMP version 1 OID to identify the illegal source address trap.
*/
static const OID trapOID =
    { LNciscoRptrIllegalSrcAddrTrap, (ulong *)IDciscoRptrIllegalSrcAddrTrap };

static const OID EnterpriseOID =
    { LNciscoRptrIllegalSrcAddrTrap - 2, (ulong *)IDciscoRptrIllegalSrcAddrTrap };

/*
 * varbinds
 */

#define VBCOUNT 1
static const OID trap_varbinds[VBCOUNT] = {
    { LNciscoRptrPortLastIllegalSrcAddr,(ulong *)IDciscoRptrPortLastIllegalSrcAddr}};     

void
generate_illegal_addr_trap (int trap_num, int portIndex)
{
    int         vbIndex;
    OID        *vbList[VBCOUNT + 1];
    OID         instanceOID;
    ulong       instance[2];
    char        trapoid_str[80];

    
    if (MakeDotFromOID((OID *)&trapOID, trapoid_str) == -1) {
	return;
    }	
    /*
     * Instance for trap varbind objects.
     * Instances for this varbind are rptrPortGroupIndex, and rptrPortIndex 
     * 
     */
    instance[0] = 1; /* GroupIndex is always 1 */
    instance[1] = portIndex;
    instanceOID.oid_ptr = instance;
    instanceOID.length = 2;

    /*
     * Create the trap's varbind list.
     */
    for (vbIndex = 0; vbIndex < VBCOUNT; vbIndex++) {
	    vbList[vbIndex] = CatOID((OID *) &trap_varbinds[vbIndex],
				  &instanceOID);
    }
    vbList[vbIndex] = NULL;

    /*
     * Generate the trap.
     * If version 1 traps are needed, snmp_trap() will use the first
     * 4 parameters to generate a version 1 trap.  If version 2 traps
     * are needed, vbList and rptr<xxxx>_trapOID_str will be used to
     * generate the trap.
     */
    snmp_trap(ENTERPRISE_TRAP,
	      RPTR_ILLEGAL_ADDR_TRAPNUM,
	      vbList,
	      (OID *)&EnterpriseOID, 
	      trapoid_str);

    /*
     * free data allocated by the CatOID service
     */
    for (vbIndex = 0; vbIndex < VBCOUNT; vbIndex++) {
        FreeOID(vbList[vbIndex]);
    }
}   /* generate_illegal_addr_trap */


static void
rptr_reset (int hub_type)
{
    if (hub_type == HUB_ETHER) {
	generate_rptr_trap(RPTRRESETEVENT_TRAPNUM);
    }
}

/*
 * rptr_trap_cfg_nvwrt -- set the TrapState through config cmd, nvgen
 */
static void
rptr_trap_cfg_nvwrt (parseinfo *csb)
{

    if((rptr_notificationEnables.rptrMIBEnableHealthNotification == TRUE) &&
       (rptr_notificationEnables.rptrMIBEnableResetNotification == TRUE)) {
	nv_write(TRUE, "%s traps repeater", csb->nv_command); 
	return;

    } else if
	((rptr_notificationEnables.rptrMIBEnableHealthNotification == TRUE) ||
       (rptr_notificationEnables.rptrMIBEnableResetNotification == TRUE)) {

	nv_write(TRUE, "%s traps repeater", csb->nv_command);
    
	if(rptr_notificationEnables.rptrMIBEnableHealthNotification == TRUE) {
	    nv_add(TRUE, " health");
	}
	
	if(rptr_notificationEnables.rptrMIBEnableResetNotification == TRUE) {
	    nv_add(TRUE, " reset");
	}
    }
}

/*
 * rptr_trap_cfg_set -- set the TrapState through config cmd
 */
static void
rptr_trap_cfg_set (
    boolean	enable,
    uint	subsys,
    uint	traps)
{
    if ((subsys & (1<< TRAP_REPEATER))) {
	if ((traps & (1 << TRAP_REPEATER_HEALTH))) {
	    rptr_notificationEnables.rptrMIBEnableHealthNotification = enable;
	}
	if ((traps & (1 << TRAP_REPEATER_RESET))) {
	    rptr_notificationEnables.rptrMIBEnableResetNotification = enable;
	}
    }
}

/*
 * WARNING - These next two functions are ONLY for the mac security
 * feature, and  should not be duplicated ANYWHERE ELSE!
 */
/*
 * rptr_trap_freq_nvwrt -- set the Trap frequency through config cmd, nvgen
 */
static void
rptr_trap_freq_nvwrt (parseinfo *csb)
{

    int hub_number;
    hub_t *hub;

    /*
     * Verify hub and get pointer to its structure.
     */
    hub_number = 0;  /* only a single hub in these products */
    hub = snmp_get_hub_group_port(HUB_ETHER, hub_number,
				  FALSE, NULL,
				  FALSE, NULL,
				  0);
    if (hub != NULL) {
	if ( hub->management->illegal_addr_trap_algorithm == 
	    D_ciscoRptrTrapAlgorithm_decay) {
	    nv_write(TRUE, "%s decay repeater illegal-address", 
		     csb->nv_command); 
	}
    }
}
/*
 * rptr_trap_freq_set -- set the Trap freq through config cmd
 */
static void
rptr_trap_freq_set (
    boolean	enable,
    uint	subsys,
    uint	traps)
{
    int hub_number;
    hub_t *hub;

    /*
     * Verify hub and get pointer to its structure.
     */
    hub_number = 0;  /* only a single hub in these products */
    hub = snmp_get_hub_group_port(HUB_ETHER, hub_number,
				  FALSE, NULL,
				  FALSE, NULL,
				  0);
    if (hub != NULL) {
	if ((traps & (1 << TRAP_REPEATER_ILLEGAL_ADDRESS))) {
	    if (enable) {
	    hub->management->illegal_addr_trap_algorithm = 
		D_ciscoRptrTrapAlgorithm_decay;
	} else {
	    hub->management->illegal_addr_trap_algorithm = 
		D_ciscoRptrTrapAlgorithm_once;
	}
	    
	}
    }
}

/*
 * rptrmib subsystem header
 */

#define MAJVERSION_rptrmib 1
#define MINVERSION_rptrmib 0
#define EDITVERSION_rptrmib 0

SUBSYS_HEADER(rptrmib,
              MAJVERSION_rptrmib,
              MINVERSION_rptrmib,
              EDITVERSION_rptrmib,
              init_rptrmib,
              SUBSYS_CLASS_MANAGEMENT,
              "req: hub",
              NULL);
      
