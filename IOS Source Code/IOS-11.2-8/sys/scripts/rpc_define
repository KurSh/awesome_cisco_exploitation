: # use perl -*-Perl-*-
eval 'exec perl5 -S $0 ${1+"$@"}'
    if 0;

# $Id: rpc_define,v 3.4 1996/02/17 09:04:57 rchiao Exp $
# $Source: /release/111/cvs/Xsys/scripts/rpc_define,v $
#------------------------------------------------------------------
# rpc_define - Convert vines service description files
#
# June 1994, David Hampton
#
# Copyright (c) 1994-1996, 1997 by cisco Systems, Inc.
# All rights reserved.
#
# This perl script takes a vines service description file, and builds
# C code headers and C code fragments for packing/unpacking the data
# structures used by this service.
#------------------------------------------------------------------
# $Log: rpc_define,v $
# Revision 3.4  1996/02/17  09:04:57  rchiao
# CSCdi49271:  makefile changes for ClearCase
#
# Revision 3.3  1995/11/17  18:50:18  hampton
# Remove old entries from the RCS header logs.
#
# Revision 3.2  1995/11/17  00:22:39  gstovall
# Ladies and gentlemen, I introduce to you, the port ready commit.
#
# Revision 3.1  1995/11/09  13:11:11  shaker
# Bump version numbers from 2.x to 3.x.
#
# Revision 2.1  1995/06/07  22:43:41  hampton
# Bump version numbers from 1.x to 2.x.
#
#------------------------------------------------------------------
# $Endlog$
#/

#
#
# Syntax for defining a VINES service
#
# Each item must begin a line of its own.
# Lines may be continued by ending with a \
#
# SERVICE <abbreviation of service>
# /* <comment lines in standard C format describing the
#     registry. These will be reformatted unless they are
#     in the comment bar format> */
# NAME <service name>
# WKP <well known port number of the service>
# DATA
#    <Lines of text to be copied from the input to the
#     between the comment and the function declaration>
# END DATA
#
# ROUTINE <abbreviation of service routine>
#   /* <comment lines in standard C format describing the
#       registry. These will be reformatted unless they are
#       in the comment bar format> */
#   NAME <service routine name>
#   NUMBER <procedure number for this routine>
#   DATA
#      <Lines of text to be copied from the input to the
#       between the comment and the function declaration>
#   END DATA
#   CALL   < ACCEPT [NODATA] [REPLY] | PROXY | IGNORE >
#   RETURN < ACCEPT | IGNORE >
#
#    <type of service> := LIST | LOOP | STUB | CASE | RETVAL | VALUE
#    <type declaration of value returned by called function>
#              must be void for LIST and CASE, boolean
#              for LOOP, and ulong for VALUE.
#    <prototype list for called function>
#              a single - represents no arguments.
#    <number of cases for case service>
#    <type for case statement>
#   END ROUTINE
#
# END SERVICE
#

#
# Set up service 'constants'.  These are defined as enums in the C code.
#
$RTN_SEND_DATA   = 1;
$RTN_SEND_NODATA = 2;

$RTN_RCV_DATA    = 1;
$RTN_RCV_NODATA  = 2;
$RTN_RCV_REJECT  = 3;
$RTN_RCV_IGNORE  = 4;
$RTN_RCV_PROXY   = 5;

# 'constants'
$TRUE  = 1;
$FALSE = 0;

$CONTENT     = 1;
$NOT_CONTENT = 0;

%alias = 
  (
   # Banyan
   "boolean",		"ushort",
   "byte", 		"uchar",
   "cardinal",		"ushort",
   "longcardinal",	"ulong",
   "integer",		"short",
   "longinteger",	"long",
   "unspecified",	"ushort",
 );

%string =
  (
   "itemname",		"VST_ITEMLEN",
   "domainname",	"VST_DOMAINLEN",
   "orgname",		"VST_ORGLEN",
   "stname",		"VST_TOTALLEN",
   "description",	"VST_DESCRIPTION",
);

%simpletype_valid =
  (
   # Cisco
   "char",		$TRUE,
   "uchar",		$TRUE,
   "short",		$TRUE,
   "ushort",		$TRUE,
   "long",		$TRUE,
   "ulong",		$TRUE,
   "address",		$TRUE,
   "macaddress",	$TRUE,
   "nonce",		$TRUE,
   
   "enum",		$TRUE,
   "string",		$TRUE,	# 2 byte length field
   "smstring",		$TRUE,	# 1 byte length field
   "stringz",		$TRUE,	# ends with null byte
);
 
%simpletype_args =
  (
   # Cisco
   "char",		1,
   "uchar",		1,
   "short",		1,
   "ushort",		1,
   "long",		1,
   "ulong",		1,
   "address",		1,
   "macaddress",	1,
   "nonce",		1,
     
   "enum",		1,
   "string",		2,	# 2 byte length field
   "smstring",		2,	# 1 byte length field
   "stringz",		2,	# ends with null byte
);

%simpletype_type =
  (
   # Cisco
   "char",		"char",
   "uchar",		"uchar",
   "short",		"short",
   "ushort",		"ushort",
   "long",		"long",
   "ulong",		"ulong",
   "address",		"vinesaddress",
   "macaddress",	"vinesmacaddress",
   "nonce",		"vinesnonce",
   
   "enum",		"short",
   "string",		"char",	# 2 byte length field
   "smstring",		"char",	# 1 byte length field
   "stringz",		"char",	# ends with null byte
);

%insert_prefix =
  (
   # Cisco
   "char",		"",
   "uchar",		"",
   "short",		"",
   "ushort",		"",
   "long",		"",
   "ulong",		"",
   "address",		"&",
   "macaddress",	"&",
   "nonce",		"&",
     
   "enum",		"",
   "string",		"",
   "smstring",		"",
   "stringz",		"",
   );

%extract_prefix =
  (
   # Cisco
   "char",		"&",
   "uchar",		"&",
   "short",		"&",
   "ushort",		"&",
   "long",		"&",
   "ulong",		"&",
   "address",		"&",
   "macaddress",	"&",
   "nonce",		"&",
   
   "enum",		"&",
   "string",		"",
   "smstring",		"",
   "stringz",		"",
);

# command line processing

$infile = '-';
$outfile = '-';
$rpcc = 0;			# Create rpch file
@argv = @ARGV;
@ARGV=();
while (@argv) {
    if ($argv[0] =~ /^-/) {
	if ($argv[0] eq '-c') {
	    shift(@argv);	# Remove option from list
	    $rpcc = 1;		# Create rpcc file
	}
	else {
	    &usage();
	}
    }
    else {
	if ($infile eq '-') {
	    $infile = shift(@argv);
	    if ( -r $infile) {
		open(STDIN, $infile) || die "Unable to read $infile: $!";
		if ($infile =~ /\.rpc$/) {
		  ($out_prefix = $infile) =~ s/\.rpc$//;
		  $out_rpcc_final = "$out_prefix.rpcc";
		  $out_rpch_final = "$out_prefix.rpch";
                  $out_rpcc = "./rpcc.$$";
                  $out_rpch = "./rpch.$$";
                  open(RPCC, '>'.$out_rpcc) ||
		    die "Unable to write to $out_rpcc: $!";
                  open(RPCH, '>'.$out_rpch) ||
		     die "Unable to write to $out_rpch: $!";
		}
		else {
		  print STDERR "inputfile of $infile does not end in .rpc\n";
		  &usage();
		}
	    }
	    else {
		print STDERR "inputfile of $infile is not readable\n";
		&usage();
	    }
	}
	else {
	    &usage();
	}
    }
}
if ($infile eq '-') {
  &usage();
}

# initialization

$lineno=0;                              # So far, no lines read
$errors=0;				# So far, no errors
($s_begin, $s_service, $s_routine, $s_comment,
$s_pc, $s_pd, $s_ds, $s_union, $s_skend) = (0..9);    # Define states

@month = ( 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
	   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' );

$state=$s_begin;			# Set to initial state
#
#  Main processing loop
#
while ($Line = <STDIN>) {	        # Read all lines from all files
					# specified on the command line
  $lineno++;				# Another line has been read
  chop($Line);				# Remove end of line character
  while (substr($Line,-1,1) eq "\\") {	# Handle continuations
    substr($Line,-1,1) = <STDIN>; 	# Fetch new line
    $lineno++;				# Another line has been read
    chop($Line);			# Remove end of line character
  }

  $Line =~ s/^\s*//;			# Remove leading white space 
  if ((substr($Line,0,1) eq "#") ||	# Ignore comment lines
      (length($Line) == 0)) {		# and null lines
    #do nothing
  }
  elsif ($state == $s_begin) {		# Nothing seen yet 
    ($t1, $t2, $rest) = split(' ',$Line,3);
    if ($t1 eq 'SERVICE') {
      if (length($rest)) {		# Extra data on line
	&extraerr;
      }
      if ($files_started == 0) {
	&begin_files;  			# Start the files
	$files_started = 1;
      }
      &begin_service($t2); 	 	# Start the service
    }
    else {
      &errmsg("Missing SERVICE statement.");
    }      
  }
  elsif ($state == $s_service) {	# Expecting NAME, WKP, BEGIN or END
    &parse_service;
  }
  elsif ($state == $s_routine) {	# Expecting NUMBER, DATA, CALL, RETURN, STRUCT, or END
    &parse_routine;
  }
  elsif ($state == $s_ds) {
    &parse_ds;
  }
  elsif ($state == $s_comment) {	# Expecting /*
    &begin_comment;
  }
  elsif ($state == $s_pc) {		# Processing comment
    &more_comment;
  }
  elsif ($state == $s_pd) {		# Processing DATA
    &parse_data;
  }
  elsif ($state == $s_union) {		# Processing DATA
    &parse_union;
  }
  elsif ($state == $s_skend) {	# Skipping to END
    ($t1, $t2, $rest) = split(' ',$Line,3);
    if ($t1 eq 'END') {		# Found the END statement
      if (length($t2)) {		# Extra data on line
	if ($t2 ne 'DATA') {		# Ignore END DATA 
	  ($t1, $rest) = split(' ',$Line,2); 
	  &extraerr;
	}
      }
    }
  }
  else {				# State has incorrect value
    &errmsg("Incorrect value ($state) for parser state.");
  }
}
#
# Cleanup at end of processing
#
if ($state != $s_begin) {		# Missing END statement
  &errmsg("Missing END statement.");
}

&end_files;
if ($errors > 0) {
  print STDERR "$errors errors.\n"
}

close (RPCC);
close (RPCH);
if ($rpcc) {
    &move($out_rpcc, $out_rpcc_final)
	|| die "Unable to mv $out_rpcc $out_rpcc_final";
    unlink($out_rpch)
	|| die "Unable to rm $out_rpch";
    chmod(0444,  $out_rpcc_final)
	|| die "Unable to chmod 444 $out_rpcc_final";
}
else {
    unlink($out_rpcc)
	|| die "Unable to rm $out_rpcc";
    &move($out_rpch, $out_rpch_final)
	|| die "Unable to mv $out_rpch $out_rpch_final";
    chmod(0444,  $out_rpch_final)
	|| die "Unable to chmod 444 $out_rpch_final";
}

exit ($errors > 0);

########################################################################
#
# subroutines follow
#
########################################################################

sub move {
    local($source, $dest) = @_;
    local($rc);
    local($mode);
    # first try to use rename
    $rc = rename($source,$dest);
    if (!$rc) {
      if (-e $dest) {                 # does the dest exist?
            $mode = (stat($dest))[2];
            if ($mode != ($mode | 0222)) {
              # chmod a+w $dest
                chmod($mode | 0222, $dest);
            }
          unlink($dest);
      }
        system("mv $source $dest"); # mv can often move across file systems
              $rc = !$?;              # rc = 0 on error, rc = 1 on success
        if (!$rc) {
          # try harder
            system("/bin/cp -r $source $dest");
          $rc = !$?;  # rc = 0 on error, rc = 1 on success
          if ($rc && !unlink($source)) {
              # copied the file, but failed to nuke the source
              # try to force nuking the source
              system("/bin/rm -f $source");
              $rc = !$?;  # rc = 0 on error, rc = 1 on success
          }
      }
    }
    $rc;
}
#
# Initialize
#
sub begin_files
{
  ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
  $year = "19$year" if ($year < 99);    # check this in 2000
  $mon  = $month[$mon];
  $company = 'cisco Systems, Inc.';
  ($out_rpcc_final_base = $out_rpcc_final) =~ s,[^/]*/,,g;
  ($out_rpch_final_base = $out_rpch_final) =~ s,[^/]*/,,g;
  ($infile_base = $infile) =~ s,[^/]*/,,g; # basename
  $rpcc_title = <<"EndOfHeader";
/* This file is generated from $infile_base. 
 * Do not attempt to edit it 
 *------------------------------------------------------------------
 * $out_rpcc_final_base -- Application Message Creation
 *
 * $mday-$mon-$year, rpc_define script
 *
 * Copyright (c) $year by $company
 * All rights reserved.
 *
 *------------------------------------------------------------------
 */
EndOfHeader
  printf RPCC $rpcc_title;

  $rpch_title = <<"EndOfHeader";
/* This file is generated from $infile_base. 
 * Do not attempt to edit it 
 *------------------------------------------------------------------
 * $out_rpch_final_base -- Application Message Creation
 *
 * $mday-$mon-$year, rpc_define script
 *
 * Copyright (c) $year by $company
 * All rights reserved.
 *
 *------------------------------------------------------------------
 *
 * *** NOTE: All definitions in this file are in native       ***
 * *** processor alignment.  There are routines that pack the ***
 * *** data from these structures into a network buffer, and  ***
 * *** also routines to unpack a network buffer into these    ***
 * *** structures.                                            ***
 */
EndOfHeader
  printf RPCH $rpch_title;
}

sub end_files
{
  local($string);

  $string =
    "/* \n" . 
    " * Local Variables:\n" .
    " * mode: C\n" .
    " * End:\n" .
    " */\n";
  
  printf RPCC $string;
  printf RPCH $string;
}


########################################################################
#
# SERVICE level subroutines follow
#
########################################################################

#
# Initialize table when BEGIN SERVICE is seen
#
sub begin_service
{
  ($svc) = @_;            		# Get the parameters
  ($svc_uabbrev = $svc) =~ tr/a-z/A-Z/;	# Make upper case
  ($svc_labbrev = $svc) =~ tr/A-Z/a-z/;	# Make lower case

  $svc_name = '';			# No longer defined
  $svc_description = '';		# No longer defined
  $svc_wkp = '';			# No longer defined
  $svc_version = 0;			# No longer defined
  $svc_min_allowed = 0;			# No longer defined
  $svc_max_allowed = 0;			# No longer defined
  $svc_accept_search = $FALSE;		# No longer defined
  $svc_default = $RTN_IGNORE;		# Set to default
  $svc_keeps_data = $FALSE;		# Set to default
  $svc_initial_period = '';		# no periodic function
  $svc_recurring_period = '';		# no periodic function
  $svc_reject_code = '0';		# Set to default
  %svc_structures = ( );		# No longer defined
  %routines = ( );	 		# Start list of routines
  %routine_defines = ( ); 		# Start list of defined for routines
  %routine_data = ( );	 		# Start list of data for routines
  %routine_code = ( );	 		# Start list of code for routines
  %routine_externs = ( );		# Start list of externs for routines
  $rtn_number = 0;			# So global svc structures are first
  $ds_prefix = "v${svc_labbrev}";
  $state = $s_service;			# Set starting state
  &want_comment;
}

#
# Output table when END SERVICE is seen
#
sub end_service
{
  local($string, $routine_count);

  if ($errors) {
      # Don't output if errors
      $state = $s_begin;	# Set starting state
      return;
  }

  #
  # Build a header for this service
  #
  &big_comment($string, "$svc_name Service");
  print RPCC $string;
  print RPCH $string;

  #
  # Output the inline code for the service routines
  #
  &big_comment($string, "$svc_name Service Inlines");
  print RPCC $string;
  foreach $key (sort numerically keys(%routine_code)) {
      printf RPCC "%s\n", $routine_code{$key};
  }
  
  #
  # Output the list of routines in this service
  #
  &big_comment($string, "$svc_name Service Routine Descriptions");
  print RPCC $string;
  printf RPCC "vsvc_rtn_info v".$svc_labbrev."_routines[V${svc_uabbrev}_RTN_COUNT] = {";
  foreach $key (sort numerically keys(%routines)) {
      printf RPCC "%s\n", $routines{$key};
  }
  printf RPCC "};\n\n";
  
  #
  # Add stuff to the header file
  #
  # Output the data structures
  $routine_count = keys(%routines);
  $string = sprintf("#define V%s_RTN_COUNT %d\n", $svc_uabbrev, $routine_count);
  printf RPCH $string;
  foreach $key (sort numerically keys(%routine_defines)) {
    printf RPCH "%s\n", $routine_defines{$key};
  }
  foreach $key (sort numerically keys(%routine_data)) {
    printf RPCH "%s\n", $routine_data{$key};
  }

  #
  # Build and print externs
  #
  printf RPCH 
    "extern vsvc_info vsvc_${svc_labbrev}_info;\n\n" .
    "extern void v${svc_labbrev}_init(void);\n" .
    "extern void v${svc_labbrev}_start(void);\n" .
    "extern void v${svc_labbrev}_stop(void);\n" .
    "extern void v${svc_labbrev}_display(void);\n" .
    "extern void v${svc_labbrev}_periodic(void);\n" .
    "extern void v${svc_labbrev}_rcv_search(vinesipcsocket *, ushort, " . 
      "uchar *, uchar *, uchar *, uchar *);\n" .
    "extern void v${svc_labbrev}_rcv_returnaddress(vinesipcsocket *, " . 
      "ushort, ulong, vinesaddress *);\n".
     "extern boolean v${svc_labbrev}_age_service_info(serverentry *);\n";
  foreach $key (sort numerically keys(%routine_externs)) {
      printf RPCH "%s\n", $routine_externs{$key};
  }

  #
  # Build the overall service description
  #
  $string  = sprintf("vsvc_info vsvc_%s_info = {\n", $svc_labbrev);
  $string .= sprintf("  0,");
  &add_comment($string, "queueing info");
  $string .= sprintf("  \"%s\", \"%s\",", $svc_name, $svc_uabbrev);
  &add_comment($string, "name, abbrev");
  $string .= sprintf("  \"%s\",", $svc_description);
  &add_comment($string, "description");
  $string .= sprintf("  \"\", &v%s_debug,", $svc_labbrev);
  &add_comment($string, "svc name, debug flag");
  if ($svc_accept_search == $TRUE) {
    $string .= sprintf("  TRUE,");
  } else {
    $string .= sprintf("  FALSE,");
  }
  &add_comment($string, "answer searches for this service");
  $string .= sprintf("  %s, 0x0000, 0x0000,", $svc_wkp);
  &add_comment($string, "ports: well known, transient, ipc data");
  $string .= sprintf("  \"\",");
  &add_comment($string, "current version string");
  $string .= sprintf("  %u, %u, %u,", $svc_version,
		     $svc_min_allowed, $svc_max_allowed);
  &add_comment($string, "versions: current, min, max");
  $string .= sprintf("  v%s_start, v%s_stop,", $svc_labbrev, $svc_labbrev);
  &add_comment($string, "start, stop");
  $string .= sprintf("  v%s_display,", $svc_labbrev);
  &add_comment($string, "display");
  if ($svc_keeps_data == $TRUE) {
    $string .= sprintf("  v%s_age_service_info,", $svc_labbrev);
  } else {
    $string .= sprintf("  NULL,");
  }
  &add_comment($string, "age service maintained info");
  if ($svc_initial_period ne '') {
    $string .= sprintf("  v%s_periodic,", $svc_labbrev);
    &add_comment($string, "periodic function");
    $string .= sprintf("  {0},");
    &add_comment($string, "periodic timer");
    $string .= sprintf("  %s, %s,", $svc_initial_period, $svc_recurring_period);
    &add_comment($string, "timer intervals");
  } else {
    $string .= sprintf("  NULL, {0}, 0, 0,");
    &add_comment($string, "periodic function and timer info");
  }
  if ($need_other_unpack) {
    $string .= sprintf("  v%s_rcv_ipc_data,", $svc_labbrev);
  } else {
    $string .= sprintf("  NULL,");
  }
  &add_comment($string, "ipc_data upcall");
  $string .= sprintf("  v%s_rcv_search,", $svc_labbrev);
  &add_comment($string, "search message handler");
  $string .= sprintf("  v%s_rcv_returnaddress,", $svc_labbrev);
  &add_comment($string, "return_address message handler");
  $string .= sprintf("  v%s_routines, %d,", $svc_labbrev, $routine_count);
  &add_comment($string, "svc info, num entries");
  $string .= sprintf("  %d, %s,", $svc_default, $svc_reject_code);
  &add_comment($string, "default action, reject code");
  $string .= sprintf("  {0}, 0,");
  &add_comment($string, "query records");
  $string .= sprintf("  0, 0, 0, 0");
  &add_comment($string, "run time statistics");
  $string .= sprintf("};\n\n");
  print RPCC $string;

  # Set starting state
  $state = $s_begin;
}

#
# Parse the commands expected at the SERVICE level
#
sub parse_service
{
  local($t1, $t2, $t3, $t4, $rest, $string);
  ($t1, $t2, $rest) = split(' ',$Line,3);
  $t1 =~ tr/a-z/A-Z/;
  if ($t1 eq 'NAME') {
    ($t1, $svc_name) = split(' ',$Line,2);
    ($svc_uname = $svc_name) =~ tr/a-z/A-Z/; # Make upper case
    ($svc_lname = $svc_name) =~ tr/A-Z/a-z/; # Make lower case
  } elsif ($t1 eq 'DESCRIPTION') {
    ($t1, $t2) = split(' ',$Line,2);
    $svc_description = $t2;
  } elsif ($t1 eq 'WKP') {
    if (length($rest)) {		# Extra data on line
      &extraerr;
    }
    $svc_wkp = $t2;
  } elsif ($t1 eq 'MAINTAINS') {
    $svc_keeps_data = $TRUE;
  } elsif ($t1 eq 'VERSIONS') {
    ($t1, $t2, $t3, $t4, $rest) = split(' ',$Line,5);
    $svc_version = $t2;
    $svc_min_allowed = $t3;
    $svc_max_allowed = $t4;
  } elsif ($t1 eq 'DEFAULT') {
    if ($t2 eq 'IGNORE') {
      $svc_default = $RTN_RCV_IGNORE;
    } elsif ($t2 eq 'REJECT') {
      ($t1, $t2, $t3, $rest) = split(' ',$Line,4);
      $svc_default = $RTN_RCV_REJECT;
      $svc_reject_code = $t3;
    } elsif ($t2 eq 'PROXY') {
      $svc_default = $RTN_RCV_PROXY;
    } else {
      &errmsg("Expecting DEFAULT [ IGNORE | REJECT | PROXY], not just DEFAULT.");
    }
  } elsif ($t1 eq 'PERIODIC') {
    ($t1, $t2, $t3, $rest) = split(' ',$Line,4);
    if (($t2 eq '') || ($t3 eq '')) {
      &errmsg("PERIODIC requires an initial and recurring interval.");
    }
    $svc_initial_period = $t2;
    $svc_recurring_period = $t3;
  } elsif ($t1 eq 'ROUTINE') {
    if (length($rest)) {		# Extra data on line
      &extraerr;
    }
    &begin_routine($t2); 	 	# Start the routine
  } elsif ($t1 eq 'STRUCT') {
      $svc_structures{$t2} = $TRUE;
      &begin_ds($t2, $NOT_CONTENT, $TRUE);
  } elsif ($t1 eq 'SEARCH') {
    if ($t2 eq 'RESPOND') {
      $svc_accept_search = $TRUE;
    } elsif (length($t2)) {
      &errmsg("Expecting keyword RESPOND");
    }
  } elsif ($t1 eq 'END') {		# End of service
    if ($t2 eq 'SERVICE') { 		# Really end of service
      &end_service;			# Finish building service
    }
    elsif (length($t2)) {
      &errmsg("Expecting END SERVICE");
    }
    else {
      &errmsg("Expecting END SERVICE, not just END");
    }
  } else {				# Unexpected statement
    &errmsg("Expecting NAME, WKP, ROUTINE or END statement");
  }
}


########################################################################
#
# ROUTINE level subroutines follow
#
########################################################################

#
# Initialize tables when BEGIN ROUTINE is seen
#
sub begin_routine
{
  local ($string);

  ($rtn_abbrev) = @_;
  ($rtn_labbrev = $rtn_abbrev) =~ tr/A-Z/a-z/;	# Make lower case
  $rtn_name = '';			# No longer defined
  $rtn_number = 0;			# No longer defined
  %rtn_structures = ( );		# No longer defined
  $rtn_send_query = 0;			# No longer defined
  $rtn_rcv_query = 0;			# No longer defined
  $rtn_send_reply = 0;			# No longer defined
  $rtn_rcv_reply = 0;			# No longer defined
  $rtn_send_data = 0;			# No longer defined
  $rtn_rcv_data = 0;			# No longer defined
  $rtn_rcv_abort = 0;			# No longer defined
  $rtn_rcv_reject = 0;			# No longer defined
  $rtn_reject_code = "0x00";		# No longer defined
  $rtn_base_name = "v${svc_labbrev}_${rtn_labbrev}";
  ($rtn_base_uname = $rtn_base_name) =~ tr/a-z/A-Z/;

  $ds_prefix = $rtn_base_name;
  $ds_name = '';
  @ds = ( );				# No longer defined
  @pack = ( );				# No longer defined
  @unpack = ( );			# No longer defined
  @routine_stack = ( );			# No longer defined
  $routine_code_started = $FALSE;
  $routine_data_started = $FALSE;
  $routine_has_query = $FALSE;
  $routine_has_reply = $FALSE;
  $routine_has_data = $FALSE;
  $query_is_padded = $FALSE;
  $state = $s_routine;
  &want_comment;
}


#
# Output table when END ROUTINE is seen
#
sub end_routine
{
  local($string, $foo, $temp);

  $string .= sprintf("#define %s %s", $rtn_base_uname, $rtn_number);
  $routine_defines{$rtn_number} = $string;

  #
  # Build missing data structures
  #
  if ($routine_has_query == $FALSE) {
    $string  = sprintf("typedef struct %s_query_ {\n", $rtn_base_name);
    $string .= sprintf("    uchar query_has_no_data[0];\n");
    $string .= sprintf("} %s_query;\n", $rtn_base_name);
    $routine_data{$rtn_number} .= $string;
  }

  if ($routine_has_reply == $FALSE) {
    $string  = sprintf("typedef struct %s_reply_ {\n", $rtn_base_name);
    $string .= sprintf("    uchar reply_has_no_data[0];\n");
    $string .= sprintf("} %s_reply;\n", $rtn_base_name);
    $routine_data{$rtn_number} .= $string;
  }

  if ($routine_has_data == $FALSE) {
    $string  = sprintf("typedef struct %s_other_ {\n", $rtn_base_name);
    $string .= sprintf("    uchar other_has_no_data[0];\n");
    $string .= sprintf("} %s_other;\n", $rtn_base_name);
    $routine_data{$rtn_number} .= $string;
  }

  #
  # Build invocation wrappers
  #
  if (($rtn_rcv_query == $RTN_RCV_DATA) || ($rtn_rcv_query == $RTN_RCV_NODATA)) {
    $routine_code{$rtn_number} .= 
      "static inline ushort ${rtn_base_name}_rcv_call_ (\n" .
      "    vinesipcsocket *socket,\n" .
      "    uchar  *call,\n" .
      "    uchar  *reply)\n" .
      "{\n" .
      "    return(${rtn_base_name}_rcv_call(socket, " .
      "(${rtn_base_name}_query *)call, " .
      "(${rtn_base_name}_reply *)reply));\n" .
      "}\n\n";

    $routine_externs{$rtn_number} .= 
      "extern ushort ${rtn_base_name}_rcv_call(vinesipcsocket *, " .
        "${rtn_base_name}_query *, ${rtn_base_name}_reply *);\n";
  }

  if (($rtn_send_reply == $RTN_SEND_DATA) || ($rtn_send_reply == $RTN_SEND_NODATA)) {
    $routine_code{$rtn_number} .= 
      "static inline void ${rtn_base_name}_send_reply (\n" .
      "    vinesipcsocket *socket,\n" .
      "    ${rtn_base_name}_reply *reply)\n" .
      "{\n" .
      "    vsvc_rtn_info *routine;\n\n" .
      "    routine = vsvc_find_routine(&vsvc_${svc_labbrev}_info, $rtn_base_uname);\n" .
      "    if (!routine) {\n" .
      "        vsvc_oops_buginf(\"$svc_uabbrev\", \"$rtn_base_name\", \"sending reply\");\n" .
      "        return;\n" .
      "    }\n" .
      "    vsvc_send_reply(socket, &vsvc_${svc_labbrev}_info, routine, (uchar *)reply);\n" .
      "}\n\n";
  }
 
  if (($rtn_rcv_reply == $RTN_RCV_DATA) || ($rtn_rcv_reply == $RTN_RCV_NODATA)) {
    $routine_code{$rtn_number} .= 
      "static inline void ${rtn_base_name}_rcv_reply_ (\n" .
      "    vinesipcsocket *socket,\n" .
      "    uchar *reply)\n" .
      "{\n" .
      "    ${rtn_base_name}_rcv_reply(socket, " .
      "(${rtn_base_name}_reply *)reply);\n" .
      "}\n\n";

    $routine_externs{$rtn_number} .=
      "extern void ${rtn_base_name}_rcv_reply(vinesipcsocket *, ${rtn_base_name}_reply *);\n";
  }

  if (($rtn_send_query == $RTN_SEND_DATA) || ($rtn_send_query == $RTN_SEND_NODATA)) {
    $routine_code{$rtn_number} .= 
      "static inline void ${rtn_base_name}_send_call_ (\n" .
      "    vinesipcsocket *socket,\n" .
      "    ${rtn_base_name}_query *call)\n" .
      "{\n" .
      "    vsvc_rtn_info *routine;\n\n" .
      "    routine = vsvc_find_routine(&vsvc_${svc_labbrev}_info, $rtn_base_uname);\n" .
      "    if (!routine) {\n" .
      "        vsvc_oops_buginf(\"$svc_uabbrev\", \"$rtn_base_name\", \"sending call\");\n" .
      "        return;\n" .
      "    }\n" .
      "    vsvc_send_call(socket, &vsvc_${svc_labbrev}_info, routine, (uchar *)call);\n" .
      "}\n\n";
  }

  if ($rtn_send_data == $RTN_SEND_DATA) {
    $routine_code{$rtn_number} .= 
      "static inline void ${rtn_base_name}_send_other_ (\n" .
      "    vinesaddress *address,\n" .
      "    ${rtn_base_name}_other *other)\n" .
      "{\n" .
      "    vsvc_rtn_info *routine;\n\n" .
      "    routine = vsvc_find_routine(&vsvc_${svc_labbrev}_info, $rtn_base_uname);\n" .
      "    if (!routine) {\n" .
      "        vsvc_oops_buginf(\"$svc_uabbrev\", \"$rtn_base_name\", \"sending data\");\n" .
      "        return;\n" .
      "    }\n" .
      "    vsvc_send_other(address, &vsvc_${svc_labbrev}_info, routine, (uchar *)other);\n" .
      "}\n\n";
  }

  if ($rtn_rcv_abort == $TRUE) {
    $routine_externs{$rtn_number} .= 
      "extern void ${rtn_base_name}_rcv_abort(vinesipcsocket *, ushort);\n";
  }

  if ($rtn_rcv_reject == $TRUE) {
    $routine_externs{$rtn_number} .= 
      "extern void ${rtn_base_name}_rcv_reject(vinesipcsocket *, ushort);\n";
  }

  #
  # Build routine descriptions
  #
  $string  = sprintf("\n  /*\n   * $rtn_name\n   */\n");
  $string .= sprintf("  {\"%s\", \"%s\",", $rtn_name, $rtn_abbrev);
  &add_comment($string, "name, abbrev");
  $string .= sprintf("   0x%04x,", $rtn_number);
  &add_comment($string, "number");

  # Initiate transaction
  if (($rtn_rcv_reply == $RTN_RCV_DATA) || ($rtn_rcv_reply == $RTN_RCV_NODATA)) {
    $temp = "${rtn_base_name}_rcv_reply_";
  } else {
    $temp = "NULL";
  }
  $string .= sprintf("   0x%02x, 0x%02x,", $rtn_send_query, $rtn_rcv_reply);
  &add_comment($string, "send query flags, rcv reply flags");
  $string .= sprintf("   %s,", $temp);
  &add_comment($string, "send query function");

  # Receive transaction
  if (($rtn_rcv_query == $RTN_RCV_DATA) || ($rtn_rcv_query == $RTN_RCV_NODATA)) {
    $temp = "${rtn_base_name}_rcv_call_";
  } else {
    $temp = "NULL";
  }
  $string .= sprintf("   0x%02x, 0x%02x,", $rtn_rcv_query, $rtn_send_reply);
  &add_comment($string, "rcv query flags, send reply flags");
  $string .= sprintf("   %s,", $temp);
  &add_comment($string, "rcv query function");
  $string .= sprintf("   %s,", $rtn_reject_code);
  &add_comment($string, "send reject code");

  if ($rtn_rcv_abort == $TRUE) {
    $temp = "${rtn_base_name}_rcv_abort";
  } else {
    $temp = "NULL";
  }
  $string .= sprintf("   %s,", $temp);
  &add_comment($string, "rcv abort fn");

  if ($rtn_rcv_reject == $TRUE) {
    $temp = "${rtn_base_name}_rcv_reject";
  } else {
    $temp = "NULL";
  }
  $string .= sprintf("   %s,", $temp);
  &add_comment($string, "rcv reject fn");

  # Query Packing/Unpacking
  if (($rtn_rcv_query == $RTN_RCV_DATA) || ($rtn_send_query == $RTN_SEND_DATA)) {
    $string .= "   sizeof(${rtn_base_name}_query),";
  } else {
    $string .= "   0,";
  }
  &add_comment($string, "query length");
  if ($rtn_send_query == $RTN_SEND_DATA) {
    $string .= "   ${rtn_base_name}_query_pack,";
  } else {
    $string .= "   NULL,";
  }
  &add_comment($string, "query packing routine");
  if ($rtn_rcv_query == $RTN_RCV_DATA) {
    $string .= "   ${rtn_base_name}_query_unpack,";
  } else {
    $string .= "   NULL,";
  }
  &add_comment($string, "query unpacking routine");
  if ($query_is_padded == $TRUE) {
    $string .= "   TRUE,";
  } else {
    $string .= "   FALSE,";
  }
  &add_comment($string, "query has padding at end");

  # Reply Packing/Unpacking
  if (($rtn_send_reply == $RTN_SEND_DATA) || ($rtn_rcv_reply == $RTN_RCV_DATA)) {
    $string .= "   sizeof(${rtn_base_name}_reply),";
  } else {
    $string .= "   0,";
  }
  &add_comment($string, "reply length");
  if ($rtn_send_reply == $RTN_SEND_DATA) {
    $string .= "   ${rtn_base_name}_reply_pack,";
  } else {
    $string .= "   NULL,";
  }
  &add_comment($string, "reply packing routine");
  if ($rtn_rcv_reply == $RTN_RCV_DATA) {
    $string .= "   ${rtn_base_name}_reply_unpack,";
  } else {
    $string .= "   NULL,";
  }
  &add_comment($string, "reply unpacking routine");

  # IPC Data Packing/Unpacking
  if (($rtn_send_data == $RTN_SEND_DATA) || ($rtn_rcv_data == $RTN_RCV_DATA)) {
    $string .= "   sizeof(${rtn_base_name}_other),";
  } else {
    $string .= "   0,";
  }
  &add_comment($string, "other length");
  if ($rtn_send_data & $RTN_SEND_DATA) {
    $string .= "   ${rtn_base_name}_other_pack,";
  } else {
    $string .= "   NULL,";
  }
  &add_comment($string, "other packing routine");
  if ($rtn_rcv_data & $RTN_RCV_DATA) {
    $string .= "   ${rtn_base_name}_other_unpack,";
  } else {
    $string .= "   NULL,";
  }
  &add_comment($string, "other unpacking routine");

  $string .= sprintf("  },\n");
  $routines{$rtn_number} = $string;

  #
  # Set next state
  #
  $ds_prefix = "v${svc_labbrev}";
  $state = $s_service;
}

#
# Parse the commands expected at the ROUTINE level
#
sub parse_routine
{
  local($t1, $t2, $t3, $t4, $rest, $string, $leftover);
  ($t1, $t2, $rest) = split(' ',$Line,3);
  if ($t1 eq 'DATA') {			# Start of verbatim text
    if (length($t2) || length($rest)) {	# Extra data on line
      &extraerr;
    }
    &begin_data;			# Process data
  } elsif ($t1 eq 'NAME') {		# Routine name
    ($t1, $rtn_name) = split(' ',$Line,2);
    ($rtn_lname = $rtn_name) =~ tr/A-Z/a-z/;	# Make lower case
  } elsif ($t1 eq 'NUMBER') {		# Procedure number
    if (length($rest)) {		# Extra data on line
      &extraerr;
    }
    $rtn_number = $t2;
  } elsif ($t1 eq 'SEND') {		# Arguments to a SEND
    ($t3, $t4, $leftover) = split(' ',$rest,3);
    if (($t2 eq 'NODATA') || ($t3 eq 'NODATA')) {
      $rtn_send_query = $RTN_SEND_NODATA;
    } else {
      $rtn_send_query = $RTN_SEND_DATA;
    }				# 
    if (($t2 eq 'PROXY') || ($t3 eq 'PROXY')) {
      $rtn_rcv_reply |= $RTN_PROXY;
    } elsif (($t2 eq 'NOREPLY') || ($t3 eq 'NOREPLY')) {
      # nothing
    } else {
      $rtn_rcv_reply |= $RTN_RCV_DATA;
    }
  } elsif ($t1 eq 'RECEIVE') {
    if ($t2 eq 'ACCEPT') {
      ($t3, $t4, $leftover) = split(' ',$rest,3);
      if (($t3 eq 'NODATA') || ($t4 eq 'NODATA')) {
	$rtn_rcv_query = $RTN_RCV_NODATA;
      } else {
	$rtn_rcv_query = $RTN_RCV_DATA;
      }
      if (($t3 ne 'NOREPLY') && ($t4 ne 'NOREPLY')) {
	$rtn_send_reply = $RTN_SEND_DATA;
      }
    } elsif ($t2 eq 'REJECT') {
      ($t3, $leftover) = split(' ',$rest,2);
      if (length($t3)) {
	$rtn_rcv_query = $RTN_RCV_REJECT;
	$rtn_reject_code = $t3;
      } else {
	&errmsg("Error code required for CALL REJECT.");
      }
    } elsif ($t2 eq 'IGNORE') {
      $leftover = $rest;
      $rtn_rcv_query = $RTN_RCV_IGNORE;
    } elsif ($t2 eq 'PROXY') {
      $leftover = $rest;
      $rtn_rcv_query = $RTN_RCV_PROXY;
    } else {
      $leftover = '';
      &errmsg("Expecting CALL RECEIVE [ ACCEPT | REJECT | IGNORE | PROXY ].");
    }
    if (length($leftover)) {		# Extra data on line
      &extraerr;
    }
  } elsif ($t1 eq 'NOTIFY') {		# Arguments to a NOTIFY
    ($t3, $leftover) = split(' ',$rest,2);
    if (($t2 eq 'ABORT') || ($t3 eq 'ABORT')) {
      $rtn_rcv_abort = $TRUE;
    }
    if (($t2 eq 'REJECT') || ($t3 eq 'REJECT')) {
      $rtn_rcv_reject = $TRUE;
    }
  } elsif ($t1 eq 'OTHER') { 
    ($t3, $leftover) = split(' ',$rest,3);
    if (($t2 eq 'SEND') || ($t3 eq 'SEND')) {
      $rtn_send_data = $RTN_SEND_DATA;
      $routine_has_data = $TRUE;
    }
    if (($t2 eq 'RECEIVE') || ($t3 eq 'RECEIVE')) {
      $rtn_rcv_data = $RTN_RCV_DATA;
      $routine_has_data = $TRUE;
    }
    if (($t2 ne 'SEND') && ($t2 ne 'RECEIVE') &&
	($t3 ne 'SEND') && ($t3 ne 'RECEIVE')) {
      &errmsg("Expecting OTHER [ SEND ] [ RECEIVE ]");
    }
  } elsif ($t1 eq 'STRUCT') {
      $rtn_structures{$t2} = $TRUE;
      &begin_ds($t2, $NOT_CONTENT, $TRUE);
  } elsif ($t1 eq 'CONTENT') {
    ($t3, $leftover) = split(' ',$rest,2);
    if ($t3 eq 'EMPTY') {
      $has_body = $FALSE;
    } else {
      $has_body = $TRUE;
    }
    if ($t2 eq 'QUERY') {
      $routine_has_query = $TRUE;
      $routine_has_code = $TRUE;
      if ($t3 eq 'PADDED') {
	$query_is_padded = $TRUE;
      }
      &begin_ds('query', $CONTENT, $has_body);
    } elsif ($t2 eq 'REPLY') {
      $routine_has_reply = $TRUE;
      $routine_has_code = $TRUE;
      &begin_ds('reply', $CONTENT, $has_body);
    } elsif ($t2 eq 'OTHER') {
      $routine_has_other = $TRUE;
      $routine_has_code = $TRUE;
      &begin_ds('other', $CONTENT, $has_body);
    } else {
      &errmsg("Expecting CONTENT [ QUERY | REPLY | OTHER ]");
    }
    if ($t3 eq 'EMPTY') {
      &end_ds;
    }
  } elsif ($t1 eq 'END') {		# End of routine
    if ($t2 eq 'ROUTINE') { 		# Really end of routine
      &end_routine;			# Finish building routine
    } elsif (length($t2)) {
      &errmsg("Expecting END ROUTINE");
    } else {
      &errmsg("Expecting END ROUTINE, not just END");
    }
  } else {				# Unexpected statement
    &errmsg("Expecting SEND, RECEIVE, DATA, ABBREV, NUMBER or END statement");
  }
}


########################################################################
#
# Data Structure subroutines follow
#
########################################################################

sub begin_ds
{
  local($dstring, $pstring, $ustring, $type, $body);

  # Save what's currently being collected.
  push(@routine_stack, $state);
  push(@routine_stack, $ds_name);
  push(@routine_stack, $str_name);
  push(@routine_stack, join('~', @ds));
  push(@routine_stack, join('~', @pack));
  push(@routine_stack, join('~', @unpack));

  # Start a new collection.
  $state = $s_ds;
  ($ds_name, $type, $body) = @_;
  @ds = ( );
  @pack = ( );
  @unpack = ( );

  $str_name = "${ds_prefix}_${ds_name}";
#  printf STDOUT "data structure $str_name\n";
  $dstring = "typedef struct ${str_name}_ {";
  if ($type == $CONTENT) {
    $pstring = "static inline uchar *${str_name}_pack (\n" .
               "    uchar *packed,\n" . 
	       "    uchar *unpacked)\n" . 
	       "{\n";
    if ($body == $TRUE) {
      $pstring .= "    ${str_name} *ds = (${str_name} *)unpacked;\n";
    }
    $ustring = "static inline uchar *${str_name}_unpack (\n" . 
               "    uchar *packed,\n" .
	       "    uchar *unpacked)\n" . 
		 "{\n";
    if ($body == $TRUE) {
      $ustring .= "    ${str_name} *ds = (${str_name} *)unpacked;\n";
    }
  } else {
    $pstring = "static inline uchar *${str_name}_pack (\n" .
               "    uchar *packed,\n" . 
	       "    $str_name *ds)\n" . 
	       "{";
    $ustring = "static inline uchar *${str_name}_unpack (\n" . 
               "    uchar *packed,\n" .
	       "    $str_name *ds)\n" . 
	       "{";
  }

  push(@ds, $dstring);
  push(@pack, $pstring);
  push(@unpack, $ustring);
}

sub end_ds
{
  local($string);

  push(@ds, "} ${str_name};\n\n");
  push(@pack, "    return(packed);\n}\n\n");
  push(@unpack, "    return(packed);\n}\n\n");

  # Save them so that everything is printed in the proper order.
  if ($routine_data_started eq 0) {
    $string = sprintf("Data structures for `%s' (%d)\n", $rtn_name, $rtn_number);
    &big_comment($routine_data{$rtn_number}, $string);
    $routine_data_started = 1;
  }
  $routine_data{$rtn_number} .= join("\n", @ds);

  if ($routine_code_started eq 0) {
    $string = sprintf("Inlines for `%s' (s)", $rtn_name, $rtn_number);
    &big_comment($routine_code{$rtn_number}, $string);
    $routine_code_started = 1;
  }
  if ($ds_name eq 'query') {
    if ($rtn_send_query == $RTN_SEND_DATA) {
      $routine_code{$rtn_number} .= join("\n", @pack);
    }
    if ($rtn_rcv_query == $RTN_RCV_DATA) {
      $routine_code{$rtn_number} .= join("\n", @unpack);
    }
  } elsif ($ds_name eq 'reply') {
    if ($rtn_send_reply == $RTN_SEND_DATA) {
      $routine_code{$rtn_number} .= join("\n", @pack);
    }
    if ($rtn_rcv_reply == $RTN_RCV_DATA) {
      $routine_code{$rtn_number} .= join("\n", @unpack);
    }
  } elsif ($ds_name eq 'other') {
    if ($rtn_send_data == $RTN_SEND_DATA) {
      $routine_code{$rtn_number} .= join("\n", @pack);
    }
    if ($rtn_rcv_data == $RTN_RCV_DATA) {
      $routine_code{$rtn_number} .= join("\n", @unpack);
    }
  } else {
    $routine_code{$rtn_number} .= join("\n", @pack);
    $routine_code{$rtn_number} .= join("\n", @unpack);
  }

  # Go back to the previous state
  @unpack = split('~', pop(@routine_stack));
  @pack   = split('~', pop(@routine_stack));
  @ds     = split('~', pop(@routine_stack));
  $str_name = pop(@routine_stack);
  $ds_name = pop(@routine_stack);
  $state  = pop(@routine_stack);
}

sub parse_ds
{
  local($t1, $t2, $t3, $t4, $rest, $name, $modifier, $dummy);
  local($dstring, $pstring, $ustring, $strlen, $tmp);
  ($t1, $t2, $rest) = split(' ',$Line,3);
  $t1 =~ tr/A-Z/a-z/;
  if ($alias{$t1} ne '') {
    $tmp = $alias{$t1};
    $t1 = $tmp;
  }
  if ($string{$t1} ne '') {
    $strlen = $string{$t1};
    $t1 = 'string';
  } else {
    $strlen = '';
  }

  ($modifier, $dummy) = split(' ',$rest,2);
  $modifier =~ tr/A-Z/a-z/;

  if ($modifier eq 'array') {		# Fixed size array
    local($type, $foo);
    $foo = $rest;
    ($t3, $t4, $rest) = split(' ',$foo,3);
    if ($simpletype_valid{$t1} != $TRUE) {
      &errmsg("Invalid type of array: $t1");
    }
    $type = $simpletype_type{$t1};

    $dstring = sprintf("    %s\t%s[%s];", $type, $t2, $t4);
    if (length($rest)) {
      $dstring .= "\t/* $rest */";
    }

    $pstring  = sprintf("    {\n");
    $pstring .= sprintf("      int i;\n");
    $pstring .= sprintf("      for (i = 0; i < %s; i++) {\n", $t4);
    $pstring .= sprintf("        packed = vines_insert_%s(packed, %sds->%s[i]);\n",
			$t1, $insert_prefix{$t1}, $t2);
    $pstring .= sprintf("      }\n");
    $pstring .= sprintf("    }");

    $ustring  = sprintf("    {\n");
    $ustring .= sprintf("      int i;\n");
    $ustring .= sprintf("      for (i = 0; i < %s; i++) {\n", $t4);
    $ustring .= sprintf("  	 packed = vines_extract_%s(packed, %sds->%s[i]);\n",
			$t1, $extract_prefix{$t1}, $t2);
    $ustring .= sprintf("      }\n");
    $ustring .= sprintf("    }");

    push(@ds, $dstring);
    push(@pack, $pstring);
    push(@unpack, $ustring);
  } elsif ($modifier eq 'sequence') {	# Variable size array with limit
    ($t1, $t2, $t3, $t4, $rest) = split(' ',$Line,5);
    if ($simpletype_valid{$t1} != $TRUE) {
      &errmsg("Invalid type of array: $t1");
    }
    $type = $simpletype_type{$t1};

    $dstring .= sprintf("    ushort\t%s_count;", $t2);
    $dstring .= sprintf("    %s\t%s[%s];", $type, $t2, $t4);
    if (length($rest)) {
      $dstring .= "\t/* $rest */";
    }

    $pstring  = sprintf("    {\n");
    $pstring .= sprintf("      int i;\n");
    $pstring .= sprintf("      packed = vines_insert_short(packed, ds->%s_count);\n", $t2);
    $pstring .= sprintf("      for (i = 0; ((i < ds->%s_count) && (i < %s)); i++) {\n", $t2, $t4);
    $pstring .= sprintf("        packed = vines_insert_%s(packed, %sds->%s[i]);\n",
			$t1, $insert_prefix{$t1}, $t2);
    $pstring .= sprintf("      }\n");
    $pstring .= sprintf("    }");

    $ustring  = sprintf("    {\n");
    $ustring .= sprintf("      int i;\n");
    $ustring .= sprintf("      packed = vines_extract_short(packed, &ds->%s_count);\n", $t2);
    $ustring .= sprintf("      for (i = 0; ((i < ds->%s_count) && (i < %s)); i++) {\n", $t2, $t4);
    $ustring .= sprintf("        packed = vines_extract_%s(packed, %sds->%s[i]);\n",
			$t1, $extract_prefix{$t1}, $t2);
    $ustring .= sprintf("      }\n");
    $ustring .= sprintf("    }");

    push(@ds, $dstring);
    push(@pack, $pstring);
    push(@unpack, $ustring);
  } elsif (($t1 eq 'string') || ($t1 eq 'smstring')) {
    if ($strlen eq '') {
      ($t1, $t2, $strlen, $rest) = split(' ',$Line,4);
    }
    $dstring = sprintf("    char\t%s[%s];", $t2, $strlen);
    $pstring = sprintf("    packed = vines_insert_%s(packed, ds->%s, %s);", $t1, $t2, $strlen);
    $ustring = sprintf("    packed = vines_extract_%s(packed, ds->%s, %s);", $t1, $t2, $strlen);
    if (length($rest)) {
      $dstring .= "\t/* $rest */";
    }
    push(@ds, $dstring);
    push(@pack, $pstring);
    push(@unpack, $ustring);
  } elsif ($simpletype_valid{$t1} == $TRUE) {
    if ($simpletype_args{$t1} == 1) {
      $dstring = sprintf("    %s\t%s;", $simpletype_type{$t1}, $t2);
      $pstring = sprintf("    packed = vines_insert_%s(packed, %sds->%s);",
			 $t1, $insert_prefix{$t1}, $t2);
      $ustring = sprintf("    packed = vines_extract_%s(packed, %sds->%s);",
			 $t1, $extract_prefix{$t1}, $t2);
    } if ($simpletype_args{$t1} == 2) {
      ($t1, $t2, $t3, $rest) = split(' ',$Line,4);
      $dstring = sprintf("    %s\t%s[%s];", $simpletype_type{$t1}, $t2, $t3);
      $pstring = sprintf("    packed = vines_insert_%s(packed, %sds->%s, %s);",
			 $t1, $insert_prefix{$t1}, $t2, $t3);
      $ustring = sprintf("    packed = vines_extract_%s(packed, %sds->%s, %s);",
			 $t1, $extract_prefix{$t1}, $t2, $t3);
    }
    if (length($rest)) {
      $dstring .= "\t/* $rest */";
    }
    push(@ds, $dstring);
    push(@pack, $pstring);
    push(@unpack, $ustring);
  } elsif (($svc_structures{$t1} == $TRUE) ||
	   ($rtn_structures{$t1} == $TRUE)) {
    ($modifier, $dummy) = split(' ',$rest,2);
    $modifier =~ tr/A-Z/a-z/;
    if ($svc_structures{$t1} == $TRUE) {
      $name = "v${svc_labbrev}_${t1}";
    } else {
      $name = "${rtn_base_name}_${t1}";
    }
    
    if ($modifier eq 'limit') {
      ($t1, $t2, $t3, $t4, $rest) = split(' ',$Line,5);
      $dstring .= sprintf("    %s\t%s[%s];", $name, $t2, $t4);

      $pstring  = sprintf("    {\n");
      $pstring .= sprintf("      int i;\n\n");
      $pstring .= sprintf("      for (i = 0; i < ds->%s_count; i++) {\n", $t2);
      $pstring .= sprintf("        packed = %s_pack(packed, &ds->%s[i]);\n", $name, $t2);
      $pstring .= sprintf("      }\n");
      $pstring .= sprintf("    }");

      $ustring .= sprintf("    {\n");
      $ustring .= sprintf("      int i;\n\n");
      $ustring .= sprintf("      for (i = 0; i < ds->%s_count; i++) {\n", $t2);
      $ustring .= sprintf("        packed = %s_unpack(packed, &ds->%s[i]);\n", $name, $t2);
      $ustring .= sprintf("      }\n");
      $ustring .= sprintf("    }");
    } else {
      $dstring .= sprintf("    %s\t%s;", $name, $t2);
      $pstring .= sprintf("    packed = %s_pack(packed, &ds->%s);", $name, $t2);
      $ustring .= sprintf("    packed = %s_unpack(packed, &ds->%s);", $name, $t2);
    }
    if (length($rest)) {
      $dstring .= "\t/* $rest */";
    }
    push(@ds, $dstring);
    push(@pack, $pstring);
    push(@unpack, $ustring);
  } elsif (($t1 eq 'struct') || ($t1 eq 'record')) {
    ($modifier, $dummy) = split(' ',$rest,2);
    $modifier =~ tr/a-z/A-Z/;
    $name = "${ds_prefix}_${t2}";
    
    if ($modifier eq 'LIMIT') {
      ($t1, $t2, $t3, $t4, $rest) = split(' ',$Line,5);
      $dstring .= sprintf("    %s\t%s[%s];", $name, $t2, $t4);

      $pstring  = sprintf("    {\n");
      $pstring .= sprintf("      int i;\n\n");
      $pstring .= sprintf("      for (i = 0; i < ds->%s_count; i++) {\n", $t2);
      $pstring .= sprintf("        packed = %s_pack(packed, &ds->%s[i]);\n", $name, $t2);
      $pstring .= sprintf("      }\n");
      $pstring .= sprintf("    }");

      $ustring .= sprintf("    {\n");
      $ustring .= sprintf("      int i;\n\n");
      $ustring .= sprintf("      for (i = 0; i < ds->%s_count; i++) {\n", $t2);
      $ustring .= sprintf("        packed = %s_unpack(packed, &ds->%s[i]);\n", $name, $t2);
      $ustring .= sprintf("      }\n");
      $ustring .= sprintf("    }");
    } else {
      $dstring .= sprintf("    %s\t%s;", $name, $t2);
      $pstring .= sprintf("    packed = %s_pack(packed, &ds->%s);", $name, $t2);
      $ustring .= sprintf("    packed = %s_unpack(packed, &ds->%s);", $name, $t2);
    }
    if (length($rest)) {
      $dstring .= "\t/* $rest */";
    }
    push(@ds, $dstring);
    push(@pack, $pstring);
    push(@unpack, $ustring);
    &begin_ds($t2, $NOT_CONTENT, $TRUE);
  } elsif ($t1 eq 'union') {
    $name = "${ds_prefix}_${t2}";
    $dstring .= sprintf("    %s\t%s;", $name, $t2);
    $pstring .= sprintf("    packed = %s_pack(packed, &ds->%s, ds->%s_type);",
			$name, $t2, $t2);
    $ustring .= sprintf("    packed = %s_unpack(packed, &ds->%s, ds->%s_type);",
			$name, $t2, $t2);

    push(@ds, $dstring);
    push(@pack, $pstring);
    push(@unpack, $ustring);
    &begin_union($t2, $rest);
  } elsif ($t1 eq 'end') {		# end of data structure
    $t2 =~ tr/A-Z/a-z/;
    if ($t2 eq 'union') {
      &end_ds;
      &end_union;
    } elsif (($t2 eq 'content') || ($t2 eq 'struct') ||
	     ($t2 eq 'query') || ($t2 eq 'reply') || ($t2 eq 'other')) {
      &end_ds;
    }
    elsif (length($t2)) {
      &errmsg("Expecting END CONTENT");
    }
    else {
      &errmsg("Expecting END CONTENT, not just END");
    }
  } elsif ($t1 eq 'case') {
    &end_ds;
    &parse_union;
  } else {				# Unexpected statement
    &errmsg("Invalid data type (parse_ds): $t1.");
    $state = $s_skend;
  }
}


########################################################################
#
# `UNION' Data Structure subroutines follow
#
########################################################################

sub begin_union
{
  local($dstring, $pstring, $ustring, $type, $comment);

  # Save what's currently being collected.
  push(@routine_stack, $state);
  push(@routine_stack, $ds_name);
  push(@routine_stack, $str_name);
  push(@routine_stack, join('~', @ds));
  push(@routine_stack, join('~', @pack));
  push(@routine_stack, join('~', @unpack));

  # Start a new collection.
  $state = $s_union;
  ($ds_name, $comment) = @_;
  @ds = ( );
  @pack = ( );
  @unpack = ( );

  $str_name = "${ds_prefix}_${ds_name}";
  $dstring = "typedef union ${str_name}_ {";
  $pstring = "static inline uchar *${str_name}_pack (\n" .
             "    uchar *packed,\n" . 
	     "    $str_name *ds,\n" .
	     "    int which_case)\n" . 
	     "{\n" .
	     "    switch (which_case) {";
  $ustring = "static inline uchar *${str_name}_unpack (\n" . 
             "    uchar *packed,\n" .
	     "    $str_name *ds,\n" .
	     "    int which_case)\n" . 
	     "{\n" .
	     "    switch (which_case) {";

  push(@ds, $dstring);
  push(@pack, $pstring);
  push(@unpack, $ustring);
}

sub end_union
{
  local($pstring, $ustring, $name);

  # Finish up the current structures.
  push(@ds, "} ${str_name};\n\n");
  $pstring  = sprintf("      default:\n");
  $pstring .= sprintf("        if (v%s_debug)\n", $svc_labbrev);
  $pstring .= sprintf("          buginf(\"\\nV%s: Illegal case %%d packing union ${str_name}\", which_case);\n",
		      $svc_uabbrev);
  $pstring .= sprintf("        break;\n");
  $pstring .= sprintf("    }\n");
  $pstring .= sprintf("    return(packed);\n");
  $pstring .= sprintf("}\n");
  $ustring  = sprintf("      default:\n");
  $ustring .= sprintf("        if (v%s_debug)\n", $svc_labbrev);
  $ustring .= sprintf("          buginf(\"\\nV%s: Illegal case %%d unpacking union ${str_name}\", which_case);\n",
		      $svc_uabbrev);
  $ustring .= sprintf("        break;");
  $ustring .= sprintf("    }\n");
  $ustring .= sprintf("    return(packed);\n");
  $ustring .= sprintf("}\n");
  push(@pack, $pstring);
  push(@unpack, $ustring);

  $routine_data{$rtn_number} .= join("\n", @ds);
  $routine_code{$rtn_number} .= join("\n", @pack);
  $routine_code{$rtn_number} .= join("\n", @unpack);

  # Go back to the previous state
  @unpack = split('~', pop(@routine_stack));
  @pack   = split('~', pop(@routine_stack));
  @ds     = split('~', pop(@routine_stack));
  $str_name = pop(@routine_stack);
  $ds_name = pop(@routine_stack);
  $state  = pop(@routine_stack);
}

sub parse_union
{
  local($label, $t1, $t2, $t3, $rest, $name);
  local($dstring, $pstring, $ustring);

  # Get label for this case
  ($t1, $t2, $t3, $rest) = split(' ',$Line,4);
  $t1 =~ tr/A-Z/a-z/;
  if ($t1 eq 'case') {	# Fixed size 
    $name = "${ds_prefix}_${t2}";
    $dstring  = sprintf("      %s\t%s;", $name, $t2);
    if (length($rest)) {
      $dstring .= "\t/* $rest */";
    }

    $pstring  = sprintf("      case %s:\n", $t3);
    $pstring .= sprintf("        packed = %s_pack(packed, &ds->%s);\n", $name, $t2);
    $pstring .= sprintf("        break;");

    $ustring  = sprintf("      case %s:\n", $t3);
    $ustring .= sprintf("        packed = %s_unpack(packed, &ds->%s);\n", $name, $t2);
    $ustring .= sprintf("        break;");

    push(@ds, $dstring);
    push(@pack, $pstring);
    push(@unpack, $ustring);
    &begin_ds($t2, $NOT_CONTENT, $TRUE);
  } else {				# Unexpected statement
    &errmsg("Invalid data type (parse_union): $t1.");
  }
}


#
# Initialize at start of DEFINE command
#
sub define
{
  ($service) = @_;			# Get parameters
  if (length($service)) {		# Make sure something there
    if ($service =~ /\W/) {		# Check for illegal characters
      &errmsg("Illegal character in '$service'");
      $state = $s_skend;		# Skip to END
    }
    else {
      ($uservice = $service) =~ tr/a-z/A-Z/;# Translate to upper case
      $uservice = "SERVICE_$uservice";  # Make full service name
      &want_comment;
      @data = ();			# No longer defined
      @prototype = ();			# No longer defined
      $cases=0;				# Null value
      $case_proto = '';			# No longer defined
    }
  }
  else {
    &errmsg("No service name specified");
    $state = $s_skend;			# Skip to END
  }
}


########################################################################
#
# COMMENT subroutines follow
#
########################################################################

#
# Set up to expect comment
#
sub want_comment
{
  $prev_state = $state;			# Remember old state
  $state = $s_comment;			# Look for comment
  $comment = '';			# No longer defined
}

#
# Process first comment line
#
sub begin_comment
{
  if ($Line !~ /^\s*\/\*/) {		# Start of comment
    &errmsg("Expecting comment.");
    $state=$s_skend;			# Skip to next end
  }

  ($rest = $Line) =~ s/^\s*\/\*\s*//;	# remove /*
  $state = $s_pc;			# Process more comment lines
  if (length($rest)) {			# Data exists
    if ($rest =~ s/\s*\*\/\s*$//) {	# Remove ending sequence if there
					# Must be one line comment
      $state = $prev_state;		# Done with comment sequence
    }
    ($comment = $rest) =~ s/\s*$//;	# Start the comment string
					# with no trailing blanks
  }
  else {
    $comment = '';			# Null comment string
  }
}

#
# Process subsequent comment lines
#
sub more_comment
{
  if ($Line =~ s/\s*\*\/\s*$//) {	# Remove ending sequence if there
    $state = $prev_state;		# Done with comment sequence
  }
  if ($Line =~ s/^\s*\*\s*//) {		# Comment bar format
    if (length($comment)) {
      $comment = $comment."\n * ".$Line;# Add new line
    }
    else {
      $comment = $Line;			# First line in comment bar
    }
  }
  else {
    $Line =~ s/^\s*(.*)\s*$/$1/;	# Remove leading and trailing blanks
    if (length($Line)) {		# Some data still exists
      if (length($comment)) {
        $comment = $comment." ".$Line;	# Add to string
      }
      else {
        $comment = $Line;		# First line in comment
      }
    }
  }

  if (($state == $prev_state) && ($state == $s_service)) {
    $svc_comment = $comment;
  }
}


########################################################################
#
# DATA (aka verbatim text) subroutines follow
#
########################################################################

#
# Start processing for DATA statement
#
sub begin_data
{
  $prev_state = $state;
  $state = $s_pd;			# Process DATA statement
}

#
# Process data records
#
sub more_data
{
  push(@data,$Line);			# Save the data
}

#
# Process END DATA statement
#
sub end_data
{
  $state = $prev_state;			# Return to previous state
}

#
# Parse the text of a DATA field
#
sub parse_data
{
  local($t1, $t2, $t3, $t4, $rest, $string);
  ($t1, $t2, $rest) = split(' ',$Line,3);
  if ($t1 eq 'END') {		# Either END or END DATA
    if ($t2 eq 'DATA') {		# End of data sequence
      if (length($rest)) {		# Extra data on line
	&extraerr;
      }
      &end_data;			# Finish data statement processing
    }
    else {				# Unexpected END statement
      if (length($t2)) {		# Extra data on line
	($t1, $rest) = split(' ',$Line,2);
	&extraerr;
      }
      &errmsg("Unexpected END statement in middle of DATA.");
      $state = $s_skend;		# Look for new DEFINE
    }
  }
  else {				# Just more data
    &more_data;
  }
}


#
# Generate an error message
#
sub errmsg
{
  ($msg) = @_;				# Get parameters
  $errors++;				# One more error
  print STDERR "$infile:$lineno: $Line\n";
  print STDERR "          $msg\n";
}
#
# Generate the extra data error message
#
sub extraerr
{
  &errmsg("Extra data '$rest' ignored.");
}
#
# tell the user out to use this program
#
sub usage {
    print STDERR "Usage: $0 [-c] input-file \n\n";
    exit 1;
}

#
# Sorting routine.  From "Programming Perl", pg 183.
#
sub numerically { $a <=> $b }

#
# Add comment
#
sub add_comment {
  local($i, $count, $pad);
  ($string, $comment) = @_;

  #
  # Count characters after last newline character
  #
  $i = rindex($string, "\n");
  if ($i == -1) {
    $i = 0;
  }
  $count = length($string) - $i;

  #
  # Now pad to the comment column, and add the column
  #
  $pad = 40 - $count;
  if ($pad <= 0) {
    $pad = 1;
  }
  $string .= " "x$pad . "/* $comment */\n";
}

#
# big comment
#
sub big_comment {
  local($count);
  ($string, $comment) = @_;

  $count   = (68 - length($comment)) / 2;
  $string  = "/" . "*"x70 . "\n *\n *" . " "x$count;
  $string .= " $comment\n *\n " . "*"x70 . "/\n\n";
}
