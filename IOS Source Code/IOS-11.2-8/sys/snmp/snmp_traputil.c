/* $Id: snmp_traputil.c,v 3.4.44.4 1996/08/28 13:09:56 thille Exp $
 * $Source: /release/112/cvs/Xsys/snmp/snmp_traputil.c,v $
 *------------------------------------------------------------------
 * snmp_traputil.c:  SNMP trap utilities
 *
 * April 1995, Jeffrey T. Johnson
 *
 * Copyright (c) 1995-1996 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 * $Log: snmp_traputil.c,v $
 * Revision 3.4.44.4  1996/08/28  13:09:56  thille
 * CSCdi67083: Message externs need a cleanup.
 * Branch: California_branch
 * Get rid of all extern msgsym()s in .c files, rework logger.h and
 * msg_foo.c files so they are included and provide the externs.  Clean up
 * other random externs in .c files.
 *
 * Revision 3.4.44.3  1996/08/15  22:47:39  ramk
 * CSCdi65392:  Link up/down traps generated before system configured
 * Branch: California_branch
 * removed "noisy" error messages
 *
 * Revision 3.4.44.2  1996/07/31  00:10:07  ramk
 * CSCdi57452:  SNMP Trap overflow on boot-up
 * Branch: California_branch
 * Trap queue implemented using buffers allocated from system buffer pool.
 * Buginfs changed to errmsgs.
 *
 * Revision 3.4.44.1  1996/04/10  05:17:00  jjohnson
 * CSCdi54210:  Cannot generate SNMP traps at interrupt level
 * Detect and prevent any evil doers
 * Branch: California_branch
 *
 * Revision 3.4  1995/12/28  22:35:44  mordock
 * CSCdi46168:  improve snmp modularity
 * move some code and globals out of the kernel subsystem and back into
 * the snmp subsystem
 *
 * Revision 3.3  1995/11/20  22:27:34  sdurham
 * CSCdi42520:  IF MIB breaks modularity in oddball images
 *        fixed IFMIB subsystem, and moved linkUp/Down trap code to IFMIB.
 *
 * Revision 3.2  1995/11/17  18:58:46  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  13:16:28  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.6  1995/11/08  21:25:42  shaker
 * Merge Arkansas_branch into 11.1 mainline.
 *
 * Revision 2.5  1995/09/06  20:40:15  jjohnson
 * CSCdi39761:  SNMP authentication trap locks up the SNMP task
 * Back out the hack that only addressed the snmp authentication failure
 * trap.  Replace it with a real fix that handles any trap that is being
 * generated by the process that already has exclusive access to the SNMP
 * engine.
 *
 * Revision 2.4  1995/09/02  06:15:45  jjohnson
 * CSCdi39761:  SNMP authentication trap locks up the SNMP task
 * Avoid locking the snmp_semaphore when it has already been locked
 *
 * Revision 2.3  1995/08/22  17:18:18  jjohnson
 * CSCdi39126:  SNMP should use new primitives for mutual exclusion
 *
 * Revision 2.2  1995/07/28  03:52:15  jjohnson
 * CSCdi36656:  snmp fails to generate a trap when line protocol changes
 * When an attempt is made to generate a linkUp or linkDown trap at
 * interrupt level, queue the request up to process level rather than
 * completely ignore it.
 *
 * Revision 2.1  1995/06/07  22:48:41  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

#include "master.h"
#include "address.h"
#include "logger.h"
#include "msg_snmp.c"			/* Not a typo, see logger.h */
#include "interface_private.h"
#include "sr_snmpd.h"
#include "sr_sysmib2.h"
#include "sr_ifmib.h"
#include "sr_old_lsysmib.h"
#include "sr_snmpmib2.h"
#include "sr_snmpv2mib.h"


/*
 * Trap registration table
 */
queuetype	trap_registrationQ;

/*
 * this routine allows method routines to tell snmp about traps that
 * are supported.  this information is used to build views which
 * allow traps to selectively be sent to hosts
 */
void
register_snmp_trap (ulong trap_keyword_id, const char *trap_oid_str)
{
    traptype *trapid;

    /*
     * this is pretty trivial.  We simply allocate a trap registration
     * record, fill it up, and place it on the trap registration queue.
     * No test for duplicate registrations is made.
     *
     * Note Well: The input string pointer is used as is, i.e. the associated
     * data is not copied.  Hence if the caller has dynamicially allocated
     * the string, it should not be freed upon return.
     */

    trapid = malloc_named(sizeof(traptype), "SNMP Trap");
    if (trapid) {
	trapid->trap_oid_str = (char *) trap_oid_str;
	trapid->trap_keyword_id = trap_keyword_id;
	trapid->next = NULL;
	p_enqueue(&trap_registrationQ, trapid);
    }
}

/*
 * process a trap registry call.  This is a front end for do_trap which
 * allows a caller to initiate a trap without knowning the values of the
 * individual var binds.  This routine will process the OIDs in the varbind
 * list, calling the associated method routine to create a varbind list
 * suitable for the do_trap function
 */
void
snmp_trap (long		genTrap,
	   long         specTrap,
	   OID        **varBindList,
	   OID         *enterprise,
	   char        *entV2Trap)
{
    int		objectIndex;
    int		vbIndex;
    VarBind    *previous = NULL;
    VarBind    *current;
    VarBind    *varBinds = NULL;
    pid_t	mypid;
    boolean	lockit;

    /*
     * traps cannot be generated from interrupt level.  Catch any evildoers
     */
    if (onintstack()) {
	errmsg(&msgsym(TRAPINTR, SNMP));
	return;
    }

    /*
     * snmp method routines are not reentrant, so get exclusive access.
     * note that if my pid has already locked the snmp_semaphore, then i
     * already have exclusive access and hence must not attempt to lock
     * the semaphore again.  this may occur when a trap is being sent as
     * a result of, and during the processing of, an snmp message.
     */
    process_get_pid(&mypid);
    lockit = (mypid != snmp_semaphore_pid);
    if (lockit) {
	process_lock_semaphore(snmp_semaphore, MAXULONG);
	snmp_semaphore_pid = mypid;
    }

    /*
     * convert the varbind list from a value-less array of OIDs to
     * a value-full linked list of VarBinds
     */
    for (vbIndex = 0; varBindList[vbIndex]; vbIndex++) {
	objectIndex = find_object(varBindList[vbIndex], EXACT);
	if (objectIndex == -1) {
	    /*
	     * object not found!!??
	     * spit out an error message later
	     */
	} else {
	    current = (*(OidIndex[objectIndex]->get)) (varBindList[vbIndex],
						       OidIndex[objectIndex],
						       EXACT, NULL, -1);
	    if (current == NULL) {
		/*
		 * retreival didn't succeed!!??
		 * spit out an error message later
		 */
	    } else {
		/*
		 * if this is the first VarBind, make it the head of
		 * the list, otherwise attach it to the end
		 */
		if (varBinds == NULL) {
		    varBinds = current;
		} else {
		    previous->next_var = current;
		}
		current->next_var = NULL;
		previous = current;
	    }
	}
    }

    /*
     * done with the method routines
     */
    if (lockit) {
	process_unlock_semaphore(snmp_semaphore);
	snmp_semaphore_pid = NO_PROCESS;
    }

    /*
     * call the "real" trap generating code.  It will free the var binds
     */
    do_trap(genTrap, specTrap, varBinds, enterprise, entV2Trap);

}


/*
	Cisco generates a modified coldStart trap:
          coldStart TRAP-TYPE
              ENTERPRISE  snmp
              VARIABLES   { sysUpTime, whyReload }
              DESCRIPTION
                          "A coldStart trap signifies that the sending
                          protocol entity is reinitializing itself such
                          that the agent's configuration or the protocol
                          entity implementation may be altered."
              ::= 0
 */
#define COLDSTART_TRAP_VBCOUNT 2
static const OID coldVarBinds[COLDSTART_TRAP_VBCOUNT] = {
    {LNsysUpTime, (ulong *)IDsysUpTime},
    {LNwhyReload, (ulong *)IDwhyReload}
};

/*
 * generate a coldStart trap
 */
void
snmp_coldstart_trap (void)
{
    int         vbIndex;
    OID        *vbList[COLDSTART_TRAP_VBCOUNT + 1];
    OID         instanceOID;
    ulong       instance[1];

    /*
     * All the trap varbind objects are scalars (instance is .0)
     */
    instance[0] = 0;
    instanceOID.oid_ptr = instance;
    instanceOID.length = 1;

    /*
     * create the variable binding list
     */
    for (vbIndex = 0; vbIndex < COLDSTART_TRAP_VBCOUNT; vbIndex++) {
        vbList[vbIndex] = CatOID((OID *) &coldVarBinds[vbIndex], &instanceOID);
    }
    vbList[vbIndex] = NULL;

    /*
     * initiate the trap - invoke it twice - the first invocation
     * will prime the arp cache
     */
    snmp_trap(COLD_START_TRAP, 0, vbList, NULL, NULL);
    snmp_trap(COLD_START_TRAP, 0, vbList, NULL, NULL);

    /*
     * free any allocated data
     */
    for (vbIndex = 0; vbIndex < COLDSTART_TRAP_VBCOUNT; vbIndex++) {
        FreeOID(vbList[vbIndex]);
    }

}

/*
	Cisco generates a modified authenticationFailure trap:
          authenticationFailure TRAP-TYPE
              ENTERPRISE  snmp
              VARIABLES   { authAddr }
              DESCRIPTION
                          "An authenticationFailure trap signifies that
                          the sending protocol entity is the addressee
                          of a protocol message that is not properly
                          authenticated.  While implementations of the
                          SNMP must be capable of generating this trap,
                          they must also be capable of suppressing the
                          emission of such traps via an implementation-
                          specific mechanism."
              ::= 4
 */
#define AUTHENTICATION_TRAP_VBCOUNT 1
static const OID authVarBinds[AUTHENTICATION_TRAP_VBCOUNT] = {
    {LNauthAddr, (ulong *)IDauthAddr}
};

/*
 * generate an authenticationFailure trap
 */
void
snmp_authentication_trap (int protocol, addrtype *source_address)
{
    int         vbIndex;
    OID        *vbList[AUTHENTICATION_TRAP_VBCOUNT + 1];
    OID         instanceOID;
    ulong       instance[1];

    /*
     * stash away the source of the failure
     */
    if (source_address->type == ADDR_IP) {
	snmp_bad_addr = source_address->ip_addr;
    } else {
	snmp_bad_addr = 0;
    }

    /*
     * see if the trap is enabled
     */
    if (((protocol == SNMPv1_DOMAIN) &&
	 (snmpData.snmpEnableAuthenTraps == D_snmpEnableAuthenTraps_disabled))
	||
	((protocol == SNMPv2_DOMAIN) &&
	 (snmpTrapData.snmpV2EnableAuthenTraps == D_snmpV2EnableAuthenTraps_false)))
	return;

    /*
     * All the trap varbind objects are scalars (instance is .0)
     */
    instance[0] = 0;
    instanceOID.oid_ptr = instance;
    instanceOID.length = 1;

    /*
     * create the variable binding list
     */
    for (vbIndex = 0; vbIndex < AUTHENTICATION_TRAP_VBCOUNT; vbIndex++) {
        vbList[vbIndex] = CatOID((OID *) &authVarBinds[vbIndex], &instanceOID);
    }
    vbList[vbIndex] = NULL;

    /*
     * initiate the trap
     */
    snmp_trap(AUTHEN_FAILURE_TRAP, 0, vbList, NULL, NULL);

    /*
     * free any allocated data
     */
    for (vbIndex = 0; vbIndex < AUTHENTICATION_TRAP_VBCOUNT; vbIndex++) {
        FreeOID(vbList[vbIndex]);
    }

}
