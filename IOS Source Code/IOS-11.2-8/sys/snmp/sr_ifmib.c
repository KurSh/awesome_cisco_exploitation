/* $Id: sr_ifmib.c,v 3.13.8.15 1996/08/15 22:47:44 ramk Exp $
 * $Source: /release/112/cvs/Xsys/snmp/sr_ifmib.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * February 1995, Sandra Durham (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1995-1997 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_ifmib.c,v $
 * Revision 3.13.8.15  1996/08/15  22:47:44  ramk
 * CSCdi65392:  Link up/down traps generated before system configured
 * Branch: California_branch
 * removed "noisy" error messages
 *
 * Revision 3.13.8.14  1996/08/08  22:16:50  ramk
 * CSCdi65392:  Link up/down traps generated before system configured
 * Branch: California_branch
 *
 * Revision 3.13.8.13  1996/07/24  18:39:26  sdurham
 * CSCdi63762:  snmp: ifEntry table displays wrong values for LEC/ATM
 * interfaces
 * Branch: California_branch - add back hwidb counts to atm physical layer
 *
 * Revision 3.13.8.12  1996/07/08  17:34:02  jjohnson
 * CSCdi57341:  %SYS-2-INTSCHED: idle at level 3 / Process= X25 Timer
 * linkUp/linkDown traps attempted to be generated by processes with
 * interrupts disabled should instead be queued to the snmp trap process
 * Branch: California_branch
 *
 * Revision 3.13.8.11  1996/07/01  18:46:01  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.13.8.10  1996/06/26  03:08:33  sdurham
 * CSCdi54840:  Channelized T1 needs support for ds1 physical interface in
 * snmp
 * Branch: California_branch
 * add support in ifmib for cdbtype
 *
 * Revision 3.13.8.9  1996/06/06  00:17:03  sdurham
 * CSCdi58097:  spurious accesses made at k_getIfEntry
 * Branch: California_branch.  Missing callback rountines are added
 *
 * Revision 3.13.8.8  1996/05/21  10:02:27  thille
 * CSCdi51599:  multiple /interface/ literals bloat code.
 * Branch: California_branch
 * Save another 392 bytes by doing away with duplicate literals.
 *
 * Revision 3.13.8.7  1996/05/21  06:38:44  mordock
 * Branch: California_branch
 * Improve snmp modularity via creating services to register interfaces
 * and chassis cards.
 * Add syslog mib.
 *
 * Revision 3.13.8.6  1996/05/17  11:42:55  ppearce
 * Merge IbuMod into Calif
 *
 * Revision 3.12.2.3  1996/05/05  23:47:06  ppearce
 * Sync to IbuMod_Calif_baseline_960504
 *
 * Revision 3.12.2.2  1996/04/03  21:26:32  ppearce
 * Sync to IbuMod_Calif_baseline_960402
 *
 * Revision 3.12.2.1  1996/03/17  18:29:49  ppearce
 * Sync IbuMod_Calif_branch to V111_1_3
 *
 * Revision 3.13.8.5  1996/04/30  23:17:35  sdurham
 * CSCdi46300:  Interface missing from MIB
 * Branch: California_branch
 *          add atm and aal5 layers to the ifmib
 *
 * Revision 3.13.8.4  1996/04/27  06:47:09  syiu
 * Branch: California_branch
 * Commit Dial1_branch
 *
 * Revision 3.7.8.3  1996/04/26  00:51:16  syiu
 * Branch: Dial1_branch
 * Dial1_branch to IosSec_postmerge_960419
 *
 * Revision 3.7.8.2  1996/04/17  04:07:37  syiu
 * Branch: Dial1_branch
 * Sync Dial1_branch to V111_1_3
 *
 * Revision 3.7.8.1  1996/02/23  20:54:39  lbustini
 * Branch: Dial1_branch
 * Move dialer fields out of the idb.
 *
 * Revision 3.13.8.3  1996/04/04  20:16:44  sdurham
 * CSCdi53465:  loopback ifType shows up as other, instead of
 * softwareLoopBack
 * Branch: California_branch
 *             make snmp recognize new ET_LOOP enctype
 *
 * Revision 3.13.8.2  1996/04/04  05:35:32  mordock
 * CSCdi51613:  incorrect locIfReason in linkUp trap
 * Branch: California_branch
 * avoid consulting mib cache if request serialNum == -1, else cache might
 * be used when it really shouldn't be.
 *
 * Revision 3.13.8.1  1996/03/18  21:48:32  gstovall
 * Branch: California_branch
 * Elvis has left the building.  He headed out to California, and took the
 * port ready changes with him.
 *
 * Revision 3.10.2.3  1996/03/16  07:30:13  gstovall
 * Branch: DeadKingOnAThrone_branch
 * Make the king aware of V111_1_3.
 *
 * Revision 3.10.2.2  1996/03/13  01:59:51  dstine
 * Branch: DeadKingOnAThrone_branch
 *         - commit IDB cleanups
 *
 * Revision 3.10.2.1  1996/02/20  17:14:16  dstine
 * Branch: DeadKingOnAThrone_branch
 *           Sync from DeadKingOnAThrone_baseline_960122 to
 *                     DeadKingOnAThrone_baseline_960213
 *
 * Revision 3.13  1996/02/29  20:29:03  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.12  1996/02/13  18:31:18  dstine
 * CSCdi48797:  Extraneous definitions in interface_private.h
 *
 * Revision 3.11  1996/01/24  21:18:49  anke
 * CSCdi47169:  Remove snmp from mibs as a required subsystem
 *
 * Revision 3.10  1996/01/22  07:15:22  mdb
 * CSCdi47065:  misuse of NULL macro in IOS sources
 *
 * Revision 3.9  1996/01/18  16:37:53  jjohnson
 * CSCdi45754:  snmp subsystem should not contain non-snmp mibs
 * move the rs232 mib, image mib, and terminal services mib into separate
 * subsystems.  move the cisco interfaces mib into the interfaces mib
 * subsystem.  consolidate the snmp timer subsystem into the snmp
 * subsystem since it really is core snmp technology.
 *
 * Revision 3.8  1996/01/18  15:52:27  anke
 * CSCdi46969:  Change empty req and/or seq strings in SUBSYS_HEADERs to
 *              NULL
 *              Five bytes saved is five bytes earned
 *
 * Revision 3.7  1996/01/03  19:41:40  sdurham
 * CSCdi39454:  ifType for ATM interface returns 0 - other
 *            make it return atm(37)
 *
 * Revision 3.6  1996/01/02  18:11:21  jjohnson
 * CSCdi45070:  NOBLOCK tracebacks by net_background in SNMP path
 * linkUp/linkDown traps attempted to be generated by non-blockable
 * processes should instead be queued to the snmp trap process
 *
 * Revision 3.5  1995/11/21  02:45:11  sdurham
 * CSCdi43776:  memory leak in ifmib
 *      removed malloc's from the HC counters...
 *
 * Revision 3.4  1995/11/20  22:27:36  sdurham
 * CSCdi42520:  IF MIB breaks modularity in oddball images
 *        fixed IFMIB subsystem, and moved linkUp/Down trap code to IFMIB.
 *
 * Revision 3.3  1995/11/17  18:59:25  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.2  1995/11/17  00:28:16  gstovall
 * Ladies and gentlemen, I introduce to you, the port ready commit.
 *
 * Revision 3.1  1995/11/09  13:16:53  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.2  1995/11/08  21:25:47  shaker
 * Merge Arkansas_branch into 11.1 mainline.
 *
 * Revision 2.1  1995/06/07  22:49:13  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include "../ui/common_strings.h"
#include "subsys.h"
#include "interface_private.h"
#include "snmp_interface.h"
#include "../snmp/snmp_api.h"
#include "sr_ifmib.h"
#include "sr_ifmib-mib.h"
#include "sr_old_lifmib.h"
#include "../if/network.h"
#include "../x25/x25.h"
#include "registry.h"
#include "sys_registry.h"
#include "../snmp/snmp_registry.regh"
#include "ifmibapi.h"
#include "ifmib_registry.h"
#include "../h/ieee.h"
#include "../parser/parser_defs_snmp.h"
#include "sr_old_lifmib.h"
#include "snmp_trap_fe.h"
#include "../if/atm.h"
#include "../wan/dialer_registry.h"
#include "packet.h"
#include "../wan/dialer.h"

#define IFALIAS_LENGTH 64

static OctetString     _ifDescr;
static OctetString     _ifName;
static OctetString     _ifAlias;
static OctetString     _ifPhysAddress;
static unsigned long   _ifSpecificOID[] = {0L, 0L};
static OID             _ifSpecific = {2, _ifSpecificOID};
static UInt64          _ifHCInOctets;
static UInt64          _ifHCInUcastPkts;
static UInt64          _ifHCInMulticastPkts;
static UInt64          _ifHCInBroadcastPkts;
static UInt64          _ifHCOutOctets;
static UInt64          _ifHCOutUcastPkts;
static UInt64          _ifHCOutMulticastPkts;
static UInt64          _ifHCOutBroadcastPkts;
 
static const char linkup_trap_oid[] = "snmpTraps.4";
static const char linkdown_trap_oid[] = "snmpTraps.3";

/*
 * For now, only hardware idbs subiabs, iabs are supported.  This will change.
 */
static const uint supportedIdbTypes = SNMP_IF_HWIDB|SNMP_IF_IAB|SNMP_IF_SUBIAB;

/* remove read/write ability for ifRcvAddressTable and ifStackTable 
  can't be in header file, as that's used by lots of other mibs */
#undef SETS

/*
 * Start of system-independent routines
 */




/*---------------------------------------------------------------------
 * Retrieve data from the interfaces family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *
interfaces_get (
    OID             *incoming,
    ObjectInfo      *object,
    int             searchType,
    ContextInfo     *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = -1;
    void            *dp;
    interfaces_t    *data = NULL;


    /*
     * Check the object instance.
     *
     * An EXACT search requires that the instance be of length 1 and
     * the single instance element be 0.
     *
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    switch (searchType) {
      case EXACT:
        if (instLength == 1 && incoming->oid_ptr[incoming->length - 1] == 0) {
          arg = object->nominator;
        }
        break;

      case NEXT:
        if (instLength <= 0) {
          arg = object->nominator;
        }
        break;

    }

    /*
     * Retrieve the data from the kernel-specific routine.
     */
     if ( (arg == -1) || (data = k_interfaces_get(serialNum, contextInfo, arg)) == NULL) {
        arg = -1;
     }

     /*
      * Build the variable binding for the variable that will be returned.
      */

     switch (arg) {

#ifdef I_ifNumber
    case I_ifNumber:
       dp = (void *) (&data->ifNumber);
       break;
#endif /* I_ifNumber */

    default:
       return ((VarBind *) NULL);

     }      /* switch */

     return (MakeVarBind(object, &ZeroOid, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the ifEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *
ifEntry_get (
    OID             *incoming,
    ObjectInfo      *object,
    int             searchType,
    ContextInfo     *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void            *dp = NULL;
    ifEntry_t       *data = NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            ifIndex;


    /*
     * Check the object instance.
     *
     * An EXACT search requires that the instance be of length 1 
     *
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
        if (instLength != 1) {
          return((VarBind *) NULL);
        }
        carry = 0;
    } else {
        carry = 1;
    }

    if ( (InstToInt(incoming, 0 + object->oid.length, &ifIndex, searchType, &carry)) < 0 ) {
       arg = -1;
    }

    if (carry) {
       arg = -1;
    }

    /*
     * Retrieve the data from the kernel-specific routine.
     */
     if ( (arg == -1) || (data = k_ifEntry_get(serialNum, contextInfo, arg ,searchType, ifIndex)) == NULL) {
        arg = -1;
     }

     else {
       /*
        * Build instance information
        */
        inst.oid_ptr = buffer;
        inst.length = 1;
        inst.oid_ptr[0] = data->ifIndex;
     }


     /*
      * Build the variable binding for the variable that will be returned.
      */

     switch (arg) {


#ifdef I_ifHCInOctets
    case I_ifHCInOctets:
	 dp = (void *) (CloneUInt64(data->ifHCInOctets));
       break;
#endif /* I_ifHCInOctets */

#ifdef I_ifHCInUcastPkts
    case I_ifHCInUcastPkts:
	   dp = (void *) (CloneUInt64(data->ifHCInUcastPkts));
       break;
#endif /* I_ifHCInUcastPkts */

#ifdef I_ifHCInMulticastPkts
    case I_ifHCInMulticastPkts:
	   dp = (void *) (CloneUInt64(data->ifHCInMulticastPkts));
       break;
#endif /* I_ifHCInMulticastPkts */

#ifdef I_ifHCInBroadcastPkts
    case I_ifHCInBroadcastPkts:
	   dp = (void *) (CloneUInt64(data->ifHCInBroadcastPkts));
       break;
#endif /* I_ifHCInBroadcastPkts */

#ifdef I_ifHCOutOctets
    case I_ifHCOutOctets:
	   dp = (void *) (CloneUInt64(data->ifHCOutOctets));
       break;
#endif /* I_ifHCOutOctets */

#ifdef I_ifHCOutUcastPkts
    case I_ifHCOutUcastPkts:
	   dp = (void *) (CloneUInt64(data->ifHCOutUcastPkts));
       break;
#endif /* I_ifHCOutUcastPkts */

#ifdef I_ifHCOutMulticastPkts
    case I_ifHCOutMulticastPkts:
	   dp = (void *) (CloneUInt64(data->ifHCOutMulticastPkts));
       break;
#endif /* I_ifHCOutMulticastPkts */

#ifdef I_ifHCOutBroadcastPkts
    case I_ifHCOutBroadcastPkts:
	   dp = (void *) (CloneUInt64(data->ifHCOutBroadcastPkts));
       break;
#endif /* I_ifHCOutBroadcastPkts */

#ifdef I_ifAlias
     case I_ifAlias:
        dp = (void *) (CloneOctetString(data->ifAlias));
        break;
#endif /* I_ifAlias */

#ifdef I_ifDescr
    case I_ifDescr:
	   dp = (void *) (CloneOctetString(data->ifDescr));
       break;
#endif /* I_ifDescr */

#ifdef I_ifPhysAddress
    case I_ifPhysAddress:
	   dp = (void *) (CloneOctetString(data->ifPhysAddress));
       break;
#endif /* I_ifPhysAddress */

#ifdef I_ifSpecific
    case I_ifSpecific:
	   dp = (void *) (CloneOID(data->ifSpecific));
       break;
#endif /* I_ifSpecific */

#ifdef I_ifName
    case I_ifName:
	   dp = (void *) (CloneOctetString(data->ifName));
       break;
#endif /* I_ifName */

#ifdef I_ifIndex
    case I_ifIndex:
#endif /* I_ifIndex */

#ifdef I_ifType
    case I_ifType:
#endif /* I_ifType */

#ifdef I_ifMtu
    case I_ifMtu:
#endif /* I_ifMtu */

#ifdef I_ifSpeed
    case I_ifSpeed:
#endif /* I_ifSpeed */

#ifdef I_ifAdminStatus
    case I_ifAdminStatus:
#endif /* I_ifAdminStatus */

#ifdef I_ifOperStatus
    case I_ifOperStatus:
#endif /* I_ifOperStatus */

#ifdef I_ifLastChange
    case I_ifLastChange:
#endif /* I_ifLastChange */

#ifdef I_ifInOctets
    case I_ifInOctets:
#endif /* I_ifInOctets */

#ifdef I_ifInUcastPkts
    case I_ifInUcastPkts:
#endif /* I_ifInUcastPkts */

#ifdef I_ifInNUcastPkts
    case I_ifInNUcastPkts:
#endif /* I_ifInNUcastPkts */

#ifdef I_ifInDiscards
    case I_ifInDiscards:
#endif /* I_ifInDiscards */

#ifdef I_ifInErrors
    case I_ifInErrors:
#endif /* I_ifInErrors */

#ifdef I_ifInUnknownProtos
    case I_ifInUnknownProtos:
#endif /* I_ifInUnknownProtos */

#ifdef I_ifOutOctets
    case I_ifOutOctets:
#endif /* I_ifOutOctets */

#ifdef I_ifOutUcastPkts
    case I_ifOutUcastPkts:
#endif /* I_ifOutUcastPkts */

#ifdef I_ifOutNUcastPkts
    case I_ifOutNUcastPkts:
#endif /* I_ifOutNUcastPkts */

#ifdef I_ifOutDiscards
    case I_ifOutDiscards:
#endif /* I_ifOutDiscards */

#ifdef I_ifOutErrors
    case I_ifOutErrors:
#endif /* I_ifOutErrors */

#ifdef I_ifOutQLen
    case I_ifOutQLen:
#endif /* I_ifOutQLen */

#ifdef I_ifInMulticastPkts
    case I_ifInMulticastPkts:
#endif /* I_ifInMulticastPkts */

#ifdef I_ifInBroadcastPkts
    case I_ifInBroadcastPkts:
#endif /* I_ifInBroadcastPkts */

#ifdef I_ifOutMulticastPkts
    case I_ifOutMulticastPkts:
#endif /* I_ifOutMulticastPkts */

#ifdef I_ifOutBroadcastPkts
    case I_ifOutBroadcastPkts:
#endif /* I_ifOutBroadcastPkts */

#ifdef I_ifLinkUpDownTrapEnable
    case I_ifLinkUpDownTrapEnable:
#endif /* I_ifLinkUpDownTrapEnable */

#ifdef I_ifHighSpeed
    case I_ifHighSpeed:
#endif /* I_ifHighSpeed */

#ifdef I_ifPromiscuousMode
    case I_ifPromiscuousMode:
#endif /* I_ifPromiscuousMode */

#ifdef I_ifConnectorPresent
    case I_ifConnectorPresent:
#endif /* I_ifConnectorPresent */

	if ((VALID(arg, data->valid)) || (snmp_nosparse)) /* or disable sparseness*/
	    dp = SR_OFFSET(data, arg);
	break;
    }				       /* switch */

    if (dp == NULL)
	return ((VarBind *) NULL);
    else
	return (MakeVarBind(object, &inst, dp));

}

/* #ifdef SETS - nixed to keep ifTable writable but not the other two */

/*----------------------------------------------------------------------
 * Free the ifEntry data object.
 *---------------------------------------------------------------------*/
void
ifEntry_free (
   ifEntry_t       *data)
{
   if (data != NULL) {
       FreeOctetString(data->ifDescr);
       FreeOctetString(data->ifPhysAddress);
       FreeOID(data->ifSpecific);
       FreeOctetString(data->ifName);
       FreeUInt64(data->ifHCInOctets);
       FreeUInt64(data->ifHCInUcastPkts);
       FreeUInt64(data->ifHCInMulticastPkts);
       FreeUInt64(data->ifHCInBroadcastPkts);
       FreeUInt64(data->ifHCOutOctets);
       FreeUInt64(data->ifHCOutUcastPkts);
       FreeUInt64(data->ifHCOutMulticastPkts);
       FreeUInt64(data->ifHCOutBroadcastPkts);
       FreeOctetString(data->ifAlias);

       free ((char *) data);
   }
}

/*----------------------------------------------------------------------
 * cleanup after ifEntry set/undo
 *---------------------------------------------------------------------*/
static int
ifEntry_cleanup (
   doList_t *trash)
{
   ifEntry_free(trash->data);
#ifdef SR_SNMPv2
   ifEntry_free(trash->undodata);
#endif /* SR_SNMPv2 */
   return NO_ERROR;
}

/*----------------------------------------------------------------------
 * clone the ifEntry family
 *---------------------------------------------------------------------*/
ifEntry_t *
Clone_ifEntry (
    ifEntry_t *ifEntry)
{
    ifEntry_t *data;

    if ((data = malloc(sizeof(ifEntry_t))) == NULL) {
        return NULL;
    }
    memcpy((char *) (data), (char *) (ifEntry), sizeof(ifEntry_t));

    data->ifDescr = CloneOctetString(ifEntry->ifDescr);
    data->ifPhysAddress = CloneOctetString(ifEntry->ifPhysAddress);
    data->ifSpecific = CloneOID(ifEntry->ifSpecific);
    data->ifName = CloneOctetString(ifEntry->ifName);
    data->ifHCInOctets = CloneUInt64(ifEntry->ifHCInOctets);
    data->ifHCInUcastPkts = CloneUInt64(ifEntry->ifHCInUcastPkts);
    data->ifHCInMulticastPkts = CloneUInt64(ifEntry->ifHCInMulticastPkts);
    data->ifHCInBroadcastPkts = CloneUInt64(ifEntry->ifHCInBroadcastPkts);
    data->ifHCOutOctets = CloneUInt64(ifEntry->ifHCOutOctets);
    data->ifHCOutUcastPkts = CloneUInt64(ifEntry->ifHCOutUcastPkts);
    data->ifHCOutMulticastPkts = CloneUInt64(ifEntry->ifHCOutMulticastPkts);
    data->ifHCOutBroadcastPkts = CloneUInt64(ifEntry->ifHCOutBroadcastPkts);
    data->ifAlias = CloneOctetString(ifEntry->ifAlias);
    return data;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int 
ifEntry_test (
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int            instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int            found;
    int            error_status = NO_ERROR;
    int            carry = 0;
    ifEntry_t     *ifEntry;
    long           ifIndex;

   /*
    * Validate the object instance
    *
    */
    if (instLength != 1) {
        return NO_CREATION_ERROR;
    }

    if ( (InstToInt(incoming, 0 + object->oid.length, &ifIndex, EXACT, &carry)) < 0 ) {
        error_status = NO_CREATION_ERROR;
    }

    if (error_status != NO_ERROR) {
        return error_status;
    }

    ifEntry = k_ifEntry_get(-1, contextInfo, -1, EXACT, ifIndex);

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) { 
         if ( (dp->setMethod == ifEntry_set) &&
            (((ifEntry_t *) (dp->data)) != NULL) &&
            (((ifEntry_t *) (dp->data))->ifIndex == ifIndex) ) {

            found = 1;
            break; 
        }
    }

    if (!found) {
        dp = doCur;

        dp->setMethod = ifEntry_set;
        dp->cleanupMethod = ifEntry_cleanup;
#ifdef SR_SNMPv2
#ifdef SR_ifEntry_UNDO
        dp->undoMethod = ifEntry_undo;
#else /* SR_ifEntry_UNDO */
        dp->undoMethod = NULL;
#endif /* SR_ifEntry_UNDO */
#endif /* SR_SNMPv2 */ 
        dp->state = UNKNOWN;

        if (ifEntry != NULL) {
            /* fill in existing values */
            if ((dp->data = (void *) Clone_ifEntry(ifEntry)) == NULL) {
                DPRINTF((APWARN, "snmpd: Cannot allocate memory\n"));
                error_status = RESOURCE_UNAVAILABLE_ERROR;
            }
#ifdef SR_SNMPv2 
            if ((dp->undodata = (void *) Clone_ifEntry(ifEntry)) == NULL) {
                DPRINTF((APWARN, "snmpd: Cannot allocate memory\n"));
                error_status = RESOURCE_UNAVAILABLE_ERROR;
            }
#endif /* SR_SNMPv2 */

        }
        else {

#ifdef ifEntry_READ_CREATE 
            if ( (dp->data = malloc(sizeof(ifEntry_t))) == NULL) { 
                DPRINTF((APWARN, "snmpd: Cannot allocate memory\n"));
                error_status = RESOURCE_UNAVAILABLE_ERROR;
            }
            else {
                memset(dp->data, 0, sizeof(ifEntry_t));
#ifdef SR_SNMPv2 
                dp->undodata = NULL;
#endif /* SR_SNMPv2 */

                /* Fill in reasonable default values for this new entry */
                ((ifEntry_t *) (dp->data))->ifIndex = (ifIndex);
                SET_VALID(I_ifIndex, ((ifEntry_t *) (dp->data))->valid);

                error_status = k_ifEntry_set_defaults(dp);
            }
#else /* ifEntry_READ_CREATE */
            error_status = NO_ACCESS_ERROR;
#endif /* ifEntry_READ_CREATE */
        }
    }

    if (error_status != NO_ERROR) {
        return error_status;
    }

    switch (object->nominator) {

#ifdef I_ifAdminStatus
   case I_ifAdminStatus:

     if ((value->sl_value < 1) || (value->sl_value > 3)) {
         return WRONG_VALUE_ERROR;
     }

     ((ifEntry_t *) (dp->data))->ifAdminStatus = value->sl_value;
     break;
#endif /* I_ifAdminStatus */

#ifdef I_ifLinkUpDownTrapEnable
   case I_ifLinkUpDownTrapEnable:

     if ((value->sl_value < 1) || (value->sl_value > 2)) {
         return WRONG_VALUE_ERROR;
     }

     ((ifEntry_t *) (dp->data))->ifLinkUpDownTrapEnable = value->sl_value;
     break;
#endif /* I_ifLinkUpDownTrapEnable */

#ifdef I_ifPromiscuousMode
   case I_ifPromiscuousMode:

     if ((value->sl_value < 1) || (value->sl_value > 2)) {
         return WRONG_VALUE_ERROR;
     }

     ((ifEntry_t *) (dp->data))->ifPromiscuousMode = value->sl_value;
     break;
#endif /* I_ifPromiscuousMode */

#ifdef I_ifAlias
   case I_ifAlias:
 
     if (((ifEntry_t *) (dp->data))->ifAlias != NULL) {
        FreeOctetString(((ifEntry_t *) (dp->data))->ifAlias);
     }
 
     ((ifEntry_t *) (dp->data))->ifAlias =
         CloneOctetString(value->os_value);
 
     break;
#endif /* I_ifAlias */
 
   default:
       DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in ifEntry_test)\n"));
       return GEN_ERROR;

   }        /* switch */
   /* Do system dependent testing in k_ifEntry_test */
   error_status = k_ifEntry_test(object, value, dp, contextInfo);

   if (error_status == NO_ERROR) {
        SET_VALID(object->nominator, ((ifEntry_t *) (dp->data))->valid);
        error_status = k_ifEntry_ready(object, value, doHead, dp);
   }

   return (error_status);
}


/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int 
ifEntry_set(doHead, doCur, contextInfo)
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
  return (k_ifEntry_set((ifEntry_t *) (doCur->data),
            contextInfo, doCur->state));
}


/*#endif * SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the ifMIBObjects family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *
ifMIBObjects_get ( OID             *incoming,
		  ObjectInfo      *object,
		  int             searchType,
		  ContextInfo     *contextInfo,
		  int             serialNum )
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = -1;
    void            *dp;
    ifMIBObjects_t  *data;


    data = NULL;
    /*
     * Check the object instance.
     *
     * An EXACT search requires that the instance be of length 1 and
     * the single instance element be 0.
     *
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    switch (searchType) {
      case EXACT:
        if (instLength == 1 && incoming->oid_ptr[incoming->length - 1] == 0) {
          arg = object->nominator;
        }
        break;

      case NEXT:
        if (instLength <= 0) {
          arg = object->nominator;
        }
        break;
    }

    /*
     * Retrieve the data from the kernel-specific routine.
     */
     if ( (arg == -1) || (data = k_ifMIBObjects_get(serialNum, contextInfo, arg)) == NULL) {
        arg = -1;
     }

     /*
      * Build the variable binding for the variable that will be returned.
      */

     switch (arg) {

#ifdef I_ifTableLastChange
    case I_ifTableLastChange:
       dp = (void *) (&data->ifTableLastChange);
       break;
#endif /* I_ifTableLastChange */

#ifdef I_ifStackLastChange
    case I_ifStackLastChange:
       dp = (void *) (&data->ifStackLastChange);
       break;
#endif /* I_ifStackLastChange */

    default:
       return ((VarBind *) NULL);

     }      /* switch */

     return (MakeVarBind(object, &ZeroOid, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the ifStackEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *
ifStackEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID             *incoming;
    ObjectInfo      *object;
    int             searchType;
    ContextInfo     *contextInfo;
    int             serialNum;
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void            *dp;
    ifStackEntry_t  *data = NULL;
    unsigned long   buffer[2];
    OID             inst;
    int             carry;
    long            ifStackHigherLayer;
    long            ifStackLowerLayer;


    /*
     * Check the object instance.
     *
     * An EXACT search requires that the instance be of length 2 
     *
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */
    if (searchType == EXACT) {
        if (instLength != 2) {
          return((VarBind *) NULL);
        }
        carry = 0;
    } else {
        carry = 1;
    }

    if ( (InstToInt(incoming, 1 + object->oid.length, &ifStackLowerLayer, searchType, &carry)) < 0 ) {
       arg = -1;
    }

    if ( (InstToInt(incoming, 0 + object->oid.length, &ifStackHigherLayer, searchType, &carry)) < 0 ) {
       arg = -1;
    }

    if (carry) {
       arg = -1;
    }

    /*
     * Retrieve the data from the kernel-specific routine.
     */
     if ( (arg == -1) || (data = k_ifStackEntry_get(serialNum, contextInfo, arg ,searchType, ifStackHigherLayer, ifStackLowerLayer)) == NULL) {
        arg = -1;
     }

     else {
       /*
        * Build instance information
        */
        inst.oid_ptr = buffer;
        inst.length = 2;
        inst.oid_ptr[0] = data->ifStackHigherLayer;
        inst.oid_ptr[1] = data->ifStackLowerLayer;
     }


     /*
      * Build the variable binding for the variable that will be returned.
      */

     switch (arg) {

#ifdef I_ifStackStatus
    case I_ifStackStatus:
       dp = (void *) (&data->ifStackStatus);
       break;
#endif /* I_ifStackStatus */

    default:
       return ((VarBind *) NULL);

     }      /* switch */

     return (MakeVarBind(object, &inst, dp));

}


/*----------------------------------------------------------------------
 * Free the ifStackEntry data object.
 *---------------------------------------------------------------------*/
void
ifStackEntry_free (
   ifStackEntry_t  *data)
{
   if (data != NULL) {

       free ((char *) data);
   }
}
/* 
 * kludge - need to remove unused sets, but can't undef SETS in
the header is this is #included all over the place!
*/

int 
ifStackEntry_test (
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
   return GEN_ERROR;
}
/* end of kludge */

#ifdef SETS 
/*----------------------------------------------------------------------
 * cleanup after ifStackEntry set/undo
 *---------------------------------------------------------------------*/
static int
ifStackEntry_cleanup (
   doList_t *trash)
{
   ifStackEntry_free(trash->data);
#ifdef SR_SNMPv2
   ifStackEntry_free(trash->undodata);
#endif /* SR_SNMPv2 */
   return NO_ERROR;
}

/*----------------------------------------------------------------------
 * clone the ifStackEntry family
 *---------------------------------------------------------------------*/
ifStackEntry_t *
Clone_ifStackEntry (
    ifStackEntry_t *ifStackEntry)
{
    ifStackEntry_t *data;

    if ((data = malloc(sizeof(ifStackEntry_t))) == NULL) {
        return NULL;
    }
    memcpy((char *) (data), (char *) (ifStackEntry), sizeof(ifStackEntry_t));


    return data;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int 
ifStackEntry_test (
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int            instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int            found;
    int            error_status = NO_ERROR;
    int            carry = 0;
    ifStackEntry_t     *ifStackEntry;
    long           ifStackHigherLayer;
    long           ifStackLowerLayer;

   /*
    * Validate the object instance
    *
    */
    if (instLength != 2) {
        return NO_CREATION_ERROR;
    }

    if ( (InstToInt(incoming, 0 + object->oid.length, &ifStackHigherLayer, EXACT, &carry)) < 0 ) {
        error_status = NO_CREATION_ERROR;
    }

    if ( (InstToInt(incoming, 1 + object->oid.length, &ifStackLowerLayer, EXACT, &carry)) < 0 ) {
        error_status = NO_CREATION_ERROR;
    }

    if (error_status != NO_ERROR) {
        return error_status;
    }

    ifStackEntry = k_ifStackEntry_get(-1, contextInfo, -1, EXACT, ifStackHigherLayer, ifStackLowerLayer);

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) { 
         if ( (dp->setMethod == ifStackEntry_set) &&
            (((ifStackEntry_t *) (dp->data)) != NULL) &&
            (((ifStackEntry_t *) (dp->data))->ifStackHigherLayer == ifStackHigherLayer) &&
            (((ifStackEntry_t *) (dp->data))->ifStackLowerLayer == ifStackLowerLayer) ) {

            found = 1;
            break; 
        }
    }

    if (!found) {
        dp = doCur;

        dp->setMethod = ifStackEntry_set;
        dp->cleanupMethod = ifStackEntry_cleanup;
#ifdef SR_SNMPv2
#ifdef SR_ifStackEntry_UNDO
        dp->undoMethod = ifStackEntry_undo;
#else /* SR_ifStackEntry_UNDO */
        dp->undoMethod = NULL;
#endif /* SR_ifStackEntry_UNDO */
#endif /* SR_SNMPv2 */ 
        dp->state = UNKNOWN;

        if (ifStackEntry != NULL) {
            /* fill in existing values */
            if ((dp->data = (void *) Clone_ifStackEntry(ifStackEntry)) == NULL) {
                DPRINTF((APWARN, "snmpd: Cannot allocate memory\n"));
                error_status = RESOURCE_UNAVAILABLE_ERROR;
            }
#ifdef SR_SNMPv2 
            if ((dp->undodata = (void *) Clone_ifStackEntry(ifStackEntry)) == NULL) {
                DPRINTF((APWARN, "snmpd: Cannot allocate memory\n"));
                error_status = RESOURCE_UNAVAILABLE_ERROR;
            }
#endif /* SR_SNMPv2 */

        }
        else {

#ifdef ifStackEntry_READ_CREATE 
            if ( (dp->data = malloc(sizeof(ifStackEntry_t))) == NULL) { 
                DPRINTF((APWARN, "snmpd: Cannot allocate memory\n"));
                error_status = RESOURCE_UNAVAILABLE_ERROR;
            }
            else {
                memset(dp->data, 0, sizeof(ifStackEntry_t));
#ifdef SR_SNMPv2 
                dp->undodata = NULL;
#endif /* SR_SNMPv2 */

                /* Fill in reasonable default values for this new entry */
                ((ifStackEntry_t *) (dp->data))->ifStackHigherLayer = (ifStackHigherLayer);
                SET_VALID(I_ifStackHigherLayer, ((ifStackEntry_t *) (dp->data))->valid);

                ((ifStackEntry_t *) (dp->data))->ifStackLowerLayer = (ifStackLowerLayer);
                SET_VALID(I_ifStackLowerLayer, ((ifStackEntry_t *) (dp->data))->valid);

            }
#else /* ifStackEntry_READ_CREATE */
            error_status = NO_ACCESS_ERROR;
#endif /* ifStackEntry_READ_CREATE */
        }
    }

    if (error_status != NO_ERROR) {
        return error_status;
    }

    switch (object->nominator) {

#ifdef I_ifStackStatus
   case I_ifStackStatus:

     if ((value->sl_value < 1) || (value->sl_value > 6)) {
         return WRONG_VALUE_ERROR;
     }

     if (value->sl_value == D_ifStackStatus_notReady) {
         return WRONG_VALUE_ERROR;
     }

	/*
	 * perform generic row status processing
	 */
	error_status = set_row_status(value->sl_value,
				(ifStackEntry != NULL) ? 1 : -1,
				&(dp->state),
				&((ifStackEntry_t *)
				  (dp->data))->ifStackStatus);

     if (error_status != NO_ERROR) 
	 return error_status;
     ((ifStackEntry_t*)(dp->data))->ifStackStatus = value->sl_value;
     break;

#endif /* I_ifStackStatus */

   default:
       DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in ifStackEntry_test)\n"));
       return GEN_ERROR;

   }        /* switch */

   /* Do system dependent testing in k_ifStackEntry_test */
   error_status = k_ifStackEntry_test(object, value, dp, contextInfo);

   if (error_status == NO_ERROR) {
        SET_VALID(object->nominator, ((ifStackEntry_t *) (dp->data))->valid);
        error_status = k_ifStackEntry_ready(object, value, doHead, dp);
   }

   return (error_status);
}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int 
ifStackEntry_set (
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
  return (k_ifStackEntry_set((ifStackEntry_t *) (doCur->data),
            contextInfo, doCur->state));
}

#endif /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the ifRcvAddressEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *
ifRcvAddressEntry_get (
    OID             *incoming,
    ObjectInfo      *object,
    int             searchType,
    ContextInfo     *contextInfo,
    int             serialNum)
{
    int             arg = object->nominator;
    void            *dp = NULL;
    ifRcvAddressEntry_t *data = NULL;
    unsigned long   buffer[MAX_OID_SIZE];
    OID             inst;
    int             carry;
    int             i;
    long            ifIndex;
    int             ifIndex_offset;
    OctetString *   ifRcvAddressAddress = NULL;
    int             ifRcvAddressAddress_offset;
    int             index;
    int             final_index;

    ifIndex_offset = object->oid.length;
    ifRcvAddressAddress_offset = ifIndex_offset + 1;
    final_index = ifRcvAddressAddress_offset + GetVariableIndexLength(incoming, ifRcvAddressAddress_offset);

    if (searchType == EXACT) {
       if (final_index != incoming->length) {
          return((VarBind *) NULL);
        }
        carry = 0;
    } else {
        carry = 1;
    }

    if ( (InstToVariableOctetString(incoming, ifRcvAddressAddress_offset, &ifRcvAddressAddress, searchType, &carry)) < 0 ) {
       arg = -1;
    }

    if ( (InstToInt(incoming, ifIndex_offset, &ifIndex, searchType, &carry)) < 0 ) {
       arg = -1;
    }

    if (carry) {
       arg = -1;
    }

    /*
     * Retrieve the data from the kernel-specific routine.
     */
     if ( (arg == -1) || (data = k_ifRcvAddressEntry_get(serialNum, contextInfo, arg ,searchType, ifIndex, ifRcvAddressAddress)) == NULL) {
        arg = -1;
     }

     else {
       /*
        * Build instance information
        */
        inst.oid_ptr = buffer;
        index = 0;
        inst.oid_ptr[index++] = (unsigned long) data->ifIndex;
        inst.oid_ptr[index++] = data->ifRcvAddressAddress->length;
        for(i = 0; i < data->ifRcvAddressAddress->length; i++) {
            inst.oid_ptr[index++] = (unsigned long) data->ifRcvAddressAddress->octet_ptr[i];
            if (index > MAX_OID_SIZE) {
                arg = -1;
                index--;
            }
        }
        
        inst.length = index;
     }

        FreeOctetString(ifRcvAddressAddress);

     /*
      * Build the variable binding for the variable that will be returned.
      */

     switch (arg) {

#ifdef I_ifRcvAddressAddress
    case I_ifRcvAddressAddress:
       if (VALID(arg,data->valid))
	   dp = (void *) (CloneOctetString(data->ifRcvAddressAddress));
       break;
#endif /* I_ifRcvAddressAddress */

#ifdef I_ifRcvAddressStatus
    case I_ifRcvAddressStatus:
       dp = (void *) (&data->ifRcvAddressStatus);
       break;
#endif /* I_ifRcvAddressStatus */

#ifdef I_ifRcvAddressType
    case I_ifRcvAddressType:
       dp = (void *) (&data->ifRcvAddressType);
       break;
#endif /* I_ifRcvAddressType */

    default:
       return ((VarBind *) NULL);

     }      /* switch */

     return (MakeVarBind(object, &inst, dp));

}


/*----------------------------------------------------------------------
 * Free the ifRcvAddressEntry data object.
 *---------------------------------------------------------------------*/
void
ifRcvAddressEntry_free (
   ifRcvAddressEntry_t *data)
{
   if (data != NULL) {
       FreeOctetString(data->ifRcvAddressAddress);

       free ((char *) data);
   }
}

/* 
 * kludge - need to remove unused sets, but can't undef SETS in
the header is this is #included all over the place!
*/
int 
ifRcvAddressEntry_test (
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
  return 0;
}

/* end of kludge */
#ifdef SETS 

/*----------------------------------------------------------------------
 * cleanup after ifRcvAddressEntry set/undo
 *---------------------------------------------------------------------*/
static int
ifRcvAddressEntry_cleanup (
   doList_t *trash)
{
   ifRcvAddressEntry_free(trash->data);
#ifdef SR_SNMPv2
   ifRcvAddressEntry_free(trash->undodata);
#endif /* SR_SNMPv2 */
   return NO_ERROR;
}

/*----------------------------------------------------------------------
 * clone the ifRcvAddressEntry family
 *---------------------------------------------------------------------*/
ifRcvAddressEntry_t *
Clone_ifRcvAddressEntry (
    ifRcvAddressEntry_t *ifRcvAddressEntry)
{
    ifRcvAddressEntry_t *data;

    if ((data = malloc(sizeof(ifRcvAddressEntry_t))) == NULL) {
        return NULL;
    }
    memcpy((char *) (data), (char *) (ifRcvAddressEntry), sizeof(ifRcvAddressEntry_t));

    data->ifRcvAddressAddress = CloneOctetString(ifRcvAddressEntry->ifRcvAddressAddress);

    return data;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int 
ifRcvAddressEntry_test (
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    doList_t       *dp;
    int            found;
    int            error_status = NO_ERROR;
    int            carry = 0;
    ifRcvAddressEntry_t     *ifRcvAddressEntry;
    long           ifIndex;
    int            ifIndex_offset;
    OctetString *  ifRcvAddressAddress = NULL;
    int            ifRcvAddressAddress_offset;
    int            final_index;

   /*
    * Validate the object instance
    *
    */
    ifIndex_offset = object->oid.length;
    ifRcvAddressAddress_offset = ifIndex_offset + 1;
    final_index = ifRcvAddressAddress_offset + GetVariableIndexLength(incoming, ifRcvAddressAddress_offset);

    if (final_index != incoming->length) {
          return(NO_CREATION_ERROR);
    }

    if ( (InstToInt(incoming, ifIndex_offset, &ifIndex, EXACT, &carry)) < 0 ) {
        error_status = NO_CREATION_ERROR;
    }

    if ( (InstToVariableOctetString(incoming, ifRcvAddressAddress_offset, &ifRcvAddressAddress, EXACT, &carry)) < 0 ) {
        error_status = NO_CREATION_ERROR;
    }

    if (error_status != NO_ERROR) {
        FreeOctetString(ifRcvAddressAddress);
        return error_status;
    }

    ifRcvAddressEntry = k_ifRcvAddressEntry_get(-1, contextInfo, -1, EXACT, ifIndex, ifRcvAddressAddress);

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) { 
         if ( (dp->setMethod == ifRcvAddressEntry_set) &&
            (((ifRcvAddressEntry_t *) (dp->data)) != NULL) &&
            (((ifRcvAddressEntry_t *) (dp->data))->ifIndex == ifIndex) &&
            (CmpOctetStrings(((ifRcvAddressEntry_t *)
  (dp->data))->ifRcvAddressAddress, ifRcvAddressAddress) == 0)) {

            found = 1;
            break; 
        }
    }

    if (!found) {
        dp = doCur;

        dp->setMethod = ifRcvAddressEntry_set;
        dp->cleanupMethod = ifRcvAddressEntry_cleanup;
#ifdef SR_SNMPv2
#ifdef SR_ifRcvAddressEntry_UNDO
        dp->undoMethod = ifRcvAddressEntry_undo;
#else /* SR_ifRcvAddressEntry_UNDO */
        dp->undoMethod = NULL;
#endif /* SR_ifRcvAddressEntry_UNDO */
#endif /* SR_SNMPv2 */ 
        dp->state = UNKNOWN;

        if (ifRcvAddressEntry != NULL) {
            /* fill in existing values */
            if ((dp->data = (void *) Clone_ifRcvAddressEntry(ifRcvAddressEntry)) == NULL) {
                DPRINTF((APWARN, "snmpd: Cannot allocate memory\n"));
                error_status = RESOURCE_UNAVAILABLE_ERROR;
            }
#ifdef SR_SNMPv2 
            if ((dp->undodata = (void *) Clone_ifRcvAddressEntry(ifRcvAddressEntry)) == NULL) {
                DPRINTF((APWARN, "snmpd: Cannot allocate memory\n"));
                error_status = RESOURCE_UNAVAILABLE_ERROR;
            }
#endif /* SR_SNMPv2 */

        }
        else {
            if ( (dp->data = malloc(sizeof(ifRcvAddressEntry_t))) == NULL) { 
                DPRINTF((APWARN, "snmpd: Cannot allocate memory\n"));
                error_status = RESOURCE_UNAVAILABLE_ERROR;
            }
            else {
                memset(dp->data, 0, sizeof(ifRcvAddressEntry_t));
#ifdef SR_SNMPv2 
                dp->undodata = NULL;
#endif /* SR_SNMPv2 */

                /* Fill in reasonable default values for this new entry */
                ((ifRcvAddressEntry_t *) (dp->data))->ifIndex = (ifIndex);
                SET_VALID(I_ifIndex, ((ifRcvAddressEntry_t *) (dp->data))->valid);

                ((ifRcvAddressEntry_t *) (dp->data))->ifRcvAddressAddress = CloneOctetString(ifRcvAddressAddress);
                SET_VALID(I_ifRcvAddressAddress, ((ifRcvAddressEntry_t *) (dp->data))->valid);

		error_status = k_ifRcvAddressEntry_set_defaults(dp);
            }
        }
    }

    if (error_status != NO_ERROR) {
        FreeOctetString(ifRcvAddressAddress);
        return error_status;
    }

    switch (object->nominator) {

#ifdef I_ifRcvAddressAddress
   case I_ifRcvAddressAddress:

     if (ifRcvAddressAddress->length != value->os_value->length) {
         return WRONG_VALUE_ERROR;
      }
     if (memcmp(ifRcvAddressAddress->octet_ptr, value->os_value->octet_ptr,  value->os_value->length) != 0) {
	 FreeOctetString(ifRcvAddressAddress);
         return WRONG_VALUE_ERROR;
     }
     
     if (((ifRcvAddressEntry_t *) (dp->data))->ifRcvAddressAddress != NULL) {
        FreeOctetString(((ifRcvAddressEntry_t *) (dp->data))->ifRcvAddressAddress);
     }

     ((ifRcvAddressEntry_t *) (dp->data))->ifRcvAddressAddress = 
         CloneOctetString(value->os_value);

     break;
#endif /* I_ifRcvAddressAddress */

#ifdef I_ifRcvAddressStatus
   case I_ifRcvAddressStatus:

     if ((value->sl_value < 1) || (value->sl_value > 6)) {
	 FreeOctetString(ifRcvAddressAddress);
         return WRONG_VALUE_ERROR;
     }

     if (value->sl_value == D_ifRcvAddressStatus_notReady) {
	 FreeOctetString(ifRcvAddressAddress);
         return WRONG_VALUE_ERROR;
     }

     if (ifRcvAddressEntry == NULL) { 	/* creating a new row */
        if((value->sl_value == D_ifRcvAddressStatus_notInService) || (value->sl_value == D_ifRcvAddressStatus_active)) {
            return INCONSISTENT_VALUE_ERROR;
        }
     } else { 			/* modifying an existing row */

        if ((value->sl_value == D_ifRcvAddressStatus_createAndGo) || (value->sl_value == D_ifRcvAddressStatus_createAndWait)) {
	    FreeOctetString(ifRcvAddressAddress);
            return INCONSISTENT_VALUE_ERROR;
        }
     }

	/*
	 * perform generic row status processing
	 */
	error_status = set_row_status(value->sl_value,
				(ifRcvAddressEntry != NULL) ? 1 : -1,
				&(dp->state),
				&((ifRcvAddressEntry_t *)
				  (dp->data))->ifRcvAddressStatus);

     if (error_status != NO_ERROR) {
      FreeOctetString(ifRcvAddressAddress);
	 return error_status;
   }

     break;
#endif /* I_ifRcvAddressStatus */

#ifdef I_ifRcvAddressType
   case I_ifRcvAddressType:

     if ((value->sl_value < 1) || (value->sl_value > 3)) {
	 FreeOctetString(ifRcvAddressAddress);
         return WRONG_VALUE_ERROR;
     }

     ((ifRcvAddressEntry_t *) (dp->data))->ifRcvAddressType = value->sl_value;
     break;
#endif /* I_ifRcvAddressType */

   default:
       DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in ifRcvAddressEntry_test)\n"));
       return GEN_ERROR;

   }        /* switch */

   /* Do system dependent testing in k_ifRcvAddressEntry_test */
   error_status = k_ifRcvAddressEntry_test(object, value, dp, contextInfo);

   if (error_status == NO_ERROR) {
        SET_VALID(object->nominator, ((ifRcvAddressEntry_t *) (dp->data))->valid);
        error_status = k_ifRcvAddressEntry_ready(object, value, doHead, dp);
   }
   FreeOctetString(ifRcvAddressAddress);
   return (error_status);
}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int 
ifRcvAddressEntry_set (
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
  return (k_ifRcvAddressEntry_set((ifRcvAddressEntry_t *) (doCur->data),
            contextInfo, doCur->state));
}

#endif /* SETS */



/*
 * Start of system-dependent routines
 */


/*
 **********************************************************************
 *
 * KERNEL CODE begins here.  Above is all generated by SNMP Research
 * compiler.  Below code does the real work in getting the router
 * information.  
 *
 * First come the utility helper routines.
 *
 **********************************************************************
 */

static boolean get_snmp_interface_tester (snmpidbtype *snmpidb, long *index2)
{
    int which_counter;
    ulong retval;
    ifmib_err_t error_status = IF_NO_ERR;

    if (snmpidb == NULL)
      return(FALSE);

    if (ifmib_snmpidb_is_type(snmpidb, SNMP_IF_HWIDB | SNMP_IF_IAB))
	return(TRUE);

    if ((snmpidb->snmp_if_struct ==  SNMP_IF_SUBIAB)) {
        subiabtype *subiab;

        subiab = snmpidb->snmp_if_ptr.ifptr.subiab;
        if (snmp_nosparse)
            return(TRUE);

        /* check to see if the var requested will get returned */
        switch (*index2) {
        case I_ifMtu:
            return(subiab->maxmtu != NULL);
        case I_ifPhysAddress:
            return(subiab->ifPhysAddrLen != NULL);

        case I_ifInOctets:
            which_counter = IN_OCTETS_CNTR;
            break;

        case I_ifInUcastPkts:
            which_counter = IN_UCAST_CNTR;
            break;

        case I_ifInDiscards:
            which_counter = IN_DISCARDS_CNTR;
            break;

        case I_ifInErrors:
            which_counter = IN_ERRORS_CNTR;
            break;

        case I_ifInUnknownProtos:
            which_counter = IN_UNK_PROTOS_CNTR;
            break;

        case I_ifOutOctets:
            which_counter = OUT_OCTETS_CNTR;
            break;


        case I_ifOutUcastPkts:
            which_counter = OUT_UCAST_CNTR;
            break;

        case I_ifOutDiscards:
            which_counter = OUT_DISCARDS_CNTR;
            break;

        case I_ifOutErrors:
            which_counter = OUT_ERRORS_CNTR;
            break;

        case I_ifInBroadcastPkts:
            which_counter = IN_BCAST_CNTR;
            break;

        case I_ifInMulticastPkts:
            which_counter = IN_MCAST_CNTR;
            break;

        case I_ifOutBroadcastPkts:
            which_counter = OUT_BCAST_CNTR;
            break;

        case I_ifOutMulticastPkts:
            which_counter = OUT_MCAST_CNTR;
            break;

        case I_ifInNUcastPkts:
        case I_ifOutNUcastPkts:
        case I_ifOutQLen:
        case I_ifSpecific:
            return(FALSE);
        default:
          return(TRUE);
        }
        error_status = reg_invoke_ifmib_cntr32(subiab->ifType, which_counter,
                                               subiab, &retval, -1);
        return(error_status == IF_NO_ERR);
    }
    return(FALSE);
}


/* 
 * ifmib_set_ifalias
 *   copy the ifAlias value in src over to dest - malloc'ing and freeing
 *   memory in dest appropriately
 */
static void ifmib_set_ifalias (char **dest, OctetString *src)
{
    char *tmp;
    uint length;

    length = src->length;

    tmp = *dest;
    *dest = malloc(length + 1);
    if (!*dest) {
	*dest = tmp;
	return;
    }

    memcpy(*dest, src->octet_ptr, length);
    (*dest)[length] = '\0';

    if (tmp)
	free(tmp);
}


interfaces_t *
k_interfaces_get (
   int serialNum,
   ContextInfo *contextInfo,
   int nominator)
{
   static interfaces_t interfacesData;

   interfacesData.ifNumber = ifmib_get_ifNumber();
   return(&interfacesData);
}

static long
ifType_get (hwidbtype *idb)
{
    switch (idb->enctype) {
    case ET_1822:
        return D_ifType_regular1822;
    case ET_X25:
	if (ISDDN(idb))
            return D_ifType_ddnX25;
        return D_ifType_rfc877x25;
    case ET_ARPA:
        return D_ifType_ethernetCsmacd;
    case ET_SAP:
    case ET_SNAP:
        if (idb->status & IDB_TR)
            return D_ifType_iso88025TokenRing;
        else if (idb->status & IDB_FDDI)
            return D_ifType_fddi;
        else
            return D_ifType_iso88023Csmacd;
    case ET_LAPB:
        return D_ifType_lapb;
    case ET_SDLCP:
    case ET_SDLCS:
    case ET_SDLC:
        return D_ifType_sdlc;
    case ET_HDLC:
        return D_ifType_propPointToPointSerial;
    case ET_PPP:
        return D_ifType_ppp;
    case ET_ULTRA_ISO2:
        return D_ifType_ultra;
    case ET_SMDS:
        return D_ifType_sip;
    case ET_FRAME_RELAY:
        return D_ifType_frameRelay;

    case ET_ATM:
	if (idb->atm_db) {
	    switch(idb->atm_db->plimtype) {
	    default:
	    case ATM_PLIM_INVALID:
	    case ATM_PLIM_4B5B:
		return D_ifType_other;
	    case ATM_PLIM_E3:
	    case ATM_PLIM_DS3:
		return D_ifType_ds3;
	    case ATM_PLIM_SONET:
		return D_ifType_sonet;
	    }
	} else {
	    return D_ifType_other;
	}
	/*
	 * note - this is sent as a DXI_Frame, but it has no ifType
	 * assigned by iana...
	 */
    case ET_ATM_DXI:
    case ET_ATM_DXI_IETF:
	    return D_ifType_other;
	
   case ET_LOOP:
        if (idb->type == IDBTYPE_LB)
            return D_ifType_softwareLoopback;
        else
            return D_ifType_other;
    default:
        return D_ifType_other;
    }

}

/*
 * update_ifentry_from_hwidb
 * Given hardware idb, and ifEntry pointers, fill out the
 * ifEntry variables as appropriate based on the hardware idb.
 */
static void update_ifentry_from_hwidb (hwidbtype   *hwidb, 
				       ifEntry_t   *ifEntryPtr)
{
    ulong remainder;
    int   ifalias_len;
    static char legal_ifalias[IFALIAS_LENGTH+1];

    SET_ALL_VALID(ifEntryPtr->valid);

    ifEntryPtr->ifIndex = hwidb->snmp_if_index;
    ifEntryPtr->ifDescr = &_ifDescr;
    _ifDescr.octet_ptr = (unsigned char *)hwidb->hw_namestring;
    _ifDescr.length = strlen(hwidb->hw_namestring);
    ifEntryPtr->ifType = ifType_get(hwidb);
    ifEntryPtr->ifMtu = hwidb->maxmtu;
    ifEntryPtr->ifSpeed = hwidb->firstsw->visible_bandwidth * 1000; 
    ifEntryPtr->ifPhysAddress = &_ifPhysAddress;
    _ifPhysAddress.octet_ptr = hwidb->hardware;

    if (hwidb->status & (IDB_ETHER|IDB_TR|IDB_FDDI))
	_ifPhysAddress.length = IEEEBYTES;
    else
	_ifPhysAddress.length = 0;

    if (hwidb->state == IDBS_ADMINDOWN)
	ifEntryPtr->ifAdminStatus = D_ifAdminStatus_down;
    else
	ifEntryPtr->ifAdminStatus = D_ifAdminStatus_up;
    if (hw_interface_up(hwidb))
	if (hwidb->inloopback)
	    ifEntryPtr->ifOperStatus = D_ifOperStatus_testing;
	else {
	    if (is_ddr(hwidb) && 
		(reg_invoke_dialer_spoofing_int(hwidb) ||
		 reg_invoke_dialer_spoofing_prot(hwidb)))
		ifEntryPtr->ifOperStatus = D_ifOperStatus_dormant;
	    else
		ifEntryPtr->ifOperStatus = D_ifOperStatus_up;
	} else
	    ifEntryPtr->ifOperStatus = D_ifOperStatus_down;
    ifEntryPtr->ifLastChange = SNMP_ABSOLUTE_TIME(hwidb->state_time);
    ifEntryPtr->ifInOctets = idb_rx_cumbytes(hwidb);
    ifEntryPtr->ifInUcastPkts = idb_inputs(hwidb) - hwidb->counters.input_broad;
    ifEntryPtr->ifInNUcastPkts = hwidb->counters.input_broad;
    ifEntryPtr->ifInDiscards = hwidb->counters.output_nobuffers;
    ifEntryPtr->ifInErrors = hwidb->counters.input_error;
    ifEntryPtr->ifInUnknownProtos = hwidb->counters.rx_frames[ACCT_PROTO_OTHER]+
	hwidb->counters.inputs_fast[ACCT_PROTO_OTHER];
    ifEntryPtr->ifOutOctets = idb_tx_cumbytes(hwidb);
    ifEntryPtr->ifOutUcastPkts = idb_outputs(hwidb) - hwidb->counters.output_broad;
    ifEntryPtr->ifOutNUcastPkts = hwidb->counters.output_broad;
    ifEntryPtr->ifOutDiscards = hwidb->counters.output_total_drops;
    ifEntryPtr->ifOutErrors = hwidb->counters.output_error;
    if (is_x25(hwidb))
	ifEntryPtr->ifOutQLen = 0;
    else if (is_lapb(hwidb))
	ifEntryPtr->ifOutQLen = hwidb->lapb_holdq.count;
    else
	ifEntryPtr->ifOutQLen = hwidb->output_qcount;
    ifEntryPtr->ifSpecific = &_ifSpecific;

    ifEntryPtr->ifName = &_ifName;
    _ifName.octet_ptr = (unsigned char *)hwidb->firstsw->short_namestring;
    _ifName.length = strlen(hwidb->firstsw->short_namestring);
    if (hwidb->snmp_trap_nolink)
	ifEntryPtr->ifLinkUpDownTrapEnable = D_ifLinkUpDownTrapEnable_disabled;
    else
	ifEntryPtr->ifLinkUpDownTrapEnable = D_ifLinkUpDownTrapEnable_enabled;

    /* ifHighSpeed must be accurate +/- 500,000bps */
    remainder = ifEntryPtr->ifSpeed % IFHIGHSPEED_SCALE;
    ifEntryPtr->ifHighSpeed = ifEntryPtr->ifSpeed / IFHIGHSPEED_SCALE
	+ ((remainder >= (IFHIGHSPEED_SCALE/2)) ? 1 : 0);

    ifEntryPtr->ifPromiscuousMode  = D_ifPromiscuousMode_false;
    if (hwidb->status & (IDB_EPHEMERAL))
	ifEntryPtr->ifConnectorPresent = D_ifConnectorPresent_false;
    else
	ifEntryPtr->ifConnectorPresent = D_ifConnectorPresent_true;

    ifEntryPtr->ifAlias = &_ifAlias;
    ifalias_len = strlen(hwidb->firstsw->description);
    if (ifalias_len >= IFALIAS_LENGTH) {
	strncpy(legal_ifalias, hwidb->firstsw->description, IFALIAS_LENGTH);
	_ifAlias.octet_ptr = legal_ifalias;
	_ifAlias.length = IFALIAS_LENGTH;
    } else {
	_ifAlias.octet_ptr = hwidb->firstsw->description;
	_ifAlias.length = ifalias_len;
    }
 
/* not currently supported */
    CLR_VALID(I_ifInMulticastPkts, ifEntryPtr->valid);
    CLR_VALID(I_ifInBroadcastPkts, ifEntryPtr->valid);
    CLR_VALID(I_ifOutMulticastPkts, ifEntryPtr->valid);
    CLR_VALID(I_ifOutBroadcastPkts, ifEntryPtr->valid);

}

/*
 * update_ifentry_from_iab
 * Given iab, and ifEntry pointers, fill out the ifEntry
 * variables as appropriate based on the iab.
 * Returns TRUE if successful, FALSE on failure.
 */
static boolean update_ifentry_from_iab (iabtype     *iab,
					ifEntry_t   *ifEntryPtr)
{
    long remainder;
    boolean result;
    iab_ifalias_t iab_ifalias;
    int ifalias_len;
    static char legal_ifalias[IFALIAS_LENGTH+1];

    /*
     * If this particular iab needs to do something to update the
     * stats in the iab (like a FLEX), then call the routine and let
     * them do it before copying the stats.
     */
    if (!(*iab->get_stats)(iab))
	return(FALSE);
    SET_ALL_VALID(ifEntryPtr->valid);

    /* 
     * Okay, iab is up to date, fill out the ifEntry.
     */
    ifEntryPtr->ifIndex = iab->snmp_if_index;
    ifEntryPtr->ifDescr = &_ifDescr;
    _ifDescr.octet_ptr = (unsigned char *)iab->if_namestring;
    _ifDescr.length = strlen(iab->if_namestring);
    ifEntryPtr->ifType = (*iab->iftype_get)(iab);
    ifEntryPtr->ifMtu = iab->maxmtu;
    ifEntryPtr->ifSpeed = *iab->visible_bandwidth_ptr * 1000;
    ifEntryPtr->ifPhysAddress = &_ifPhysAddress;
    _ifPhysAddress.octet_ptr = iab->hardware;
    if (iab->status & (IDB_ETHER|IDB_TR|IDB_FDDI))
	_ifPhysAddress.length = IEEEBYTES;
    else
	_ifPhysAddress.length = 0;
    if (iab->state == IDBS_ADMINDOWN)
	ifEntryPtr->ifAdminStatus = D_ifAdminStatus_down;
    else
	ifEntryPtr->ifAdminStatus = D_ifAdminStatus_up;
    if ((*iab->hw_if_up)(iab))
	if (iab->inloopback)
	    ifEntryPtr->ifOperStatus = D_ifOperStatus_testing;
	else {
	    if (iab->dialer &&
		(iab->dialer_spoofing_int || 
		 iab->dialer_spoofing_prot))
		ifEntryPtr->ifOperStatus = D_ifOperStatus_dormant;
	    else
		ifEntryPtr->ifOperStatus = D_ifOperStatus_up;
	} else
	    ifEntryPtr->ifOperStatus = D_ifOperStatus_down;
    ifEntryPtr->ifLastChange = SNMP_ABSOLUTE_TIME(iab->state_time);
    ifEntryPtr->ifInOctets = (*iab->rx_cumbytes)(iab);
    ifEntryPtr->ifInUcastPkts = (((*iab->inputs)(iab)) - iab->input_broad);
    ifEntryPtr->ifInNUcastPkts = iab->input_broad;
    ifEntryPtr->ifInDiscards = iab->nobuffers;
    ifEntryPtr->ifInErrors = iab->input_error;
    ifEntryPtr->ifInUnknownProtos = iab->rx_frames[ACCT_PROTO_OTHER]+
	iab->inputs_fast[ACCT_PROTO_OTHER];
    ifEntryPtr->ifOutOctets = (*iab->tx_cumbytes)(iab);
    ifEntryPtr->ifOutUcastPkts = (((*iab->outputs)(iab)) - iab->output_broad);
    ifEntryPtr->ifOutNUcastPkts = iab->output_broad;
    ifEntryPtr->ifOutDiscards = iab->outputdrops;
    ifEntryPtr->ifOutErrors = iab->output_error;
    ifEntryPtr->ifOutQLen = (*iab->oqueue_len)(iab);
    ifEntryPtr->ifSpecific = &_ifSpecific;

   /*
    * there's a problem here - bchannel isdn should have ifName of
    * dchannel as that's what controls bchannel config... 
    */
    ifEntryPtr->ifName = &_ifName;
    _ifName.octet_ptr = (unsigned char *)iab->if_namestring;
    _ifName.length = strlen(iab->if_namestring);

    ifEntryPtr->ifAlias = &_ifAlias;
    result = FALSE;
    if (iab->update_ifalias) {
	result = (*iab->update_ifalias)(iab, &iab_ifalias, FALSE);
    }
    if (result == TRUE) {
	ifalias_len = strlen(iab_ifalias.value);
	if (ifalias_len >= IFALIAS_LENGTH) {
	    strncpy(legal_ifalias, iab_ifalias.value, IFALIAS_LENGTH);
	    _ifAlias.octet_ptr = legal_ifalias;
	    _ifAlias.length = IFALIAS_LENGTH;
	} else { 
	    _ifAlias.octet_ptr = iab_ifalias.value;
	    _ifAlias.length = iab_ifalias.length;
	}
    } else {
	_ifAlias.octet_ptr = NULL;
	_ifAlias.length = 0;
    }

    /*
     * missing broadcast and multicast counters here - need added 
     * support counters in code and hwidbs!
     */

    CLR_VALID(I_ifInMulticastPkts, ifEntryPtr->valid);
    CLR_VALID(I_ifInBroadcastPkts, ifEntryPtr->valid);
    CLR_VALID(I_ifOutMulticastPkts, ifEntryPtr->valid);
    CLR_VALID(I_ifOutBroadcastPkts, ifEntryPtr->valid);

    ifEntryPtr->ifLinkUpDownTrapEnable = D_ifLinkUpDownTrapEnable_disabled;

    /*
     * ifHighSpeed must be accurate +/- 500,000bps 
     */
    remainder = ifEntryPtr->ifSpeed % IFHIGHSPEED_SCALE;
    ifEntryPtr->ifHighSpeed = ifEntryPtr->ifSpeed / IFHIGHSPEED_SCALE
	+ ((remainder >= (IFHIGHSPEED_SCALE/2)) ? 1 : 0);
    ifEntryPtr->ifPromiscuousMode  = D_ifPromiscuousMode_false;
    ifEntryPtr->ifConnectorPresent = D_ifConnectorPresent_false;
    return(TRUE);
}

static uint get_ifcounter(subiabtype *subiab,
                          uint which_counter,
                          int serialNum,
                          uint validbit,
                          char *validentry)
{
    ulong counter_val;

    if (reg_invoke_ifmib_cntr32(subiab->ifType, which_counter, 
                                subiab, &counter_val, 
                                serialNum) == IF_NO_ERR) {
        SET_VALID(validbit, validentry);
        return(counter_val);
    }

    return(0);
}

/*
 * update_ifentry_from_subiab
 * Given subiab, and ifEntry pointers, fill out the ifEntry
 * variables as appropriate based on the subinterface idb.
 * Returns TRUE if successful, FALSE on failure.
 */

static boolean update_ifentry_from_subiab (subiabtype  *subiab,
					   ifEntry_t   *ifEntryPtr,
					   int         serialNum)
{
    uint sub_ifType;
    char *ifEntryvalid;

    sub_ifType  = subiab->ifType;
    ifEntryvalid = ifEntryPtr->valid;

    ZERO_VALID(ifEntryPtr->valid);
    /*   
     * fill out the ifEntry from callbacks in the subiab...
     */
    ifEntryPtr->ifIndex = subiab->snmp_if_index;
    SET_VALID(I_ifIndex, ifEntryvalid);
    ifEntryPtr->ifDescr = &_ifDescr;
    _ifDescr.octet_ptr = (unsigned char *)subiab->if_descrstring;
    _ifDescr.length = strlen(subiab->if_descrstring);
    SET_VALID(I_ifDescr, ifEntryvalid);

    ifEntryPtr->ifName = &_ifName;
    _ifName.octet_ptr = (unsigned char *)subiab->if_name;
    _ifName.length = strlen(subiab->if_name);
    SET_VALID(I_ifName, ifEntryvalid);

    ifEntryPtr->ifType = sub_ifType;
    SET_VALID(I_ifType, ifEntryvalid);

    if (subiab->maxmtu != NULL) {
	ifEntryPtr->ifMtu = *subiab->maxmtu;
	SET_VALID(I_ifMtu, ifEntryvalid);
    } else if (snmp_nosparse) {
	ifEntryPtr->ifMtu = 0;
	SET_VALID(I_ifMtu, ifEntryvalid);
    }

  ifEntryPtr->ifSpeed =
	reg_invoke_ifmib_get_if_speed(subiab->ifType, subiab);
    SET_VALID(I_ifSpeed, ifEntryPtr->valid);

    ifEntryPtr->ifHighSpeed =ifEntryPtr->ifSpeed / IFHIGHSPEED_SCALE
	+ (((ifEntryPtr->ifSpeed % IFHIGHSPEED_SCALE) >= 
	    (IFHIGHSPEED_SCALE/2)) ? 1 : 0);

    SET_VALID(I_ifHighSpeed, ifEntryPtr->valid);

    ifEntryPtr->ifPhysAddress = &_ifPhysAddress;
    _ifPhysAddress.octet_ptr = (uchar *)subiab->ifPhysAddr;
    if (subiab->ifPhysAddrLen != NULL) {
	_ifPhysAddress.length = *subiab->ifPhysAddrLen;
	SET_VALID(I_ifPhysAddress, ifEntryvalid); 
    } else {
	_ifPhysAddress.length = 0;
	SET_VALID(I_ifPhysAddress, ifEntryvalid); 
    }

    ifEntryPtr->ifAdminStatus = 
        reg_invoke_ifmib_get_adminstatus(sub_ifType, subiab);
    SET_VALID(I_ifAdminStatus, ifEntryvalid);

    ifEntryPtr->ifOperStatus = 
        reg_invoke_ifmib_get_operstatus(sub_ifType, subiab); 
    SET_VALID(I_ifOperStatus, ifEntryvalid);

    ifEntryPtr->ifLastChange = SNMP_ABSOLUTE_TIME(subiab->last_change);
    SET_VALID(I_ifLastChange, ifEntryvalid);

    ifEntryPtr->ifInOctets = 
        get_ifcounter(subiab, IN_OCTETS_CNTR, serialNum, 
                      I_ifInOctets, ifEntryvalid);

    ifEntryPtr->ifInUcastPkts = 
        get_ifcounter(subiab, IN_UCAST_CNTR, serialNum, 
                      I_ifInUcastPkts, ifEntryvalid);

    ifEntryPtr->ifInDiscards = 
        get_ifcounter(subiab, IN_DISCARDS_CNTR, serialNum,
                      I_ifInDiscards, ifEntryvalid);

    ifEntryPtr->ifInErrors =
        get_ifcounter(subiab, IN_ERRORS_CNTR, serialNum,
                      I_ifInErrors, ifEntryvalid);    

    ifEntryPtr->ifInUnknownProtos =
        get_ifcounter(subiab, IN_UNK_PROTOS_CNTR, serialNum,
                      I_ifInUnknownProtos, ifEntryvalid);

    ifEntryPtr->ifOutOctets =
        get_ifcounter(subiab, OUT_OCTETS_CNTR, serialNum,
                      I_ifOutOctets, ifEntryvalid);

    ifEntryPtr->ifOutUcastPkts = 
        get_ifcounter(subiab, OUT_UCAST_CNTR, serialNum,
                      I_ifOutUcastPkts, ifEntryvalid);

    ifEntryPtr->ifOutDiscards =
        get_ifcounter(subiab, OUT_DISCARDS_CNTR, serialNum,
                      I_ifOutDiscards, ifEntryvalid);
   
    ifEntryPtr->ifOutErrors =
        get_ifcounter(subiab, OUT_ERRORS_CNTR, serialNum,
	I_ifOutErrors, ifEntryvalid);
    
    ifEntryPtr->ifInBroadcastPkts =
        get_ifcounter(subiab, IN_BCAST_CNTR, serialNum,
        I_ifInBroadcastPkts, ifEntryvalid);

    ifEntryPtr->ifInMulticastPkts =
        get_ifcounter(subiab, IN_MCAST_CNTR, serialNum,
        I_ifInMulticastPkts, ifEntryvalid);

    ifEntryPtr->ifOutBroadcastPkts = 
        get_ifcounter(subiab, OUT_BCAST_CNTR, serialNum,
        I_ifOutBroadcastPkts, ifEntryvalid);

    ifEntryPtr->ifOutMulticastPkts =
        get_ifcounter(subiab, OUT_MCAST_CNTR, serialNum,
        I_ifOutMulticastPkts, ifEntryvalid);

    /*
     * deprecated objects not supported for subinterfaces.  But need
     * to fill in something incase a nosparse table is requested...
     */
    _ifSpecificOID[0] = 0L;
    _ifSpecificOID[1] = 0L;
    ifEntryPtr->ifSpecific = &_ifSpecific;
    
    /**temp - need to add code for HCcounters here, if applicable...*/

    if (subiab->master_type == SNMP_IF_CDB) {
	ifEntryPtr->ifConnectorPresent = D_ifConnectorPresent_true;
    }
    else {
	ifEntryPtr->ifConnectorPresent = D_ifConnectorPresent_false;
    }
    SET_VALID(I_ifConnectorPresent, ifEntryvalid);

    ifEntryPtr->ifLinkUpDownTrapEnable =  D_ifLinkUpDownTrapEnable_disabled;
    SET_VALID(I_ifLinkUpDownTrapEnable, ifEntryvalid);

    ifEntryPtr->ifPromiscuousMode  = D_ifPromiscuousMode_false;
    SET_VALID(I_ifPromiscuousMode, ifEntryvalid);


    ifEntryPtr->ifAlias = &_ifAlias;
    _ifAlias.octet_ptr = NULL;
    reg_invoke_ifmib_update_ifAlias(subiab->ifType, subiab, &_ifAlias, FALSE);
    if (_ifAlias.octet_ptr)
	_ifAlias.length = strlen(_ifAlias.octet_ptr);
    else
	_ifAlias.length = 0;
    SET_VALID(I_ifAlias, ifEntryvalid);
 
    return(TRUE);
}


ifEntry_t *
k_ifEntry_get (
   int serialNum,
   ContextInfo *contextInfo,
   int nominator,
   int searchType,
   long ifIndex)
{

/*
 * this isn't the most optimal way to do this, but it most easily fits in
 * the framework of the SR mib compiler.  I'll probably optimize this at
 * a later date  --jeff
 */
   static snmpidbtype *snmpidb = NULL;
   static subiabtype *subiab = NULL;
   static iabtype *iab = NULL;
   static hwidbtype *hwidb = NULL;
   static int lastserial = MAXINT;
   static int lastifIndex = MAXINT;
   static ifEntry_t ifEntryData;

   /*
    * Don't leave dangling data pointers.
    */
   if (snmpidb == NULL) {
       hwidb = NULL;
       iab = NULL;
       subiab = NULL;
   } else {
       if (snmpidb->snmp_if_struct != SNMP_IF_HWIDB) {
	   hwidb = NULL;
       }
       if (snmpidb->snmp_if_struct != SNMP_IF_IAB) {
	   iab = NULL;
       }
       if (snmpidb->snmp_if_struct != SNMP_IF_SUBIAB) {
	   subiab = NULL;
       }
   }

   /*
    * See if we got a cache hit.
    */
   if ((serialNum != -1) && (serialNum == lastserial) &&
       (lastifIndex == ifIndex)) {
       /* hit cache */
       if (snmpidb) {
	   switch (snmpidb->snmp_if_struct) {
	     case SNMP_IF_HWIDB:
	       if (hwidb) {
		   return(&ifEntryData);
	       } else {
		   return(NULL);
	       }
	       break;
	     case SNMP_IF_IAB:
	       if (iab) {
		   return(&ifEntryData);
	       } else {
		   return(NULL);
	       }
	     case SNMP_IF_SUBIAB:
	       if (subiab) {
		   return(&ifEntryData);
	       } else {
		   return(NULL);
	       }
	     default:
	       return(NULL);
	   }
       } else
           return(NULL);
   }
   
   /* missed cache, store info for next cache hit */
   lastserial = serialNum;
   lastifIndex = ifIndex;

   while (TRUE) {   
       snmpidb = ifmib_snmpidb_get(NULL, serialNum, searchType, ifIndex,
				   get_snmp_interface_tester, &nominator);

       if (snmpidb == NULL)
	   return(NULL);

       switch (snmpidb->snmp_if_struct) {
       case SNMP_IF_HWIDB:
	   hwidb = snmpidb->snmp_if_ptr.ifptr.hwidb;
	   if (hwidb == NULL) {
	       return(NULL);
	   }
	   update_ifentry_from_hwidb(hwidb, &ifEntryData);
	   break;

       case SNMP_IF_IAB:
	   iab = snmpidb->snmp_if_ptr.ifptr.iab;
	   if (iab == NULL) {
	       return(NULL);
	   }
	   if (!update_ifentry_from_iab(iab, &ifEntryData))
	       return(NULL);
	   break;

       case SNMP_IF_SUBIAB:
	   subiab = snmpidb->snmp_if_ptr.ifptr.subiab;
	   if (subiab == NULL) {
	       return(NULL);
	   }
	   if (!update_ifentry_from_subiab(subiab, &ifEntryData, serialNum))
	       return(NULL);
	   break;

       default:
	   return(NULL);
       } /* switch (snmpidb->snmp_if_struct) */

       if(((VALID(nominator, ifEntryData.valid)) || snmp_nosparse)) {
	   /*
	    * if the request was a get, or if the request was a
	    * get-next and the requested field has data, then
	    * fill in the HC counters and return the record
	    */

           /*HC counters aren't really supported yet, but return for nosparse*/
           if (snmp_nosparse) {
              ifEntryData.ifHCInOctets = &_ifHCInOctets;       
              _ifHCInOctets.big_end = 0;
              _ifHCInOctets.little_end = ifEntryData.ifInOctets;
        
              ifEntryData.ifHCInUcastPkts = &_ifHCInUcastPkts;
              _ifHCInUcastPkts.big_end = 0;
              _ifHCInUcastPkts.little_end = ifEntryData.ifInUcastPkts;
    
              ifEntryData.ifHCInMulticastPkts = &_ifHCInMulticastPkts;
              _ifHCInMulticastPkts.big_end = 0; 
              _ifHCInMulticastPkts.little_end = ifEntryData.ifInMulticastPkts;

              ifEntryData.ifHCInBroadcastPkts = &_ifHCInBroadcastPkts;
              _ifHCInBroadcastPkts.big_end = 0;
              _ifHCInBroadcastPkts.little_end = ifEntryData.ifInBroadcastPkts;
    
              ifEntryData.ifHCOutOctets = &_ifHCOutOctets;       
              _ifHCOutOctets.big_end = 0;
              _ifHCOutOctets.little_end = ifEntryData.ifOutOctets;
    
              ifEntryData.ifHCOutUcastPkts = &_ifHCOutUcastPkts;
              _ifHCOutUcastPkts.big_end = 0;
              _ifHCOutUcastPkts.little_end = ifEntryData.ifOutUcastPkts;
    
              ifEntryData.ifHCOutMulticastPkts = &_ifHCOutMulticastPkts;
              _ifHCOutMulticastPkts.big_end = 0;
              _ifHCOutMulticastPkts.little_end = ifEntryData.ifOutMulticastPkts;

              ifEntryData.ifHCOutBroadcastPkts = &_ifHCOutBroadcastPkts;
              _ifHCOutBroadcastPkts.big_end = 0;
              _ifHCOutBroadcastPkts.little_end = ifEntryData.ifOutBroadcastPkts;
           }
	   return(&ifEntryData);
       }
       if (searchType == EXACT) {
	   return (NULL);
       }
       ifIndex++;
       lastifIndex = ifIndex;
   }
}

/* #ifdef SETS - nixed to keep ifTable writable but not the other two   */
int
k_ifEntry_test(object, value, dp, contextInfo)
    ObjectInfo     *object;
    ObjectSyntax   *value;
    doList_t       *dp;
    ContextInfo    *contextInfo;
{

    snmpidbtype * snmpidb;
    iabtype    *iab = NULL;
    subiabtype *subiab = NULL;
    boolean    error_status;

    /* first validate the ifIndex exists, as this isn't read-create
       table */
   snmpidb = ifmib_snmpidb_get_by_type(NULL, -1, EXACT, 
				       ((ifEntry_t *)(dp->data))->ifIndex,
				       supportedIdbTypes, NULL, NULL);

    if(snmpidb == NULL)
	return (NO_CREATION_ERROR);

    switch (snmpidb->snmp_if_struct) {
    case SNMP_IF_IAB:
	iab = snmpidb->snmp_if_ptr.ifptr.iab;
	if (iab == NULL)
	    return (GEN_ERROR);
	break;
    case SNMP_IF_SUBIAB:
	subiab = snmpidb->snmp_if_ptr.ifptr.subiab;
	if (subiab == NULL)
	    return (GEN_ERROR);
	break;
    default:
	break;
    }

    switch (object->nominator) {

#ifdef I_ifAdminStatus
   case I_ifAdminStatus:

	if ((value->sl_value != D_ifAdminStatus_up) &&
#ifdef IF_TESTING_SUPPORTED
	    (value->sl_value != D_ifAdminStatus_testing) &&
#endif
	    (value->sl_value != D_ifAdminStatus_down))
	    return (WRONG_VALUE_ERROR);

	switch (snmpidb->snmp_if_struct) {
	case SNMP_IF_IAB:
	    return(NOT_WRITABLE_ERROR);

	case SNMP_IF_SUBIAB:
	    error_status = 
		reg_invoke_ifmib_admin_change(subiab->ifType, value->sl_value,
					      TRUE, subiab);
	    if (error_status != TRUE)
		return  WRONG_VALUE_ERROR;
	    break;

	default:
	    break;
	}

	SET_VALID(I_ifAdminStatus, ((ifEntry_t *) (dp->data))->valid);
	break;
#endif /* I_ifAdminStatus */

#ifdef I_ifLinkUpDownTrapEnable
   case I_ifLinkUpDownTrapEnable:
	/* 
	 * Currently, only hwidbs can have link traps enabled
	 */
	if (snmpidb->snmp_if_struct != SNMP_IF_HWIDB)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_ifLinkUpDownTrapEnable, ((ifEntry_t *) (dp->data))->valid);
	break;
#endif /* I_ifLinkUpDownTrapEnable */

#ifdef I_ifPromiscuousMode
   case I_ifPromiscuousMode:
	/* 
	 * don't currently support any set of I_ifPromiscuousMode 
	 */
         return WRONG_VALUE_ERROR;
#endif /* I_ifPromiscuousMode */

#ifdef I_ifAlias
   case I_ifAlias:
    if (value->os_value->length > IFALIAS_LENGTH) {
        return (WRONG_LENGTH_ERROR);
    }
    if (!IsDisplayString(value->os_value)) {
        return (WRONG_VALUE_ERROR);
    }

    switch (snmpidb->snmp_if_struct) {
    case SNMP_IF_IAB:
	if (iab->update_ifalias == NULL)
	    return (NOT_WRITABLE_ERROR);
	break;

    case SNMP_IF_SUBIAB:
	if (!reg_used_ifmib_update_ifAlias(subiab->ifType) &&
	    subiab->master_type != SNMP_IF_SWIDB)
	    return (NOT_WRITABLE_ERROR);
	break;

    default:
	break;
    }

    SET_VALID(I_ifAlias, ((ifEntry_t *) (dp->data))->valid);
     break;
#endif /* I_ifAlias */
    }
    return NO_ERROR;
}

int
k_ifEntry_ready(object, value, doHead, dp)
    ObjectInfo     *object;
    ObjectSyntax   *value;
    doList_t       *doHead;
    doList_t       *dp;
{
    /* no specific relation between settable objects here */
    dp->state = ADD_MODIFY;
    return NO_ERROR;
}

int
k_ifEntry_set_defaults(dp)
    doList_t       *dp;
{
#ifdef ifEntry_READ_CREATE 

    ifEntry_t *data = (ifEntry_t *) (dp->data);

    data->ifAdminStatus = D_ifAdminStatus_down;
    data->ifLinkUpDownTrapEnable = D_ifLinkUpDownTrapEnable_disabled;
    data->ifPromiscuousMode = D_ifPromiscuousMode_false;
    data->ifConnectorPresent = D_ifConnectorPresent_false;

#endif
    return NO_ERROR;
}

int
k_ifEntry_set(data, contextInfo, function)
   ifEntry_t *data;
   ContextInfo *contextInfo;
   int function;
{
    snmpidbtype *snmpidb;
    hwidbtype *hwidb = NULL;
    iabtype *iab;
    subiabtype *subiab;
    iab_ifalias_t iab_ifalias;

    /*
     * the test routine has already validated the new value
     * so it is simply a matter to "make it so"
     */
    snmpidb = ifmib_snmpidb_get_by_type(NULL, -1, EXACT, data->ifIndex,
					supportedIdbTypes, NULL, NULL);
    if (snmpidb == NULL)
       return(GEN_ERROR);

    switch (snmpidb->snmp_if_struct) {
     case SNMP_IF_HWIDB:
       hwidb = snmpidb->snmp_if_ptr.ifptr.hwidb;
       if (hwidb == NULL) {
	   return(GEN_ERROR);
       }
       if (VALID(I_ifAdminStatus, data->valid)) {
	   switch (data->ifAdminStatus) {
	   case D_ifAdminStatus_up:
	       if (hwidb->state == IDBS_ADMINDOWN)
		   shutdown_coming_up(hwidb);
	       break;
	   case D_ifAdminStatus_down:
	       if (hwidb->state != IDBS_ADMINDOWN)
		   shutdown_going_down(hwidb);
	       break;
	   }
       }

       if (VALID(I_ifLinkUpDownTrapEnable, data->valid)) {
	   /* 
	    * Currently, only hwidbs can have link traps enabled
	    */
	   if (data->ifLinkUpDownTrapEnable == D_ifLinkUpDownTrapEnable_disabled)
	       hwidb->snmp_trap_nolink = TRUE;
	   else
	       hwidb->snmp_trap_nolink = FALSE;
       }

       if (VALID(I_ifAlias, data->valid))
	   ifmib_set_ifalias(&hwidb->firstsw->description, data->ifAlias);
 
       break;

     case SNMP_IF_IAB:
       iab = snmpidb->snmp_if_ptr.ifptr.iab;
       if (iab == NULL) {
           return (GEN_ERROR);
       }
       if (VALID(I_ifAlias, data->valid)) {
           if (iab->update_ifalias == NULL)
	       return (GEN_ERROR);
	   iab_ifalias.value = data->ifAlias->octet_ptr;
	   iab_ifalias.length = data->ifAlias->length;
	   (iab->update_ifalias)(iab, &iab_ifalias, TRUE);
       }
	   
       break;   

     case SNMP_IF_SUBIAB:
       subiab = snmpidb->snmp_if_ptr.ifptr.subiab;
       if (subiab == NULL) {
	   return(GEN_ERROR);
       }

       if (VALID(I_ifAdminStatus, data->valid)) {
	   reg_invoke_ifmib_admin_change(subiab->ifType, data->ifAdminStatus,
					 FALSE, subiab);
       }
      
       if (VALID(I_ifAlias, data->valid)) {
	   reg_invoke_ifmib_update_ifAlias(subiab->ifType, subiab,
					   data->ifAlias, TRUE);
       }

       break;
 
     default:
       return(GEN_ERROR);
   } /* switch (snmpidb->snmp_if_struct) */

   return (NO_ERROR);
}
/*#endif * SETS */

#ifdef SR_SNMPv2
#ifdef SR_ifEntry_UNDO
/* add #define SR_ifEntry_UNDO in ifmib.h to
 * include the undo routine for the ifEntry family.
 */
int
ifEntry_undo(doHead, doCur, contextInfo)
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
   return UNDO_FAILED_ERROR;
}
#endif /* SR_ifEntry_UNDO */
#endif /* SR_SNMPv2 */

ifMIBObjects_t *
k_ifMIBObjects_get (  int serialNum,
            ContextInfo *contextInfo,
            int nominator)
{
#ifdef NOT_YET
   static ifMIBObjects_t ifMIBObjectsData;
 
   /*
    * put your code to retrieve the information here
    */
 
   ifMIBObjectsData.ifTableLastChange = ;
   ifMIBObjectsData.ifStackLastChange = ;
   return(&ifMIBObjectsData);
#else /* NOT_YET */
   return(NULL);
#endif /* NOT_YET */
}

/*
 * ifStackQget:  grab the requested ifStackTable entry
 */
 ifStackQ *
ifStackQget (int	searchType,
	       long     ifHighIndex,
	       long     ifLowIndex)

{
    ifStackQ	       *test;
    ifStackEntry_t     *entry;

    for (test = snmpifStackQ.qhead; test; test = test->next) {

	entry = test->entry;
	/*
	 * the snmpifStackQ is sorted by ifHighIndex and
	 * ifLowIndex
	 */
	if ((entry->ifStackHigherLayer == ifHighIndex) &&
	    (entry->ifStackLowerLayer == ifLowIndex))
	    break;

	if (searchType == NEXT) {
            if (entry->ifStackHigherLayer > ifHighIndex) {
		break;
	    } else {
		if ((entry->ifStackHigherLayer == ifHighIndex) &&
		    (entry->ifStackLowerLayer > ifLowIndex))
		    break;
		
	    }
	} else {
	    if ((entry->ifStackHigherLayer > ifHighIndex) ||
		((entry->ifStackHigherLayer == ifHighIndex) &&
		 (entry->ifStackLowerLayer > ifLowIndex))) {
		test = NULL;
		break;
            } 
        }
    } /* end of for loop */
    return (test);
}

ifStackEntry_t *
k_ifStackEntry_get(serialNum, contextInfo, nominator, searchType, ifStackHigherLayer, ifStackLowerLayer)
   int serialNum;
   ContextInfo *contextInfo;
   int nominator;
   int searchType;
   long ifStackHigherLayer;
   long ifStackLowerLayer;
{
   static ifStackEntry_t ifStackEntryData;

    ifStackQ  *data;
   
   data = ifStackQget(searchType, ifStackHigherLayer, ifStackLowerLayer);

   if (data == NULL)
       return (NULL);

   memcpy(&ifStackEntryData,
	  data->entry,
	  sizeof(ifStackEntry_t));
   /*
    * if the request was a get, or if the request was a
    * get-next and the requested field has data, then
    * return the record
    */
   if ((searchType == EXACT) ||
       (VALID(nominator, ifStackEntryData.valid)))
       return (&ifStackEntryData);

   return (NULL);

}

#ifdef SETS
int
k_ifStackEntry_test(object, value, dp, contextInfo)
    ObjectInfo     *object;
    ObjectSyntax   *value;
    doList_t       *dp;
    ContextInfo    *contextInfo;
{
    long            ifHighIndex;
    long            ifLowIndex;
    snmpidbtype    *snmpidb = NULL;
    int             error_status;
    subiabtype     *subiab = NULL;
    subiabtype     *hisubiab = NULL;
    snmpifptrtype   *hiPtr = NULL;
    snmpifptrtype   *lowPtr = NULL;
    boolean         changeIsAdd;
 /*
  * must validate ifIndex exists, and object is allowed 
  * to be added or removed from ifStackTable
  */
    ifHighIndex = ((ifStackEntry_t *)(dp->data))->ifStackHigherLayer;
    ifLowIndex = ((ifStackEntry_t *)(dp->data))->ifStackLowerLayer;

    /*
     * preset error condition for fallthru case
     */
    error_status = INCONSISTENT_VALUE_ERROR;
    FOR_ALL_SNMPIDBS(snmpidb) {
	if (snmpidb->snmp_if_index == ifHighIndex) {
	    hiPtr = &(snmpidb->snmp_if_ptr);
    	    hisubiab = snmpidb->snmp_if_ptr.ifptr.subiab;
	}
	if (snmpidb->snmp_if_index == ifLowIndex) {
	    /*
	     * use ifStack callback stored in lower layer subiab to
	     * validate this stack change
	     */
	    lowPtr = &(snmpidb->snmp_if_ptr);
    	    subiab = snmpidb->snmp_if_ptr.ifptr.subiab;
	}
	if ((hiPtr != NULL) && (lowPtr != NULL))  
	    /* done with search. */
	    break;
    }

    if ((!hiPtr) || (!lowPtr) || (!subiab) || (!hisubiab) || 
	(ifHighIndex == ifLowIndex))
        return error_status;

    switch (object->nominator) {

#ifdef I_ifStackStatus
   case I_ifStackStatus:
	/*
	 * allow status to be set to createAndGo or detroy only for now...
	 */
        if((value->sl_value != D_ifStackStatus_createAndGo) && 
	    (value->sl_value != D_ifStackStatus_destroy)) 
            return WRONG_VALUE_ERROR;

	SET_VALID(I_ifStackStatus, 
		  ((ifStackEntry_t *) (dp->data))->valid);

	/* 
	 * need to see if this is add(create) or delete(destroy)
	 */
	if (value->sl_value == D_ifStackStatus_createAndGo)
	    changeIsAdd = TRUE;
	else
	    changeIsAdd = FALSE;
	    
	if (subiab != NULL) {
	    error_status = reg_invoke_ifmib_stack_screen(subiab->ifType,hiPtr,lowPtr,hisubiab->ifType,
            changeIsAdd,TRUE);
	    if (error_status != TRUE) {
		return WRONG_VALUE_ERROR;
	    }
	} else {
	    return INCONSISTENT_VALUE_ERROR;
	}
	break;
#endif /* I_ifStackStatus */

   default:
       DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in ifStackEntry_test)\n"));
       return GEN_ERROR;

   }        /* switch */

    return NO_ERROR;
}


int
k_ifStackEntry_ready(object, value, doHead, dp)
    ObjectInfo     *object;
    ObjectSyntax   *value;
    doList_t       *doHead;
    doList_t       *dp;
{
    boolean good_row = FALSE;

    /*
     * see if we have a complete row
     */
    if (VALID(I_ifStackStatus, ((ifStackEntry_t *)(dp->data))->valid)) 
	good_row = TRUE;
    else
	good_row = FALSE;

    /*
     * transition the row status as necessary
     */
    switch (((ifStackEntry_t *)
	     (dp->data))->ifStackStatus) {
    case D_ifStackStatus_createAndGo:
	if(good_row)
	    dp->state = ADD_MODIFY;
	break;
	
    case D_ifStackStatus_destroy:
	dp->state = DELETE;
	break;
	
	/*  
	 * No support yet for createAndWait rows, or setting row to
	 *  notInService.
	 */
    case D_ifStackStatus_createAndWait:
    case D_ifStackStatus_notReady:
    case D_ifStackStatus_notInService:
    default:
	return (INCONSISTENT_VALUE_ERROR);
	break;
    }
    return (NO_ERROR);

}

int
k_ifStackEntry_set(data, contextInfo, function)
   ifStackEntry_t *data;
   ContextInfo *contextInfo;
   int function;
{

    long           ifHighIndex;
    long           ifLowIndex;
    snmpidbtype    *snmpidb = NULL;
    int            error_status;
    subiabtype     *subiab = NULL;
    subiabtype     *hisubiab = NULL;
    snmpifptrtype  *hiPtr = NULL;
    snmpifptrtype  *lowPtr = NULL;
    ifStackQ	   *current;
    ifStackEntry_t *entry;

    ifHighIndex = data->ifStackHigherLayer;
    ifLowIndex = data->ifStackLowerLayer;

    current = ifStackQget(EXACT, data->ifStackHigherLayer,data->ifStackLowerLayer);

    /*
     * use ifStack callback stored in lower layer subiab to
     * make this stack change
     */
    FOR_ALL_SNMPIDBS(snmpidb) {
	if (snmpidb->snmp_if_index == ifHighIndex) {
    	    hiPtr = &snmpidb->snmp_if_ptr;
    	    hisubiab = snmpidb->snmp_if_ptr.ifptr.subiab;
	}
	if (snmpidb->snmp_if_index == ifLowIndex) {
    	    lowPtr = &snmpidb->snmp_if_ptr;
    	    subiab = snmpidb->snmp_if_ptr.ifptr.subiab;
	}
	if ((hiPtr != NULL) && (lowPtr != NULL))
	    /* leave loop - search done */
	    break;
    }

    if ((!hiPtr) || (!lowPtr) ||(!subiab) || (!hisubiab))
        return INCONSISTENT_VALUE_ERROR;
	    
    switch (function) {
    case DELETE:
	if (current) {
	    /*
	     * we've located the appropriate record, now add to
	     * internal structures via callback.
	     */
		error_status = reg_invoke_ifmib_stack_screen(subiab->ifType,hiPtr,
		    lowPtr,hisubiab->ifType, FALSE,FALSE);
		if (error_status != TRUE) {
		    /*
		     * This is a bad thing - failing on a set!  Means we need
		     * to add an Undo_* function for this 
		     */
		    return WRONG_VALUE_ERROR;
		}
		ifmib_destroy_stacklink(ifHighIndex,ifLowIndex);
	    }
	return (NO_ERROR);

    case ADD_MODIFY:
	if (current == NULL) {
	    /*
	     * adding a new row
	     */
	    error_status = reg_invoke_ifmib_stack_screen(subiab->ifType,hiPtr,
		    lowPtr,hisubiab->ifType,TRUE,FALSE);
	    if (error_status != TRUE) {
	    /*
	     * This is a bad thing - failing on a set!  Means we need
	     * to add an Undo_* function for this 
	     */
		return WRONG_VALUE_ERROR;
	    }
	    entry = ifmib_create_stacklink(ifHighIndex,ifLowIndex);
	    if (!entry) {
	    /*
	     * This is a bad thing - failing on a set!  Means we need
	     * to add an Undo_* function for this 
	     */
		return WRONG_VALUE_ERROR;
	    }
	} else {
	    entry = current->entry;
	}

	if (VALID(I_ifStackStatus, data->valid)) {
	    /*
	     * turn createAndGo into active since they're the same
	     * thing at this point
	     */
	    if (data->ifStackStatus == D_ifStackStatus_createAndGo)
		data->ifStackStatus = D_ifStackStatus_active;

	    SET_VALID(I_ifStackStatus, entry->valid);
	    entry->ifStackStatus = data->ifStackStatus;

	}
	return (NO_ERROR);
    }
    return (GEN_ERROR);
}
#endif /* SETS */

#ifdef SR_SNMPv2
#ifdef SR_ifStackEntry_UNDO
/* add #define SR_ifStackEntry_UNDO in ifmib.h to
 * include the undo routine for the ifStackEntry family.
 */
int
ifStackEntry_undo (
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
   return UNDO_FAILED_ERROR;
}
#endif /* SR_ifStackEntry_UNDO */
#endif /* SR_SNMPv2 */

/*
 * ifRcvAddrQget:  grab the requested ifRcvAddressTable entry
 */
ifRcvAddrQ *
ifRcvAddrQget (int	searchType,
	       long     ifIndex,
	       OctetString * ifRcvAddressAddress)
{
    ifRcvAddrQ	       *test = NULL;
    ifRcvAddressEntry_t   *entry = NULL;

    for (test = snmpifRcvAddrQ.qhead; test != NULL; test = test->next) {
	entry = test->entry;

	/*
	 * the snmpifRcvAddrQ is sorted by ifIndex and
	 * ifRcvAddressAddress.
	 */
	if ((test->snmp_if_index == ifIndex)
	    &&	    (CmpOctetStrings(entry->ifRcvAddressAddress,
			     ifRcvAddressAddress) == 0)) 
	    break;

	if (searchType == NEXT) {
            if (test->snmp_if_index > ifIndex) {
		break;
	    } else {
		if ((test->snmp_if_index == ifIndex) &&
		    (test->entry->ifRcvAddressAddress->length >
		    ifRcvAddressAddress->length)) {
		    break;
		} else if ((test->snmp_if_index == ifIndex) &&
		    (test->entry->ifRcvAddressAddress->length ==
		    ifRcvAddressAddress->length) &&
		     (CmpOctetStrings(test->entry->ifRcvAddressAddress,
			  ifRcvAddressAddress) > 0)) { 
		    break;
		}
	    }
        } else {
	    if ((test->snmp_if_index > ifIndex) ||
	         ((test->snmp_if_index == ifIndex)  &&
		    (test->entry->ifRcvAddressAddress->length >
		    ifRcvAddressAddress->length)) || 
		  ((test->snmp_if_index == ifIndex) &&
		   (test->entry->ifRcvAddressAddress->length ==
		    ifRcvAddressAddress->length) &&
		   (CmpOctetStrings(test->entry->ifRcvAddressAddress,
			    ifRcvAddressAddress) > 0))) {
		test = NULL;
		break;
            } 
        }
    }

    return (test);

}

ifRcvAddressEntry_t *
k_ifRcvAddressEntry_get (
   int serialNum,
   ContextInfo *contextInfo,
   int nominator,
   int searchType,
   long ifIndex,
   OctetString * ifRcvAddressAddress)
{
   static ifRcvAddressEntry_t ifRcvAddressEntryData;
    ifRcvAddrQ  *data;
   OctetString  *temp_os;
   uchar    *string;    

   /*
    * check if getnext caused the max address to wrap back to zero
    */
   if((string = malloc(ifRcvAddressAddress->length)) == NULL) {
       return (NULL);
   }
   memset(string, 0, ifRcvAddressAddress->length);
   temp_os = MakeOctetString(string,ifRcvAddressAddress->length);
      
   if ((searchType == NEXT) && (CmpOctetStrings(
	       ifRcvAddressAddress,temp_os)== 0)) {
	       ifIndex++;
	       ifRcvAddressAddress->length = 0;
   }
   FreeOctetString(temp_os);
   free(string);

   data = ifRcvAddrQget(searchType, ifIndex, ifRcvAddressAddress);

   if (data == NULL)
       return (NULL);

   memcpy(&ifRcvAddressEntryData,
	  data->entry,
	  sizeof(ifRcvAddressEntry_t));
   /*
    * if the request was a get, or if the request was a
    * get-next and the requested field has data, then
    * return the record
    */
   if ((searchType == EXACT) ||
       (VALID(nominator, ifRcvAddressEntryData.valid)))
       return (&ifRcvAddressEntryData);

   return (NULL);

}


#ifdef SETS
int
k_ifRcvAddressEntry_test (
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *dp,
    ContextInfo    *contextInfo)
{

    long           ifIndex;
    OctetString *  ifRcvAddressAddress = NULL;
    snmpidbtype  * snmpidb = NULL;
    int            error_status;
    subiabtype *    subiab = NULL;
    boolean        changeIsAdd;

 /*
  * must validate ifIndex exists, and object is allowed 
  * to be added or removed from ifRcvAddressTable
  */

    ifIndex = ((ifRcvAddressEntry_t*)(dp->data))->ifIndex;
    ifRcvAddressAddress = CloneOctetString(((ifRcvAddressEntry_t*)
					    (dp->data))->ifRcvAddressAddress);
    /*
     * preset error condition for fallthru case - validate ifIndex
     */
    error_status = INCONSISTENT_VALUE_ERROR;
    FOR_ALL_SNMPIDBS(snmpidb) 
	if (snmpidb->snmp_if_index == ifIndex) {
	    error_status = NO_ERROR;
	    break;
	}

    if (error_status != NO_ERROR) {
        FreeOctetString(ifRcvAddressAddress);
        return error_status;
    }

    switch(object->nominator) {

#ifdef I_ifRcvAddressAddress
    case I_ifRcvAddressAddress:

     if (memcmp(ifRcvAddressAddress->octet_ptr, value->os_value->octet_ptr,  value->os_value->length) != 0) {
	 FreeOctetString(ifRcvAddressAddress);
	 return WRONG_VALUE_ERROR;
     }
     
     if (((ifRcvAddressEntry_t *) (dp->data))->ifRcvAddressAddress != NULL) {
        FreeOctetString(((ifRcvAddressEntry_t *) (dp->data))->ifRcvAddressAddress);
     }

     ((ifRcvAddressEntry_t *) (dp->data))->ifRcvAddressAddress = 
         CloneOctetString(value->os_value);
    /*
     * use rcvAddress callback stored in subiab to validate this address
     */
      subiab = snmpidb->snmp_if_ptr.ifptr.subiab;
    
    /* need to see if this is add(create) or delete(destroy)
     * before checking whether it can be added etc, but row status
     * may not be known yet! check here and in ifRcvAddressStatus...
     */
    if(VALID(I_ifRcvAddressStatus, ((ifRcvAddressEntry_t *)
				  (dp->data))->valid)) {
	if (((ifRcvAddressEntry_t *)(dp->data))->ifRcvAddressStatus == D_ifRcvAddressStatus_createAndGo)
	    changeIsAdd = TRUE;
	else
	    changeIsAdd = FALSE;
	    
	if (subiab != NULL) {
	    error_status = 
		reg_invoke_ifmib_rcvaddr_screen(subiab->ifType,
						value->os_value->octet_ptr,
						value->os_value->length,
						changeIsAdd, TRUE,
						&snmpidb->snmp_if_ptr);
	    if (error_status != TRUE) {
		FreeOctetString(ifRcvAddressAddress);
		return WRONG_VALUE_ERROR;
	    }
	}  else {
	    /* 
	     * memory error
	     */
	    FreeOctetString(ifRcvAddressAddress);
	    return GEN_ERROR;
	}
    } /* end of VALID check */
 
     SET_VALID(I_ifRcvAddressAddress, 
	      ((ifRcvAddressEntry_t *) (dp->data))->valid);
     break;
#endif /* I_ifRcvAddressAddress */

#ifdef I_ifRcvAddressStatus
   case I_ifRcvAddressStatus:
	/*
	 * allow status to be set to createAndGo or detroy only for now...
	 */
        if((value->sl_value != D_ifRcvAddressStatus_createAndGo) && 
	    (value->sl_value != D_ifRcvAddressStatus_destroy)) {
	    FreeOctetString(ifRcvAddressAddress);
            return WRONG_VALUE_ERROR;
        }

	SET_VALID(I_ifRcvAddressStatus, 
		  ((ifRcvAddressEntry_t *) (dp->data))->valid);

    /*
     * use rcvAddress callback stored in subiab to validate this address
     */
      subiab = snmpidb->snmp_if_ptr.ifptr.subiab;
    
    /* need to see if this is add(create) or delete(destroy)
     * before checking whether it can be added etc, but address
     * may not be known yet! check here and in ifRcvAddressAddress...
     */
    if (VALID(I_ifRcvAddressAddress, ((ifRcvAddressEntry_t *)
				  (dp->data))->valid)) {
	if (value->sl_value == D_ifRcvAddressStatus_createAndGo)
	    changeIsAdd = TRUE;
	else
	    changeIsAdd = FALSE;
	
	if (subiab != NULL) {
	    error_status = 
		reg_invoke_ifmib_rcvaddr_screen(subiab->ifType,
						value->os_value->octet_ptr,
						value->os_value->length,
						changeIsAdd, TRUE,
						&snmpidb->snmp_if_ptr);
	    if (error_status != TRUE) {
		FreeOctetString(ifRcvAddressAddress);
		return WRONG_VALUE_ERROR;
	    }
	}  else {
	    FreeOctetString(ifRcvAddressAddress);
	    return GEN_ERROR;
	}
    }  /* end of VALID check */

     ((ifRcvAddressEntry_t *) (dp->data))->ifRcvAddressStatus = value->sl_value;
     break;
#endif /* I_ifRcvAddressStatus */

#ifdef I_ifRcvAddressType
   case I_ifRcvAddressType:
     /* support only other for now */			    
     if (value->sl_value != D_ifRcvAddressType_other) {
	 FreeOctetString(ifRcvAddressAddress);
	 return WRONG_VALUE_ERROR;
     }			    
     ((ifRcvAddressEntry_t *) (dp->data))->ifRcvAddressType = value->sl_value;
	SET_VALID(I_ifRcvAddressType, 
		  ((ifRcvAddressEntry_t *) (dp->data))->valid);
     break;
#endif /* I_ifRcvAddressType */

   default:
       DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in ifRcvAddressEntry_test)\n"));
       FreeOctetString(ifRcvAddressAddress);
       return GEN_ERROR;

   }        /* switch */


    FreeOctetString(ifRcvAddressAddress);
    return NO_ERROR;
}

int
k_ifRcvAddressEntry_ready (
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *dp)
{
    boolean good_row = FALSE;

    /*
     * see if we have a complete row
     */
    if (VALID(I_ifRcvAddressAddress,((ifRcvAddressEntry_t *)(dp->data))->valid) &&
	VALID(I_ifRcvAddressType, ((ifRcvAddressEntry_t *)(dp->data))->valid) &&
	VALID(I_ifRcvAddressStatus, ((ifRcvAddressEntry_t
				      *)(dp->data))->valid)) {
	good_row = TRUE;
    } else {
	good_row = FALSE;
    }

    /*
     * transition the row status as necessary
     */
    switch (((ifRcvAddressEntry_t *)
	     (dp->data))->ifRcvAddressStatus) {
    case D_ifRcvAddressStatus_createAndGo:
	if(good_row)
	    dp->state = ADD_MODIFY;
	break;
	
    case D_ifRcvAddressStatus_destroy:
	dp->state = DELETE;
	break;
	
	/*  
	 * No support yet for createAndWait rows, or setting row to
	 *  notInService.
	 */
    case D_ifRcvAddressStatus_createAndWait:
    case D_ifRcvAddressStatus_notReady:
    case D_ifRcvAddressStatus_notInService:
    default:
	return (INCONSISTENT_VALUE_ERROR);
	break;
    }
    return (NO_ERROR);
}

int
k_ifRcvAddressEntry_set_defaults ( doList_t  *dp)
{
    ifRcvAddressEntry_t *data = (ifRcvAddressEntry_t *) (dp->data);
    data->ifRcvAddressType = D_ifRcvAddressType_other;
    SET_VALID (I_ifRcvAddressType, data->valid);
    return NO_ERROR;
}

int
k_ifRcvAddressEntry_set (
			 ifRcvAddressEntry_t *data,
			 ContextInfo *contextInfo,
			 int function)
{

    long           ifIndex;
    OctetString    *ifRcvAddressAddress = NULL;
    snmpidbtype    *snmpidb = NULL;
    int            error_status;
    subiabtype     *subiab = NULL;
    uchar          *address;
    uint           length;     

    ifRcvAddrQ	   *current;
    ifRcvAddressEntry_t *entry;

    ifIndex = data->ifIndex;
    if (!(ifRcvAddressAddress =
	  CloneOctetString(data->ifRcvAddressAddress)))
	return GEN_ERROR;

   current = ifRcvAddrQget(EXACT, ifIndex, ifRcvAddressAddress);
    /*
     * use rcvAddrFn callback to make this address change
     */
    FOR_ALL_SNMPIDBS(snmpidb) 
	if (snmpidb->snmp_if_index == ifIndex) {
	    subiab = snmpidb->snmp_if_ptr.ifptr.subiab;
	    break;
	}

    if (subiab == NULL) {
	FreeOctetString(ifRcvAddressAddress);
	return INCONSISTENT_VALUE_ERROR;
    }

    address = ifRcvAddressAddress->octet_ptr;
    length = ifRcvAddressAddress->length;

    switch (function) {
    case DELETE:
	if (current) {
	    /*
	     * we've located the appropriate record, now add to
	     * internal structures via callback.
	     */
	    error_status = 
		reg_invoke_ifmib_rcvaddr_screen(subiab->ifType,
						address, length, TRUE, FALSE,
						&snmpidb->snmp_if_ptr);
	    if (error_status != TRUE) {
	    /*
	     * This is a bad thing - failing on a set!  Means we need
	     * to add an Undo_* function for this 
	     */
		FreeOctetString(ifRcvAddressAddress);
		return WRONG_VALUE_ERROR;
	    }
	    ifmib_destroy_rcvaddr(ifIndex,address,length);
	}
	FreeOctetString(ifRcvAddressAddress);
	return (NO_ERROR);

    case ADD_MODIFY:
	if (current == NULL) {
	    /*
	     * adding a new row
	     */

	    error_status = 
		reg_invoke_ifmib_rcvaddr_screen(subiab->ifType,
						address, length, TRUE, FALSE,
						&snmpidb->snmp_if_ptr);
	    if (error_status != TRUE) {
	    /*
	     * This is a bad thing - failing on a set!  Means we need
	     * to add an Undo_* function for this 
	     */
		FreeOctetString(ifRcvAddressAddress);
		return WRONG_VALUE_ERROR;
	    }
	    entry = ifmib_create_rcvaddr(ifIndex,address,length);
	} else {
	    entry = current->entry;
	}

	if (VALID(I_ifRcvAddressStatus, data->valid)) {
	    /*
	     * turn createAndGo into active since they're the same
	     * thing at this point
	     */
	    if (data->ifRcvAddressStatus == D_ifRcvAddressStatus_createAndGo)
		data->ifRcvAddressStatus = D_ifRcvAddressStatus_active;

	    SET_VALID(I_ifRcvAddressStatus, entry->valid);
	    entry->ifRcvAddressStatus = data->ifRcvAddressStatus;

	}
	FreeOctetString(ifRcvAddressAddress);
	return (NO_ERROR);
    }
    return (GEN_ERROR);

}
#endif /* SETS */

#ifdef SR_SNMPv2
#ifdef SR_ifRcvAddressEntry_UNDO
/* add #define SR_ifRcvAddressEntry_UNDO in ifmib.h to
 * include the undo routine for the ifRcvAddressEntry family.
 */
int
ifRcvAddressEntry_undo (
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
   return UNDO_FAILED_ERROR;
}
#endif /* SR_ifRcvAddressEntry_UNDO */
#endif /* SR_SNMPv2 */



static enum SNMP_ADMIN_STATE
ifmib_get_adminstatus_default (const subiabtype *subiab)
{
    /* we can only try to figger it out if the subiab refers to a swidb */
    if (subiab->master_type != SNMP_IF_SWIDB)
	return (SNMP_ADMIN_UNKNOWN);

    switch (subiab->master_ptr.ifptr.swidb->subif_state) {
    case SUBIF_STATE_ADMINDOWN:
	return SNMP_ADMIN_DOWN;
	
    case SUBIF_STATE_DELETED:
    case SUBIF_STATE_DOWN:
    default:		/* Fall through for "ADMIN UP"if not set
			   admin down */
	return SNMP_ADMIN_UP;
    }
    
}

static boolean ifmib_admin_change_default (
	  enum SNMP_ADMIN_STATE	newStatus,
	  boolean		testPhase,
	  const	subiabtype      *subiab)

/*
 * support function for changing ifAdminStatus - correct api wrapper
 * around shutdown_subif() routine.
 *
 * LOG-IF-MIB ifAdminStatus change callback function.
 * INPUTS:
 *     newStatus == requested new value of ifAdminStatus
 *		     this must be different than the current value
 *     testPhase == TRUE if this the value is being checked
 *                   in the test phase of PDU processing
 *		     FALSE if the change should take effect now
 *     subiab == r/o pointer to SUBIAB for this interface
 * RETURNS:
 *   TRUE if the change is allowed by LOG-IF-MIB
 *       if testPhase == TRUE:
 *          upon exit, ifAdminStatus has not changed.       
 *       if testPhase == FALSE:
 *	    upon exit, the new value of ifAdminStatus is in effect
 *  FALSE if LOG-IF-MIB is rejecting the requested change
 *       upon exit, ifAdminStatus has not changed.
 */ 

{
    ulong newstate;
    idbtype *swidb;

    /* we can only do this for subiab's that refer to a swidb */
    if (subiab->master_type != SNMP_IF_SWIDB)
	return (FALSE);

    swidb = subiab->master_ptr.ifptr.swidb;

   /*
    * convert to subif state enum
    */
    switch ( newStatus) {
    case D_ifAdminStatus_down:
	newstate = SUBIF_STATE_ADMINDOWN;
	break;

    case D_ifAdminStatus_up:
	newstate = SUBIF_STATE_UP;
    /*
     * Make sure our configuration allows us to remove this interface
     * from the shutdown state.
     */
	if (reg_invoke_stay_shutdown(swidb))
	    return FALSE;

	break;
    default:
	return FALSE;

    }

    if (!testPhase)
	shutdown_subif(swidb, newstate);
    return TRUE;
}

static enum SNMP_ADMIN_STATE
ifmib_get_operstatus_default (const subiabtype *subiab)
{
    idbtype *swidb = NULL;

    /* we can only try to figger it out if the subiab refers to a swidb */
    if (subiab->master_type != SNMP_IF_SWIDB)
	return (SNMP_ADMIN_UNKNOWN);   /* state is really unkown...*/

    swidb = subiab->master_ptr.ifptr.swidb;

    switch (swidb->subif_state) {
    case SUBIF_STATE_ADMINDOWN:
    case SUBIF_STATE_DELETED:
    case SUBIF_STATE_DOWN:
	return(SNMP_ADMIN_DOWN);

    default:		/* Fall through for "ADMIN UP"if not set
			   admin down */
	break;
	
    }
    /*
     * Return hwidb state - same as show int does
     */
    switch (swidb->hwptr->state) {
	case IDBS_TESTING: 
	   return(SNMP_ADMIN_TESTING);
	case IDBS_UP: 
	   return (SNMP_ADMIN_UP);
	case IDBS_DOWN: 
	case IDBS_GOINGDOWN:
	case IDBS_INIT: 
	case IDBS_RESET:
	case IDBS_ADMINDOWN:
      	default: 
	   return(SNMP_ADMIN_DOWN);
    }
}

static void
ifmib_update_ifAlias_default (subiabtype *subiab, OctetString *ifalias,
			      boolean set)
{
    idbtype *swidb;
    int ifalias_len;
    static char legal_ifalias[IFALIAS_LENGTH+1];

    /* if subiab refers to a swidb, store ifalias in swidb->description */

    if (subiab->master_type != SNMP_IF_SWIDB)
	return;

    swidb = subiab->master_ptr.ifptr.swidb;

    if (set) {
	ifmib_set_ifalias(&swidb->description, ifalias);
    } else {
	ifalias_len = strlen(swidb->description);
	if (ifalias_len >= IFALIAS_LENGTH) {
	    strncpy(legal_ifalias, swidb->description, IFALIAS_LENGTH);
	    ifalias->octet_ptr = legal_ifalias;
	    ifalias->length = IFALIAS_LENGTH;
	} else {
	    ifalias->octet_ptr = swidb->description;
	    ifalias->length = strlen(swidb->description);
	}
    }
}


static ulong ifmib_get_if_speed_default ( const	subiabtype *subiab)
{

/*
 * responsible for updating ifSpeed from subinterface bandwidth
 * changes for an ifmib registered swidb sublayer
 */

    idbtype *swidb;

    if (subiab->master_type != SNMP_IF_SWIDB)
	return 0;

    swidb = subiab->master_ptr.ifptr.swidb;
    return (swidb->visible_bandwidth * 1000);
}

void
init_ifmib (subsystype *subsys)
{
    snmpidbtype *snmpidb;
    hwidbtype       *hwidb  = NULL;

    load_mib(ifmib_OidList, ifmib_OidListNum);
    load_oid(ifmib_oid_table);

    reg_add_default_ifmib_get_operstatus(ifmib_get_operstatus_default,
					 "ifmib_get_operstatus_default");
    reg_add_default_ifmib_get_adminstatus(ifmib_get_adminstatus_default,
					  "ifmib_get_adminstatus_default");
    reg_add_default_ifmib_admin_change(ifmib_admin_change_default,
				       "ifmib_admin_change_default");
    reg_add_default_ifmib_update_ifAlias(ifmib_update_ifAlias_default,
				      "ifmib_update_ifAlias_default");
    reg_add_default_ifmib_get_if_speed(ifmib_get_if_speed_default, 
				       "ifmib_get_if_speed_default");

    /*
     * good place to add first item into ifRcvAddressTable for hwidbs
     * subiab will add this in the ifmib_ register function. Also want
     * to add the endpoints into ifStackTable here.
     */

   FOR_ALL_SNMPIDBS(snmpidb) {
       if (snmpidb)
	   switch (snmpidb->snmp_if_struct) {
	
	   case SNMP_IF_HWIDB:
	       hwidb = snmpidb->snmp_if_ptr.ifptr.hwidb;
	       if ((!is_ieee_zero(&hwidb->hardware[0])) &&
		       (hwidb->status & (IDB_ETHER|IDB_TR|IDB_FDDI))) {
		   ifmib_create_rcvaddr(snmpidb->snmp_if_index, 
			    (const uchar *)hwidb->hardware,IEEEBYTES);
	       }

	       /*
		* add broadcast/mcast addresses to ifRcvAddressTable
		*/
	       if (hwidb->status & IDB_ETHER)
		   ifmib_create_rcvaddr(hwidb->snmp_if_index,
						   baddr,IEEEBYTES);
	       /*
		* register aal5 and atm sublayers with SNMP IFMIB,
		* since ifmib isn't ready yet when atm intf. comes up.
		*/
	       if (hwidb->enctype == ET_ATM) {
		   reg_invoke_ifmib_add_subif(ET_ATM,hwidb->firstsw);
	       }

	       ifmib_create_stacklink(hwidb->snmp_if_index, 0);
	       ifmib_create_stacklink(0,hwidb->snmp_if_index);
	       break;
	   
	   default:
	       break;
	   
	   }
   }

    /* 
     * Now register all cdb-based interfaces. Has to be service point
     * since it depends on cdbQ, not available on all platforms
     */
    reg_invoke_ifmib_add_all_cdb_if();

    /*
     * Tell SNMP what traps I support
     */
    register_snmp_trap(TRAP_SNMP, linkup_trap_oid);
    register_snmp_trap(TRAP_SNMP, linkdown_trap_oid);

    reg_add_ifmib_link_trap(snmp_link_trap, "snmp_link_trap");

    /*
     * initialize cisco private interfaces mib
     */
    init_old_lifmib();

}


/*
	Cisco emits a modified linkUp/linkDown trap:
          linkDown TRAP-TYPE
              ENTERPRISE  snmp
              VARIABLES   { ifIndex, ifDescr, ifType, locIfReason }
              DESCRIPTION
                          "A linkDown trap signifies that the sending
                          protocol entity recognizes a failure in one of
                          the communication links represented in the
                          agent's configuration."
              ::= 2

          linkUp TRAP-TYPE
              ENTERPRISE  snmp
              VARIABLES   { ifIndex, ifDescr, ifType, locIfReason }
              DESCRIPTION
                          "A linkUp trap signifies that the sending
                          protocol entity recognizes that one of the
                          communication links represented in the agent's
                          configuration has come up."
              ::= 3

 */
#define IFMIB_LINK_TRAP_VBCOUNT 4
static const OID linkVarBinds[IFMIB_LINK_TRAP_VBCOUNT] = {
    {LNifIndex, (ulong *)IDifIndex},
    {LNifDescr, (ulong *)IDifDescr},
    {LNifType, (ulong *)IDifType},
    {LNlocIfReason, (ulong *)IDlocIfReason}
};

/*
 * process a link up/down registry call
 */
void
snmp_link_trap (long		genTrap,
		hwidbtype      *idb)
{
    OID	       *vbList[IFMIB_LINK_TRAP_VBCOUNT+1];
    int		vbIndex;
    OID         instanceOID;
    ulong       instance[1];

    /*
     * see if traps have been inhibited on this interface
     */
    if (idb->snmp_trap_nolink)
	return;

    /*
     * All the trap varbind objects have an instance described by
     * INDEX { ifIndex }
     */
    instance[0] = idb->snmp_if_index;
    instanceOID.oid_ptr = instance;
    instanceOID.length = 1;

    /*
     * traps cannot be generated directly from interrupt level
     * since the trap generation code utilizes dynamic memory.
     * traps also cannot be generated directly from non-blockable
     * processes since building the trap message may result in a
     * process block.  if either of these criteria are in effect,
     * then queue the trap information to the background trap
     * process, which will generate the trap.
     */
    if (get_interrupt_level() || blocking_disabled) {
	SnmpSendTrap_Generic(linkVarBinds,		/* vblist */
			     NULL,			/* enterprise */
			     NULL,			/* v2TrapOID */
			     &instanceOID,		/* instanceOID */
			     IFMIB_LINK_TRAP_VBCOUNT,	/* varbindCount */
			     genTrap,			/* genericTrapNum */
			     0);			/* specificTrapNum */
        return;
    }

    /*
     * the trap can be generated directly by this process
     */


    /*
     * create the OID * array
     */
    for (vbIndex = 0; vbIndex < IFMIB_LINK_TRAP_VBCOUNT; vbIndex++) {
	vbList[vbIndex] = CatOID((OID *) &linkVarBinds[vbIndex], &instanceOID);
    }

    /*
     * NULL terminate the array
     */
    vbList[IFMIB_LINK_TRAP_VBCOUNT] = NULL;

    /*
     * initiate generic trap processing
     */
    snmp_trap(genTrap, 0, vbList, NULL, NULL);

    /*
     * free all the allocated structures
     */
    for (vbIndex = 0; vbIndex < IFMIB_LINK_TRAP_VBCOUNT; vbIndex++) {
	FreeOID(vbList[vbIndex]);
    }
}

/*
 * ifmib subsystem header
 */

#define MAJVERSION_ifmib 1
#define MINVERSION_ifmib 0
#define EDITVERSION_ifmib 0

SUBSYS_HEADER(ifmib,
              MAJVERSION_ifmib,
              MINVERSION_ifmib,
              EDITVERSION_ifmib,
              init_ifmib,
              SUBSYS_CLASS_MANAGEMENT,
              NULL,
              NULL);
      
