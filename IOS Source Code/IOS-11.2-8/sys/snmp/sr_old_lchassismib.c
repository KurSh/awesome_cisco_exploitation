/* $Id: sr_old_lchassismib.c,v 3.8.10.6 1996/07/03 20:43:28 thille Exp $
 * $Source: /release/112/cvs/Xsys/snmp/sr_old_lchassismib.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * March 1994, Kenny Roberts (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1996-1997 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_old_lchassismib.c,v $
 * Revision 3.8.10.6  1996/07/03  20:43:28  thille
 * CSCdi61860: Implement Jeffs glass of slim-fast for snmp
 * Branch: California_branch
 * Take hunk of common code from many mib files, make it a procedure in
 * snmp_util.c and call it from the mibs.  Save 1640 bytes.
 *
 * Revision 3.8.10.5  1996/07/01  18:46:04  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.8.10.4  1996/05/21  10:02:30  thille
 * CSCdi51599:  multiple /interface/ literals bloat code.
 * Branch: California_branch
 * Save another 392 bytes by doing away with duplicate literals.
 *
 * Revision 3.8.10.3  1996/05/21  06:38:46  mordock
 * Branch: California_branch
 * Improve snmp modularity via creating services to register interfaces
 * and chassis cards.
 * Add syslog mib.
 *
 * Revision 3.8.10.2  1996/05/17  11:43:02  ppearce
 * Merge IbuMod into Calif
 *
 * Revision 3.8.2.2  1996/05/05  23:47:11  ppearce
 * Sync to IbuMod_Calif_baseline_960504
 *
 * Revision 3.8.2.1  1996/04/26  07:57:11  dstine
 * Branch: IbuMod_Calif_branch
 * - commit of IBU modularity work, phase 1.
 *
 * Revision 3.8.10.1  1996/04/19  17:46:36  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.8  1996/02/24  03:17:04  anke
 * CSCdi49086:  snmp-server chassis-id disappears from config and is lost
 * String & default pointers were set to be equal.  Point default at
 * original platform string, and copy it into seperate space for the
 * string pointer
 *
 * Revision 3.7  1996/02/15  18:03:46  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.6  1995/12/15  03:14:26  rpratt
 * CSCdi45651:  Chassis MIB enhancements made Port Ready
 *
 * Revision 3.5  1995/12/14  08:27:33  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.4  1995/12/10  23:28:04  rpratt
 * CSCdi45343:  Chassis MIB enhancements for VIP & port adapters
 *
 * Revision 3.3  1995/11/24  16:41:12  jjohnson
 * CSCdi42637:  platform-specific code should be moved out of sub_snmp
 * Install an API for accessing platform-specific SNMP objects
 *
 * Revision 3.2  1995/11/17  19:00:09  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  13:17:20  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.6  1995/11/08  21:25:53  shaker
 * Merge Arkansas_branch into 11.1 mainline.
 *
 * Revision 2.5  1995/09/17  07:43:32  anke
 * CSCdi40479:  chassis mib attempts to free non-allocated memory
 * Added setstring to calls to platform_get_string
 *
 * Revision 2.4  1995/08/30  17:50:03  snyder
 * CSCdi39308:  SNMP should skip NOHARDWARE idbs
 *              If a board has been pulled cardIfIndexTable should
 *              not report the board
 *
 * Revision 2.3  1995/08/17  22:25:47  schaefer
 * CSCdi38945: cardIfIndexTable not present on RSP
 *
 * Revision 2.2  1995/07/17  07:34:00  bchan
 * CSCdi34760:  Ifindex usage incorrect
 *
 * Revision 2.1  1995/06/07  22:49:46  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include "../ui/common_strings.h"
#include "config_register.h"
#include "snmp_api.h"
#include "sr_old_lchassismib.h"
#include "sr_old_lchassismib-mib.h"

#include "logger.h"
#include "packet.h"
#include "../dev/monitor1.h"
#include "../os/free.h"
#include "../os/region.h"

#include "snmp_interface.h"
#include "snmp_platform_api.h"
#include "chassismib_api.h"
#include "ifmib_registry.h"
#include "chassismib_registry.h"
#include "registry.h"

#include "interface_private.h"

/* chassis data */
char	       *chassis_version;	/* hardware revision level */
char	       *snmp_chassis_string;
char	       *snmp_chassis_string_default;

static OctetString    *romVersion;		/* ROM monitor version */
static OctetString    *romSysVersion;		/* system software in ROM */

void
init_old_lchassismib(void)
{
    char *cp;

    setstring(&chassis_version,
              platform_get_string(PLATFORM_STRING_HARDWARE_REVISION)); 

    cp = mon_vstring();
    if (cp == (char*) -1)
	cp = "";
    romVersion = MakeOctetString(cp, strlen(cp));
    ConvertToDisplayString(romVersion);
    cp = mon_vstring_sys_rom();
    if (cp == (char*) -1)
	cp = "";
    romSysVersion = MakeOctetString(cp, strlen(cp));
    ConvertToDisplayString(romSysVersion);
    snmp_chassis_string_default =
	platform_get_string(PLATFORM_STRING_HARDWARE_SERIAL);
    snmp_chassis_string = NULL;
    if (snmp_chassis_string_default)
	setstring(&snmp_chassis_string, snmp_chassis_string_default);
    load_mib(old_lchassismib_OidList, old_lchassismib_OidListNum);
    load_oid(old_lchassismib_oid_table);
}



/*---------------------------------------------------------------------
 * Retrieve data from the chassis family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
chassis_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             arg;
    void           *dp;
    chassis_t      *data=NULL;


    arg = snmp_scalar_instance(incoming, object, searchType);

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_chassis_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_chassisType
      case I_chassisType:
	dp = &data->chassisType;
	break;
#endif				       /* I_chassisType */

#ifdef I_chassisVersion
      case I_chassisVersion:
	dp = MakeOctetString(data->chassisVersion->octet_ptr, data->chassisVersion->length);
	break;
#endif				       /* I_chassisVersion */

#ifdef I_chassisId
      case I_chassisId:
	dp = MakeOctetString(data->chassisId->octet_ptr, data->chassisId->length);
	break;
#endif				       /* I_chassisId */

#ifdef I_romVersion
      case I_romVersion:
	dp = MakeOctetString(data->romVersion->octet_ptr, data->romVersion->length);
	break;
#endif				       /* I_romVersion */

#ifdef I_romSysVersion
      case I_romSysVersion:
	dp = MakeOctetString(data->romSysVersion->octet_ptr, data->romSysVersion->length);
	break;
#endif				       /* I_romSysVersion */

#ifdef I_processorRam
      case I_processorRam:
	dp = &data->processorRam;
	break;
#endif				       /* I_processorRam */

#ifdef I_nvRAMSize
      case I_nvRAMSize:
	dp = &data->nvRAMSize;
	break;
#endif				       /* I_nvRAMSize */

#ifdef I_nvRAMUsed
      case I_nvRAMUsed:
	dp = &data->nvRAMUsed;
	break;
#endif				       /* I_nvRAMUsed */

#ifdef I_configRegister
      case I_configRegister:
	dp = &data->configRegister;
	break;
#endif				       /* I_configRegister */

#ifdef I_configRegNext
      case I_configRegNext:
	dp = &data->configRegNext;
	break;
#endif				       /* I_configRegNext */

#ifdef I_chassisSlots
      case I_chassisSlots:
	dp = &data->chassisSlots;
	break;
#endif				       /* I_chassisSlots */

#ifdef I_chassisPartner
    case I_chassisPartner:
       dp = (void *) (&data->chassisPartner);
       break;
#endif /* I_chassisPartner */

#ifdef I_sysUpTimeAtLastChassisChange
    case I_sysUpTimeAtLastChassisChange:
       dp = (void *) (&data->sysUpTimeAtLastChassisChange);
       break;
#endif /* I_sysUpTimeAtLastChassisChange */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the chassis data object.
 *---------------------------------------------------------------------*/
void
chassis_free(chassis_t *data)
{
    if (data != NULL) {
	if (data->chassisId != NULL) {
	    FreeOctetString(data->chassisId);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after chassis set/undo
 *---------------------------------------------------------------------*/
static int
chassis_cleanup(doList_t       *trash)
{
    chassis_free(trash->data);
#ifdef SR_SNMPv2
    chassis_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
chassis_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    /*VarBind        *vb = (VarBind *) NULL;*/
    int             found;
    /*int             carry = 0;
    chassis_t      *chassis;*/

    /*
     * Validate the object instance: 1) It must be of length 1  2) and the
     * instance must be 0.
     */
    if (instLength != 1 || incoming->oid_ptr[incoming->length - 1] != 0) {
	return (NO_CREATION_ERROR);
    }
    found = 0;

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(chassis_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(chassis_t));

	dp->setMethod = chassis_set;
	dp->cleanupMethod = chassis_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

    }
    switch (object->nominator) {

#ifdef I_chassisId
      case I_chassisId:

        if (value->os_value->length > SYSSIZE) {
            return (WRONG_LENGTH_ERROR);
        }

        if (!IsDisplayString(value->os_value)) {
            return (WRONG_VALUE_ERROR);
        }

	SET_VALID(I_chassisId, ((chassis_t *) (dp->data))->valid);

	if (((chassis_t *) (dp->data))->chassisId != NULL) {
	    FreeOctetString(((chassis_t *) (dp->data))->chassisId);
	}
	((chassis_t *) (dp->data))->chassisId =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_chassisId */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in chassis_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
chassis_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_chassis_set((chassis_t *) (doCur->data),
			  contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the cardTableEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
cardTableEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    cardTableEntry_t *data = NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            cardIndex;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &cardIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_cardTableEntry_get(serialNum, contextInfo, arg, searchType, cardIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->cardIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_cardIndex
      case I_cardIndex:
	dp = &data->cardIndex;
	break;
#endif				       /* I_cardIndex */

#ifdef I_cardType
      case I_cardType:
	dp = &data->cardType;
	break;
#endif				       /* I_cardType */

#ifdef I_cardDescr
      case I_cardDescr:
	dp = MakeOctetString(data->cardDescr->octet_ptr, data->cardDescr->length);
	break;
#endif				       /* I_cardDescr */

#ifdef I_cardSerial
      case I_cardSerial:
	dp = &data->cardSerial;
	break;
#endif				       /* I_cardSerial */

#ifdef I_cardHwVersion
      case I_cardHwVersion:
	dp = MakeOctetString(data->cardHwVersion->octet_ptr, data->cardHwVersion->length);
	break;
#endif				       /* I_cardHwVersion */

#ifdef I_cardSwVersion
      case I_cardSwVersion:
	dp = MakeOctetString(data->cardSwVersion->octet_ptr, data->cardSwVersion->length);
	break;
#endif				       /* I_cardSwVersion */

#ifdef I_cardSlotNumber
      case I_cardSlotNumber:
	dp = &data->cardSlotNumber;
	break;
#endif				       /* I_cardSlotNumber */

#ifdef I_cardContainedByIndex
    case I_cardContainedByIndex:
       dp = (void *) (&data->cardContainedByIndex);
       break;
#endif /* I_cardContainedByIndex */

#ifdef I_cardOperStatus
    case I_cardOperStatus:
       dp = (void *) (&data->cardOperStatus);
       break;
#endif /* I_cardOperStatus */

#ifdef I_cardSlots
    case I_cardSlots:
       dp = (void *) (&data->cardSlots);
       break;
#endif /* I_cardSlots */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the cardIfIndexEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
cardIfIndexEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum
    )
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    cardIfIndexEntry_t *data = NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            cardIfIndex;


    /*
     * Check the object instance.
     *
     * An EXACT search requires that the instance be of length 1
     *
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
        if (instLength != 1) {
            return ((VarBind *) NULL);
        }
        carry = 0;
    } else {
        carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &cardIfIndex, searchType, &carry)) < 0) {
        arg = -1;
    }
    if (carry) {
        arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_cardIfIndexEntry_get(serialNum, contextInfo, arg, searchType, cardIfIndex)) == NULL) {
        arg = -1;
    } else {
        /*
         * Build instance information
         */
        inst.oid_ptr = buffer;
        inst.length = 1;
        inst.oid_ptr[0] = data->cardIfIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_cardIfIndex
      case I_cardIfIndex:
        dp = &data->cardIfIndex;
        break;
#endif                                 /* I_cardIfIndex */

#ifdef I_cardIfSlotNumber
      case I_cardIfSlotNumber:
        dp = &data->cardIfSlotNumber;
        break;
#endif                                 /* I_cardIfSlotNumber */

#ifdef I_cardIfPortNumber
      case I_cardIfPortNumber:
        dp = &data->cardIfPortNumber;
        break;
#endif                                 /* I_cardIfPortNumber */

#ifdef I_cardIfCardIndex
    case I_cardIfCardIndex:
       dp = (void *) (&data->cardIfCardIndex);
       break;
#endif /* I_cardIfCardIndex */

#ifdef I_cardIfConnectorTypeEnabled
    case I_cardIfConnectorTypeEnabled:
       dp = (void *) (&data->cardIfConnectorTypeEnabled);
       break;
#endif /* I_cardIfConnectorTypeEnabled */

      default:
        return ((VarBind *) NULL);

    }                                  /* switch */

    return (MakeVarBind(object, &inst, dp));

}

chassis_t *
k_chassis_get(int serialNum, ContextInfo *contextInfo, int nominator)
{
    static chassis_t chassisData;
    static OctetString chassisId, chassisVersion;

    chassisData.chassisType =
	snmp_platform_get_value(SNMP_PLATFORM_CHASSIS_TYPE);

    chassisData.chassisVersion = &chassisVersion;
    chassisData.chassisVersion->octet_ptr = chassis_version;
    chassisData.chassisVersion->length = strlen(chassis_version);

    chassisData.chassisId = &chassisId;
    chassisData.chassisId->octet_ptr = (uchar *)snmp_chassis_string;
    chassisData.chassisId->length = strlen(snmp_chassis_string);

    chassisData.romVersion = romVersion;

    chassisData.romSysVersion = romSysVersion;

    chassisData.processorRam = region_get_size_by_class(REGION_CLASS_LOCAL);
    chassisData.nvRAMSize = nvsize;
    chassisData.nvRAMUsed = nvused;
    chassisData.configRegister = configregister;
    chassisData.configRegNext = (ushort) ~mon_getconfig();
    chassisData.chassisSlots = snmp_platform_get_value(SNMP_PLATFORM_SLOTS);
    chassisData.chassisPartner = platform_get_value(PLATFORM_VALUE_VENDOR);
    chassisData.sysUpTimeAtLastChassisChange = 
			get_sysUpTimeAtLastChassisChange();

    return (&chassisData);
}

#ifdef SETS
int
k_chassis_set(
    chassis_t      *data,
    ContextInfo    *contextInfo,
    int             function)
{
    char* temp;
    int len;

    if (VALID(I_chassisId, data->valid)) {
	len = data->chassisId->length;
	if (len == 0)
	    temp = NULL;
	else {
	    temp = malloc(len + 1);
	    if (temp == NULL)
		return (GEN_ERROR);
	    bcopy(data->chassisId->octet_ptr, temp, len);
	    temp[len] = '\0';
	}
	setstring(&snmp_chassis_string, temp);
    }
    return (NO_ERROR);
}

#endif				       /* SETS */

cardTableEntry_t *
k_cardTableEntry_get(int serialNum, ContextInfo *contextInfo, int nominator,
    int searchType, long cardIndex)
{
    static cardTableEntry_t cardTableEntryData;
    static OctetString cardDescr, cardHwVersion, cardSwVersion;
    card_entry* cep;

    cep = chassismib_get_cep(searchType, &cardIndex);
    if (cep == NULL)
	return (NULL);

    cardTableEntryData.cardIndex = cep->card_index;
    cardTableEntryData.cardType = cep->card_type;

    cardTableEntryData.cardDescr = &cardDescr;
    cardTableEntryData.cardDescr->octet_ptr = cep->card_descr;
    cardTableEntryData.cardDescr->length = strlen(cep->card_descr);

    cardTableEntryData.cardSerial = (long) cep->card_serial;

    cardTableEntryData.cardHwVersion = &cardHwVersion;
    cardTableEntryData.cardHwVersion->octet_ptr = cep->card_hw_version;
    cardTableEntryData.cardHwVersion->length = strlen(cep->card_hw_version);

    cardTableEntryData.cardSwVersion = &cardSwVersion;
    cardTableEntryData.cardSwVersion->octet_ptr = cep->card_sw_version;
    cardTableEntryData.cardSwVersion->length = strlen(cep->card_sw_version);

    cardTableEntryData.cardSlotNumber = cep->card_slot_number;

    cardTableEntryData.cardContainedByIndex = cep->card_contained_by_index;

    cardTableEntryData.cardOperStatus = snmp_platform_get_card_value(
						cardTableEntryData.cardIndex,
						SNMP_PLATFORM_CARD_OPER_STATUS);

    cardTableEntryData.cardSlots = cep->card_slots;

    return (&cardTableEntryData);
}

static boolean cardIfIndextest(snmpidbtype *snmpidb, long* dummy)
{

    ulong idb_status;
    /* only hardware idbs  could indicate a card for now */
    /* remove tunnels, loopbacks and such               */

    if (snmpidb->snmp_if_struct == SNMP_IF_HWIDB) {
        idb_status = snmpidb->snmp_if_ptr.ifptr.hwidb->status;
        /*
         * On slot base platform allow to see Async.
         */
        if (snmp_platform_get_value(SNMP_PLATFORM_SLOTS)) {
            idb_status &= ~IDB_ASYNC;
        }
        return(!(idb_status & (IDB_EPHEMERAL | IDB_DELETED | IDB_NOHARDWARE)));
    }
    if (snmpidb->snmp_if_struct == SNMP_IF_SUBIAB)
            if (snmpidb->snmp_if_ptr.ifptr.subiab->master_type == SNMP_IF_CDB)
                return (TRUE);
    return(FALSE);

}

cardIfIndexEntry_t *
k_cardIfIndexEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            cardIfIndex 
    )
{
    snmpidbtype *snmpidb = NULL;
    static cardIfIndexEntry_t cardIfIndexEntryData;
    hwidbtype* hwidb;
    cdbtype *cdb = NULL;
    subiabtype *subiab = NULL;

    /* if this chassis does not have slots, it is a moot point */
    if (snmp_platform_get_value(SNMP_PLATFORM_SLOTS) == 0)
        return(NULL);

    snmpidb = reg_invoke_ifmib_snmpidb_get(NULL, serialNum, 
                                           searchType, cardIfIndex,
					   cardIfIndextest, NULL);
    if (snmpidb == NULL)
       return(NULL);

    cardIfIndexEntryData.cardIfIndex = snmpidb->snmp_if_index;
    if (snmpidb->snmp_if_struct == SNMP_IF_SUBIAB) {
            if (snmpidb->snmp_if_ptr.ifptr.subiab->master_type == SNMP_IF_CDB) {
                subiab = snmpidb->snmp_if_ptr.ifptr.subiab;
                cdb = subiab->master_ptr.ifptr.cdb;
                if (cdb == NULL)
                    return(NULL);
                cardIfIndexEntryData.cardIfCardIndex =
                    reg_invoke_cardifmib_get_card_index(cdb);
                cardIfIndexEntryData.cardIfSlotNumber =
                    reg_invoke_cardifmib_get_slot_number(cdb);
                cardIfIndexEntryData.cardIfPortNumber =
                    reg_invoke_cardifmib_get_port_number(cdb);
                cardIfIndexEntryData.cardIfConnectorTypeEnabled =
                    reg_invoke_cardifmib_get_connector_type(cdb);
                return (&cardIfIndexEntryData);
            }
    }

    hwidb = snmpidb->snmp_if_ptr.ifptr.hwidb;

    cardIfIndexEntryData.cardIfCardIndex = snmp_platform_get_if_value(hwidb,
						SNMP_PLATFORM_IF_CARD_INDEX);

    cardIfIndexEntryData.cardIfSlotNumber = snmp_platform_get_if_value(hwidb,
						SNMP_PLATFORM_IF_SLOT_NUMBER);

    cardIfIndexEntryData.cardIfPortNumber = snmp_platform_get_if_value(hwidb,
						SNMP_PLATFORM_IF_PORT_NUMBER);

    cardIfIndexEntryData.cardIfConnectorTypeEnabled = 
				snmp_platform_get_if_value(hwidb, 
				SNMP_PLATFORM_IF_CONNECTOR_TYPE_ENABLED);

    return (&cardIfIndexEntryData);
}

OID *make_card_indexOID (int index_val)
{
    OID *CardIndex_oid;
    int i;
    unsigned long *oid_array;

    if (!(oid_array = malloc((LNcardIndex+1)*sizeof(long))))
	return (NULL);

    for (i=0; i<LNcardIndex; i++)
	oid_array[i] =  IDcardIndex[i];
    oid_array[LNcardIndex] = index_val;

    CardIndex_oid = MakeOID(oid_array, (LNcardIndex+1));
    free(oid_array);
    return (CardIndex_oid);
}
      
