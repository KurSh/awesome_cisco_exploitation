/* $Id: sr_old_lcpumib.c,v 3.4.6.3 1996/07/03 20:43:31 thille Exp $
 * $Source: /release/112/cvs/Xsys/snmp/sr_old_lcpumib.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * April 1994, Kenny Roberts (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1994-1996 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_old_lcpumib.c,v $
 * Revision 3.4.6.3  1996/07/03  20:43:31  thille
 * CSCdi61860: Implement Jeffs glass of slim-fast for snmp
 * Branch: California_branch
 * Take hunk of common code from many mib files, make it a procedure in
 * snmp_util.c and call it from the mibs.  Save 1640 bytes.
 *
 * Revision 3.4.6.2  1996/07/01  18:46:06  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.4.6.1  1996/04/19  17:46:39  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.4  1996/03/01  14:42:22  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.3  1995/12/14  08:27:34  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.2  1995/11/17  19:00:13  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  13:17:23  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.1  1995/06/07  22:49:51  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include "../snmp/snmp_api.h"
#include "sr_old_lcpumib.h"
#include "sr_old_lcpumib-mib.h"

#include "../os/sched_private.h"

void
init_old_lcpumib(void)
{
    load_mib(old_lcpumib_OidList, old_lcpumib_OidListNum);
    load_oid(old_lcpumib_oid_table);
}


/*---------------------------------------------------------------------
 * Retrieve data from the lcpu family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
lcpu_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             arg;
    void           *dp;
    lcpu_t         *data=NULL;


    arg = snmp_scalar_instance(incoming, object, searchType);

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_lcpu_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_busyPer
      case I_busyPer:
	dp = &data->busyPer;
	break;
#endif				       /* I_busyPer */

#ifdef I_avgBusy1
      case I_avgBusy1:
	dp = &data->avgBusy1;
	break;
#endif				       /* I_avgBusy1 */

#ifdef I_avgBusy5
      case I_avgBusy5:
	dp = &data->avgBusy5;
	break;
#endif				       /* I_avgBusy5 */

#ifdef I_idleCount
      case I_idleCount:
	dp = &data->idleCount;
	break;
#endif				       /* I_idleCount */

#ifdef I_idleWired
      case I_idleWired:
	dp = &data->idleWired;
	break;
#endif				       /* I_idleWired */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the lcpu data object.
 *---------------------------------------------------------------------*/
void
lcpu_free(lcpu_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after lcpu set/undo
 *---------------------------------------------------------------------*/
static int
lcpu_cleanup(doList_t *trash)
{
    lcpu_free(trash->data);
#ifdef SR_SNMPv2
    lcpu_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
lcpu_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int             found;
    /*int             carry = 0;
    lcpu_t         *lcpu;*/

    /*
     * Validate the object instance: 1) It must be of length 1  2) and the
     * instance must be 0.
     */
    if (instLength != 1 || incoming->oid_ptr[incoming->length - 1] != 0) {
	return (NO_CREATION_ERROR);
    }
    found = 0;

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(lcpu_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(lcpu_t));

	dp->setMethod = lcpu_set;
	dp->cleanupMethod = lcpu_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

    }
    switch (object->nominator) {

#ifdef I_idleCount
      case I_idleCount:

	SET_VALID(I_idleCount, ((lcpu_t *) (dp->data))->valid);

	((lcpu_t *) (dp->data))->idleCount = value->sl_value;
	break;
#endif				       /* I_idleCount */

#ifdef I_idleWired
      case I_idleWired:

	SET_VALID(I_idleWired, ((lcpu_t *) (dp->data))->valid);

	((lcpu_t *) (dp->data))->idleWired = value->sl_value;
	break;
#endif				       /* I_idleWired */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in lcpu_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
lcpu_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_lcpu_set((lcpu_t *) (doCur->data),
		       contextInfo, doCur->state));
}

#endif				       /* SETS */


lcpu_t         *
k_lcpu_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator)
{
    static lcpu_t   lcpuData;

    lcpuData.busyPer = last_busy_percent;
    lcpuData.avgBusy1 = avg_busy1_percent;
    lcpuData.avgBusy5 = avg_busy5_percent;
    lcpuData.idleCount = idle_count;
    lcpuData.idleWired = idle_count_wired;

    return (&lcpuData);
}

#ifdef SETS
int
k_lcpu_set(
    lcpu_t         *data,
    ContextInfo    *contextInfo,
    int             function)
{
    
    if (VALID(I_idleCount, data->valid)) {
	idle_count = data->idleCount;
    }
    if (VALID(I_idleWired, data->valid)) {
	idle_count_wired = data->idleWired;
    }
    return (NO_ERROR);
}

#endif				       /* SETS */

      
