/* $Id: sr_old_lifmib.c,v 3.7.12.6 1996/07/01 18:46:09 hampton Exp $
 * $Source: /release/112/cvs/Xsys/snmp/sr_old_lifmib.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * April 1994, Kenny Roberts (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1996-1997 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_old_lifmib.c,v $
 * Revision 3.7.12.6  1996/07/01  18:46:09  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.7.12.5  1996/05/21  10:02:32  thille
 * CSCdi51599:  multiple /interface/ literals bloat code.
 * Branch: California_branch
 * Save another 392 bytes by doing away with duplicate literals.
 *
 * Revision 3.7.12.4  1996/05/21  06:38:50  mordock
 * Branch: California_branch
 * Improve snmp modularity via creating services to register interfaces
 * and chassis cards.
 * Add syslog mib.
 *
 * Revision 3.7.12.3  1996/04/19  17:46:42  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.7.12.2  1996/04/04  05:35:35  mordock
 * CSCdi51613:  incorrect locIfReason in linkUp trap
 * Branch: California_branch
 * avoid consulting mib cache if request serialNum == -1, else cache might
 * be used when it really shouldn't be.
 *
 * Revision 3.7.12.1  1996/03/18  21:48:45  gstovall
 * Branch: California_branch
 * Elvis has left the building.  He headed out to California, and took the
 * port ready changes with him.
 *
 * Revision 3.6.12.4  1996/03/16  07:30:24  gstovall
 * Branch: DeadKingOnAThrone_branch
 * Make the king aware of V111_1_3.
 *
 * Revision 3.6.12.3  1996/03/13  01:59:54  dstine
 * Branch: DeadKingOnAThrone_branch
 *         - commit IDB cleanups
 *
 * Revision 3.6.12.2  1996/03/07  12:33:49  mdb
 * Branch: DeadKingOnAThrone_branch
 * cisco and ANSI/POSIX libraries.
 *
 * Revision 3.6.12.1  1996/02/20  17:14:42  dstine
 * Branch: DeadKingOnAThrone_branch
 *           Sync from DeadKingOnAThrone_baseline_960122 to
 *                     DeadKingOnAThrone_baseline_960213
 *
 * Revision 3.7  1996/02/15  22:08:28  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.6  1995/12/23  03:11:27  thille
 * CSCdi45961:  snmp agent lex-next failure in lifTable when LEX is present
 * The old local interfaces mib needs to understand iabs and skip them.
 *
 * Revision 3.5  1995/12/20  23:46:32  gstovall
 * CSCdi45909:  Item->handled field tested while uninitialized
 * Make sure that item->handled is initialized.  Bad programmer, no pizza.
 *
 * Revision 3.4  1995/12/14  08:27:36  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.3  1995/11/17  19:00:18  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.2  1995/11/17  00:28:20  gstovall
 * Ladies and gentlemen, I introduce to you, the port ready commit.
 *
 * Revision 3.1  1995/11/09  13:17:26  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.3  1995/11/08  21:25:57  shaker
 * Merge Arkansas_branch into 11.1 mainline.
 *
 * Revision 2.2  1995/07/17  07:34:02  bchan
 * CSCdi34760:  Ifindex usage incorrect
 *
 * Revision 2.1  1995/06/07  22:49:54  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include "../ui/common_strings.h"
#include <ciscolib.h>
#include "interface_private.h"
#include "../if/network.h"

#include "../snmp/snmp_api.h"
#include "sr_old_lifmib.h"
#include "sr_old_lifmib-mib.h"
#include "sr_ifmibsupp.h"
#include "snmp_interface.h"
#include "../snmp/ifmibapi.h"
#include "../if/ether.h"
#include "../util/itemlist.h"



void
init_old_lifmib(void)
{
    load_mib(old_lifmib_OidList, old_lifmib_OidListNum);
    load_oid(old_lifmib_oid_table);
}


/*---------------------------------------------------------------------
 * Retrieve data from the lifEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
lifEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    lifEntry_t     *data=NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            ifIndex;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &ifIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_lifEntry_get(serialNum, contextInfo, arg, searchType, ifIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->ifIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_locIfHardType
      case I_locIfHardType:
	dp = MakeOctetString(data->locIfHardType->octet_ptr, data->locIfHardType->length);
	break;
#endif				       /* I_locIfHardType */

#ifdef I_locIfLineProt
      case I_locIfLineProt:
	dp = &data->locIfLineProt;
	break;
#endif				       /* I_locIfLineProt */

#ifdef I_locIfLastIn
      case I_locIfLastIn:
	dp = &data->locIfLastIn;
	break;
#endif				       /* I_locIfLastIn */

#ifdef I_locIfLastOut
      case I_locIfLastOut:
	dp = &data->locIfLastOut;
	break;
#endif				       /* I_locIfLastOut */

#ifdef I_locIfLastOutHang
      case I_locIfLastOutHang:
	dp = &data->locIfLastOutHang;
	break;
#endif				       /* I_locIfLastOutHang */

#ifdef I_locIfInBitsSec
      case I_locIfInBitsSec:
	dp = &data->locIfInBitsSec;
	break;
#endif				       /* I_locIfInBitsSec */

#ifdef I_locIfInPktsSec
      case I_locIfInPktsSec:
	dp = &data->locIfInPktsSec;
	break;
#endif				       /* I_locIfInPktsSec */

#ifdef I_locIfOutBitsSec
      case I_locIfOutBitsSec:
	dp = &data->locIfOutBitsSec;
	break;
#endif				       /* I_locIfOutBitsSec */

#ifdef I_locIfOutPktsSec
      case I_locIfOutPktsSec:
	dp = &data->locIfOutPktsSec;
	break;
#endif				       /* I_locIfOutPktsSec */

#ifdef I_locIfInRunts
      case I_locIfInRunts:
	dp = &data->locIfInRunts;
	break;
#endif				       /* I_locIfInRunts */

#ifdef I_locIfInGiants
      case I_locIfInGiants:
	dp = &data->locIfInGiants;
	break;
#endif				       /* I_locIfInGiants */

#ifdef I_locIfInCRC
      case I_locIfInCRC:
	dp = &data->locIfInCRC;
	break;
#endif				       /* I_locIfInCRC */

#ifdef I_locIfInFrame
      case I_locIfInFrame:
	dp = &data->locIfInFrame;
	break;
#endif				       /* I_locIfInFrame */

#ifdef I_locIfInOverrun
      case I_locIfInOverrun:
	dp = &data->locIfInOverrun;
	break;
#endif				       /* I_locIfInOverrun */

#ifdef I_locIfInIgnored
      case I_locIfInIgnored:
	dp = &data->locIfInIgnored;
	break;
#endif				       /* I_locIfInIgnored */

#ifdef I_locIfInAbort
      case I_locIfInAbort:
	dp = &data->locIfInAbort;
	break;
#endif				       /* I_locIfInAbort */

#ifdef I_locIfResets
      case I_locIfResets:
	dp = &data->locIfResets;
	break;
#endif				       /* I_locIfResets */

#ifdef I_locIfRestarts
      case I_locIfRestarts:
	dp = &data->locIfRestarts;
	break;
#endif				       /* I_locIfRestarts */

#ifdef I_locIfKeep
      case I_locIfKeep:
	dp = &data->locIfKeep;
	break;
#endif				       /* I_locIfKeep */

#ifdef I_locIfReason
      case I_locIfReason:
	dp = MakeOctetString(data->locIfReason->octet_ptr, data->locIfReason->length);
	break;
#endif				       /* I_locIfReason */

#ifdef I_locIfCarTrans
      case I_locIfCarTrans:
	dp = &data->locIfCarTrans;
	break;
#endif				       /* I_locIfCarTrans */

#ifdef I_locIfReliab
      case I_locIfReliab:
	dp = &data->locIfReliab;
	break;
#endif				       /* I_locIfReliab */

#ifdef I_locIfDelay
      case I_locIfDelay:
	dp = &data->locIfDelay;
	break;
#endif				       /* I_locIfDelay */

#ifdef I_locIfLoad
      case I_locIfLoad:
	dp = &data->locIfLoad;
	break;
#endif				       /* I_locIfLoad */

#ifdef I_locIfCollisions
      case I_locIfCollisions:
	dp = &data->locIfCollisions;
	break;
#endif				       /* I_locIfCollisions */

#ifdef I_locIfInputQueueDrops
      case I_locIfInputQueueDrops:
	dp = &data->locIfInputQueueDrops;
	break;
#endif				       /* I_locIfInputQueueDrops */

#ifdef I_locIfOutputQueueDrops
      case I_locIfOutputQueueDrops:
	dp = &data->locIfOutputQueueDrops;
	break;
#endif				       /* I_locIfOutputQueueDrops */

#ifdef I_locIfDescr
      case I_locIfDescr:
	dp = MakeOctetString(data->locIfDescr->octet_ptr, data->locIfDescr->length);
	break;
#endif				       /* I_locIfDescr */

#ifdef I_locIfSlowInPkts
      case I_locIfSlowInPkts:
	dp = &data->locIfSlowInPkts;
	break;
#endif				       /* I_locIfSlowInPkts */

#ifdef I_locIfSlowOutPkts
      case I_locIfSlowOutPkts:
	dp = &data->locIfSlowOutPkts;
	break;
#endif				       /* I_locIfSlowOutPkts */

#ifdef I_locIfSlowInOctets
      case I_locIfSlowInOctets:
	dp = &data->locIfSlowInOctets;
	break;
#endif				       /* I_locIfSlowInOctets */

#ifdef I_locIfSlowOutOctets
      case I_locIfSlowOutOctets:
	dp = &data->locIfSlowOutOctets;
	break;
#endif				       /* I_locIfSlowOutOctets */

#ifdef I_locIfFastInPkts
      case I_locIfFastInPkts:
	dp = &data->locIfFastInPkts;
	break;
#endif				       /* I_locIfFastInPkts */

#ifdef I_locIfFastOutPkts
      case I_locIfFastOutPkts:
	dp = &data->locIfFastOutPkts;
	break;
#endif				       /* I_locIfFastOutPkts */

#ifdef I_locIfFastInOctets
      case I_locIfFastInOctets:
	dp = &data->locIfFastInOctets;
	break;
#endif				       /* I_locIfFastInOctets */

#ifdef I_locIfFastOutOctets
      case I_locIfFastOutOctets:
	dp = &data->locIfFastOutOctets;
	break;
#endif				       /* I_locIfFastOutOctets */

#ifdef I_locIfotherInPkts
      case I_locIfotherInPkts:
	dp = &data->locIfotherInPkts;
	break;
#endif				       /* I_locIfotherInPkts */

#ifdef I_locIfotherOutPkts
      case I_locIfotherOutPkts:
	dp = &data->locIfotherOutPkts;
	break;
#endif				       /* I_locIfotherOutPkts */

#ifdef I_locIfotherInOctets
      case I_locIfotherInOctets:
	dp = &data->locIfotherInOctets;
	break;
#endif				       /* I_locIfotherInOctets */

#ifdef I_locIfotherOutOctets
      case I_locIfotherOutOctets:
	dp = &data->locIfotherOutOctets;
	break;
#endif				       /* I_locIfotherOutOctets */

#ifdef I_locIfipInPkts
      case I_locIfipInPkts:
	dp = &data->locIfipInPkts;
	break;
#endif				       /* I_locIfipInPkts */

#ifdef I_locIfipOutPkts
      case I_locIfipOutPkts:
	dp = &data->locIfipOutPkts;
	break;
#endif				       /* I_locIfipOutPkts */

#ifdef I_locIfipInOctets
      case I_locIfipInOctets:
	dp = &data->locIfipInOctets;
	break;
#endif				       /* I_locIfipInOctets */

#ifdef I_locIfipOutOctets
      case I_locIfipOutOctets:
	dp = &data->locIfipOutOctets;
	break;
#endif				       /* I_locIfipOutOctets */

#ifdef I_locIfdecnetInPkts
      case I_locIfdecnetInPkts:
	dp = &data->locIfdecnetInPkts;
	break;
#endif				       /* I_locIfdecnetInPkts */

#ifdef I_locIfdecnetOutPkts
      case I_locIfdecnetOutPkts:
	dp = &data->locIfdecnetOutPkts;
	break;
#endif				       /* I_locIfdecnetOutPkts */

#ifdef I_locIfdecnetInOctets
      case I_locIfdecnetInOctets:
	dp = &data->locIfdecnetInOctets;
	break;
#endif				       /* I_locIfdecnetInOctets */

#ifdef I_locIfdecnetOutOctets
      case I_locIfdecnetOutOctets:
	dp = &data->locIfdecnetOutOctets;
	break;
#endif				       /* I_locIfdecnetOutOctets */

#ifdef I_locIfxnsInPkts
      case I_locIfxnsInPkts:
	dp = &data->locIfxnsInPkts;
	break;
#endif				       /* I_locIfxnsInPkts */

#ifdef I_locIfxnsOutPkts
      case I_locIfxnsOutPkts:
	dp = &data->locIfxnsOutPkts;
	break;
#endif				       /* I_locIfxnsOutPkts */

#ifdef I_locIfxnsInOctets
      case I_locIfxnsInOctets:
	dp = &data->locIfxnsInOctets;
	break;
#endif				       /* I_locIfxnsInOctets */

#ifdef I_locIfxnsOutOctets
      case I_locIfxnsOutOctets:
	dp = &data->locIfxnsOutOctets;
	break;
#endif				       /* I_locIfxnsOutOctets */

#ifdef I_locIfclnsInPkts
      case I_locIfclnsInPkts:
	dp = &data->locIfclnsInPkts;
	break;
#endif				       /* I_locIfclnsInPkts */

#ifdef I_locIfclnsOutPkts
      case I_locIfclnsOutPkts:
	dp = &data->locIfclnsOutPkts;
	break;
#endif				       /* I_locIfclnsOutPkts */

#ifdef I_locIfclnsInOctets
      case I_locIfclnsInOctets:
	dp = &data->locIfclnsInOctets;
	break;
#endif				       /* I_locIfclnsInOctets */

#ifdef I_locIfclnsOutOctets
      case I_locIfclnsOutOctets:
	dp = &data->locIfclnsOutOctets;
	break;
#endif				       /* I_locIfclnsOutOctets */

#ifdef I_locIfappletalkInPkts
      case I_locIfappletalkInPkts:
	dp = &data->locIfappletalkInPkts;
	break;
#endif				       /* I_locIfappletalkInPkts */

#ifdef I_locIfappletalkOutPkts
      case I_locIfappletalkOutPkts:
	dp = &data->locIfappletalkOutPkts;
	break;
#endif				       /* I_locIfappletalkOutPkts */

#ifdef I_locIfappletalkInOctets
      case I_locIfappletalkInOctets:
	dp = &data->locIfappletalkInOctets;
	break;
#endif				       /* I_locIfappletalkInOctets */

#ifdef I_locIfappletalkOutOctets
      case I_locIfappletalkOutOctets:
	dp = &data->locIfappletalkOutOctets;
	break;
#endif				       /* I_locIfappletalkOutOctets */

#ifdef I_locIfnovellInPkts
      case I_locIfnovellInPkts:
	dp = &data->locIfnovellInPkts;
	break;
#endif				       /* I_locIfnovellInPkts */

#ifdef I_locIfnovellOutPkts
      case I_locIfnovellOutPkts:
	dp = &data->locIfnovellOutPkts;
	break;
#endif				       /* I_locIfnovellOutPkts */

#ifdef I_locIfnovellInOctets
      case I_locIfnovellInOctets:
	dp = &data->locIfnovellInOctets;
	break;
#endif				       /* I_locIfnovellInOctets */

#ifdef I_locIfnovellOutOctets
      case I_locIfnovellOutOctets:
	dp = &data->locIfnovellOutOctets;
	break;
#endif				       /* I_locIfnovellOutOctets */

#ifdef I_locIfapolloInPkts
      case I_locIfapolloInPkts:
	dp = &data->locIfapolloInPkts;
	break;
#endif				       /* I_locIfapolloInPkts */

#ifdef I_locIfapolloOutPkts
      case I_locIfapolloOutPkts:
	dp = &data->locIfapolloOutPkts;
	break;
#endif				       /* I_locIfapolloOutPkts */

#ifdef I_locIfapolloInOctets
      case I_locIfapolloInOctets:
	dp = &data->locIfapolloInOctets;
	break;
#endif				       /* I_locIfapolloInOctets */

#ifdef I_locIfapolloOutOctets
      case I_locIfapolloOutOctets:
	dp = &data->locIfapolloOutOctets;
	break;
#endif				       /* I_locIfapolloOutOctets */

#ifdef I_locIfvinesInPkts
      case I_locIfvinesInPkts:
	dp = &data->locIfvinesInPkts;
	break;
#endif				       /* I_locIfvinesInPkts */

#ifdef I_locIfvinesOutPkts
      case I_locIfvinesOutPkts:
	dp = &data->locIfvinesOutPkts;
	break;
#endif				       /* I_locIfvinesOutPkts */

#ifdef I_locIfvinesInOctets
      case I_locIfvinesInOctets:
	dp = &data->locIfvinesInOctets;
	break;
#endif				       /* I_locIfvinesInOctets */

#ifdef I_locIfvinesOutOctets
      case I_locIfvinesOutOctets:
	dp = &data->locIfvinesOutOctets;
	break;
#endif				       /* I_locIfvinesOutOctets */

#ifdef I_locIfbridgedInPkts
      case I_locIfbridgedInPkts:
	dp = &data->locIfbridgedInPkts;
	break;
#endif				       /* I_locIfbridgedInPkts */

#ifdef I_locIfbridgedOutPkts
      case I_locIfbridgedOutPkts:
	dp = &data->locIfbridgedOutPkts;
	break;
#endif				       /* I_locIfbridgedOutPkts */

#ifdef I_locIfbridgedInOctets
      case I_locIfbridgedInOctets:
	dp = &data->locIfbridgedInOctets;
	break;
#endif				       /* I_locIfbridgedInOctets */

#ifdef I_locIfbridgedOutOctets
      case I_locIfbridgedOutOctets:
	dp = &data->locIfbridgedOutOctets;
	break;
#endif				       /* I_locIfbridgedOutOctets */

#ifdef I_locIfsrbInPkts
      case I_locIfsrbInPkts:
	dp = &data->locIfsrbInPkts;
	break;
#endif				       /* I_locIfsrbInPkts */

#ifdef I_locIfsrbOutPkts
      case I_locIfsrbOutPkts:
	dp = &data->locIfsrbOutPkts;
	break;
#endif				       /* I_locIfsrbOutPkts */

#ifdef I_locIfsrbInOctets
      case I_locIfsrbInOctets:
	dp = &data->locIfsrbInOctets;
	break;
#endif				       /* I_locIfsrbInOctets */

#ifdef I_locIfsrbOutOctets
      case I_locIfsrbOutOctets:
	dp = &data->locIfsrbOutOctets;
	break;
#endif				       /* I_locIfsrbOutOctets */

#ifdef I_locIfchaosInPkts
      case I_locIfchaosInPkts:
	dp = &data->locIfchaosInPkts;
	break;
#endif				       /* I_locIfchaosInPkts */

#ifdef I_locIfchaosOutPkts
      case I_locIfchaosOutPkts:
	dp = &data->locIfchaosOutPkts;
	break;
#endif				       /* I_locIfchaosOutPkts */

#ifdef I_locIfchaosInOctets
      case I_locIfchaosInOctets:
	dp = &data->locIfchaosInOctets;
	break;
#endif				       /* I_locIfchaosInOctets */

#ifdef I_locIfchaosOutOctets
      case I_locIfchaosOutOctets:
	dp = &data->locIfchaosOutOctets;
	break;
#endif				       /* I_locIfchaosOutOctets */

#ifdef I_locIfpupInPkts
      case I_locIfpupInPkts:
	dp = &data->locIfpupInPkts;
	break;
#endif				       /* I_locIfpupInPkts */

#ifdef I_locIfpupOutPkts
      case I_locIfpupOutPkts:
	dp = &data->locIfpupOutPkts;
	break;
#endif				       /* I_locIfpupOutPkts */

#ifdef I_locIfpupInOctets
      case I_locIfpupInOctets:
	dp = &data->locIfpupInOctets;
	break;
#endif				       /* I_locIfpupInOctets */

#ifdef I_locIfpupOutOctets
      case I_locIfpupOutOctets:
	dp = &data->locIfpupOutOctets;
	break;
#endif				       /* I_locIfpupOutOctets */

#ifdef I_locIfmopInPkts
      case I_locIfmopInPkts:
	dp = &data->locIfmopInPkts;
	break;
#endif				       /* I_locIfmopInPkts */

#ifdef I_locIfmopOutPkts
      case I_locIfmopOutPkts:
	dp = &data->locIfmopOutPkts;
	break;
#endif				       /* I_locIfmopOutPkts */

#ifdef I_locIfmopInOctets
      case I_locIfmopInOctets:
	dp = &data->locIfmopInOctets;
	break;
#endif				       /* I_locIfmopInOctets */

#ifdef I_locIfmopOutOctets
      case I_locIfmopOutOctets:
	dp = &data->locIfmopOutOctets;
	break;
#endif				       /* I_locIfmopOutOctets */

#ifdef I_locIflanmanInPkts
      case I_locIflanmanInPkts:
	dp = &data->locIflanmanInPkts;
	break;
#endif				       /* I_locIflanmanInPkts */

#ifdef I_locIflanmanOutPkts
      case I_locIflanmanOutPkts:
	dp = &data->locIflanmanOutPkts;
	break;
#endif				       /* I_locIflanmanOutPkts */

#ifdef I_locIflanmanInOctets
      case I_locIflanmanInOctets:
	dp = &data->locIflanmanInOctets;
	break;
#endif				       /* I_locIflanmanInOctets */

#ifdef I_locIflanmanOutOctets
      case I_locIflanmanOutOctets:
	dp = &data->locIflanmanOutOctets;
	break;
#endif				       /* I_locIflanmanOutOctets */

#ifdef I_locIfstunInPkts
      case I_locIfstunInPkts:
	dp = &data->locIfstunInPkts;
	break;
#endif				       /* I_locIfstunInPkts */

#ifdef I_locIfstunOutPkts
      case I_locIfstunOutPkts:
	dp = &data->locIfstunOutPkts;
	break;
#endif				       /* I_locIfstunOutPkts */

#ifdef I_locIfstunInOctets
      case I_locIfstunInOctets:
	dp = &data->locIfstunInOctets;
	break;
#endif				       /* I_locIfstunInOctets */

#ifdef I_locIfstunOutOctets
      case I_locIfstunOutOctets:
	dp = &data->locIfstunOutOctets;
	break;
#endif				       /* I_locIfstunOutOctets */

#ifdef I_locIfspanInPkts
      case I_locIfspanInPkts:
	dp = &data->locIfspanInPkts;
	break;
#endif				       /* I_locIfspanInPkts */

#ifdef I_locIfspanOutPkts
      case I_locIfspanOutPkts:
	dp = &data->locIfspanOutPkts;
	break;
#endif				       /* I_locIfspanOutPkts */

#ifdef I_locIfspanInOctets
      case I_locIfspanInOctets:
	dp = &data->locIfspanInOctets;
	break;
#endif				       /* I_locIfspanInOctets */

#ifdef I_locIfspanOutOctets
      case I_locIfspanOutOctets:
	dp = &data->locIfspanOutOctets;
	break;
#endif				       /* I_locIfspanOutOctets */

#ifdef I_locIfarpInPkts
      case I_locIfarpInPkts:
	dp = &data->locIfarpInPkts;
	break;
#endif				       /* I_locIfarpInPkts */

#ifdef I_locIfarpOutPkts
      case I_locIfarpOutPkts:
	dp = &data->locIfarpOutPkts;
	break;
#endif				       /* I_locIfarpOutPkts */

#ifdef I_locIfarpInOctets
      case I_locIfarpInOctets:
	dp = &data->locIfarpInOctets;
	break;
#endif				       /* I_locIfarpInOctets */

#ifdef I_locIfarpOutOctets
      case I_locIfarpOutOctets:
	dp = &data->locIfarpOutOctets;
	break;
#endif				       /* I_locIfarpOutOctets */

#ifdef I_locIfprobeInPkts
      case I_locIfprobeInPkts:
	dp = &data->locIfprobeInPkts;
	break;
#endif				       /* I_locIfprobeInPkts */

#ifdef I_locIfprobeOutPkts
      case I_locIfprobeOutPkts:
	dp = &data->locIfprobeOutPkts;
	break;
#endif				       /* I_locIfprobeOutPkts */

#ifdef I_locIfprobeInOctets
      case I_locIfprobeInOctets:
	dp = &data->locIfprobeInOctets;
	break;
#endif				       /* I_locIfprobeInOctets */

#ifdef I_locIfprobeOutOctets
      case I_locIfprobeOutOctets:
	dp = &data->locIfprobeOutOctets;
	break;
#endif				       /* I_locIfprobeOutOctets */

#ifdef I_locIfDribbleInputs
      case I_locIfDribbleInputs:
	dp = &data->locIfDribbleInputs;
	break;
#endif				       /* I_locIfDribbleInputs */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the lifEntry data object.
 *---------------------------------------------------------------------*/
void
lifEntry_free(lifEntry_t *data)
{
    if (data != NULL) {
	if (data->locIfDescr != NULL) {
	    FreeOctetString(data->locIfDescr);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after lifEntry set/undo
 *---------------------------------------------------------------------*/
static int
lifEntry_cleanup(doList_t *trash)
{
    lifEntry_free(trash->data);
#ifdef SR_SNMPv2
    lifEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
lifEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    /*VarBind        *vb = (VarBind *) NULL;*/
    int             found;
    int             carry = 0;
    lifEntry_t     *lifEntry;
    long            ifIndex;

    /*
     * Validate the object instance
     * 
     */
    if (instLength != 1) {
	return NO_CREATION_ERROR;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &ifIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    lifEntry = k_lifEntry_get(-1, contextInfo, object->nominator, EXACT, ifIndex);

#ifndef lifEntry_READ_CREATE

    if (lifEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* lifEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == lifEntry_set) &&
	    (((lifEntry_t *) (dp->data)) != NULL) &&
	    (((lifEntry_t *) (dp->data))->ifIndex == ifIndex)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(lifEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(lifEntry_t));

	dp->setMethod = lifEntry_set;
	dp->cleanupMethod = lifEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_ifIndex, ((lifEntry_t *) (dp->data))->valid);
	((lifEntry_t *) (dp->data))->ifIndex = ifIndex;

#ifdef lifEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (lifEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, lifEntry, sizeof(lifEntry_t));

	    SET_ALL_VALID(((lifEntry_t *) (dp->data))->valid);

	    ((lifEntry_t *) (dp->data))->locIfDescr =
		CloneOctetString(lifEntry->locIfDescr);

	} else {


	    /* Fill in default values here */


	}
#endif				       /* lifEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_locIfDescr
      case I_locIfDescr:

	if (value->os_value->length > SYSSIZE) {
	    return (WRONG_LENGTH_ERROR);
	}
	if (!IsDisplayString(value->os_value)) {
	    return (WRONG_VALUE_ERROR);
	}

	SET_VALID(I_locIfDescr, ((lifEntry_t *) (dp->data))->valid);

	if (((lifEntry_t *) (dp->data))->locIfDescr != NULL) {
	    FreeOctetString(((lifEntry_t *) (dp->data))->locIfDescr);
	}
	((lifEntry_t *) (dp->data))->locIfDescr =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_locIfDescr */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in lifEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
lifEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_lifEntry_set((lifEntry_t *) (doCur->data),
			   contextInfo, doCur->state));
}

#endif				       /* SETS */



/*
 **********************************************************************
 *
 * KERNEL CODE begins here.  Above is all generated by SNMP Research
 * compiler.  Below code does the real work in getting the router
 * information.  
 *
 * First come the utility helper routines.
 *
 **********************************************************************
 */

static boolean idb_tester (hwidbtype *idb, long* index2)
{
    return(TRUE);
}


static void update_lifentry_from_hwidb(snmpidbtype *snmpidb, 
				       hwidbtype *hwidb, 
				       lifEntry_t *lifEntryPtr)
{
    static OctetString locIfHardType;
    static OctetString locIfReason;
    static OctetString locIfDescr;

    lifEntryPtr->ifIndex = snmpidb->snmp_if_index;

    lifEntryPtr->locIfHardType = &locIfHardType;
    lifEntryPtr->locIfHardType->octet_ptr = hwidb->typestring;
    lifEntryPtr->locIfHardType->length = strlen(hwidb->typestring);

    lifEntryPtr->locIfLineProt = hw_interface_up(hwidb);
    lifEntryPtr->locIfLastIn = ELAPSED_TIME(hwidb->lastinput);
    lifEntryPtr->locIfLastOut = ELAPSED_TIME(hwidb->lastoutput);
    lifEntryPtr->locIfLastOutHang = ELAPSED_TIME(hwidb->lastreset);
    lifEntryPtr->locIfInBitsSec = hwidb->counters.rx_datarate*1000;
    lifEntryPtr->locIfInPktsSec = hwidb->counters.rx_packetrate;
    lifEntryPtr->locIfOutBitsSec = hwidb->counters.tx_datarate*1000;
    lifEntryPtr->locIfOutPktsSec = hwidb->counters.tx_packetrate;
    lifEntryPtr->locIfInRunts = hwidb->counters.runts;
    lifEntryPtr->locIfInGiants = hwidb->counters.giants;
    lifEntryPtr->locIfInCRC = hwidb->counters.input_crc;
    lifEntryPtr->locIfInFrame = hwidb->counters.input_frame;
    lifEntryPtr->locIfInOverrun = hwidb->counters.input_overrun;
    lifEntryPtr->locIfInIgnored = hwidb->counters.input_resource;
    lifEntryPtr->locIfInAbort = hwidb->counters.input_abort;
    lifEntryPtr->locIfResets = hwidb->counters.resets;

    /* All the multibus cards that needed restarts have been retired */
    lifEntryPtr->locIfRestarts = 0;                  /* no more restarts */

    lifEntryPtr->locIfKeep = !hwidb->nokeepalive;

    lifEntryPtr->locIfReason = &locIfReason;
    lifEntryPtr->locIfReason->octet_ptr = hwidb->reason;
    lifEntryPtr->locIfReason->length = strlen(hwidb->reason);

    lifEntryPtr->locIfCarTrans = hwidb->counters.transitions;
    lifEntryPtr->locIfReliab = hwidb->reliability;
    lifEntryPtr->locIfDelay = hwidb->firstsw->delay * 10;
    lifEntryPtr->locIfLoad = hwidb->load;

    lifEntryPtr->locIfCollisions = hwidb->counters.output_collision;

    if (hwidb->status & IDB_ETHER) {
	N_ITEM_LIST(tmp, 3);

	item_desc_init(&tmp_item[0], ETHER_HW_OUTPUT_ONE_COLLISION,
		       sizeof(ulong));

	item_desc_init(&tmp_item[1], ETHER_HW_OUTPUT_MORE_COLLISION,
		       sizeof(ulong));
	
	item_desc_init(&tmp_item[2], ETHER_HW_OUTPUT_EXCESSIVE_COLLISION,
		       sizeof(ulong));

	(*hwidb->state_config)(hwidb, IDB_CONTROL_READ_STATE, &tmp_list);

	lifEntryPtr->locIfCollisions += tmp_item[0].u.l_value + /* one_coll */
	    tmp_item[1].u.l_value +                             /* more_coll */
		(tmp_item[2].u.l_value * 16);                 /* excess_coll */
    }

    lifEntryPtr->locIfInputQueueDrops = hwidb->counters.input_drops;
    lifEntryPtr->locIfOutputQueueDrops = hwidb->counters.output_total_drops;

    lifEntryPtr->locIfDescr = &locIfDescr;
    lifEntryPtr->locIfDescr->octet_ptr = hwidb->firstsw->description;
    lifEntryPtr->locIfDescr->length = strlen(hwidb->firstsw->description);

    lifEntryPtr->locIfSlowInPkts = hwidb->counters.inputs;
    lifEntryPtr->locIfSlowOutPkts = hwidb->counters.outputs;
    lifEntryPtr->locIfSlowInOctets = hwidb->counters.rx_cumbytes;
    lifEntryPtr->locIfSlowOutOctets = hwidb->counters.tx_cumbytes;
    lifEntryPtr->locIfFastInPkts = idb_fast_in(hwidb) + idb_auto_in(hwidb);
    lifEntryPtr->locIfFastOutPkts = idb_fast_out(hwidb) + idb_auto_out(hwidb);
    lifEntryPtr->locIfFastInOctets = idb_rx_fast_cumbytes(hwidb) +
	idb_rx_auto_cumbytes(hwidb);
    lifEntryPtr->locIfFastOutOctets = idb_tx_fast_cumbytes(hwidb) +
	idb_tx_auto_cumbytes(hwidb);
    lifEntryPtr->locIfotherInPkts = hwidb->counters.rx_frames[ACCT_PROTO_OTHER]+
	hwidb->counters.inputs_fast[ACCT_PROTO_OTHER]+
	hwidb->counters.inputs_auto[ACCT_PROTO_OTHER];
    lifEntryPtr->locIfotherOutPkts = hwidb->counters.tx_frames[ACCT_PROTO_OTHER]+
	hwidb->counters.outputs_fast[ACCT_PROTO_OTHER]+
	hwidb->counters.outputs_auto[ACCT_PROTO_OTHER];
    lifEntryPtr->locIfotherInOctets = hwidb->counters.rx_bytes[ACCT_PROTO_OTHER]+
	hwidb->counters.rx_cumbytes_fast[ACCT_PROTO_OTHER]+
	hwidb->counters.rx_cumbytes_auto[ACCT_PROTO_OTHER];
    lifEntryPtr->locIfotherOutOctets = hwidb->counters.tx_bytes[ACCT_PROTO_OTHER]+
	hwidb->counters.tx_cumbytes_fast[ACCT_PROTO_OTHER]+
	hwidb->counters.tx_cumbytes_auto[ACCT_PROTO_OTHER];
    lifEntryPtr->locIfipInPkts = hwidb->counters.rx_frames[ACCT_PROTO_IP]+
	hwidb->counters.inputs_fast[ACCT_PROTO_IP]+
	hwidb->counters.inputs_auto[ACCT_PROTO_IP];
    lifEntryPtr->locIfipOutPkts = hwidb->counters.tx_frames[ACCT_PROTO_IP]+
	hwidb->counters.outputs_fast[ACCT_PROTO_IP]+
	hwidb->counters.outputs_auto[ACCT_PROTO_IP];
    lifEntryPtr->locIfipInOctets = hwidb->counters.rx_bytes[ACCT_PROTO_IP]+
	hwidb->counters.rx_cumbytes_fast[ACCT_PROTO_IP]+
	hwidb->counters.rx_cumbytes_auto[ACCT_PROTO_IP];
    lifEntryPtr->locIfipOutOctets = hwidb->counters.tx_bytes[ACCT_PROTO_IP]+
	hwidb->counters.tx_cumbytes_fast[ACCT_PROTO_IP]+
	hwidb->counters.tx_cumbytes_auto[ACCT_PROTO_IP];
    lifEntryPtr->locIfdecnetInPkts = hwidb->counters.rx_frames[ACCT_PROTO_DECNET]+
	hwidb->counters.inputs_fast[ACCT_PROTO_DECNET]+
	hwidb->counters.inputs_auto[ACCT_PROTO_DECNET];
    lifEntryPtr->locIfdecnetOutPkts = hwidb->counters.tx_frames[ACCT_PROTO_DECNET]+
	hwidb->counters.outputs_fast[ACCT_PROTO_DECNET]+
	hwidb->counters.outputs_auto[ACCT_PROTO_DECNET];
    lifEntryPtr->locIfdecnetInOctets = hwidb->counters.rx_bytes[ACCT_PROTO_DECNET]+
	hwidb->counters.rx_cumbytes_fast[ACCT_PROTO_DECNET]+
	hwidb->counters.rx_cumbytes_auto[ACCT_PROTO_DECNET];
    lifEntryPtr->locIfdecnetOutOctets = hwidb->counters.tx_bytes[ACCT_PROTO_DECNET]+
	hwidb->counters.tx_cumbytes_fast[ACCT_PROTO_DECNET]+
	hwidb->counters.tx_cumbytes_auto[ACCT_PROTO_DECNET];
    lifEntryPtr->locIfxnsInPkts = hwidb->counters.rx_frames[ACCT_PROTO_XNS]+
	hwidb->counters.inputs_fast[ACCT_PROTO_XNS]+
	hwidb->counters.inputs_auto[ACCT_PROTO_XNS];
    lifEntryPtr->locIfxnsOutPkts = hwidb->counters.tx_frames[ACCT_PROTO_XNS]+
	hwidb->counters.outputs_fast[ACCT_PROTO_XNS]+
	hwidb->counters.outputs_auto[ACCT_PROTO_XNS];
    lifEntryPtr->locIfxnsInOctets = hwidb->counters.rx_bytes[ACCT_PROTO_XNS]+
	hwidb->counters.rx_cumbytes_fast[ACCT_PROTO_XNS]+
	hwidb->counters.rx_cumbytes_auto[ACCT_PROTO_XNS];
    lifEntryPtr->locIfxnsOutOctets = hwidb->counters.tx_bytes[ACCT_PROTO_XNS]+
	hwidb->counters.tx_cumbytes_fast[ACCT_PROTO_XNS]+
	hwidb->counters.tx_cumbytes_auto[ACCT_PROTO_XNS];
    lifEntryPtr->locIfclnsInPkts = hwidb->counters.rx_frames[ACCT_PROTO_CLNS]+
	hwidb->counters.inputs_fast[ACCT_PROTO_CLNS]+
	hwidb->counters.inputs_auto[ACCT_PROTO_CLNS];
    lifEntryPtr->locIfclnsOutPkts = hwidb->counters.tx_frames[ACCT_PROTO_CLNS]+
	hwidb->counters.outputs_fast[ACCT_PROTO_CLNS]+
	hwidb->counters.outputs_auto[ACCT_PROTO_CLNS];
    lifEntryPtr->locIfclnsInOctets = hwidb->counters.rx_bytes[ACCT_PROTO_CLNS]+
	hwidb->counters.rx_cumbytes_fast[ACCT_PROTO_CLNS]+
	hwidb->counters.rx_cumbytes_auto[ACCT_PROTO_CLNS];
    lifEntryPtr->locIfclnsOutOctets = hwidb->counters.tx_bytes[ACCT_PROTO_CLNS]+
	hwidb->counters.tx_cumbytes_fast[ACCT_PROTO_CLNS]+
	hwidb->counters.tx_cumbytes_auto[ACCT_PROTO_CLNS];
    lifEntryPtr->locIfappletalkInPkts = hwidb->counters.rx_frames[ACCT_PROTO_APPLE]+
	hwidb->counters.inputs_fast[ACCT_PROTO_APPLE]+
	hwidb->counters.inputs_auto[ACCT_PROTO_APPLE];
    lifEntryPtr->locIfappletalkOutPkts = hwidb->counters.tx_frames[ACCT_PROTO_APPLE]+
	hwidb->counters.outputs_fast[ACCT_PROTO_APPLE]+
	hwidb->counters.outputs_auto[ACCT_PROTO_APPLE];
    lifEntryPtr->locIfappletalkInOctets = hwidb->counters.rx_bytes[ACCT_PROTO_APPLE]+
	hwidb->counters.rx_cumbytes_fast[ACCT_PROTO_APPLE]+
	hwidb->counters.rx_cumbytes_auto[ACCT_PROTO_APPLE];
    lifEntryPtr->locIfappletalkOutOctets = hwidb->counters.tx_bytes[ACCT_PROTO_APPLE]+
	hwidb->counters.tx_cumbytes_fast[ACCT_PROTO_APPLE]+
	hwidb->counters.tx_cumbytes_auto[ACCT_PROTO_APPLE];
    lifEntryPtr->locIfnovellInPkts = hwidb->counters.rx_frames[ACCT_PROTO_NOVELL]+
	hwidb->counters.inputs_fast[ACCT_PROTO_NOVELL]+
	hwidb->counters.inputs_auto[ACCT_PROTO_NOVELL];
    lifEntryPtr->locIfnovellOutPkts = hwidb->counters.tx_frames[ACCT_PROTO_NOVELL]+
	hwidb->counters.outputs_fast[ACCT_PROTO_NOVELL]+
	hwidb->counters.outputs_auto[ACCT_PROTO_NOVELL];
    lifEntryPtr->locIfnovellInOctets = hwidb->counters.rx_bytes[ACCT_PROTO_NOVELL]+
	hwidb->counters.rx_cumbytes_fast[ACCT_PROTO_NOVELL]+
	hwidb->counters.rx_cumbytes_auto[ACCT_PROTO_NOVELL];
    lifEntryPtr->locIfnovellOutOctets = hwidb->counters.tx_bytes[ACCT_PROTO_NOVELL]+
	hwidb->counters.tx_cumbytes_fast[ACCT_PROTO_NOVELL]+
	hwidb->counters.tx_cumbytes_auto[ACCT_PROTO_NOVELL];
    lifEntryPtr->locIfapolloInPkts = hwidb->counters.rx_frames[ACCT_PROTO_APOLLO]+
	hwidb->counters.inputs_fast[ACCT_PROTO_APOLLO]+
	hwidb->counters.inputs_auto[ACCT_PROTO_APOLLO];
    lifEntryPtr->locIfapolloOutPkts = hwidb->counters.tx_frames[ACCT_PROTO_APOLLO]+
	hwidb->counters.outputs_fast[ACCT_PROTO_APOLLO]+
	hwidb->counters.outputs_auto[ACCT_PROTO_APOLLO];
    lifEntryPtr->locIfapolloInOctets = hwidb->counters.rx_bytes[ACCT_PROTO_APOLLO]+
	hwidb->counters.rx_cumbytes_fast[ACCT_PROTO_APOLLO]+
	hwidb->counters.rx_cumbytes_auto[ACCT_PROTO_APOLLO];
    lifEntryPtr->locIfapolloOutOctets = hwidb->counters.tx_bytes[ACCT_PROTO_APOLLO]+
	hwidb->counters.tx_cumbytes_fast[ACCT_PROTO_APOLLO]+
	hwidb->counters.tx_cumbytes_auto[ACCT_PROTO_APOLLO];
    lifEntryPtr->locIfvinesInPkts = hwidb->counters.rx_frames[ACCT_PROTO_VINES]+
	hwidb->counters.inputs_fast[ACCT_PROTO_VINES]+
	hwidb->counters.inputs_auto[ACCT_PROTO_VINES];
    lifEntryPtr->locIfvinesOutPkts = hwidb->counters.tx_frames[ACCT_PROTO_VINES]+
	hwidb->counters.outputs_fast[ACCT_PROTO_VINES]+
	hwidb->counters.outputs_auto[ACCT_PROTO_VINES];
    lifEntryPtr->locIfvinesInOctets = hwidb->counters.rx_bytes[ACCT_PROTO_VINES]+
	hwidb->counters.rx_cumbytes_fast[ACCT_PROTO_VINES]+
	hwidb->counters.rx_cumbytes_auto[ACCT_PROTO_VINES];
    lifEntryPtr->locIfvinesOutOctets = hwidb->counters.tx_bytes[ACCT_PROTO_VINES]+
	hwidb->counters.tx_cumbytes_fast[ACCT_PROTO_VINES]+
	hwidb->counters.tx_cumbytes_auto[ACCT_PROTO_VINES];
    lifEntryPtr->locIfbridgedInPkts = hwidb->counters.rx_frames[ACCT_PROTO_BRIDGE]+
	hwidb->counters.inputs_fast[ACCT_PROTO_BRIDGE]+
	hwidb->counters.inputs_auto[ACCT_PROTO_BRIDGE];
    lifEntryPtr->locIfbridgedOutPkts = hwidb->counters.tx_frames[ACCT_PROTO_BRIDGE]+
	hwidb->counters.outputs_fast[ACCT_PROTO_BRIDGE]+
	hwidb->counters.outputs_auto[ACCT_PROTO_BRIDGE];
    lifEntryPtr->locIfbridgedInOctets = hwidb->counters.rx_bytes[ACCT_PROTO_BRIDGE]+
	hwidb->counters.rx_cumbytes_fast[ACCT_PROTO_BRIDGE]+
	hwidb->counters.rx_cumbytes_auto[ACCT_PROTO_BRIDGE];
    lifEntryPtr->locIfbridgedOutOctets = hwidb->counters.tx_bytes[ACCT_PROTO_BRIDGE]+
	hwidb->counters.tx_cumbytes_fast[ACCT_PROTO_BRIDGE]+
	hwidb->counters.tx_cumbytes_auto[ACCT_PROTO_BRIDGE];
    lifEntryPtr->locIfsrbInPkts = hwidb->counters.rx_frames[ACCT_PROTO_SRB]+
	hwidb->counters.inputs_fast[ACCT_PROTO_SRB]+
	hwidb->counters.inputs_auto[ACCT_PROTO_SRB];
    lifEntryPtr->locIfsrbOutPkts = hwidb->counters.tx_frames[ACCT_PROTO_SRB]+
	hwidb->counters.outputs_fast[ACCT_PROTO_SRB]+
	hwidb->counters.outputs_auto[ACCT_PROTO_SRB];
    lifEntryPtr->locIfsrbInOctets = hwidb->counters.rx_bytes[ACCT_PROTO_SRB]+
	hwidb->counters.rx_cumbytes_fast[ACCT_PROTO_SRB]+
	hwidb->counters.rx_cumbytes_auto[ACCT_PROTO_SRB];
    lifEntryPtr->locIfsrbOutOctets = hwidb->counters.tx_bytes[ACCT_PROTO_SRB]+
	hwidb->counters.tx_cumbytes_fast[ACCT_PROTO_SRB]+
	hwidb->counters.tx_cumbytes_auto[ACCT_PROTO_SRB];

    /* Chaos and Pup are no longer supported */
    lifEntryPtr->locIfchaosInPkts = 0;		/* no longer supported */
    lifEntryPtr->locIfchaosOutPkts = 0;		/* no longer supported */
    lifEntryPtr->locIfchaosInOctets = 0;	/* no longer supported */
    lifEntryPtr->locIfchaosOutOctets = 0;	/* no longer supported */
    lifEntryPtr->locIfpupInPkts = 0;            /* no longer supported */
    lifEntryPtr->locIfpupOutPkts = 0;           /* no longer supported */
    lifEntryPtr->locIfpupInOctets = 0;          /* no longer supported */
    lifEntryPtr->locIfpupOutOctets = 0;         /* no longer supported */

    lifEntryPtr->locIfmopInPkts = hwidb->counters.rx_frames[ACCT_PROTO_MOP]+
	hwidb->counters.inputs_fast[ACCT_PROTO_MOP]+
	hwidb->counters.inputs_auto[ACCT_PROTO_MOP];
    lifEntryPtr->locIfmopOutPkts = hwidb->counters.tx_frames[ACCT_PROTO_MOP]+
	hwidb->counters.outputs_fast[ACCT_PROTO_MOP]+
	hwidb->counters.outputs_auto[ACCT_PROTO_MOP];
    lifEntryPtr->locIfmopInOctets = hwidb->counters.rx_bytes[ACCT_PROTO_MOP]+
	hwidb->counters.rx_cumbytes_fast[ACCT_PROTO_MOP]+
	hwidb->counters.rx_cumbytes_auto[ACCT_PROTO_MOP];
    lifEntryPtr->locIfmopOutOctets = hwidb->counters.tx_bytes[ACCT_PROTO_MOP]+
	hwidb->counters.tx_cumbytes_fast[ACCT_PROTO_MOP]+
	hwidb->counters.tx_cumbytes_auto[ACCT_PROTO_MOP];
    lifEntryPtr->locIflanmanInPkts = hwidb->counters.rx_frames[ACCT_PROTO_LANMAN]+
	hwidb->counters.inputs_fast[ACCT_PROTO_LANMAN]+
	hwidb->counters.inputs_auto[ACCT_PROTO_LANMAN];
    lifEntryPtr->locIflanmanOutPkts = hwidb->counters.tx_frames[ACCT_PROTO_LANMAN]+
	hwidb->counters.outputs_fast[ACCT_PROTO_LANMAN]+
	hwidb->counters.outputs_auto[ACCT_PROTO_LANMAN];
    lifEntryPtr->locIflanmanInOctets = hwidb->counters.rx_bytes[ACCT_PROTO_LANMAN]+
	hwidb->counters.rx_cumbytes_fast[ACCT_PROTO_LANMAN]+
	hwidb->counters.rx_cumbytes_auto[ACCT_PROTO_LANMAN];
    lifEntryPtr->locIflanmanOutOctets = hwidb->counters.tx_bytes[ACCT_PROTO_LANMAN]+
	hwidb->counters.tx_cumbytes_auto[ACCT_PROTO_LANMAN]+
	hwidb->counters.tx_cumbytes_fast[ACCT_PROTO_LANMAN];
    lifEntryPtr->locIfstunInPkts = hwidb->counters.rx_frames[ACCT_PROTO_STUN]+
	hwidb->counters.inputs_fast[ACCT_PROTO_STUN]+
	hwidb->counters.inputs_auto[ACCT_PROTO_STUN];
    lifEntryPtr->locIfstunOutPkts = hwidb->counters.tx_frames[ACCT_PROTO_STUN]+
	hwidb->counters.outputs_auto[ACCT_PROTO_STUN]+
	hwidb->counters.outputs_fast[ACCT_PROTO_STUN];
    lifEntryPtr->locIfstunInOctets = hwidb->counters.rx_bytes[ACCT_PROTO_STUN]+
	hwidb->counters.rx_cumbytes_fast[ACCT_PROTO_STUN]+
	hwidb->counters.rx_cumbytes_auto[ACCT_PROTO_STUN];
    lifEntryPtr->locIfstunOutOctets = hwidb->counters.tx_bytes[ACCT_PROTO_STUN]+
	hwidb->counters.tx_cumbytes_fast[ACCT_PROTO_STUN]+
	hwidb->counters.tx_cumbytes_auto[ACCT_PROTO_STUN];
    lifEntryPtr->locIfspanInPkts = hwidb->counters.rx_frames[ACCT_PROTO_SPAN]+
	hwidb->counters.inputs_fast[ACCT_PROTO_SPAN]+
	hwidb->counters.inputs_auto[ACCT_PROTO_SPAN];
    lifEntryPtr->locIfspanOutPkts = hwidb->counters.tx_frames[ACCT_PROTO_SPAN]+
	hwidb->counters.outputs_fast[ACCT_PROTO_SPAN]+
	hwidb->counters.outputs_auto[ACCT_PROTO_SPAN];
    lifEntryPtr->locIfspanInOctets = hwidb->counters.rx_bytes[ACCT_PROTO_SPAN]+
	hwidb->counters.rx_cumbytes_fast[ACCT_PROTO_SPAN]+
	hwidb->counters.rx_cumbytes_auto[ACCT_PROTO_SPAN];
    lifEntryPtr->locIfspanOutOctets = hwidb->counters.tx_bytes[ACCT_PROTO_SPAN]+
	hwidb->counters.tx_cumbytes_fast[ACCT_PROTO_SPAN]+
	hwidb->counters.tx_cumbytes_auto[ACCT_PROTO_SPAN];
    lifEntryPtr->locIfarpInPkts = hwidb->counters.rx_frames[ACCT_PROTO_ARP]+
	hwidb->counters.inputs_fast[ACCT_PROTO_ARP]+
	hwidb->counters.inputs_auto[ACCT_PROTO_ARP];
    lifEntryPtr->locIfarpOutPkts = hwidb->counters.tx_frames[ACCT_PROTO_ARP]+
	hwidb->counters.outputs_fast[ACCT_PROTO_ARP]+
	hwidb->counters.outputs_auto[ACCT_PROTO_ARP];
    lifEntryPtr->locIfarpInOctets = hwidb->counters.rx_bytes[ACCT_PROTO_ARP]+
	hwidb->counters.rx_cumbytes_fast[ACCT_PROTO_ARP]+
	hwidb->counters.rx_cumbytes_auto[ACCT_PROTO_ARP];
    lifEntryPtr->locIfarpOutOctets = hwidb->counters.tx_bytes[ACCT_PROTO_ARP]+
	hwidb->counters.tx_cumbytes_fast[ACCT_PROTO_ARP]+
	hwidb->counters.tx_cumbytes_auto[ACCT_PROTO_ARP];
    lifEntryPtr->locIfprobeInPkts = hwidb->counters.rx_frames[ACCT_PROTO_PROBE]+
	hwidb->counters.inputs_fast[ACCT_PROTO_PROBE]+
	hwidb->counters.inputs_auto[ACCT_PROTO_PROBE];
    lifEntryPtr->locIfprobeOutPkts = hwidb->counters.tx_frames[ACCT_PROTO_PROBE]+
	hwidb->counters.outputs_fast[ACCT_PROTO_PROBE]+
	hwidb->counters.outputs_auto[ACCT_PROTO_PROBE];
    lifEntryPtr->locIfprobeInOctets = hwidb->counters.rx_bytes[ACCT_PROTO_PROBE]+
	hwidb->counters.rx_cumbytes_fast[ACCT_PROTO_PROBE]+
	hwidb->counters.rx_cumbytes_auto[ACCT_PROTO_PROBE];
    lifEntryPtr->locIfprobeOutOctets = hwidb->counters.tx_bytes[ACCT_PROTO_PROBE]+
	hwidb->counters.tx_cumbytes_fast[ACCT_PROTO_PROBE]+
	hwidb->counters.tx_cumbytes_auto[ACCT_PROTO_PROBE];
    lifEntryPtr->locIfDribbleInputs = hwidb->counters.input_dribble;
}

lifEntry_t     *
k_lifEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            ifIndex)
{
    static snmpidbtype *snmpidb = NULL;
    static hwidbtype *hwidb = NULL;
    static int lastserial = MAXINT;
    static int lastifIndex = MAXINT;
      static lifEntry_t lifEntryData;
  
    /*
     * Don't leave dangling data pointers.
     */
    if (snmpidb == NULL) {
	hwidb = NULL;
    } else {
	if (snmpidb->snmp_if_struct != SNMP_IF_HWIDB) {
	    hwidb = NULL;
	}
    }
  
    /*
     * See if we got a cache hit.
     */
    if ((serialNum != -1) && (serialNum == lastserial) &&
	(lastifIndex == ifIndex)) {
	/* hit cache */
	if (snmpidb) {
	    switch (snmpidb->snmp_if_struct) {
	      case SNMP_IF_HWIDB:
		if (hwidb) {
		    return(&lifEntryData);
		} else {
		    return(NULL);
		}
		break;
	      default:
		return(NULL);
	    }
	} else
	    return(NULL);
    }
  
    /* missed cache, store info for next cache hit */
    lastserial = serialNum;
    lastifIndex = ifIndex;

    /*
     * For now, only hardware idbs are supported in the lifTable.  This
     * may change, but don't hold your breath.
     */
    snmpidb = ifmib_snmpidb_get_by_type(NULL,serialNum, searchType, ifIndex,
					SNMP_IF_HWIDB, NULL, NULL);
    if (snmpidb == NULL)
	  return (NULL);

    switch (snmpidb->snmp_if_struct) {
      case SNMP_IF_HWIDB:
	hwidb = snmpidb->snmp_if_ptr.ifptr.hwidb;
	if (hwidb == NULL) {
	    return(NULL);
	}
	update_lifentry_from_hwidb(snmpidb, hwidb, &lifEntryData);
	break;
  
      default:
	return(NULL);
    } /* switch (snmpidb->snmp_if_struct) */
  
    return (&lifEntryData);
}

#ifdef SETS
int
k_lifEntry_set(
    lifEntry_t     *data,
    ContextInfo    *contextInfo,
    int             function)
{
    register hwidbtype *idb;
    int len;
    char *temp;

    idb = ifmib_hwidb_get(-1, EXACT, data->ifIndex,
			  idb_tester, NULL);
    if (idb==NULL)
	return (GEN_ERROR);

    if (VALID(I_locIfDescr, data->valid)) {
	len = data->locIfDescr->length;
	if (len == 0)
	    temp = NULL;
	else {
	    temp = malloc(len + 1);
	    if (temp == NULL)
		return (GEN_ERROR);
	    bcopy(data->locIfDescr->octet_ptr, temp, len);
	    temp[len] = '\0';
	}
	setstring(&idb->firstsw->description, temp);
    }

    return (NO_ERROR);
}

#endif				       /* SETS */

      
