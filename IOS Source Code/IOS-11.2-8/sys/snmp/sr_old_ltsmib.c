/* $Id: sr_old_ltsmib.c,v 3.8.4.5 1996/08/28 13:10:04 thille Exp $
 * $Source: /release/112/cvs/Xsys/snmp/sr_old_ltsmib.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * March 1994, Kenny Roberts (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1994-1997 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_old_ltsmib.c,v $
 * Revision 3.8.4.5  1996/08/28  13:10:04  thille
 * CSCdi67083: Message externs need a cleanup.
 * Branch: California_branch
 * Get rid of all extern msgsym()s in .c files, rework logger.h and
 * msg_foo.c files so they are included and provide the externs.  Clean up
 * other random externs in .c files.
 *
 * Revision 3.8.4.4  1996/07/03  20:43:38  thille
 * CSCdi61860: Implement Jeffs glass of slim-fast for snmp
 * Branch: California_branch
 * Take hunk of common code from many mib files, make it a procedure in
 * snmp_util.c and call it from the mibs.  Save 1640 bytes.
 *
 * Revision 3.8.4.3  1996/07/01  18:46:15  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.8.4.2  1996/04/19  17:46:46  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.8.4.1  1996/03/18  21:48:50  gstovall
 * Branch: California_branch
 * Elvis has left the building.  He headed out to California, and took the
 * port ready changes with him.
 *
 * Revision 3.6.2.2  1996/03/16  07:30:32  gstovall
 * Branch: DeadKingOnAThrone_branch
 * Make the king aware of V111_1_3.
 *
 * Revision 3.6.2.1  1996/03/07  12:33:55  mdb
 * Branch: DeadKingOnAThrone_branch
 * cisco and ANSI/POSIX libraries.
 *
 * Revision 3.8  1996/03/07  12:09:58  billw
 * CSCdi46565:  <uses> in  <show line> doesnt include PPP, Xremote, etc
 *
 * Revision 3.7  1996/02/21  18:08:38  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.6  1996/01/18  16:37:56  jjohnson
 * CSCdi45754:  snmp subsystem should not contain non-snmp mibs
 * move the rs232 mib, image mib, and terminal services mib into separate
 * subsystems.  move the cisco interfaces mib into the interfaces mib
 * subsystem.  consolidate the snmp timer subsystem into the snmp
 * subsystem since it really is core snmp technology.
 *
 * Revision 3.5  1995/12/14  08:27:39  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.4  1995/11/24  16:41:15  jjohnson
 * CSCdi42637:  platform-specific code should be moved out of sub_snmp
 * Install an API for accessing platform-specific SNMP objects
 *
 * Revision 3.3  1995/11/17  19:00:32  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.2  1995/11/17  00:28:25  gstovall
 * Ladies and gentlemen, I introduce to you, the port ready commit.
 *
 * Revision 3.1  1995/11/09  13:17:35  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.7  1995/11/08  21:26:02  shaker
 * Merge Arkansas_branch into 11.1 mainline.
 *
 * Revision 2.6  1995/08/25  11:45:01  hampton
 * Miscellaneous changes to eliminate direct references to the system
 * clock and to convert to always using the timer macros to access timers.
 * [CSCdi39258]
 *
 * Revision 2.5  1995/07/14 07:03:06  hampton
 * Convert Terminal Server to fully use the passive timers macros instead
 * of referencing the system clock directly.  [CSCdi37093]
 *
 * Revision 2.4  1995/07/12 23:45:21  hampton
 * Convert TCP to fully use the passive timers macros instead of
 * referencing the system clock directly.  [CSCdi37015]
 *
 * Revision 2.3  1995/06/14 19:22:54  vandys
 * CSCdi35265:  Should use intfc description if no line description
 * Don't reference tty->location directly; pass tt_soc to a
 * function, let it take from either tt_soc or IDB.
 *
 * Revision 2.2  1995/06/09  13:18:55  hampton
 * Rename old scheduler calls to fit the new naming convention.
 * [CSCdi35514]
 *
 * Revision 2.1  1995/06/07 22:50:08  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include <ciscolib.h>
#include "subsys.h"
#include "snmp_api.h"
#include "sr_sysmib2.h"
#include "sr_old_ltsmib.h"
#include "sr_old_ltsmib-mib.h"
#include "sr_old_lsysmib.h"
#include "ttysrv.h"
#include "connect.h"
#include "logger.h"
#include "aaa.h"

#include "logger.h"			/* for errmsg */
#include "../os/msg_system.c"		/* Not a typo, see logger.h */
#include "sys_registry.h"		/* for reload */
#include "../ui/command.h"		/* for terminate_line */
#include "../parser/parser_defs_snmp.h"
#include "../os/hostname.h"


struct message_data
{
    int ttyline;
    int repeat_interval;
    int duration;
    int oncompletion;
    int temp_banner_flag;
    char *text;
};
struct message_data m;

#define TSMSG_DURATION_MIN    10000
#define TSMSG_INTERVAL_MIN    10000

static void generate_reload_trap(void);
static conntype * snmp_get_conntype(int searchType, long *line, long *session);
static tt_soc *snmp_get_tty (int searchtype, long *linein);
static process netmessage(void);
pid_t netmessage_pid;

char *message_text;
int message_ttyline;
uint message_inttime;
uint message_duration;
uint message_tempbanner;
uchar current_message_state;
long ts_last_cleared_line;

static const char reload_trap_oid[] = "cisco.0.0";

static void init_old_ltsmib (subsystype *subsys)
{
    message_text = NULL;
    setstring(&message_text, "Null Message");
    message_ttyline = -1;
    message_inttime = 0;
    message_duration = 0;
    message_tempbanner = D_tsMsgTmpBanner_no;
    current_message_state = D_tsMsgSend_messagedone;
    ts_last_cleared_line = -1;
    reg_add_will_reload(generate_reload_trap, "generate_reload_trap");

    load_mib(old_ltsmib_OidList, old_ltsmib_OidListNum);
    load_oid(old_ltsmib_oid_table);
    register_snmp_trap(TRAP_SNMP, reload_trap_oid);
}

/*---------------------------------------------------------------------
 * Retrieve data from the lts family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
lts_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             arg;
    void           *dp;
    lts_t          *data = NULL;


    arg = snmp_scalar_instance(incoming, object, searchType);

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_lts_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_tsLines
      case I_tsLines:
	dp = &data->tsLines;
	break;
#endif				       /* I_tsLines */

#ifdef I_tsMsgTtyLine
      case I_tsMsgTtyLine:
	dp = &data->tsMsgTtyLine;
	break;
#endif				       /* I_tsMsgTtyLine */

#ifdef I_tsMsgIntervaltim
      case I_tsMsgIntervaltim:
	dp = &data->tsMsgIntervaltim;
	break;
#endif				       /* I_tsMsgIntervaltim */

#ifdef I_tsMsgDuration
      case I_tsMsgDuration:
	dp = &data->tsMsgDuration;
	break;
#endif				       /* I_tsMsgDuration */

#ifdef I_tsMsgText
      case I_tsMsgText:
	dp = MakeOctetString(data->tsMsgText->octet_ptr, data->tsMsgText->length);
	break;
#endif				       /* I_tsMsgText */

#ifdef I_tsMsgTmpBanner
      case I_tsMsgTmpBanner:
	dp = &data->tsMsgTmpBanner;
	break;
#endif				       /* I_tsMsgTmpBanner */

#ifdef I_tsMsgSend
      case I_tsMsgSend:
	dp = &data->tsMsgSend;
	break;
#endif				       /* I_tsMsgSend */

#ifdef I_tsClrTtyLine
      case I_tsClrTtyLine:
	dp = &data->tsClrTtyLine;
	break;
#endif				       /* I_tsClrTtyLine */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the lts data object.
 *---------------------------------------------------------------------*/
void
lts_free(lts_t          *data)
{
    if (data != NULL) {
	if (data->tsMsgText != NULL) {
	    FreeOctetString(data->tsMsgText);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after lts set/undo
 *---------------------------------------------------------------------*/
static int
lts_cleanup(doList_t       *trash)
{
    lts_free(trash->data);
#ifdef SR_SNMPv2
    lts_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
lts_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    /*VarBind        *vb = (VarBind *) NULL;*/
    int             found;
    /*int             carry = 0;*/
    /*lts_t          *lts;*/

    /*
     * Validate the object instance: 1) It must be of length 1  2) and the
     * instance must be 0.
     */
    if (instLength != 1 || incoming->oid_ptr[incoming->length - 1] != 0) {
	return (NO_CREATION_ERROR);
    }
    found = 0;

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(lts_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(lts_t));

	dp->setMethod = lts_set;
	dp->cleanupMethod = lts_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

    }
    switch (object->nominator) {

#ifdef I_tsMsgTtyLine
      case I_tsMsgTtyLine:

	SET_VALID(I_tsMsgTtyLine, ((lts_t *) (dp->data))->valid);

	((lts_t *) (dp->data))->tsMsgTtyLine = value->sl_value;
	break;
#endif				       /* I_tsMsgTtyLine */

#ifdef I_tsMsgIntervaltim
      case I_tsMsgIntervaltim:

	SET_VALID(I_tsMsgIntervaltim, ((lts_t *) (dp->data))->valid);

	((lts_t *) (dp->data))->tsMsgIntervaltim = value->sl_value;
	break;
#endif				       /* I_tsMsgIntervaltim */

#ifdef I_tsMsgDuration
      case I_tsMsgDuration:

	SET_VALID(I_tsMsgDuration, ((lts_t *) (dp->data))->valid);

	((lts_t *) (dp->data))->tsMsgDuration = value->sl_value;
	break;
#endif				       /* I_tsMsgDuration */

#ifdef I_tsMsgText
      case I_tsMsgText:

        if (value->os_value->length > SYSSIZE) {
            return (WRONG_LENGTH_ERROR);
        }

        if (!IsDisplayString(value->os_value)) {
            return (WRONG_VALUE_ERROR);
        }

	SET_VALID(I_tsMsgText, ((lts_t *) (dp->data))->valid);

	if (((lts_t *) (dp->data))->tsMsgText != NULL) {
	    FreeOctetString(((lts_t *) (dp->data))->tsMsgText);
	}
	((lts_t *) (dp->data))->tsMsgText =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_tsMsgText */

#ifdef I_tsMsgTmpBanner
      case I_tsMsgTmpBanner:

	if ((value->sl_value != D_tsMsgTmpBanner_no) &&
	    (value->sl_value != D_tsMsgTmpBanner_additive))
	    return(WRONG_VALUE_ERROR);

	SET_VALID(I_tsMsgTmpBanner, ((lts_t *) (dp->data))->valid);

	((lts_t *) (dp->data))->tsMsgTmpBanner = value->sl_value;
	break;
#endif				       /* I_tsMsgTmpBanner */

#ifdef I_tsMsgSend
      case I_tsMsgSend:

	if ((value->sl_value != D_tsMsgSend_nothing) &&
	    (value->sl_value != D_tsMsgSend_reload) &&
	    (value->sl_value != D_tsMsgSend_messagedone) &&
	    (value->sl_value != D_tsMsgSend_abort))
	    return(WRONG_VALUE_ERROR);

	if ((value->sl_value == D_tsMsgSend_reload) && (!snmp_shutdown)) {
	    errmsg(&msgsym(RELOAD_ATTEMPT, SYS));
	    return(WRONG_VALUE_ERROR);
	}

	SET_VALID(I_tsMsgSend, ((lts_t *) (dp->data))->valid);

	((lts_t *) (dp->data))->tsMsgSend = value->sl_value;
	break;
#endif				       /* I_tsMsgSend */

#ifdef I_tsClrTtyLine
      case I_tsClrTtyLine:

	if ((value->sl_value < 0) || (value->sl_value >= ALLlines))
	    return(WRONG_VALUE_ERROR);

	SET_VALID(I_tsClrTtyLine, ((lts_t *) (dp->data))->valid);

	((lts_t *) (dp->data))->tsClrTtyLine = value->sl_value;
	break;
#endif				       /* I_tsClrTtyLine */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in lts_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
lts_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_lts_set((lts_t *) (doCur->data),
		      contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the ltsLineEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ltsLineEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ltsLineEntry_t *data=NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            tsLineNumber;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &tsLineNumber, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ltsLineEntry_get(serialNum, contextInfo, arg, searchType, tsLineNumber)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->tsLineNumber;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_tsLineActive
      case I_tsLineActive:
	dp = &data->tsLineActive;
	break;
#endif				       /* I_tsLineActive */

#ifdef I_tsLineType
      case I_tsLineType:
	dp = &data->tsLineType;
	break;
#endif				       /* I_tsLineType */

#ifdef I_tsLineAutobaud
      case I_tsLineAutobaud:
	dp = &data->tsLineAutobaud;
	break;
#endif				       /* I_tsLineAutobaud */

#ifdef I_tsLineSpeedin
      case I_tsLineSpeedin:
	dp = &data->tsLineSpeedin;
	break;
#endif				       /* I_tsLineSpeedin */

#ifdef I_tsLineSpeedout
      case I_tsLineSpeedout:
	dp = &data->tsLineSpeedout;
	break;
#endif				       /* I_tsLineSpeedout */

#ifdef I_tsLineFlow
      case I_tsLineFlow:
	dp = &data->tsLineFlow;
	break;
#endif				       /* I_tsLineFlow */

#ifdef I_tsLineModem
      case I_tsLineModem:
	dp = &data->tsLineModem;
	break;
#endif				       /* I_tsLineModem */

#ifdef I_tsLineLoc
      case I_tsLineLoc:
	dp = MakeOctetString(data->tsLineLoc->octet_ptr, data->tsLineLoc->length);
	break;
#endif				       /* I_tsLineLoc */

#ifdef I_tsLineTerm
      case I_tsLineTerm:
	dp = MakeOctetString(data->tsLineTerm->octet_ptr, data->tsLineTerm->length);
	break;
#endif				       /* I_tsLineTerm */

#ifdef I_tsLineScrlen
      case I_tsLineScrlen:
	dp = &data->tsLineScrlen;
	break;
#endif				       /* I_tsLineScrlen */

#ifdef I_tsLineScrwid
      case I_tsLineScrwid:
	dp = &data->tsLineScrwid;
	break;
#endif				       /* I_tsLineScrwid */

#ifdef I_tsLineEsc
      case I_tsLineEsc:
	dp = MakeOctetString(data->tsLineEsc->octet_ptr, data->tsLineEsc->length);
	break;
#endif				       /* I_tsLineEsc */

#ifdef I_tsLineTmo
      case I_tsLineTmo:
	dp = &data->tsLineTmo;
	break;
#endif				       /* I_tsLineTmo */

#ifdef I_tsLineSestmo
      case I_tsLineSestmo:
	dp = &data->tsLineSestmo;
	break;
#endif				       /* I_tsLineSestmo */

#ifdef I_tsLineRotary
      case I_tsLineRotary:
	dp = &data->tsLineRotary;
	break;
#endif				       /* I_tsLineRotary */

#ifdef I_tsLineUses
      case I_tsLineUses:
	dp = &data->tsLineUses;
	break;
#endif				       /* I_tsLineUses */

#ifdef I_tsLineNses
      case I_tsLineNses:
	dp = &data->tsLineNses;
	break;
#endif				       /* I_tsLineNses */

#ifdef I_tsLineUser
      case I_tsLineUser:
	dp = MakeOctetString(data->tsLineUser->octet_ptr, data->tsLineUser->length);
	break;
#endif				       /* I_tsLineUser */

#ifdef I_tsLineNoise
      case I_tsLineNoise:
	dp = &data->tsLineNoise;
	break;
#endif				       /* I_tsLineNoise */

#ifdef I_tsLineNumber
      case I_tsLineNumber:
	dp = &data->tsLineNumber;
	break;
#endif				       /* I_tsLineNumber */

#ifdef I_tsLineTimeActive
      case I_tsLineTimeActive:
	dp = &data->tsLineTimeActive;
	break;
#endif				       /* I_tsLineTimeActive */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the ltsLineSessionEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ltsLineSessionEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ltsLineSessionEntry_t *data=NULL;
    unsigned long   buffer[2];
    OID             inst;
    int             carry;
    long            tslineSesLine;
    long            tslineSesSession;

 
    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 2
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 2) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 1 + object->oid.length, &tslineSesSession, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &tslineSesLine, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ltsLineSessionEntry_get(serialNum, contextInfo, arg, searchType, tslineSesLine, tslineSesSession)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 2;
	inst.oid_ptr[0] = data->tslineSesLine;
	inst.oid_ptr[1] = data->tslineSesSession;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_tslineSesType
      case I_tslineSesType:
	dp = &data->tslineSesType;
	break;
#endif				       /* I_tslineSesType */

#ifdef I_tslineSesDir
      case I_tslineSesDir:
	dp = &data->tslineSesDir;
	break;
#endif				       /* I_tslineSesDir */

#ifdef I_tslineSesAddr
      case I_tslineSesAddr:
	dp = IPToOctetString(data->tslineSesAddr);
	break;
#endif				       /* I_tslineSesAddr */

#ifdef I_tslineSesName
      case I_tslineSesName:
	dp = MakeOctetString(data->tslineSesName->octet_ptr, data->tslineSesName->length);
	break;
#endif				       /* I_tslineSesName */

#ifdef I_tslineSesCur
      case I_tslineSesCur:
	dp = &data->tslineSesCur;
	break;
#endif				       /* I_tslineSesCur */

#ifdef I_tslineSesIdle
      case I_tslineSesIdle:
	dp = &data->tslineSesIdle;
	break;
#endif				       /* I_tslineSesIdle */

#ifdef I_tslineSesLine
      case I_tslineSesLine:
	dp = &data->tslineSesLine;
	break;
#endif				       /* I_tslineSesLine */

#ifdef I_tslineSesSession
      case I_tslineSesSession:
	dp = &data->tslineSesSession;
	break;
#endif				       /* I_tslineSesSession */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}



/*
 **********************************************************************
 *
 * KERNEL CODE begins here.  Above is all generated by SNMP Research
 * compiler.  Below code does the real work in getting the router
 * information.  
 *
 **********************************************************************
 */

lts_t          *
k_lts_get(serialNum, contextInfo, nominator)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
{
    static OctetString tsMsgText;
    static lts_t    ltsData;

    ltsData.tsLines = ALLlines;
    ltsData.tsMsgTtyLine = message_ttyline;
    ltsData.tsMsgIntervaltim = message_inttime;
    ltsData.tsMsgDuration = message_duration;

    ltsData.tsMsgText = &tsMsgText;
    ltsData.tsMsgText->octet_ptr = (uchar *)message_text;
    ltsData.tsMsgText->length = strlen(message_text);

    ltsData.tsMsgTmpBanner = message_tempbanner;
    ltsData.tsMsgSend = D_tsMsgSend_messagedone;
    ltsData.tsClrTtyLine = ts_last_cleared_line;

    return (&ltsData);
}

#ifdef SETS
int
k_lts_set(
    lts_t          *data,
    ContextInfo    *contextInfo,
    int             function)
{
    tt_soc *tty;
    int len;
    char *temp;

    if (VALID(I_tsMsgTtyLine, data->valid)) { 
	message_ttyline = data->tsMsgTtyLine;
    }

    if (VALID(I_tsMsgIntervaltim, data->valid)) { 
	message_inttime = data->tsMsgIntervaltim;
    }

    if (VALID(I_tsMsgDuration, data->valid)) { 
	message_duration = data->tsMsgDuration;
    }

    if (VALID(I_tsMsgText, data->valid)) { 
	len = data->tsMsgText->length;
	if (len == 0) {
	    temp = NULL;
	} else {
	    temp = malloc (len + 1);
	    if (temp == NULL)
		return (GEN_ERROR);
	    bcopy(data->tsMsgText->octet_ptr, temp, len);
	    temp[len] = '\0';
	}
	setstring(&message_text, temp);
    }

    if (VALID(I_tsMsgTmpBanner, data->valid)) { 
	message_tempbanner = data->tsMsgTmpBanner;
    }

    if (VALID(I_tsMsgSend, data->valid)) { 
	switch (data->tsMsgSend) {
	case D_tsMsgSend_reload:   /* send message and reload box */
	    if (!snmp_shutdown) {
		errmsg(&msgsym(RELOAD_ATTEMPT, SYS));
		return(WRONG_VALUE_ERROR);
	    }
	case D_tsMsgSend_nothing:  /* just send the message */
	    if (current_message_state != D_tsMsgSend_messagedone) {
		errmsg(&msgsym(DUAL_MESSAGE, SYS), data->tsMsgSend);
		return(WRONG_VALUE_ERROR);
	    }
	    if ((message_ttyline >= -1) && (message_ttyline < ALLlines))
		m.ttyline = message_ttyline;
	    else
		m.ttyline = 0;
	    m.repeat_interval = (message_inttime < TSMSG_DURATION_MIN) ?
		0 : message_inttime;
	    m.duration = (message_duration < TSMSG_INTERVAL_MIN) ?
		0 : message_duration;
	    m.oncompletion =  data->tsMsgSend;
	    m.temp_banner_flag = message_tempbanner;
	    m.text = message_text;
	    current_message_state = data->tsMsgSend;
	    netmessage_pid = process_create(netmessage, "Net Message",
					    NORMAL_STACK, PRIO_NORMAL);
	    break;
	case D_tsMsgSend_messagedone:
	    break;
	case D_tsMsgSend_abort:
	    if ((current_message_state == D_tsMsgSend_nothing) ||
		(current_message_state == D_tsMsgSend_reload)) {
		current_message_state = D_tsMsgSend_abort;
		process_wakeup(netmessage_pid);
	    }
	    break;
	}
    }

    if (VALID(I_tsClrTtyLine, data->valid)) { 
	ts_last_cleared_line = data->tsClrTtyLine; /* Keep track of line # */
	tty = MODEMS[data->tsClrTtyLine];
	if (tty != NULL)
	    terminate_line(tty);
	return(NO_ERROR);
    }

    data->tsMsgSend = current_message_state;
    return (NO_ERROR);
}

#endif				       /* SETS */

ltsLineEntry_t *
k_ltsLineEntry_get(serialNum, contextInfo, nominator, searchType, tsLineNumber)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
    int             searchType;
    long            tsLineNumber;
{
    static ltsLineEntry_t ltsLineEntryData;
    static OctetString tsLineTerm, tsLineEsc, tsLineLoc, tsLineUser;
    tt_soc *tty;
    char *user;

    tty = snmp_get_tty(searchType, &tsLineNumber);
    if (tty == NULL)
	return (NULL);	

    ltsLineEntryData.tsLineActive = (tty->statbits & HASPROC) ? TRUE : FALSE;
    switch (tty->type) {
    case CTY_LINE:
	ltsLineEntryData.tsLineType = D_tsLineType_console;
	break;
    case TTY_LINE:
	ltsLineEntryData.tsLineType = D_tsLineType_terminal;
	break;
    case VTY_LINE:
	ltsLineEntryData.tsLineType = D_tsLineType_virtual_terminal;
	break;
    case AUX_LINE:
	ltsLineEntryData.tsLineType = D_tsLineType_auxiliary;
	break;
    default:
	ltsLineEntryData.tsLineType = D_tsLineType_unknown;
	break;
    }
    ltsLineEntryData.tsLineAutobaud = (tty->capabilities & AUTOBAUD) ? 
		TRUE : FALSE;
    ltsLineEntryData.tsLineSpeedin = tty->tty_rxspeed;
    ltsLineEntryData.tsLineSpeedout = tty->tty_txspeed;
    switch (tty->capabilities & (SFLOWIN|SFLOWOUT|HFLOWIN|HFLOWOUT)) {
    case 0:
	ltsLineEntryData.tsLineFlow = D_tsLineFlow_none;
	break;
    case SFLOWIN:
	ltsLineEntryData.tsLineFlow = D_tsLineFlow_software_input;
	break;
    case SFLOWOUT:
	ltsLineEntryData.tsLineFlow = D_tsLineFlow_software_output;
	break;
    case SFLOWIN|SFLOWOUT:
	ltsLineEntryData.tsLineFlow = D_tsLineFlow_software_both;
	break;
    case HFLOWIN:
	ltsLineEntryData.tsLineFlow = D_tsLineFlow_hardware_input;
	break;
    case HFLOWOUT:
	ltsLineEntryData.tsLineFlow = D_tsLineFlow_hardware_output;
	break;
    case HFLOWIN|HFLOWOUT:
	ltsLineEntryData.tsLineFlow = D_tsLineFlow_hardware_both;
	break;
    default:
	ltsLineEntryData.tsLineFlow = D_tsLineFlow_unknown;
	break;
    }

    switch (tty->capabilities & (MODEMIN|MODEMOUT|MODEMCTS|MODEMRI)) {
    case MODEMIN:
	ltsLineEntryData.tsLineModem = D_tsLineModem_call_in;
	break;
    case MODEMOUT:
	ltsLineEntryData.tsLineModem = D_tsLineModem_call_out;
	break;
    case MODEMCTS:
	ltsLineEntryData.tsLineModem = D_tsLineModem_cts_required;
	break;
    case MODEMRI:
	ltsLineEntryData.tsLineModem = D_tsLineModem_ri_is_cd;
	break;
    case MODEMRI|MODEMOUT:
	ltsLineEntryData.tsLineModem = D_tsLineModem_inout;
	break;
    default:
	ltsLineEntryData.tsLineModem = D_tsLineModem_none;
	break;
    }
    ltsLineEntryData.tsLineLoc = &tsLineLoc;
    ltsLineEntryData.tsLineLoc->octet_ptr = (uchar *)get_tty_location(tty);
    ltsLineEntryData.tsLineLoc->length =
	strlen((uchar *)get_tty_location(tty));

    ltsLineEntryData.tsLineTerm = &tsLineTerm;
    ltsLineEntryData.tsLineTerm->octet_ptr = (uchar *)tty->termtype;
    ltsLineEntryData.tsLineTerm->length = strlen((uchar *)tty->termtype);

    ltsLineEntryData.tsLineScrlen = tty->tty_length;
    ltsLineEntryData.tsLineScrwid = tty->tty_width;

    ltsLineEntryData.tsLineEsc = &tsLineEsc;
    if (tty->tty_escapechar == BREAK_CHAR) {
	ltsLineEntryData.tsLineEsc->octet_ptr = (uchar *)"BREAK";
	ltsLineEntryData.tsLineEsc->length = strlen("BREAK");
    } else if (tty->tty_escapechar < 0) {
	ltsLineEntryData.tsLineEsc->octet_ptr = NULL;
	ltsLineEntryData.tsLineEsc->length = 0;
    } else {
	ltsLineEntryData.tsLineEsc->octet_ptr = (uchar *)&tty->tty_escapechar
		 + 3;
	ltsLineEntryData.tsLineEsc->length = 1;
    }

    ltsLineEntryData.tsLineTmo = tty->tty_exectimeout / ONESEC;
    ltsLineEntryData.tsLineSestmo = tty->tty_sessiontimeout / ONESEC;
    ltsLineEntryData.tsLineRotary = tty->rotary;
    ltsLineEntryData.tsLineUses = tty->usagecount;
    ltsLineEntryData.tsLineNses = tty->nconns;

    ltsLineEntryData.tsLineUser = &tsLineUser;
    if (old_access_control) {
	ltsLineEntryData.tsLineUser->octet_ptr = (uchar *)tty->user;
	ltsLineEntryData.tsLineUser->length = strlen(tty->user);
    } else {
	if (!aaa_get_user_p(tty->ustruct, &user))
	    user = NULL;
	ltsLineEntryData.tsLineUser->octet_ptr = user;
	ltsLineEntryData.tsLineUser->length = strlen(user);
    }
    ltsLineEntryData.tsLineNoise = tty->linenoise;
    ltsLineEntryData.tsLineNumber = tsLineNumber;
    if (TIMER_RUNNING(tty->time_activated)) {
	ltsLineEntryData.tsLineTimeActive = 
	    (ELAPSED_TIME(tty->time_activated) / ONESEC);
    } else {
	ltsLineEntryData.tsLineTimeActive = 0;
    }

    return (&ltsLineEntryData);
}

ltsLineSessionEntry_t *
k_ltsLineSessionEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            tslineSesLine,
    long            tslineSesSession)
{
    static ltsLineSessionEntry_t ltsLineSessionEntryData;
    register conntype *con;
    static OctetString tslineSesName;
    tt_soc *tty;

    con = snmp_get_conntype(searchType, &tslineSesLine, &tslineSesSession);
    if (con == NULL)
	return (NULL);	

    tty = con->tty;

    ltsLineSessionEntryData.tslineSesType = con->snmp_sesstype;
    if (tty->xrcb)
	ltsLineSessionEntryData.tslineSesType = D_tslineSesType_xremote;
    else if (tty->statbits & SLIPMODE)
	ltsLineSessionEntryData.tslineSesType = D_tslineSesType_slip;

    if ((conntype *)con->tty->conntop == con)
	ltsLineSessionEntryData.tslineSesDir = D_tslineSesDir_incoming;
    else
	ltsLineSessionEntryData.tslineSesDir = D_tslineSesDir_outgoing;

    ltsLineSessionEntryData.tslineSesAddr =  0;
    if (con->address.ip_addr)
	ltsLineSessionEntryData.tslineSesAddr = con->address.ip_addr; 

    ltsLineSessionEntryData.tslineSesName = &tslineSesName;
    if (con->hostname[0]) {
	ltsLineSessionEntryData.tslineSesName->octet_ptr = 
		(uchar *)con->hostname;
	ltsLineSessionEntryData.tslineSesName->length = 
		sizeof((uchar *)con->hostname);
    } else {
	ltsLineSessionEntryData.tslineSesName->octet_ptr = NULL;
	ltsLineSessionEntryData.tslineSesName->length = 0;
    }

    ltsLineSessionEntryData.tslineSesCur = (con->status & CONN_CURRENT) ? 
	TRUE : FALSE;
    ltsLineSessionEntryData.tslineSesIdle =
	ELAPSED_TIME(con->idletime) / ONESEC; 
    ltsLineSessionEntryData.tslineSesLine = tslineSesLine;
    ltsLineSessionEntryData.tslineSesSession = tslineSesSession;

    return (&ltsLineSessionEntryData);
}


static conntype *
snmp_get_conntype (int searchType, long *line, long *session)
{
    conntype *q = NULL;
    long cline, csession;

    cline = *line;
    /* session number must be >= 1 */
    csession = (*session == 0)? 1 : *session; 

    while (cline < MAXLINES && MODEMS[cline] != NULL) {
	while (csession <= MODEMS[cline]->nconns + 1) {  /* for conntop */
	    if (MODEMS[cline]->conntop != NULL && csession == 1) {
		q = (conntype *)MODEMS[cline]->conntop;
		goto done;
	    }
	    q = (conntype *)MODEMS[cline]->connhead.qhead;

	    /*
	     * conntop->number can be 0 or 1 (if it exists).
	     * For the queue elements, q->number can be 1 or greater.
	     * We uniquely index the queue elements for a line
	     * based on the q->number. However, we also treat
	     * conntop (if it exists) as the first element of the queue.
	     * 
	     * The code fragment below:
	     * "csession-(MODEMS[cline]->conntop ? 1 : 0)"
	     * ensures that conntop is numbered 1 if it exists.
	     */
	    while (q) {
	        if (q->number == (csession - (MODEMS[cline]->conntop ? 1 : 0)))
		    goto done;
		if ((searchType == EXACT) &&
		    ((csession - (MODEMS[cline]->conntop ?1:0)) > q->number)) {
		    return(NULL);
		}
		q = q->link;
	    }
	    csession++;
	}
	cline++;
	if (searchType == EXACT) {
	    /* 
	     * for an EXACT search, if you increment cline,
	     * the element you were looking for doesnt exist 
	     */
	    return(NULL);
	}
	csession = 1;
    }
done:
    if (q != NULL) {
	if (searchType == EXACT) {
	    /* if this was a get did we get what we asked for? */
	    if (!((cline == *line) && (csession == *session)))
	        q = NULL;
	}

	*session = csession;
	*line = cline;
    }
    return(q);
}


static tt_soc *snmp_get_tty (int searchtype, long *linein)
{
    register tt_soc *tty;
    long line;

    for (line = 0; line < ALLlines; line++) {
	tty = MODEMS[line];
	if (tty) {
	    if ((*linein == line) || (*linein < line && searchtype == NEXT)) {
		*linein = line;
		return(tty);
	    }
	}
    }
    *linein = line;
    return(NULL);
}


#define NMSGTIMES 6
int netmsgtimes[NMSGTIMES] =
    {0, 60*ONESEC, 5*60*ONESEC, 30*60*ONESEC, 60*60*ONESEC, 120*60*ONESEC};

static process netmessage (void)
{
    struct message_data *mess = &m;
    int i, firstline, lastline;
    tt_soc *line;
    int dest = mess->ttyline;
    int howmany;
    int remaining, rhr, rmin, rsec;
    int aborting = FALSE;
    int aborted = FALSE;
    sys_timestamp endtime, wakeup_time;
    ulong slop;

    slop = 0; /* Silence compiler warning */
    if (mess->repeat_interval == 0) {
	for (howmany = NMSGTIMES-1; howmany; howmany--)
	   if (mess->duration > netmsgtimes[howmany])
	      break;
	howmany += 2; /* count initial notification and final reboot */
    } else if (mess->duration == 0)
        howmany = 1;
    else {
        howmany = (mess->duration / mess->repeat_interval) + 1;
        slop = mess->duration - ((mess->duration / mess->repeat_interval) * 
               mess->repeat_interval);
        if ((mess->duration % mess->repeat_interval) != 0)
            howmany++;
    }
    TIMER_START(endtime, mess->duration);

    if (dest == -1) {
        firstline = 0; lastline = ALLlines;
    }
    else {
        firstline = dest; lastline = dest + 1;
    }
    if (mess->temp_banner_flag == D_tsMsgTmpBanner_additive) 
        banner_temp = mess->text;

    process_watch_timer(&wakeup_time, ENABLE);
    while (howmany--) {
        rhr = rmin = rsec = 0; /* stop the warning messages */
	remaining = TIME_LEFT_SLEEPING(endtime);
        if (remaining) {
            rhr = remaining / ONEHOUR;
            remaining %= ONEHOUR;
            rmin = remaining / ONEMIN;
            remaining %= ONEMIN;
            rsec = remaining / ONESEC;
        }

        for (i = firstline; i < lastline; ++i) {
            vectortype *tmpvector = NULL;
            line = MODEMS[i];
            if ((line->statbits & READY)
                && (line->statbits & (SLIPMODE | CARDROP | HANGUP)) == 0) {
                if (line->conntop && line->type != VTY_LINE) {  /* incoming */
                    if (((conntype *)line->conntop)->status & CONN_STREAM)
                        continue;
                    tmpvector = line->ovector;
                    line->ovector = line->ivector;
                }
                tty_clearbuffers(line);
                if (mess->oncompletion != D_tsMsgSend_reload)
                    ttyprintf(line,"\n\n\n\07***\n***");
                else
                    if (aborted)
                        ttyprintf(line,
				  "\n\n\n\07***\n*** --- SHUTDOWN ABORTED ---");
                    else if (howmany)
                        ttyprintf(line,
				  "\n\n\n\07***\n*** --- SHUTDOWN in %d:%-0#2d:%-0#2d ---",
				  rhr, rmin, rsec);
                    else
                        ttyprintf(line,"\n\n\n\07***\n*** --- SHUTDOWN NOW ---");
                ttyprintf(line,"\n*** Message from network");
                if (dest == -1)
                    ttyprintf(line," to all terminals:\n***\n%s\n",mess->text);
                else
                    ttyprintf(line," to tty%t:\n***\n%s\n",
			      line->ttynum, mess->text);
                startoutput(line);
                if (tmpvector)
                    line->ovector = tmpvector;
                process_suspend();
            }
        }
        if (current_message_state == D_tsMsgSend_abort) {
            aborting = TRUE;
        }
        if (howmany)
            if (!aborting)
	        if (mess->repeat_interval) {
                    if (TIME_LEFT_SLEEPING(endtime) > mess->repeat_interval) {
                        /*
                         * Subtract off an extra second so the messages 
                         * show the right time
                         */
			wakeup_time = TIMER_SUB_DELTA(endtime,
			      (mess->repeat_interval*(howmany-1)) + slop);
			process_wait_for_event();
                    } else {
			COPY_TIMESTAMP(endtime, wakeup_time);
			process_wait_for_event();
		    }
		} else {
		    wakeup_time = TIMER_SUB_DELTA(endtime,
						  netmsgtimes[howmany-1]);
		    process_wait_for_event();
		}
        if (current_message_state == D_tsMsgSend_abort) {
            aborting = TRUE;
        }
        if (!aborted && aborting) {
            if (mess->oncompletion == D_tsMsgSend_reload)
                howmany = 1;
            else
                howmany = 0;
            aborted = TRUE;
        }
    }
    if (mess->oncompletion == D_tsMsgSend_reload && !aborting) {
         boot_reason = "snmp shutdown request";
	 reload_system(RELOAD_NORMAL);	/* Reload the system */
    }
    /* check to see if our message is a temporary banner */
    if (banner_temp == mess->text)
        banner_temp = NULL;
    current_message_state = D_tsMsgSend_messagedone;
    netmessage_pid = 0;
    process_kill (-1);
}

/*
          reload TRAP-TYPE
              ENTERPRISE  cisco
              VARIABLES   { sysUpTime, whyReload }
              DESCRIPTION
                          "A reload trap signifies that the sending
                          protocol entity is reinitializing itself such
                          that the agent's configuration or the protocol
                          entity implementation may be altered."
              ::= 0
*/

#define RELOAD_TRAP_NUMBER 0
#define TRAP_VARBIND_COUNT 2
static const OID trapVarBinds[TRAP_VARBIND_COUNT] = {
    {LNsysUpTime, (ulong *)IDsysUpTime},
    {LNwhyReload, (ulong *)IDwhyReload}
};

static void
generate_reload_trap (void)
{
    int		vbIndex;
    OID	       *vbList[TRAP_VARBIND_COUNT+1];
    OID         instanceOID;
    ulong       instance[1];

    /*
     * All the trap varbind objects are scalars (instance is .0)
     */
    instance[0] = 0;
    instanceOID.oid_ptr = instance;
    instanceOID.length = 1;

    /*
     * create the variable binding list
     */
    for (vbIndex = 0; vbIndex < TRAP_VARBIND_COUNT; vbIndex++) {
        vbList[vbIndex] = CatOID((OID *) &trapVarBinds[vbIndex], &instanceOID);
    }
    vbList[vbIndex] = NULL;

    /*
     * initiate the trap
     */
    snmp_trap(ENTERPRISE_TRAP, RELOAD_TRAP_NUMBER, vbList,
	      (OID *)&ciscoOID, (char *)reload_trap_oid);

    /*
     * free any allocated data
     */
    for (vbIndex = 0; vbIndex < TRAP_VARBIND_COUNT; vbIndex++) {
        FreeOID(vbList[vbIndex]);
    }
}


/*
 * old_ltsmib subsystem header
 */

#define MAJVERSION_old_ltsmib 1
#define MINVERSION_old_ltsmib 0
#define EDITVERSION_old_ltsmib 0

SUBSYS_HEADER(old_ltsmib,
              MAJVERSION_old_ltsmib,
              MINVERSION_old_ltsmib,
              EDITVERSION_old_ltsmib,
              init_old_ltsmib,
              SUBSYS_CLASS_MANAGEMENT,
              NULL,
              NULL);
      
