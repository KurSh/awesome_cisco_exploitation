/* $Id: sr_pingmib.c,v 3.3.12.1 1996/04/19 17:46:48 jjohnson Exp $
 * $Source: /release/112/cvs/Xsys/snmp/sr_pingmib.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * April 1994, Jeffrey T. Johnson (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1996 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_pingmib.c,v $
 * Revision 3.3.12.1  1996/04/19  17:46:48  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.3  1996/02/12  21:32:03  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.2  1995/11/17  19:00:37  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  13:17:38  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.2  1995/06/09  13:18:57  hampton
 * Rename old scheduler calls to fit the new naming convention.
 * [CSCdi35514]
 *
 * Revision 2.1  1995/06/07 22:50:12  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include "snmp_api.h"
#include "sr_pingmib.h"
#include "sr_pingmib-mib.h"
#include "sys_registry.h"
#include "snmp_registry.h"

/*
 * the following min/default/max values are taken directly from the mib
 */

#define MIN_ciscoPingSerialNumber	1
#define MAX_ciscoPingSerialNumber	2147483647

#define MIN_ciscoPingPacketCount	1
#define DEF_ciscoPingPacketCount	5
#define MAX_ciscoPingPacketCount	2147483647

/* min and max packet size are protocol-dependent */
#define DEF_ciscoPingPacketSize		100

#define MIN_ciscoPingPacketTimeout	0
#define DEF_ciscoPingPacketTimeout	2000
#define MAX_ciscoPingPacketTimeout	3600000

#define MIN_ciscoPingDelay		0
#define DEF_ciscoPingDelay		0
#define MAX_ciscoPingDelay		3600000

#define DEF_ciscoPingTrapOnCompletion	D_ciscoPingTrapOnCompletion_false

#define PING_ENTRY_AGEOUT		(ONEMIN * 5)


#define pingQ struct pingQ_
pingQ {
    pingQ	       *next;
    ciscoPingEntry_t   *entry;
    int			pid;
    sys_timestamp	timer;
    boolean		active;
};

static queuetype	snmppingQ;


/*
 * forward reference
 */

static forktype snmp_ping_task(pingQ *ping);
static void snmp_ping_ageout(void);
static int snmp_ping_validate_default(ciscoPingEntry_t *entry);
static void snmp_ping_completion_trap(ciscoPingEntry_t *entry);


void
init_pingmib (void)
{
    queue_init(&snmppingQ, 0);
    load_mib(pingmib_OidList, pingmib_OidListNum);
    load_oid(pingmib_oid_table);

    reg_add_default_snmp_ping_validate(snmp_ping_validate_default,
				       "snmp_ping_validate_default");

    reg_add_onemin(snmp_ping_ageout, "snmp_ping_ageout");
}

/*---------------------------------------------------------------------
 * Retrieve data from the ciscoPingEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ciscoPingEntry_get (OID            *incoming,
		    ObjectInfo     *object,
		    int             searchType,
		    ContextInfo    *contextInfo,
		    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ciscoPingEntry_t *data = NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            ciscoPingSerialNumber;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &ciscoPingSerialNumber, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ciscoPingEntry_get(serialNum, contextInfo, arg, searchType, ciscoPingSerialNumber)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->ciscoPingSerialNumber;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    dp = NULL;
    switch (arg) {

#ifdef I_ciscoPingAddress
      case I_ciscoPingAddress:
	if (VALID(arg, data->valid))
	    dp = CloneOctetString(data->ciscoPingAddress);
	break;
#endif				       /* I_ciscoPingAddress */

#ifdef I_ciscoPingEntryOwner
      case I_ciscoPingEntryOwner:
	if (VALID(arg, data->valid))
	    dp = CloneOctetString(data->ciscoPingEntryOwner);
	break;
#endif				       /* I_ciscoPingEntryOwner */

#ifdef I_ciscoPingProtocol
      case I_ciscoPingProtocol:
#endif				       /* I_ciscoPingProtocol */

#ifdef I_ciscoPingPacketCount
      case I_ciscoPingPacketCount:
#endif				       /* I_ciscoPingPacketCount */

#ifdef I_ciscoPingPacketSize
      case I_ciscoPingPacketSize:
#endif				       /* I_ciscoPingPacketSize */

#ifdef I_ciscoPingPacketTimeout
      case I_ciscoPingPacketTimeout:
#endif				       /* I_ciscoPingPacketTimeout */

#ifdef I_ciscoPingDelay
      case I_ciscoPingDelay:
#endif				       /* I_ciscoPingDelay */

#ifdef I_ciscoPingTrapOnCompletion
      case I_ciscoPingTrapOnCompletion:
#endif				       /* I_ciscoPingTrapOnCompletion */

#ifdef I_ciscoPingSentPackets
      case I_ciscoPingSentPackets:
#endif				       /* I_ciscoPingSentPackets */

#ifdef I_ciscoPingReceivedPackets
      case I_ciscoPingReceivedPackets:
#endif				       /* I_ciscoPingReceivedPackets */

#ifdef I_ciscoPingMinRtt
      case I_ciscoPingMinRtt:
#endif				       /* I_ciscoPingMinRtt */

#ifdef I_ciscoPingAvgRtt
      case I_ciscoPingAvgRtt:
#endif				       /* I_ciscoPingAvgRtt */

#ifdef I_ciscoPingMaxRtt
      case I_ciscoPingMaxRtt:
#endif				       /* I_ciscoPingMaxRtt */

#ifdef I_ciscoPingCompleted
      case I_ciscoPingCompleted:
#endif				       /* I_ciscoPingCompleted */

#ifdef I_ciscoPingEntryStatus
      case I_ciscoPingEntryStatus:
#endif				       /* I_ciscoPingEntryStatus */
	if (VALID(arg, data->valid))
	    dp = SR_OFFSET(data, arg);
	break;
    }				       /* switch */

    if (dp == NULL)
	return ((VarBind *) NULL);
    else
	return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS
/*----------------------------------------------------------------------
 * Free the ciscoPingEntry data object.
 *---------------------------------------------------------------------*/
void
ciscoPingEntry_free (ciscoPingEntry_t *data)
{
    if (data != NULL) {
	if (data->ciscoPingAddress != NULL) {
	    FreeOctetString(data->ciscoPingAddress);
	}
	if (data->ciscoPingEntryOwner != NULL) {
	    FreeOctetString(data->ciscoPingEntryOwner);
	}
	free(data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after ciscoPingEntry set/undo
 *---------------------------------------------------------------------*/
static int
ciscoPingEntry_cleanup (doList_t       *trash)
{
    ciscoPingEntry_free(trash->data);
#ifdef SR_SNMPv2
    ciscoPingEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
ciscoPingEntry_test (OID            *incoming,
		     ObjectInfo     *object,
		     ObjectSyntax   *value,
		     doList_t       *doHead,
		     doList_t       *doCur,
		     ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int		    retval;
    int             found;
    int             carry = 0;
    ciscoPingEntry_t *ciscoPingEntry;
    long            ciscoPingSerialNumber;
    boolean	    validated = FALSE;
    boolean	    entry_found;
    boolean	    good_row;

    /*
     * Validate the object instance
     * 
     */
    if (instLength != 1) {
	return NO_CREATION_ERROR;
    }
    if ((InstToInt(incoming, object->oid.length, &ciscoPingSerialNumber, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if (ciscoPingSerialNumber < MIN_ciscoPingSerialNumber ||
	ciscoPingSerialNumber > MAX_ciscoPingSerialNumber) {
	return (NO_CREATION_ERROR);
    }

    ciscoPingEntry = k_ciscoPingEntry_get(-1, contextInfo, object->nominator, EXACT, ciscoPingSerialNumber);
    entry_found = (ciscoPingEntry != NULL);

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = FALSE;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == ciscoPingEntry_set) &&
	    (((ciscoPingEntry_t *) (dp->data)) != NULL) &&
	    (((ciscoPingEntry_t *) (dp->data))->ciscoPingSerialNumber == ciscoPingSerialNumber)) {

	    found = TRUE;
	    break;
	}
    }

    if (found) {
	ciscoPingEntry = dp->data;
    } else {
	dp = doCur;
	dp->data = malloc(sizeof(ciscoPingEntry_t));
	if (dp->data == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(ciscoPingEntry_t));

	dp->setMethod = ciscoPingEntry_set;
	dp->cleanupMethod = ciscoPingEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

        /*
         * Try to fill in reasonable default values for this new dolist entry.
         */

	if (ciscoPingEntry != NULL) {
	    /*
	     * we'll just start with the values that already exist
	     */
	    memcpy(dp->data, ciscoPingEntry, sizeof(ciscoPingEntry_t));

	    if (ciscoPingEntry->ciscoPingAddress != NULL)
		((ciscoPingEntry_t *) (dp->data))->ciscoPingAddress =
		    CloneOctetString(ciscoPingEntry->ciscoPingAddress);

	    if (ciscoPingEntry->ciscoPingEntryOwner != NULL)
		((ciscoPingEntry_t *) (dp->data))->ciscoPingEntryOwner =
		    CloneOctetString(ciscoPingEntry->ciscoPingEntryOwner);

	    ciscoPingEntry = dp->data;

	} else {
	    /*
	     * this is a brand new row
	     */
	    ciscoPingEntry = dp->data;

	    SET_VALID(I_ciscoPingSerialNumber, ciscoPingEntry->valid);
	    ciscoPingEntry->ciscoPingSerialNumber = ciscoPingSerialNumber;

	    SET_VALID(I_ciscoPingPacketCount, ciscoPingEntry->valid);
	    ciscoPingEntry->ciscoPingPacketCount = DEF_ciscoPingPacketCount;

	    SET_VALID(I_ciscoPingPacketSize, ciscoPingEntry->valid);
	    ciscoPingEntry->ciscoPingPacketSize = DEF_ciscoPingPacketSize;

	    SET_VALID(I_ciscoPingPacketTimeout, ciscoPingEntry->valid);
	    ciscoPingEntry->ciscoPingPacketTimeout = DEF_ciscoPingPacketTimeout;

	    SET_VALID(I_ciscoPingDelay, ciscoPingEntry->valid);
	    ciscoPingEntry->ciscoPingDelay = DEF_ciscoPingDelay;

	    SET_VALID(I_ciscoPingTrapOnCompletion, ciscoPingEntry->valid);
	    ciscoPingEntry->ciscoPingTrapOnCompletion = DEF_ciscoPingTrapOnCompletion;

	    /*
	     * we'll assign a value to ciscoPingEntryStatus but won't set the
	     * valid flag.  The valid flag will be set when a set request for
	     * this object is received
	     */
	    ciscoPingEntry->ciscoPingEntryStatus = D_ciscoPingEntryStatus_notReady;
	}
    }
    switch (object->nominator) {

#ifdef I_ciscoPingProtocol
      case I_ciscoPingProtocol:

	/*
	 * don't allow the protocol to change once it's set
	 */
	if ((VALID(I_ciscoPingProtocol, ciscoPingEntry->valid)) &&
	    (ciscoPingEntry->ciscoPingProtocol != value->sl_value))
	    return (INCONSISTENT_VALUE_ERROR);

	SET_VALID(I_ciscoPingProtocol, ciscoPingEntry->valid);
	ciscoPingEntry->ciscoPingProtocol = value->sl_value;

	/*
	 * invoke the snmp_ping_validate registry to see if this
	 * is a valid protocol which supports the snmp ping mib
	 */
	switch (reg_invoke_snmp_ping_validate(value->sl_value,
					      ciscoPingEntry)) {
	case SNMP_PING_VALID:
	    break;
	case SNMP_PING_INVALID_PROTOCOL:
	    return (WRONG_VALUE_ERROR);
	case SNMP_PING_INVALID_ADDRESS:
	case SNMP_PING_INVALID_SIZE:
	    return (INCONSISTENT_VALUE_ERROR);
	}
	validated = TRUE;
	break;
#endif				       /* I_ciscoPingProtocol */

#ifdef I_ciscoPingAddress
      case I_ciscoPingAddress:

	/*
	 * don't allow the value to change once the row is active
	 */
	if (ciscoPingEntry->ciscoPingEntryStatus == D_ciscoPingEntryStatus_active)
	    return (INCONSISTENT_VALUE_ERROR);

	/*
	 * value tested later via snmp_ping_validate registry
	 */
	SET_VALID(I_ciscoPingAddress, ciscoPingEntry->valid);

	if (ciscoPingEntry->ciscoPingAddress != NULL) {
	    FreeOctetString(ciscoPingEntry->ciscoPingAddress);
	}
	ciscoPingEntry->ciscoPingAddress = CloneOctetString(value->os_value);

	break;
#endif				       /* I_ciscoPingAddress */

#ifdef I_ciscoPingPacketCount
      case I_ciscoPingPacketCount:
	if ((value->sl_value < MIN_ciscoPingPacketCount) ||
	    (value->sl_value > MAX_ciscoPingPacketCount))
	    return (WRONG_VALUE_ERROR);

	/*
	 * don't allow the value to change once the row is active
	 */
	if (ciscoPingEntry->ciscoPingEntryStatus == D_ciscoPingEntryStatus_active)
	    return (INCONSISTENT_VALUE_ERROR);

	SET_VALID(I_ciscoPingPacketCount, ciscoPingEntry->valid);
	ciscoPingEntry->ciscoPingPacketCount = value->sl_value;
	break;
#endif				       /* I_ciscoPingPacketCount */

#ifdef I_ciscoPingPacketSize
      case I_ciscoPingPacketSize:

	/*
	 * don't allow the value to change once the row is active
	 */
	if (ciscoPingEntry->ciscoPingEntryStatus == D_ciscoPingEntryStatus_active)
	    return (INCONSISTENT_VALUE_ERROR);

	/*
	 * value tested later via snmp_ping_validate registry
	 */
	SET_VALID(I_ciscoPingPacketSize, ciscoPingEntry->valid);
	ciscoPingEntry->ciscoPingPacketSize = value->sl_value;
	break;
#endif				       /* I_ciscoPingPacketSize */

#ifdef I_ciscoPingPacketTimeout
      case I_ciscoPingPacketTimeout:

	if ((value->sl_value < MIN_ciscoPingPacketTimeout) ||
	    (value->sl_value > MAX_ciscoPingPacketTimeout))
	    return (WRONG_VALUE_ERROR);

	/*
	 * don't allow the value to change once the row is active
	 */
	if (ciscoPingEntry->ciscoPingEntryStatus == D_ciscoPingEntryStatus_active)
	    return (INCONSISTENT_VALUE_ERROR);

	SET_VALID(I_ciscoPingPacketTimeout, ciscoPingEntry->valid);
	ciscoPingEntry->ciscoPingPacketTimeout = value->sl_value;
	break;
#endif				       /* I_ciscoPingPacketTimeout */

#ifdef I_ciscoPingDelay
      case I_ciscoPingDelay:

	if ((value->sl_value < MIN_ciscoPingDelay) ||
	    (value->sl_value > MAX_ciscoPingDelay))
	    return (WRONG_VALUE_ERROR);

	/*
	 * don't allow the value to change once the row is active
	 */
	if (ciscoPingEntry->ciscoPingEntryStatus == D_ciscoPingEntryStatus_active)
	    return (INCONSISTENT_VALUE_ERROR);

	SET_VALID(I_ciscoPingDelay, ciscoPingEntry->valid);
	ciscoPingEntry->ciscoPingDelay = value->sl_value;
	break;
#endif				       /* I_ciscoPingDelay */

#ifdef I_ciscoPingTrapOnCompletion
      case I_ciscoPingTrapOnCompletion:

	if ((value->sl_value < D_ciscoPingTrapOnCompletion_true) ||
	    (value->sl_value > D_ciscoPingTrapOnCompletion_false))
	    return (WRONG_VALUE_ERROR);

	/*
	 * don't allow the value to change once the row is active
	 */
	if (ciscoPingEntry->ciscoPingEntryStatus == D_ciscoPingEntryStatus_active)
	    return (INCONSISTENT_VALUE_ERROR);

	SET_VALID(I_ciscoPingTrapOnCompletion, ciscoPingEntry->valid);
	ciscoPingEntry->ciscoPingTrapOnCompletion = value->sl_value;
	break;
#endif				       /* I_ciscoPingTrapOnCompletion */

#ifdef I_ciscoPingEntryOwner
      case I_ciscoPingEntryOwner:

        if (value->os_value->length > SYSSIZE) {
            return (WRONG_LENGTH_ERROR);
        }

        if (!IsDisplayString(value->os_value)) {
            return (WRONG_VALUE_ERROR);
        }

	/*
	 * don't allow the value to change once the row is active
	 */
	if (ciscoPingEntry->ciscoPingEntryStatus == D_ciscoPingEntryStatus_active)
	    return (INCONSISTENT_VALUE_ERROR);

	SET_VALID(I_ciscoPingEntryOwner, ciscoPingEntry->valid);

	if (ciscoPingEntry->ciscoPingEntryOwner != NULL) {
	    FreeOctetString(ciscoPingEntry->ciscoPingEntryOwner);
	}
	ciscoPingEntry->ciscoPingEntryOwner = CloneOctetString(value->os_value);

	break;
#endif				       /* I_ciscoPingEntryOwner */

#ifdef I_ciscoPingEntryStatus
      case I_ciscoPingEntryStatus:

	/*
	 * don't allow status to be set to notInService
	 */
	if (value->sl_value == D_ciscoPingEntryStatus_notInService)
	    return (INCONSISTENT_VALUE_ERROR);

	/*
	 * perform generic row status processing
	 */
	retval = set_row_status(value->sl_value,
				entry_found ? 1 : -1,
				&(dp->state),
				&(ciscoPingEntry->ciscoPingEntryStatus));

	if (retval != NO_ERROR)
	    return (retval);

	SET_VALID(I_ciscoPingEntryStatus, ciscoPingEntry->valid);

	break;
#endif				       /* I_ciscoPingEntryStatus */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in ciscoPingEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */

    /*
     * do protocol-dependent sanity check if we can and if it hasn't
     * already been done earlier
     */
    if (!validated &&
	VALID(I_ciscoPingProtocol, ciscoPingEntry->valid) &&
	reg_invoke_snmp_ping_validate(ciscoPingEntry->ciscoPingProtocol,
				      ciscoPingEntry) != SNMP_PING_VALID) {
	return (INCONSISTENT_VALUE_ERROR);
    }

    /*
     * see if we have a complete row
     */
    if (VALID(I_ciscoPingProtocol, ciscoPingEntry->valid) &&
	VALID(I_ciscoPingAddress, ciscoPingEntry->valid) &&
	VALID(I_ciscoPingPacketSize, ciscoPingEntry->valid) &&
	VALID(I_ciscoPingEntryStatus, ciscoPingEntry->valid)) {
	good_row = TRUE;
    } else {
	good_row = FALSE;
    }

    /*
     * transition the row status as necessary
     */
    if (entry_found) {
	switch (ciscoPingEntry->ciscoPingEntryStatus) {
	case D_ciscoPingEntryStatus_notInService:
	    if (good_row)
		dp->state = ADD_MODIFY;
	    else
		dp->state = NOT_READY_STATE;
	    break;

	case D_ciscoPingEntryStatus_destroy:
	    dp->state = DELETE;
	    break;

	case D_ciscoPingEntryStatus_notReady:
	    if (good_row)
		ciscoPingEntry->ciscoPingEntryStatus = D_ciscoPingEntryStatus_notInService;
	    dp->state = ADD_MODIFY;
	    break;

	case D_ciscoPingEntryStatus_active:
	    if (good_row)
		dp->state = ADD_MODIFY;
	    else
		dp->state = NOT_READY_STATE;
	    break;

	default:
	    return (INCONSISTENT_VALUE_ERROR);
            break;

	}
    } else {
	switch (ciscoPingEntry->ciscoPingEntryStatus) {
	case D_ciscoPingEntryStatus_createAndWait:
	    if (good_row)
		ciscoPingEntry->ciscoPingEntryStatus = D_ciscoPingEntryStatus_notInService;
	    else
		ciscoPingEntry->ciscoPingEntryStatus = D_ciscoPingEntryStatus_notReady;
	    dp->state = ADD_MODIFY;
	    break;

	case D_ciscoPingEntryStatus_notReady:
	    if (good_row)
		ciscoPingEntry->ciscoPingEntryStatus = D_ciscoPingEntryStatus_notInService;
	    if (VALID(I_ciscoPingEntryStatus, ciscoPingEntry->valid))
		dp->state = ADD_MODIFY;
	    break;

	case D_ciscoPingEntryStatus_createAndGo:
	    if (good_row)
		dp->state = ADD_MODIFY;
	    else
		dp->state = CREATE_AND_GO_STATE;
	    break;

	case D_ciscoPingEntryStatus_destroy:
	    dp->state = DELETE;
	    break;

	case D_ciscoPingEntryStatus_notInService:
	    if (!good_row)
		ciscoPingEntry->ciscoPingEntryStatus = D_ciscoPingEntryStatus_notReady;
	    dp->state = ADD_MODIFY;

	default:
	    return (INCONSISTENT_VALUE_ERROR);
            break;
	}
    }

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
ciscoPingEntry_set (doList_t       *doHead,
		    doList_t       *doCur,
		    ContextInfo    *contextInfo)
{
    return (k_ciscoPingEntry_set((ciscoPingEntry_t *) (doCur->data),
				 contextInfo, doCur->state));
}

#endif				       /* SETS */


/*
 * pingQget:  grab the requested snmppingQ entry
 */
static pingQ *
pingQget (int	searchType,
	  long	serialNumber)
{
    leveltype		level;
    pingQ	       *test;
    ciscoPingEntry_t   *entry;

    /*
     * don't allow the timeout task access to the Q
     */
    level = raise_interrupt_level(ALL_DISABLE);

    for (test = snmppingQ.qhead; test; test = test->next) {
	/*
	 * skip any entries that are being hidden from SNMP
	 */
	if (!test->active)
	    continue;

	entry = test->entry;
	/*
	 * the snmppingQ is sorted by serial number, so we can stop a NEXT
	 * search when we find a candidate
	 */
	if (((entry->ciscoPingSerialNumber == serialNumber) &&
	     (searchType == EXACT)) ||
	    ((entry->ciscoPingSerialNumber >= serialNumber) &&
	     (searchType == NEXT)))
	    break;

	if ((entry->ciscoPingSerialNumber >= serialNumber) &&
	    (searchType == EXACT)) {
	    /*
	     * gone too far for an exact match
	     */
	    test = NULL;
	    break;
	}
    }

    /*
     * re-allow access to the snmppingQ
     */
    reset_interrupt_level(level);

    return (test);
}

/*
 * pingQinsert:  insert a new entry into the ordered snmppingQ
 */
static void
pingQinsert (pingQ     *newping)
{
    leveltype		level;
    pingQ	       *prev;
    pingQ	       *test;
    long		serialNumber;

    /*
     * don't allow the timeout task access to the Q
     */
    level = raise_interrupt_level(ALL_DISABLE);

    serialNumber = newping->entry->ciscoPingSerialNumber;
    prev = NULL;
    test = snmppingQ.qhead;
    while (test) {
	if (serialNumber < test->entry->ciscoPingSerialNumber)
	    break;
	prev = test;
	test = test->next;
    }

    insqueue(&snmppingQ, newping, prev);

    /*
     * re-allow access to the snmppingQ
     */
    reset_interrupt_level(level);

    return;
}

ciscoPingEntry_t *
k_ciscoPingEntry_get (int             serialNum,
		      ContextInfo    *contextInfo,
		      int             nominator,
		      int             searchType,
		      long            ciscoPingSerialNumber)
{
    pingQ      *data;
    leveltype	level;

    static ciscoPingEntry_t ciscoPingEntryData;

    while (TRUE) {
	data = pingQget(searchType, ciscoPingSerialNumber);

	if (data == NULL)
	    return (NULL);

	/*
	 * disable the ping task for a quick snapshot
	 */
	level = raise_interrupt_level(ALL_DISABLE);
	memcpy(&ciscoPingEntryData,
	       data->entry,
	       sizeof(ciscoPingEntry_t));
	reset_interrupt_level(level);

	/*
	 * if the request was a get, or if the request was a
	 * get-next and the requested field has data, then
	 * return the record
	 */
	if ((searchType == EXACT) ||
	    (VALID(nominator, ciscoPingEntryData.valid)))
	    return (&ciscoPingEntryData);

	/*
	 * the request was obviously a get-next on a sparse field so
	 * look for another
	 */
	ciscoPingSerialNumber = ciscoPingEntryData.ciscoPingSerialNumber + 1;
	if ((ulong)ciscoPingSerialNumber > MAX_ciscoPingSerialNumber) {
	    return (NULL);
	}
    }
}

#ifdef SETS
int
k_ciscoPingEntry_set (ciscoPingEntry_t *data,
		      ContextInfo      *contextInfo,
		      int		function)
{
    pingQ	       *current;
    ciscoPingEntry_t   *entry;

    current = pingQget(EXACT, data->ciscoPingSerialNumber);

    switch (function) {
    case DELETE:
	if (current) {

	    /*
	     * we've located the appropriate pingQ record
	     */
	    if (current->pid == 0) {
		/*
		 * the ping either was never started or has completed
		 * so the associated entry may be deleted
		 */
		p_unqueue(&snmppingQ, current);
		ciscoPingEntry_free(current->entry);
		free(current);
	    } else {
		/*
		 * the ping is still active. we'll let it run to completion,
		 * but we'll change the packet count as a flag to the task,
		 * and we'll hide the associated entry from SNMP
		 */
		current->entry->ciscoPingPacketCount = 0;
		current->active = FALSE;
	    }
	}
	return (NO_ERROR);
	
    case ADD_MODIFY:
	if (current == NULL) {
	    /*
	     * adding a new row
	     */
	    current = malloc(sizeof(pingQ));
	    if (current == NULL)
		return (RESOURCE_UNAVAILABLE_ERROR);

	    entry = malloc(sizeof(ciscoPingEntry_t));
	    if (entry == NULL) {
		free(current);
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }

	    current->next = NULL;
	    current->active = TRUE;
	    current->pid = 0;
	    current->entry = entry;
	    entry->ciscoPingSerialNumber = data->ciscoPingSerialNumber;
	    entry->ciscoPingEntryStatus = D_ciscoPingEntryStatus_notInService;
	    pingQinsert(current);
	} else {
	    entry = current->entry;
	}

	/*
	 * entry is being modified, so restart the ageout timer
	 */
	TIMER_START(current->timer, PING_ENTRY_AGEOUT);

	if (VALID(I_ciscoPingProtocol, data->valid)) {
	    SET_VALID(I_ciscoPingProtocol, entry->valid);
	    entry->ciscoPingProtocol = data->ciscoPingProtocol;
	}

	if (VALID(I_ciscoPingAddress, data->valid)) {
	    SET_VALID(I_ciscoPingAddress, entry->valid);
	    if (entry->ciscoPingAddress != NULL) {
		FreeOctetString(entry->ciscoPingAddress);
	    }
	    entry->ciscoPingAddress = CloneOctetString(data->ciscoPingAddress);
	}

	if (VALID(I_ciscoPingPacketCount, data->valid)) {
	    SET_VALID(I_ciscoPingPacketCount, entry->valid);
	    entry->ciscoPingPacketCount = data->ciscoPingPacketCount;
	}

	if (VALID(I_ciscoPingPacketSize, data->valid)) {
	    SET_VALID(I_ciscoPingPacketSize, entry->valid);
	    entry->ciscoPingPacketSize = data->ciscoPingPacketSize;
	}

	if (VALID(I_ciscoPingPacketTimeout, data->valid)) {
	    SET_VALID(I_ciscoPingPacketTimeout, entry->valid);
	    entry->ciscoPingPacketTimeout = data->ciscoPingPacketTimeout;
	}

	if (VALID(I_ciscoPingDelay, data->valid)) {
	    SET_VALID(I_ciscoPingDelay, entry->valid);
	    entry->ciscoPingDelay = data->ciscoPingDelay;
	}

	if (VALID(I_ciscoPingTrapOnCompletion, data->valid)) {
	    SET_VALID(I_ciscoPingTrapOnCompletion, entry->valid);
	    entry->ciscoPingTrapOnCompletion = data->ciscoPingTrapOnCompletion;
	}

	if (VALID(I_ciscoPingEntryOwner, data->valid)) {
	    SET_VALID(I_ciscoPingEntryOwner, entry->valid);
        if (entry->ciscoPingEntryOwner != NULL) {
            FreeOctetString(entry->ciscoPingEntryOwner);
        }
        entry->ciscoPingEntryOwner = CloneOctetString(data->ciscoPingEntryOwner);
	}

	if (VALID(I_ciscoPingEntryStatus, data->valid)) {
	    /*
	     * turn createAndGo into active since they're the same
	     * thing at this point
	     */
	    if (data->ciscoPingEntryStatus == D_ciscoPingEntryStatus_createAndGo)
		data->ciscoPingEntryStatus = D_ciscoPingEntryStatus_active;

	    SET_VALID(I_ciscoPingEntryStatus, entry->valid);
	    entry->ciscoPingEntryStatus = data->ciscoPingEntryStatus;

	    /*
	     * if we're active and a ping task hasn't been started, do it
	     */
	    if (entry->ciscoPingEntryStatus == D_ciscoPingEntryStatus_active &&
		current->pid == 0) {
		current->pid = cfork((forkproc *) snmp_ping_task,
				     (long) current, 0, "SNMP PING", 0);
		if (current->pid == -1) {
		    current->pid = 0;
		    return (RESOURCE_UNAVAILABLE_ERROR);
		}
	    }
	}
	return (NO_ERROR);
    }
    return (GEN_ERROR);
}

#endif				       /* SETS */

/*
 * generic snmp ping task
 * An instance of this task is started for each snmp ping activation
 */
static forktype
snmp_ping_task (pingQ *ping)
{
    /*
     * disable ageout while the task is running
     */
    TIMER_STOP(ping->timer);

    /*
     * perform the protocol-specific ping function
     */
    reg_invoke_snmp_ping_activate(ping->entry->ciscoPingProtocol, ping->entry);

    if (ping->active) {
	/*
	 * the entry is still active from an snmp point-of-view
	 * issue a completion trap if one was requested
	 */
	if (ping->entry->ciscoPingTrapOnCompletion == D_ciscoPingTrapOnCompletion_true) {
	    snmp_ping_completion_trap(ping->entry);
	}

	/*
	 * restart the ageout timer
	 */
	TIMER_START(ping->timer, PING_ENTRY_AGEOUT);
    } else {
	/*
	 * this entry was already deleted via snmp, so delete it
	 */
	p_unqueue(&snmppingQ, ping);
	ciscoPingEntry_free(ping->entry);
	free(ping);
    }

    /*
     * kill myself
     */
    process_kill(THIS_PROCESS);
}

/*
 * ping entry ageout function
 * called via the ONEMIN registry
 */
static void
snmp_ping_ageout (void)
{
    leveltype		level;
    pingQ	       *test;
    pingQ	       *next;

    /*
     * make sure we have exclusive access to the snmppingQ
     */
    level = raise_interrupt_level(ALL_DISABLE);

    for (test = snmppingQ.qhead; test; test = next) {
	next = test->next;

	if (TIMER_RUNNING(test->timer) && AWAKE(test->timer)) {
	    unqueue(&snmppingQ, test);
	    ciscoPingEntry_free(test->entry);
	    free(test);
	}
    }

    /*
     * re-allow access to the snmppingQ
     */
    reset_interrupt_level(level);

}

/*
 * function for handling the default case of an snmp_ping_validate
 * registry call.  If nobody has registered to validate the protocol,
 * then it must be unsupported
 */
static int
snmp_ping_validate_default (ciscoPingEntry_t *entry)
{
    printf("\nreached snmp_ping_validate_default");
    return (SNMP_PING_INVALID_PROTOCOL);
}

/*
 * ciscoPingMIBTrapPrefix OBJECT IDENTIFIER ::= { ciscoPingMIB 2 }
 * ciscoPingMIBTraps OBJECT IDENTIFIER ::= { ciscoPingMIBTrapPrefix 0 }
 * 
 * ciscoPingCompletion NOTIFICATION-TYPE
 *	OBJECTS	   {	ciscoPingCompleted,
 *			ciscoPingSentPackets,
 *			ciscoPingReceivedPackets
 *		   }
 *	STATUS	   current
 *	DESCRIPTION
 *		"A ciscoPingCompleted trap is sent at the completion
 *		of a sequence of pings if such a trap was requested
 *		when the sequence was initiated.  In addition to the
 *		above listed objects (which are always present),
 *		the message will also contain the following objects
 *		if any responses were received:
 *			ciscoPingMinRtt
 *			ciscoPingAvgRtt
 *			ciscoPingMaxRtt"
 * 	::= { ciscoPingMIBTraps 1 }
 */

#define MIN_TRAP_VARBIND_COUNT 3
#define MAX_TRAP_VARBIND_COUNT 6
#define TRAP_NUMBER 1

/*
 * The OID that identifies the SNMPv2 trap
 */
static const OID trapOID = 
    {LNciscoPingCompletion, (ulong *)IDciscoPingCompletion};

/*
 * The OID that identifies the SNMPv1 enterprise. This is identical to the
 * SNMPv2 trap OID with the last two subidentifiers removed
 */
static const OID enterpriseOID =
    {LNciscoPingCompletion - 2, (ulong *)IDciscoPingCompletion};

static const OID trap_varbinds[MAX_TRAP_VARBIND_COUNT] = {
    {LNciscoPingCompleted, (ulong *)IDciscoPingCompleted},
    {LNciscoPingSentPackets, (ulong *)IDciscoPingSentPackets},
    {LNciscoPingReceivedPackets, (ulong *)IDciscoPingReceivedPackets},
    {LNciscoPingMinRtt, (ulong *)IDciscoPingMinRtt},
    {LNciscoPingAvgRtt, (ulong *)IDciscoPingAvgRtt},
    {LNciscoPingMaxRtt, (ulong *)IDciscoPingMaxRtt}};

/*
 * ping completion trap
 * called when a ping has completed and a completion trap was requested
 */
static void
snmp_ping_completion_trap (ciscoPingEntry_t *entry)
{
    int         vbIndex;
    int		vbCount;
    OID        *vbList[MAX_TRAP_VARBIND_COUNT+1];
    OID         instanceOID;
    ulong       instance[1];
    char	trapoid_str[80];

    /*
     * For some unknown reason, SNMP Research made all the object
     * identifier parameters (OID *) *except* for the SNMPv2
     * trap identifier which is (char *).  It is much easier for
     * us to use the mib-compiler generate OID structure, so
     * we'll just convert that into a string.
     */
    if (MakeDotFromOID((OID *)&trapOID, trapoid_str) == -1) {
	return;
    }	

    /*
     * All the trap varbind objects have an instance described by
     * INDEX { ciscoPingSerialNumber }
     */
    instance[0] = entry->ciscoPingSerialNumber;
    instanceOID.oid_ptr = instance;
    instanceOID.length = 1;

    /*
     * The actual number of varbinds is based on whether or not any
     * ping responses were received
     */
    if (entry->ciscoPingReceivedPackets) {
	vbCount = MAX_TRAP_VARBIND_COUNT;
    } else {
	vbCount = MIN_TRAP_VARBIND_COUNT;
    }

    /*
     * create the varbind list
     */
    for (vbIndex = 0; vbIndex < vbCount; vbIndex++) {
        vbList[vbIndex] = CatOID((OID *) &trap_varbinds[vbIndex],
				 &instanceOID);
    }
    vbList[vbIndex] = NULL;

    /*
     * tell snmp to do something
     */
     snmp_trap(ENTERPRISE_TRAP, TRAP_NUMBER, vbList,
	       (OID *)&enterpriseOID, trapoid_str);

    /*
     * free data allocated by the CatOID service
     */
    for (vbIndex = 0; vbIndex < vbCount; vbIndex++) {
        FreeOID(vbList[vbIndex]);
    }
}

      
