/* $Id: sr_snmpengine.c,v 3.10.20.3 1996/07/12 23:29:09 jjohnson Exp $
 * $Source: /release/112/cvs/Xsys/snmp/sr_snmpengine.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * February 1994, SNMP Research
 *
 * Copyright (c) 1994-1997 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_snmpengine.c,v $
 * Revision 3.10.20.3  1996/07/12  23:29:09  jjohnson
 * CSCdi62131:  Need a mechanism to support logical snmp entities
 * Branch: California_branch
 *
 * Revision 3.10.20.2  1996/03/28  16:47:04  jjohnson
 * CSCdi50399:  SNMP can drive CPU utilization to over 90%
 * Make SNMP processes default to low priority, and add a hidden config
 * command to allow customers to change it
 * Branch: California_branch
 *
 * Revision 3.10.20.1  1996/03/18  21:49:05  gstovall
 * Branch: California_branch
 * Elvis has left the building.  He headed out to California, and took the
 * port ready changes with him.
 *
 * Revision 3.9.2.2  1996/03/07  12:34:09  mdb
 * Branch: DeadKingOnAThrone_branch
 * cisco and ANSI/POSIX libraries.
 *
 * Revision 3.9.2.1  1996/02/20  17:15:13  dstine
 * Branch: DeadKingOnAThrone_branch
 *           Sync from DeadKingOnAThrone_baseline_960122 to
 *                     DeadKingOnAThrone_baseline_960213
 *
 * Revision 3.10  1996/01/31  23:26:46  jjohnson
 * CSCdi47892:  SNMP oid translation table needs to be modularized
 *
 * Revision 3.9  1996/01/20  02:36:08  jjohnson
 * CSCdi47220:  need snmp packet debugging
 *
 * Revision 3.8  1996/01/18  16:38:00  jjohnson
 * CSCdi45754:  snmp subsystem should not contain non-snmp mibs
 * move the rs232 mib, image mib, and terminal services mib into separate
 * subsystems.  move the cisco interfaces mib into the interfaces mib
 * subsystem.  consolidate the snmp timer subsystem into the snmp
 * subsystem since it really is core snmp technology.
 *
 * Revision 3.7  1996/01/17  19:46:15  jjohnson
 * CSCdi47027:  Need mechanism for debugging snmp timers
 *
 * Revision 3.6  1995/12/28  22:35:51  mordock
 * CSCdi46168:  improve snmp modularity
 * move some code and globals out of the kernel subsystem and back into
 * the snmp subsystem
 *
 * Revision 3.5  1995/12/14  08:27:40  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.4  1995/11/24  16:41:18  jjohnson
 * CSCdi42637:  platform-specific code should be moved out of sub_snmp
 * Install an API for accessing platform-specific SNMP objects
 *
 * Revision 3.3  1995/11/20  22:27:38  sdurham
 * CSCdi42520:  IF MIB breaks modularity in oddball images
 *        fixed IFMIB subsystem, and moved linkUp/Down trap code to IFMIB.
 *
 * Revision 3.2  1995/11/17  19:01:20  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  13:18:06  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.7  1995/11/08  21:26:08  shaker
 * Merge Arkansas_branch into 11.1 mainline.
 *
 * Revision 2.6  1995/09/06  20:40:33  jjohnson
 * CSCdi39761:  SNMP authentication trap locks up the SNMP task
 * Back out the hack that only addressed the snmp authentication failure
 * trap.  Replace it with a real fix that handles any trap that is being
 * generated by the process that already has exclusive access to the SNMP
 * engine.
 *
 * Revision 2.5  1995/08/22  17:18:20  jjohnson
 * CSCdi39126:  SNMP should use new primitives for mutual exclusion
 *
 * Revision 2.4  1995/08/17  04:24:40  bchan
 * CSCdi36821:  SNMP trap process started without SNMP being configured
 *
 * Revision 2.3  1995/07/17  07:34:08  bchan
 * CSCdi34760:  Ifindex usage incorrect
 *
 * Revision 2.2  1995/06/28  10:22:00  smackie
 * Subsystem header cleanup. Round up the last few stragglers and rope 'em
 * in with the rest of the herd. (CSCdi23568)
 *
 * Revision 2.1  1995/06/07  22:50:45  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1993 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

/*
 * snmpengine.c - An SNMP agent packet processing engine
 */


#define MAIN

#include "master.h"
#include <ciscolib.h>
#include "subsys.h"
#include "sys_registry.h"
#include "address.h"

#include "sr_snmpd.h"
#include "snmp_debug.h"
#include "sr_config.h"
#include "sr_objectdb.h"
#include "snmp_registry.h"
#include "../parser/parser_defs_snmp.h"
#include "sr_sysmib2.h"
#include "sr_pingmib.h"
#include "sr_snmpmib2.h"
#include "sr_old_lchassismib.h"
#include "sr_old_lcpumib.h"
#include "sr_old_lmemmib.h"
#include "sr_old_lsysmib.h"
#include "snmp_trap_fe.h"
#include "sr_tmq.h"

#ifdef SR_SNMPv2
#include "sr_snmpv2mib.h"
#endif				/* SR_SNMPv2 */

/* constant cisco enterprise oid */
#define SNMPPART_DECL
#define N_cisco
#include "sr_lsmi.h"
const OID ciscoOID = {LNcisco, (ulong *)IDcisco};
#undef SNMPPART_DECL


/* globals */

process_priority_t snmp_priority;
boolean snmp_shutdown;
ipaddrtype snmp_bad_addr;
boolean snmp_nosparse;       /* disable sparse tables in ifmib
			     implementation */

#ifdef	SR_SNMPv2
unsigned long   last_security_check;
int             partyMibNotActiveFlag;
int             writePartyFlag;
#endif				/* SR_SNMPv2 */

/*
 * The following provides exclusive access to the snmp engine
 * since snmp method routines are not reentrant
 */

watched_semaphore *snmp_semaphore;
pid_t snmp_semaphore_pid;


static addrtype packet_source_address;
static addrtype *
snmp_src_address(void)
{
    return &packet_source_address;
}

void
snmp_engine (addrtype      *src_address,
	     unsigned char *in_packet,
	     unsigned int   in_packet_len,
	     unsigned char *out_packet,
	     unsigned int  *out_packet_len)

{
    unsigned short  result_len;

#ifdef SR_SNMPv2
    unsigned long   current_time;
#endif				/* SR_SNMPv2 */

    /*
     * the snmp engine is not re-entrant
     * get an exclusive lock on the engine
     */
    process_lock_semaphore(snmp_semaphore, MAXULONG);
    process_get_pid(&snmp_semaphore_pid);

    /*
     * stash away the source address of the message
     */
    bcopy(src_address, &packet_source_address, sizeof(addrtype));

#ifdef SR_SNMPv2
    /*
     * Check the current time and see whether the security tables need to
     * be checked.
     */
    if (partyMibNotActiveFlag == TRUE) {
	current_time = GetTimeNow() / 100;

	if ((current_time - last_security_check) > SR_MAX_TIMEOUT) {
	    DPRINTF((APTRACE, "snmpd: checking security tables. . .\n"));
	    partyMibNotActiveFlag = CheckSecurityTables(current_time);
	    last_security_check = current_time;
	}
    }
#endif				/* SR_SNMPv2 */

    /*
     * so that we don't have to change a bunch of SNMP Research code,
     * we do something really gross.  We pass a pointer to the generic
     * source address addrtype structure through the source ip address
     * paramater.  This paramater is only used once, specificially
     * when authenticating the address in sr_mgmt.c.  At that point we
     * cast it back to an addrtype pointer and then validate it
     */
    result_len = do_mgmt(in_packet,
			 in_packet_len,
			 (ulong) src_address,	/* input address */
			 0,			/* dummy input udp port */
			 0,			/* dummy output ip address */
			 0,			/* dummy output udp port */
			 out_packet,
			 *out_packet_len);
    *out_packet_len = (unsigned int) result_len;


   /*
    * Send the response.
    */

    if (*out_packet_len > 0) {
	snmpData.snmpOutPkts++;

#ifdef SR_SNMPv2
	if (writePartyFlag == TRUE) {
	    (void) WriteParties();
	    writePartyFlag = FALSE;
	}
#endif				/* SR_SNMPv2 */
    }

    /*
     * done with the snmp engine, release the lock
     */
    process_unlock_semaphore(snmp_semaphore);
    snmp_semaphore_pid = NO_PROCESS;

}				/* main */


static void
snmp_register_thyself(void)
{
    /* Support for Method Routines */
    reg_add_OctetStringToIP(OctetStringToIP, "OctetStringToIP");
    reg_add_OctetStringToUlong(OctetStringToUlong, "OctetStringToUlong");

    reg_add_snmp_engine(snmp_engine, "snmp_engine");
    reg_add_snmp_packet_source(snmp_src_address, "snmp_src_address");
    reg_add_restarted(snmp_coldstart_trap, "snmp_coldstart_trap");
    reg_add_setup_common(snmp_setup_common, "snmp_setup_common");


}

static const char snmpauth_trap_oid[] = "snmpTraps.5";
static const char coldstart_trap_oid[] = "snmpTraps.1";

/* make sure their copyright notice is in the image */
static const char SNMP_RESEARCH_BANNER1[] = STARTUP_BANNER_1;
static const char SNMP_RESEARCH_BANNER2[] = STARTUP_BANNER_2;

static void
snmp_engine_init(subsystype *subsys)
{
    /*
     * initialize the mib object database
     */
    init_var();
    init_oid();

    /*
     * create the trap registration queue
     */
    queue_init(&trap_registrationQ, 0);

    /*
     * initialize the object resources
     */
    snmp_resource_init();

    /*
     * initialize some globals
     */
    snmp_shutdown = FALSE;
    snmp_bad_addr = 0;
  
    snmp_nosparse = FALSE;
    snmp_priority = SNMP_PRIORITY_DEF;

    /*
     * Register some functions
     */
    snmp_register_thyself();

    /*
     * Initialize snmp parser routines
     */
    snmp_debug_init();
    snmp_parser_init();
    snmp_parse_config_init();

    /*
     * Initialize snmp timer task
     */
    init_snmp_timers();

    /*
     * Tell myself what traps I support
     */
    register_snmp_trap(TRAP_SNMP, coldstart_trap_oid);
    register_snmp_trap(TRAP_SNMP, snmpauth_trap_oid);

    /*
     * Initialize other data structures
     */
    snmpData.snmpEnableAuthenTraps = D_snmpEnableAuthenTraps_disabled;

#ifdef SR_SNMPv2
    snmpTrapData.snmpV2EnableAuthenTraps = SNMPv2_TRAPS_DISABLED;
    snmpORData.snmpORLastChange = 0L;
    snmpSetData.snmpSetSerialNo = 0L;
    last_security_check = GetTimeNow() / 100;
    partyMibNotActiveFlag = FALSE;
    writePartyFlag = FALSE;
#endif				/* SR_SNMPv2 */

#ifdef	SR_SNMPv2
    basetime = BaseClock();
    InitSecure();
    snmp_admin_init();
#endif				/* SR_SNMPv2 */

    init_sysmib2();
    init_snmpmib2();
    init_pingmib();
    init_old_lchassismib();
    init_old_lcpumib();
    init_old_lmemmib();
    init_old_lsysmib();
    init_snmp_trap();

#ifdef	SR_SNMPv2
    init_snmpv2mib();
#endif				/* SR_SNMPv2 */


    reg_invoke_snmp_init();

    snmp_semaphore = create_watched_semaphore("SNMP Semaphore", 0);
    snmp_semaphore_pid = NO_PROCESS;
}

/*
 * SNMP subsystem header
 */

#define SNMP_MAJVERSION 2
#define SNMP_MINVERSION 0
#define SNMP_EDITVERSION  0

SUBSYS_HEADER(snmp, SNMP_MAJVERSION, SNMP_MINVERSION, SNMP_EDITVERSION,
              snmp_engine_init, SUBSYS_CLASS_PROTOCOL,
              "seq: iphost,iprouting",
              NULL);
