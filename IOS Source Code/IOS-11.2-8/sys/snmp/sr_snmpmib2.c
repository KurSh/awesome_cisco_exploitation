/* $Id: sr_snmpmib2.c,v 3.4.10.2 1996/07/01 18:46:19 hampton Exp $
 * $Source: /release/112/cvs/Xsys/snmp/sr_snmpmib2.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * February 1994, Jeffrey T. Johnson (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1994-1996 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_snmpmib2.c,v $
 * Revision 3.4.10.2  1996/07/01  18:46:19  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.4.10.1  1996/04/19  17:46:50  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.4  1996/02/23  17:08:52  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.3  1995/12/14  08:27:41  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.2  1995/11/17  19:01:22  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  13:18:07  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.1  1995/06/07  22:50:48  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1993 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */
#include "master.h"
#include "../snmp/snmp_api.h"
#include "sr_snmpmib2.h"
#include "sr_snmpmib2-mib.h"

snmp_t snmpData;

void
init_snmpmib2(void)
{
    load_mib(snmpmib2_OidList, snmpmib2_OidListNum);
    load_oid(snmpmib2_oid_table);
}





/*----------------------------------------------------------------------
 * Retrieve data from the snmp group. This is performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be reuturned.
 *----------------------------------------------------------------------*/
VarBind        *
snmp_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = -1;
    
    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1 and the single
     * instance element be 0.
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically preceed the current object type.
     */
    
    switch (searchType) {
    case EXACT:
	if (instLength == 1 && incoming->oid_ptr[incoming->length - 1] == 0) {
	    arg = object->nominator;
	}
	break;
	
    case NEXT:
	if (instLength <= 0) {
	    arg = object->nominator;
	}
	break;
	
    default:
	DPRINTF((0, "snmpd: Internal error. (invalid search type in \
snmp_get -- %d\n", searchType));
    }				/* switch */
    
    if (arg == -1) {
	return ((VarBind *) NULL);
    }
    else {
	return (MakeVarBind(object, &ZeroOid, SR_OFFSET(&snmpData, arg)));
    }
}


#ifdef SETS
/*----------------------------------------------------------------------
 * Free the snmp data object.
 *----------------------------------------------------------------------*/
void
snmp_free(snmp_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * Cleanup after snmp set/undo.
 *----------------------------------------------------------------------*/
static int
snmp_cleanup(doList_t *trash)
{
    snmp_free(trash->data);
    
#ifdef SR_SNMPv2
    snmp_free(trash->undodata);
#endif				/* SR_SNMPv2 */
    
    return NO_ERROR;
}


/*----------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET requet to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *----------------------------------------------------------------------*/
int
snmp_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             inst_length = incoming->length - object->oid.length;
    
    /*
     * Validate the object instance: 1) It must be of length 1 2) and the
     * instance must be 0.
     */
    
    if (inst_length != 1 || incoming->oid_ptr[incoming->length - 1] != 0) {
	DPRINTF((APTRACE, "snmpd: Invalid instance\n"));
	return (NO_CREATION_ERROR);
    }
    
    /*
     * Add the SET request to the do-list element. Test the validity of the
     * value at this point.
     */
    
    (doCur->data) = malloc(sizeof(snmp_t));
    if (doCur->data == (void *) NULL) {
	DPRINTF((0, "snmpd: cannot allocate memory\n"));
	return (GEN_ERROR);
    }
    ZERO_VALID(((snmp_t *) (doCur->data))->valid);
    
    doCur->setMethod = snmp_set;
    doCur->cleanupMethod = snmp_cleanup;
    doCur->state = UNKNOWN;
    
    switch (object->nominator) {
	
#ifdef I_snmpEnableAuthenTraps
    case I_snmpEnableAuthenTraps:
	if (value->sl_value != D_snmpEnableAuthenTraps_enabled &&
	    value->sl_value != D_snmpEnableAuthenTraps_disabled) {
	    
	    return (WRONG_VALUE_ERROR);
	}
	
	SET_VALID(I_snmpEnableAuthenTraps, ((snmp_t *) (doCur->data))->valid);
	((snmp_t *) (doCur->data))->snmpEnableAuthenTraps = value->sl_value;
	break;
#endif
	
    default:
	DPRINTF((0, "snmpd: Internal error (invalid nominator \
in snmp_test)\n"));
	return (GEN_ERROR);
    }				/* switch */
    
    doCur->state = ADD_MODIFY;
    
    return (NO_ERROR);
}


/*----------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *
 * Note: In this case all related items are contained in the
 *    structure pointed to by "doCur->data," but in the more
 *    general case, this routine may need to scan the do-list to
 *    determine if there are other "related" objects. This is
 *    not recommended but is included for maximum flexibility.
*----------------------------------------------------------------------*/
int
snmp_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    /* it's already tested... just do it */
    snmpData.snmpEnableAuthenTraps =
	((snmp_t *) doCur->data)->snmpEnableAuthenTraps;
    
    return (NO_ERROR);
}

#endif
      
