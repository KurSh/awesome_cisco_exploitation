/************************************************************************
 *                                                                      *
 *                              NOTE WELL                               *
 * This is vendor-supplied and vendor-supported code.  Do not make any  *
 * modifications to this code without the knowledge and consent of the  *
 * SNMP agent group.                                                    *
 *                                                                      *
 ************************************************************************/
/* $Id: sr_v_acl.c,v 3.2.60.1 1996/04/19 17:46:54 jjohnson Exp $
 * $Source: /release/112/cvs/Xsys/snmp/sr_v_acl.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * February 1994, SNMP Research
 *
 * Copyright (c) 1994-1997 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_v_acl.c,v $
 * Revision 3.2.60.1  1996/04/19  17:46:54  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.2  1995/11/17  19:01:58  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  13:18:33  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.1  1995/06/07  22:51:18  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */
/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

/*
 *                PROPRIETARY NOTICE
 *
 * This software is an unpublished work subject to a confidentiality agreement
 * and is protected by copyright and trade secret law.  Unauthorized copying,
 * redistribution or other use of this work is prohibited.
 *
 * The above notice of copyright on this source code product does not indicate
 * any actual or intended publication of such source code.
 *
 */

#if (! ( defined(lint) ) && defined(SR_RCSID))
static char     rcsid[] = "v_acl.c,v 1.11 1995/02/06 18:11:43 battle Exp";
#endif				/* (! ( defined(lint) ) && defined(SR_RCSID)) */

/*
 * Revision History:
 *
 * v_acl.c,v
 * Revision 1.11  1995/02/06  18:11:43  battle
 * Changes for vrtx.
 *
 * Revision 1.10  1994/10/28  17:32:26  vaughn
 * Placed new copyright in the file
 *
 * Revision 1.9  1994/10/26  21:58:48  vaughn
 * Changed copyrights to the new copyright structure
 *
 * Revision 1.8  1994/09/30  16:11:30  battle
 * hprt changes
 *
 * Revision 1.7  1994/08/04  15:37:44  battle
 * pSOS 2.0 changes
 *
 * Revision 1.6  1994/04/18  18:28:51  battle
 * pSOS changes
 *
 * Revision 1.5  1994/02/14  16:42:26  pearson
 * Updated copyright notices for 1994.
 *
 * AMP
 *
 * Revision 1.4  1994/02/08  00:10:11  pearson
 * Here's a brief description of the changes in this commit of the source
 * tree:
 * 	The structure of the packaged tree has changed somewhat.
 * 	Assembly language files and system-specific startup code are in
 * 	the pkg/lib/sys directory.  There is a 'serial' directory which
 * 	contains rs232 code for all of the different platforms.
 *
 * 	Uart code has a more uniform initialization call now.  For
 * 	example, init_uart() is mapped to init code for different uarts
 * 	on different systems.
 *
 * 	The national semiconductor "rib" code is in this release, along
 * 	with support for the debug/rt debugger and paradigm locate.
 * 	That created some new directories in the pkg/cmd tree.  There is
 * 	support now for a sonic driver, the ethernet repeater mib, and
 * 	sonic/ric statistics.
 *
 * 	The dos agent and utilities now configure themselves from an
 * 	ascii text file, rather than a "device driver".
 *
 * 	Various parts of the standard agent have had large stack
 * 	variables moved to malloc-ed structures to save room.
 *
 * 	Some bugs which were exposed by the marshall/levi test tool have
 * 	been fixed.
 *
 * 	Two new hello programs have been created.  Hello3 is essentially
 * 	a ping server, which allows embedded developers to test their
 * 	network stack, and hello4 allows tests of bootp and tftp.
 *
 * 	Some new routines have been added to the pkg/lib/c directory.
 * 	Dmemdump dumps memory in hex and in ascii.  32-bit versions of
 * 	memcpy, memset, etc have been created.
 *
 * Revision 1.3  1993/12/23  18:38:46  battle
 * Added cvs headers to all .c and .h files.
 *
 *
 *  22-Jun-92 MGH
 *  method routines for acl table.
 *
 *  9-July-92 MRD
 *  Ifdef the whole thing - this allows for dumb makefiles that
 *  try to compile this file even when security is not used.
 *
 *  22-July-92 MGH
 *  Put a check into aclEntry_test that makes sure that aclSubject and
 *  aclTarget are using the same authentication protocol(partyAuthProtocol).
 *  Changed the default value for aclPrivileges to GET + GET_NEXT + GET_BULK.
 *
 *  13-Aug-92 MGH
 *  In aclEntry_set, added call to WriteAclFile, which saves changes to the
 *  acl table.
 *
 *  9-Dec-1992 DLB
 *    Lint nits.
 *
 *  21-Dec-1992 MGH
 *    Changed all calls of CmpNOID() to CmpOID()
 *    Started adding the changes made by the new security drafts.
 *
 *  7-Jan-1993 MGH
 *    Continued making changes in aclEntry_get (reflecting changes in the
 *    new security drafts).
 *
 *  25-Jan-1993 MGH
 *  Started revising aclEntry_set and aclEntry_test to reflect the new
 *  security drafts.
 *
 *  7-May-1993 MGH
 *  Changed the name of the reqId parameter to serialNum.
 *
 *  28-May-1993 MGH
 *  Code maintenance
 *
 *  2-June-1993 MGH
 *  Changed the call to WriteAclFile().  There are now no arguments to
 *  WriteAclFile().
 *
 *  4-June-1993 MGH
 *  Added a free call in aclEntry_free() for data->acl.
 *
 * 15-June-93 MGH
 * Changed the method of accessing the acl table.  There is now an array
 * of pointers that point to separately malloced acl structures.  When
 * adding a new acl row, the new acl row is malloced separately, and
 * the array is realloced if another entry in the array is needed.
 * Should be able to add as many new acl rows as memory will allow.
 *
 * Also had the aclEntry_test routine set dp->state to DELETE if
 * aclStatus is set to DESTROY. Added case statement to aclEntry_set.
 *
 * 18-June-93 MGH
 * Added an external global variable, partyMibNotActiveFlag.  It's set to
 * TRUE if there are any non active rows in the table.
 *
 * 28-June-1993 MGH
 * Changed all references of "asod" to "contextInfo".  The
 * variable is now a ContextInfo variable.
 *
 * 1-July-1993 MGH
 * Added a check in aclEntry_get().  If aclStatus is ACTIVE or NOT_IN_SERVICE,
 * it makes sure the parties aclTarget and aclSubject point to are still
 * ACTIVE and that the context aclResources points to is still ACTIVE.
 *
 * 20-Jul-1993 DAR
 *   Removed searchType parameter to calls to scalar k_ get routines
 *   Added nominator parameter to all calls to k_ get routines.
 *   Removed valid paramter from all calls to k_ set routines.
 *   changed test methods to use valid field defined in snmptype.h
 *
 * Jan-28-1994 AMP
 *   Fixed an obscure memory leak in aclEntry_get(), where an exact search on
 *   an instance OID of length != 3 caused an OID to be allocated but not
 *   freed.  The solution was just to get out of the get routine as soon as
 *   it was determined that the input parameters couldn't be matched.
 */

#include "master.h"

#include "sr_snmpd.h"

#ifdef	SR_SNMPv2


#include "sr_diag.h"
#include "sr_snmpv2mib.h"

extern int      partyMibNotActiveFlag;

typedef struct _ACL_TABLE {
    aclEntry_t     *acl;
    OID            *acl_instance;
} ACL_TABLE;

/*----------------------------------------------------------------------
 * Retrieve data from the aclEntry group. This is performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *----------------------------------------------------------------------*/
VarBind        *
aclEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = -1;
    int             i;
    int             found;
    int             sub_pos, tgt_pos, context_pos;
    unsigned long   bestBuf[3];
    void           *dp;
    OID            *acl_instance;
    OID            *best;
    OID            *aclInst;
    VarBind        *retval;

    found = -1;
    best = NULL;

    /*
     * Check the object instance
     * 
     * An EXACT search requires that the instance be of the form:
     * aclTarget.aclSubject.aclResources, where aclTarget and aclSubject are
     * indexes for the party table (partyIndex), and aclResources is an index
     * for the context table (contextIndex).  The instance must have a length
     * of 3.
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    switch (searchType) {
      case EXACT:
	if (instLength == 3) {
	    arg = object->nominator;
	}
	else {
	    return ((VarBind *) NULL);
	}
	break;

      case NEXT:
	arg = object->nominator;
	break;
      default:
	DPRINTF((APERROR, "snmpd: Internal error. Invalid search type in \
aclEntry_get -- %d\n", searchType));
    }				/* switch */


    /*
     * Retrieve the data from the acl table and return the instance if
     * successful.
     */

    /*
     * Determine instance OID -- first sub-field after name
     */

    if (CmpOIDClass(incoming, &object->oid) == 0) {
	if (instLength > 0) {
	    if ((acl_instance = (OID *) malloc(sizeof(OID))) == NULL) {
		DPRINTF((APWARN, "snmpd: malloc failure in aclEntry_get\n"));
		return ((VarBind *) NULL);
	    }
	    acl_instance->oid_ptr = NULL;
	    acl_instance->length = instLength;

	    if ((acl_instance->oid_ptr = (unsigned long *)
		 malloc((unsigned) (acl_instance->length * sizeof(unsigned long))))
		== NULL) {
		DPRINTF((APWARN, "snmpd: malloc failure in aclEntry_get\n"));
		FreeOID(acl_instance);
		acl_instance = NULL;
		return ((VarBind *) NULL);
	    }

	    for (i = 0; i < acl_instance->length; i++) {
		acl_instance->oid_ptr[i] =
		    incoming->oid_ptr[i + object->oid.length];
	    }
	}
	else {
	    if ((acl_instance = MakeOIDFromDot("0.0.0")) == NULL) {
		DPRINTF((APWARN, "snmpd: malloc failure for 0.0.0 in aclEntry_get\n"));
		return ((VarBind *) NULL);
	    }
	}
    }
    else {
	if ((acl_instance = MakeOIDFromDot("0.0.0")) == NULL) {
	    DPRINTF((APWARN, "snmpd: malloc failure for 0.0.0 in aclEntry_get\n"));
	    return ((VarBind *) NULL);
	}
    }


    /*
     * Now scan the acl table
     */

    if (arg != -1) {
	if (searchType == EXACT) {
	    best = NULL;
	    aclInst = NULL;
	    for (i = 0; i < num_acls; i++) {
		if (access_control[i].acl == NULL) {
		    continue;
		}
		/*
		 * The instances must match and the acl entry must be valid
		 */
		if ((access_control[i].acl->aclTarget == acl_instance->oid_ptr[0]) &&
		    (access_control[i].acl->aclSubject == acl_instance->oid_ptr[1]) &&
		    (access_control[i].acl->aclResources == acl_instance->oid_ptr[2]) &&
		    (access_control[i].acl->aclStatus != DESTROY)) {
		    bestBuf[0] = access_control[i].acl->aclTarget;
		    bestBuf[1] = access_control[i].acl->aclSubject;
		    bestBuf[2] = access_control[i].acl->aclResources;
		    if (best != NULL) {
			FreeOID(best);
			best = NULL;
		    }
		    if ((best = MakeOID(bestBuf, (short) 3)) == NULL) {
			DPRINTF((APWARN, "aclEntry_get: malloc failure for best\n"));
			FreeOID(acl_instance);
			acl_instance = NULL;
			return ((VarBind *) NULL);
		    }
		    found = i;
		    break;
		}
	    }			/* for */
	}			/* if searchType */

	else {			/* searchType == NEXT */
	    best = NULL;
	    aclInst = NULL;
	    for (i = 0; i < num_acls; i++) {
		FreeOID(aclInst);
		aclInst = NULL;
		if (access_control[i].acl == NULL) {
		    continue;
		}
		bestBuf[0] = access_control[i].acl->aclTarget;
		bestBuf[1] = access_control[i].acl->aclSubject;
		bestBuf[2] = access_control[i].acl->aclResources;

		if ((aclInst = MakeOID(bestBuf, (short) 3)) == NULL) {
		    DPRINTF((APWARN, "aclEntry_get: malloc failure for aclInst\n"));
		    FreeOID(best);
		    best = NULL;
		    FreeOID(acl_instance);
		    acl_instance = NULL;
		    return ((VarBind *) NULL);
		}


		/*
		 * best = thisone if ((incoming > thisone) && (thisone <
		 * best) && (valid entry))
		 */
		if ((CmpOID(aclInst, acl_instance) > 0)
		    && ((best == NULL) ||
			(CmpOID(aclInst, best) < 0)) &&
		    (access_control[i].acl->aclStatus != DESTROY)) {
		    FreeOID(best);
		    best = NULL;
		    if ((best = CloneOID(aclInst)) == NULL) {
			DPRINTF((APWARN, "aclEntry_get: malloc failure for best\n"));
			FreeOID(aclInst);
			aclInst = NULL;
			FreeOID(acl_instance);
			acl_instance = NULL;
			return ((VarBind *) NULL);
		    }
		    found = i;
		}		/* if match */
	    }			/* for */
	}			/* else searchType */

	FreeOID(acl_instance);
	acl_instance = NULL;
	FreeOID(aclInst);
	aclInst = NULL;

	if (searchType == EXACT) {
	    if (i == num_acls) {/* Not found by the end of the table */
		DPRINTF((APTRACE, "aclEntry_get: exact search failed.\n"));
		return ((VarBind *) NULL);
	    }
	}

	else {
	    if (best == NULL) {
		DPRINTF((APTRACE, "aclEntry_get: next search failed.\n"));
		return ((VarBind *) NULL);
	    }
	}

    }				/* if arg != -1 */

    switch (arg) {

#ifdef I_aclPrivileges
      case I_aclPrivileges:
	dp = (void *) &access_control[found].acl->aclPrivileges;
	break;
#endif				/* I_aclPrivileges */

#ifdef I_aclStorageType
      case I_aclStorageType:
	dp = (void *) &access_control[found].acl->aclStorageType;
	break;
#endif				/* I_aclStorageType */

#ifdef I_aclStatus
      case I_aclStatus:
	/*
	 * Check to see if this row needs to revert to NOT_READY.  Should
	 * only happen if the entries pointed to by aclTarget, aclSubject, or
	 * aclResources are not ACTIVE.
	 */
	if (access_control[found].acl->aclStatus != NOT_READY) {
	    tgt_pos = GetPartyLocation(access_control[found].acl->aclTarget);
	    sub_pos = GetPartyLocation(access_control[found].acl->aclSubject);
	    context_pos = GetContextEntry(access_control[found].acl->aclResources);
	    if ((tgt_pos == -1) || (sub_pos == -1) || (context_pos == -1)) {
		DPRINTF((APTRACE, "aclEntry_get: Need to change status to notReady.\n"));
		if (access_control[found].acl->aclStatus == ACTIVE) {
		    access_control[found].last_active = GetTimeNow() / 100;
		    partyMibNotActiveFlag = TRUE;
		}
		access_control[found].acl->aclStatus = NOT_READY;
	    }
	}
	dp = (void *) &access_control[found].acl->aclStatus;
	break;
#endif				/* I_aclStatus */

      default:
	DPRINTF((APWARN, "snmpd: Invalid variable in aclEntry_get: object: %d arg: %d\n",
		 object->nominator, arg));
	return ((VarBind *) NULL);
    }

    retval = MakeVarBind(object, best, dp);
    FreeOID(best);
    best = NULL;

    return (retval);

}				/* aclEntry_get() */

#ifdef SETS
static void aclEntry_freex SR_PROTOTYPE((ACL_TABLE *data));

static void
aclEntry_freex(data)
    ACL_TABLE      *data;
{
    if (data != NULL) {
	if (data->acl_instance != NULL) {
	    FreeOID(data->acl_instance);
	    data->acl_instance = NULL;
	}
	if (data->acl != NULL) {
	    free((char *) data->acl);
	    data->acl = NULL;
	}
	free((char *) data);
	data = NULL;
    }
}				/* aclEntry_freex() */

/*----------------------------------------------------------------------
 * Cleanup after acl set/undo.
 *----------------------------------------------------------------------*/
static int aclEntry_cleanup SR_PROTOTYPE((doList_t *trash));

static int
aclEntry_cleanup(trash)
    doList_t       *trash;
{
    aclEntry_freex(trash->data);

#ifdef SR_SNMPv2
    aclEntry_freex(trash->undodata);
#endif				/* SR_SNMPv2 */

    return NO_ERROR;
}


/*----------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *----------------------------------------------------------------------*/
int
aclEntry_test(incoming, object, value, dolist_head, doCur, contextInfo)
    OID            *incoming;
    ObjectInfo     *object;
    ObjectSyntax   *value;
    doList_t       *dolist_head;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    int             instLength = incoming->length - object->oid.length;
    int             i;
    int             found, good_row;
    int             name_found;
    int             sub_pos, tgt_pos;
    int             context_pos, return_val;
    unsigned long   bestBuf[3];
    doList_t       *dp;
    ACL_TABLE      *acl_entry;
    OID            *acl_instance;
    OID            *best;

    /*
     * Validate the object instance. 1) It should be the proper length.(3) 2)
     * Validate the acl_instance.
     */
    if (instLength != 3) {
	DPRINTF((APTRACE, "snmpd: Invalid instance in aclEntry_test\n"));
	return (NO_CREATION_ERROR);
    }

    /*
     * Determine instance OID -- first sub-field after name
     */

    if (CmpOIDClass(incoming, &object->oid) == 0) {
	if ((acl_instance = (OID *) malloc(sizeof(OID))) == NULL) {
	    DPRINTF((APWARN, "snmpd: malloc failure in aclEntry_test\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	acl_instance->oid_ptr = NULL;
	acl_instance->length = instLength;

	if ((acl_instance->oid_ptr = (unsigned long *)
	  malloc((unsigned) (acl_instance->length * sizeof(unsigned long))))
	    == NULL) {
	    DPRINTF((APWARN, "snmpd: malloc failure in aclEntry_test\n"));
	    FreeOID(acl_instance);
	    acl_instance = NULL;
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}

	for (i = 0; i < acl_instance->length; i++) {
	    acl_instance->oid_ptr[i] =
		incoming->oid_ptr[i + object->oid.length];
	}
    }
    else {
	if ((acl_instance = MakeOIDFromDot("0.0.0")) == NULL) {
	    DPRINTF((APWARN, "snmpd: malloc failure for 0.0.0 in aclEntry_test\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
    }

    /*
     * Now scan the acl table
     */
    name_found = -1;
    best = (OID *) NULL;

    for (i = 0; i < num_acls; i++) {
	if (access_control[i].acl == NULL) {
	    continue;
	}
	if ((access_control[i].acl->aclTarget == acl_instance->oid_ptr[0]) &&
	  (access_control[i].acl->aclSubject == acl_instance->oid_ptr[1]) &&
	(access_control[i].acl->aclResources == acl_instance->oid_ptr[2]) &&
	    (access_control[i].acl->aclStatus != DESTROY)) {
	    bestBuf[0] = access_control[i].acl->aclTarget;
	    bestBuf[1] = access_control[i].acl->aclSubject;
	    bestBuf[2] = access_control[i].acl->aclResources;
	    if (best != NULL) {
		FreeOID(best);
		best = NULL;
	    }
	    if ((best = MakeOID(bestBuf, (short) 3)) == NULL) {
		DPRINTF((APWARN, "aclEntry_test: cannot malloc best\n"));
		FreeOID(acl_instance);
		acl_instance = NULL;
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }
	    name_found = i;
	    break;
	}			/* if ((access_control .... ) */
    }				/* for */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = dolist_head; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == aclEntry_set) &&
	    (((ACL_TABLE *) (dp->data)) != (ACL_TABLE *) NULL)) {
	    /*
	     * If best is non-null, a match was found.  If best matches a
	     * previous do-list element, the two elements are related and are
	     * part of an entry in the table.
	     */
	    if ((((ACL_TABLE *) (dp->data))->acl_instance != (OID *) NULL) &&
		(best != (OID *) NULL)) {
		if (CmpOID(((ACL_TABLE *) (dp->data))->acl_instance,
			   best) == 0) {
		    found = 1;
		    break;
		}
	    }
	    /*
	     * If best is null(no entry in the table), but the instance for
	     * this do-list element matches a previous do-list element, the
	     * two elements are related, and they need to be added to the
	     * table.
	     */
	    else if ((((ACL_TABLE *) (dp->data))->acl_instance != (OID *) NULL) &&
		     (best == (OID *) NULL)) {
		if (CmpOID(((ACL_TABLE *) (dp->data))->acl_instance,
			   acl_instance) == 0) {
		    found = 1;
		    break;
		}
	    }			/* else if */
	}			/* if dp->setMethod */
    }				/* for ( dp = dolist_head ... */

    /*
     * If a related do-list element was found, mark the one created for this
     * SET request with a NULL setMethod (this invalidates it).
     * 
     * Otherwise, there does not exist a related do-list element so fill-in the
     * do-list element with all known/default values.
     */

    if (!found) {
	dp = doCur;
	if ((dp->data = (void *) malloc(sizeof(ACL_TABLE))) == NULL) {
	    DPRINTF((APWARN, "aclEntry_test: Cannot allocate memory for dp->data"));
	    FreeOID(acl_instance);
	    acl_instance = NULL;
	    FreeOID(best);
	    best = NULL;
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset((char *) dp->data, 0, sizeof(ACL_TABLE));

	if ((((ACL_TABLE *) (dp->data))->acl =
	     (aclEntry_t *) malloc(sizeof(aclEntry_t))) == NULL) {
	    DPRINTF((APWARN, "aclEntry_test: Cannot allocate aclEntry_t\n"));
	    FreeOID(acl_instance);
	    acl_instance = NULL;
	    FreeOID(best);
	    best = NULL;
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset((char *) ((ACL_TABLE *) (dp->data))->acl, 0, sizeof(aclEntry_t));

	dp->setMethod = aclEntry_set;
	dp->cleanupMethod = aclEntry_cleanup;
	dp->state = UNKNOWN;

	/*
	 * Try to fill in reasonable default values for this new acl entry.
	 */

	if (name_found == -1) {
	    FreeOID(best);
	    best = NULL;

	    if ((((ACL_TABLE *) (dp->data))->acl_instance =
		 CloneOID(acl_instance)) == (OID *) NULL) {
		DPRINTF((APWARN, "aclEntry_test: cannot malloc acl_instance\n"));
		FreeOID(acl_instance);
		acl_instance = NULL;
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }
	    FreeOID(acl_instance);
	    acl_instance = NULL;

	    ((ACL_TABLE *) (dp->data))->acl->aclPrivileges =
		GET_MASK + GET_NEXT_MASK + BULK_MASK;
	    ((ACL_TABLE *) (dp->data))->acl->aclStorageType = NONVOLATILE;
	    ((ACL_TABLE *) (dp->data))->acl->aclStatus = DESTROY;

	    SET_ALL_VALID(((ACL_TABLE *) (dp->data))->acl->valid);
	}

	else {

	    if ((((ACL_TABLE *) (dp->data))->acl_instance =
		 CloneOID(best)) == (OID *) NULL) {
		DPRINTF((APWARN, "aclEntry_test: cannot malloc acl_instance\n"));
		FreeOID(acl_instance);
		acl_instance = NULL;
		FreeOID(best);
		best = NULL;
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }

	    FreeOID(best);
	    best = NULL;
	    FreeOID(acl_instance);
	    acl_instance = NULL;

	    ((ACL_TABLE *) (dp->data))->acl->aclPrivileges =
		access_control[name_found].acl->aclPrivileges;

	    ((ACL_TABLE *) (dp->data))->acl->aclStorageType =
		access_control[name_found].acl->aclStorageType;

	    ((ACL_TABLE *) (dp->data))->acl->aclStatus =
		access_control[name_found].acl->aclStatus;
	}
    }				/* if (!found) */
    else {
	FreeOID(best);
	best = NULL;
	FreeOID(acl_instance);
	acl_instance = NULL;
    }

    acl_entry = (ACL_TABLE *) (dp->data);

    switch (object->nominator) {

#ifdef I_aclPrivileges
      case I_aclPrivileges:
	if ((value->sl_value < 0) || (value->sl_value > TOTAL_MASK)) {
	    return (WRONG_VALUE_ERROR);
	}

	acl_entry->acl->aclPrivileges = value->sl_value;
	SET_VALID(I_aclPrivileges, acl_entry->acl->valid);
	break;
#endif				/* I_aclPrivileges */

#ifdef I_aclStorageType
      case I_aclStorageType:
	if ((value->sl_value != OTHER) && (value->sl_value != VOLATILE) &&
	    (value->sl_value != NONVOLATILE) &&
	    (value->sl_value != PERMANENT)) {
	    return (WRONG_VALUE_ERROR);
	}

	acl_entry->acl->aclStorageType = value->sl_value;
	SET_VALID(I_aclStorageType, acl_entry->acl->valid);
	break;
#endif				/* I_aclStorageType */

#ifdef I_aclStatus
      case I_aclStatus:
	if ((return_val = set_row_status(value->sl_value, name_found,
			     &(dp->state), &(acl_entry->acl->aclStatus))) !=
	    NO_ERROR) {
	    return (return_val);
	}
	SET_VALID(I_aclStatus, acl_entry->acl->valid);
	break;
#endif				/* I_aclStatus */

      default:
	DPRINTF((APWARN, "snmpd: Internal error. (test called on \
readOnly or unsupported object in aclEntry_test)\n"));
	return (RESOURCE_UNAVAILABLE_ERROR);
	break;
    }

    /*
     * Check to see if the two parties and context in the instance exist in
     * the party and context table, respectively.
     */
    tgt_pos = GetPartyLocation((long) acl_entry->acl_instance->oid_ptr[0]);
    sub_pos = GetPartyLocation((long) acl_entry->acl_instance->oid_ptr[1]);
    context_pos = GetContextEntry((long) acl_entry->acl_instance->oid_ptr[2]);

    if ((tgt_pos < 0) || (sub_pos < 0) || (context_pos < 0)) {
	DPRINTF((APTRACE,
		 "aclEntry_test: parties and/or context do not exist: \
tgt_pos: %d, sub_pos: %d, context_pos: %d\n", tgt_pos, sub_pos, context_pos));
	good_row = FALSE;
    }
    else {
	good_row = TRUE;
    }

    /*
     * Determine if all the fields of this row are now valid.
     */
    if (name_found == -1) {	/* adding a row */
	/*
	 * If the authentication protocols for the aclTarget and aclSubject
	 * are not identical, return INCONSISTENT_VALUE_ERROR.
	 */

	if ((sub_pos >= 0) && (tgt_pos >= 0)) {
	    if (parties[sub_pos].party->partyAuthProtocol !=
		parties[tgt_pos].party->partyAuthProtocol) {
		DPRINTF((APWARN, "aclEntry_test: auth protocols not equal.\n"));
		return (INCONSISTENT_VALUE_ERROR);
	    }
	}

	switch (acl_entry->acl->aclStatus) {
	  case CREATE_AND_WAIT:
	    if (good_row == TRUE) {
		acl_entry->acl->aclStatus = NOT_IN_SERVICE;
		SET_VALID(I_aclStatus, acl_entry->acl->valid);
	    }
	    else {
		acl_entry->acl->aclStatus = NOT_READY;
		SET_VALID(I_aclStatus, acl_entry->acl->valid);
	    }
	    dp->state = ADD_MODIFY;
	    break;
	  case NOT_READY:
	    if (good_row == TRUE) {
		acl_entry->acl->aclStatus = NOT_IN_SERVICE;
		SET_VALID(I_aclStatus, acl_entry->acl->valid);
	    }
	    dp->state = ADD_MODIFY;
	    break;
	  case CREATE_AND_GO:
	    if (good_row == TRUE) {
		dp->state = ADD_MODIFY;
	    }
	    else {
		dp->state = CREATE_AND_GO_STATE;
	    }
	    break;
	  case DESTROY:
	    dp->state = DELETE;
	    break;
	  case NOT_IN_SERVICE:
	    if (good_row != TRUE) {
		acl_entry->acl->aclStatus = NOT_READY;
		SET_VALID(I_aclStatus, acl_entry->acl->valid);
	    }
	    dp->state = ADD_MODIFY;
	    break;
	  default:
	    DPRINTF((APWARN, "aclEntry_test: Invalid aclStatus value.\n"));
	    return (INCONSISTENT_VALUE_ERROR);
	    break;
	}			/* end switch */
    }
    else {			/* modifying an existing row */
	switch (acl_entry->acl->aclStatus) {
	  case NOT_IN_SERVICE:
	    if (good_row == TRUE) {
		dp->state = ADD_MODIFY;
	    }
	    else {
		dp->state = NOT_READY_STATE;
	    }
	    break;
	  case DESTROY:
	    dp->state = DELETE;
	    break;
	  case NOT_READY:
	    if (good_row == TRUE) {
		acl_entry->acl->aclStatus = NOT_IN_SERVICE;
		SET_VALID(I_aclStatus, acl_entry->acl->valid);
	    }
	    dp->state = ADD_MODIFY;
	    break;
	  case ACTIVE:
	    if (good_row == TRUE) {
		dp->state = ADD_MODIFY;
	    }
	    else {
		dp->state = NOT_READY_STATE;
	    }
	    break;
	  default:
	    DPRINTF((APWARN, "aclEntry_test: Invalid aclStatus value.\n"));
	    return (INCONSISTENT_VALUE_ERROR);
	    break;
	}			/* end switch */

    }				/* else modifying an existing row */

    return (NO_ERROR);

}				/* aclEntry_test() */


/*----------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *
 * Note: In this case all related items are contained in the
 *    structure pointed to by "doCur->data," but in the more
 *    general case, this routine may need to scan the do-list to
 *    determine if there are other "related" objects. This is
 *    not recommended but is included for maximum flexibility.
 *----------------------------------------------------------------------*/
int
aclEntry_set(doHead, doCur, contextInfo)
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{

    ACL_TABLE      *acl_entry;
    V2_ACL         *temp_ptr;
    ACCESS         *new_acl;
    OID            *acl_instance;
    int             i;
    int             found, new_entry;
    int             open_slot;

    found = -1;
    temp_ptr = NULL;
    new_acl = NULL;
    new_entry = FALSE;
    acl_entry = (ACL_TABLE *) (doCur->data);
    acl_instance = acl_entry->acl_instance;

    switch (doCur->state) {
      case DELETE:
	for (i = 0; i < num_acls; i++) {
	    if (access_control[i].acl == NULL) {
		continue;
	    }
	    if ((access_control[i].acl->aclTarget == acl_instance->oid_ptr[0]) &&

		(access_control[i].acl->aclSubject == acl_instance->oid_ptr[1]) &&
		(access_control[i].acl->aclResources == acl_instance->oid_ptr[2])) {
		if (DeleteAclElement(access_control[i].acl) == -1) {
		    DPRINTF((APWARN, "aclEntry_set: delete failed.\n"));
		    return (GEN_ERROR);
		}
		access_control[i].acl = NULL;
		(void) WriteAclFile();
		return (NO_ERROR);
	    }
	}
	break;
      case ADD_MODIFY:
	open_slot = -1;
	for (i = 0; i < num_acls; i++) {
	    if ((access_control[i].acl == NULL) && (open_slot == -1)) {
		open_slot = i;
	    }
	    if (access_control[i].acl == NULL) {
		continue;
	    }

	    if ((access_control[i].acl->aclTarget == acl_instance->oid_ptr[0]) &&

		(access_control[i].acl->aclSubject == acl_instance->oid_ptr[1]) &&
		(access_control[i].acl->aclResources == acl_instance->oid_ptr[2])) {
		found = i;
		break;
	    }
	}
	/*
	 * If the acl_instance doesn't match any in the table, a new row must
	 * be added to the table.
	 */

	if (i == num_acls) {
	    new_entry = TRUE;
	    if (!(new_acl = (ACCESS *) malloc((unsigned) sizeof(ACCESS)))) {
		DPRINTF((APWARN, "aclEntry_set: Cannot allocate memory for new \
acl entry.\n"));
		return (GEN_ERROR);
	    }
	    memset((char *) new_acl, 0, sizeof(ACCESS));

	    if (open_slot == -1) {	/* Totally new entry needed */
		/*
		 * realloc acl ptr table.
		 */
		num_acls++;
		if (!(temp_ptr = (V2_ACL *) realloc((char *) access_control,
				 (unsigned) (num_acls * sizeof(V2_ACL))))) {
		    DPRINTF((APWARN, "aclEntry_set: Cannot reallocate memory \
for new acl entry.\n"));
		    free((char *) new_acl);
		    new_acl = NULL;
		    num_acls--;
		    return (GEN_ERROR);
		}
		access_control = temp_ptr;
		temp_ptr = NULL;
		found = num_acls - 1;

		access_control[found].acl = new_acl;
	    }
	    else {		/* reuse old, invalidated entry */
		found = open_slot;
		access_control[found].acl = new_acl;
	    }
	    access_control[found].last_active = GetTimeNow() / 100;
	    access_control[found].acl->aclTarget = acl_instance->oid_ptr[0];
	    access_control[found].acl->aclSubject = acl_instance->oid_ptr[1];
	    access_control[found].acl->aclResources = acl_instance->oid_ptr[2];
	}

	if (VALID(I_aclPrivileges, acl_entry->acl->valid)) {
	    access_control[found].acl->aclPrivileges = acl_entry->acl->aclPrivileges;
	}

	if (VALID(I_aclStorageType, acl_entry->acl->valid)) {
	    access_control[found].acl->aclStorageType = acl_entry->acl->aclStorageType;
	}

	if (VALID(I_aclStatus, acl_entry->acl->valid)) {
	    if (acl_entry->acl->aclStatus == CREATE_AND_GO) {
		access_control[found].acl->aclStatus = ACTIVE;
	    }
	    else {
		if ((access_control[found].acl->aclStatus == ACTIVE) &&
		    (acl_entry->acl->aclStatus == NOT_IN_SERVICE)) {
		    access_control[found].last_active = GetTimeNow() / 100;
		}
		access_control[found].acl->aclStatus = acl_entry->acl->aclStatus;
	    }
	    if (access_control[found].acl->aclStatus == ACTIVE) {
		access_control[found].last_active = GetTimeNow() / 100;
	    }
	}

	if (access_control[found].acl->aclStatus != ACTIVE) {
	    partyMibNotActiveFlag = TRUE;
	}
	break;

    }				/* end switch */

    if (new_entry == TRUE) {
	if (AclInsertSort(new_acl) == -1) {
	    DPRINTF((APWARN, "aclEntry_set: Could not insert new acl element \
into linked list. "));
	    DPRINTF((APWARN, "  Set failed!\n"));
	    FreeAclElement(new_acl);
	    access_control[found].acl = NULL;
	    return (GEN_ERROR);
	}
    }

    (void) WriteAclFile();

    return (NO_ERROR);

}				/* aclEntry_set() */

#endif				/* SETS */

#endif				/* SR_SNMPv2 */
