/************************************************************************
 *                                                                      *
 *                              NOTE WELL                               *
 * This is vendor-supplied and vendor-supported code.  Do not make any  *
 * modifications to this code without the knowledge and consent of the  *
 * SNMP agent group.                                                    *
 *                                                                      *
 ************************************************************************/
/* $Id: sr_v_contex.c,v 3.2.62.1 1996/04/19 17:46:55 jjohnson Exp $
 * $Source: /release/112/cvs/Xsys/snmp/sr_v_contex.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * February 1994, SNMP Research
 *
 * Copyright (c) 1994-1996 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_v_contex.c,v $
 * Revision 3.2.62.1  1996/04/19  17:46:55  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.2  1995/11/17  19:02:01  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  13:18:35  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.1  1995/06/07  22:51:21  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */
/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

/*
 *                PROPRIETARY NOTICE
 *
 * This software is an unpublished work subject to a confidentiality agreement
 * and is protected by copyright and trade secret law.  Unauthorized copying,
 * redistribution or other use of this work is prohibited.
 *
 * The above notice of copyright on this source code product does not indicate
 * any actual or intended publication of such source code.
 *
 */

#if (! ( defined(lint) ) && defined(SR_RCSID))
static char     rcsid[] = "v_contex.c,v 1.12 1995/02/06 18:11:45 battle Exp";
#endif				/* (! ( defined(lint) ) && defined(SR_RCSID)) */

/*
 * Revision History:
 *
 * v_contex.c,v
 * Revision 1.12  1995/02/06  18:11:45  battle
 * Changes for vrtx.
 *
 * Revision 1.11  1994/10/28  17:32:28  vaughn
 * Placed new copyright in the file
 *
 * Revision 1.10  1994/10/26  21:58:50  vaughn
 * Changed copyrights to the new copyright structure
 *
 * Revision 1.9  1994/09/30  16:11:32  battle
 * hprt changes
 *
 * Revision 1.8  1994/08/04  15:37:46  battle
 * pSOS 2.0 changes
 *
 * Revision 1.7  1994/04/18  18:28:53  battle
 * pSOS changes
 *
 * Revision 1.6  1994/02/14  16:42:28  pearson
 * Updated copyright notices for 1994.
 *
 * AMP
 *
 * Revision 1.5  1994/02/08  18:44:00  reid
 * added support for WinSock
 *
 * Revision 1.4  1994/02/08  00:10:13  pearson
 * Here's a brief description of the changes in this commit of the source
 * tree:
 * 	The structure of the packaged tree has changed somewhat.
 * 	Assembly language files and system-specific startup code are in
 * 	the pkg/lib/sys directory.  There is a 'serial' directory which
 * 	contains rs232 code for all of the different platforms.
 *
 * 	Uart code has a more uniform initialization call now.  For
 * 	example, init_uart() is mapped to init code for different uarts
 * 	on different systems.
 *
 * 	The national semiconductor "rib" code is in this release, along
 * 	with support for the debug/rt debugger and paradigm locate.
 * 	That created some new directories in the pkg/cmd tree.  There is
 * 	support now for a sonic driver, the ethernet repeater mib, and
 * 	sonic/ric statistics.
 *
 * 	The dos agent and utilities now configure themselves from an
 * 	ascii text file, rather than a "device driver".
 *
 * 	Various parts of the standard agent have had large stack
 * 	variables moved to malloc-ed structures to save room.
 *
 * 	Some bugs which were exposed by the marshall/levi test tool have
 * 	been fixed.
 *
 * 	Two new hello programs have been created.  Hello3 is essentially
 * 	a ping server, which allows embedded developers to test their
 * 	network stack, and hello4 allows tests of bootp and tftp.
 *
 * 	Some new routines have been added to the pkg/lib/c directory.
 * 	Dmemdump dumps memory in hex and in ascii.  32-bit versions of
 * 	memcpy, memset, etc have been created.
 *
 * Revision 1.3  1993/12/23  18:38:47  battle
 * Added cvs headers to all .c and .h files.
 *
 *
 * 21-Dec-92 MGH
 * New routine for manipulating the target table (security)
 *
 * 7-Jan-93 MGH
 * The target table is now the context table (reflecting recent changes in
 * the security drafts).
 *
 * 11-Jan-93 MGH
 * Added contextLocal to the context table
 *
 * 24-Mar-93 MGH
 * Converted internal representation of contextLocalTime from an OID to an
 * integer.
 *
 * 7-May-1993 MGH
 * Changed the name of the reqId parameter to serialNum.
 *
 * 28-May-1993 MGH
 * Code maintenance
 *
 * 2-June-1993 MGH
 * Changed call to WriteContextFile().  There are not any parameters
 * in the call anymore.
 *
 * 15-June-1993 MGH
 * Changed the method of accessing the context table.  There is now an array
 * of pointers that point to separately malloced context structures.  When
 * adding a new context row, the new context row is malloced separately, and
 * the array is realloced if another entry in the array is needed.
 * Should be able to add as many new context rows as memory will allow.
 *
 * Also had the contextEntry_test routine set dp->state to DELETE if
 * contextStatus is set to DESTROY. Added case statement to contextEntry_set.
 *
 * 18-June-93 MGH
 * Added an external global variable, partyMibNotActiveFlag.  It's set to
 * TRUE if there are any non active rows in the table.
 *
 * 22-June-93 MGH
 * Optimized contextEntry_test by eliminating some repetitive code (see the
 * end of the routine).
 *
 * 28-June-1993 MGH
 * Changed all references of "asod" to "contextInfo".  The
 * variable is now a ContextInfo variable.
 *
 * 1-July-1993 MGH
 * Added a check in contextEntry_get().  If contextStatus is ACTIVE or
 * NOT_IN_SERVICE, it makes sure that this entry is still valid.  If
 * contextViewIndex > 0, it makes sure there are still matching entries in
 * the view Table.  If contextViewIndex == 0 (proxy), it makes sure that the
 * party entries that contextProxyDstParty and contextProxySrcParty point to
 * are ACTIVE rows, and makes sure that the context entry that
 * contextProxyContext points to is an ACTIVE row.
 *
 * Added a check to contextEntry_test() and contextEntry_set() to ensure that
 * a new row will have a unique contextIndex field.  For now, the contextIndex
 * field for a new row is assigned the value of the biggest current
 * contextIndex plus one.  The max_context_index variable holds that value,
 * and its value cannot decrease during run-time if rows are deleted. The
 * code will eventually use the smallest available contextIndex value.
 */

#include "master.h"




#include "sr_snmpd.h"

#ifdef SR_SNMPv2


#include "sr_diag.h"
#include "sr_snmpv2mib.h"

extern int      partyMibNotActiveFlag;

typedef struct _CONTEXT_TABLE {
    contextEntry_t *context;
    OID            *context_instance;
} CONTEXT_TABLE;

/*----------------------------------------------------------------------
 * Retrieve data from the contextEntry group. This is performed in
 * 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *----------------------------------------------------------------------*/
VarBind        *
contextEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{

    int             instLength = incoming->length - object->oid.length;
    int             arg = -1;
    int             i;
    int             found;
    int             view_pos, dst_pos, src_pos, context_pos;
    int             bad_row;
    void           *dp;
    OID            *context_instance;
    OID            *best;
    OID            *null_oid;
    OID            *localTimeOID;

    view_pos = -1;
    dst_pos = -1;
    src_pos = -1;
    context_pos = -1;
    found = -1;
    best = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of the form: context, where
     * context(an OID) refers to the intended context of an interaction
     * between a source and destination party.
     * 
     * A NEXT search  requires that the requested object does not
     * lexicographically precede the current object type.
     */

    switch (searchType) {
      case EXACT:
	if (instLength > 0) {
	    arg = object->nominator;
	}
	else {
	    return ((VarBind *) NULL);
	}
	break;
      case NEXT:
	arg = object->nominator;
	break;

      default:
	DPRINTF((APWARN, "snmpd: Internal error. (invalid search type in \
contextEntry_get -- %d)\n", searchType));
    }				/* switch */

    /*
     * Retrieve the data from the context database and return instance if
     * successful.
     */

    /*
     * Determine instance OID -- first sub-field after name
     */
    if (CmpOIDClass(incoming, &object->oid) == 0) {
	if (instLength > 0) {
	    if ((context_instance = (OID *) malloc(sizeof(OID))) == NULL) {
		DPRINTF((APWARN, "contextEntry_get: malloc failure\n"));
		return ((VarBind *) NULL);
	    }
	    context_instance->oid_ptr = NULL;
	    context_instance->length = instLength;

	    if ((context_instance->oid_ptr = (unsigned long *)
		 malloc((unsigned) (context_instance->length * sizeof(unsigned long)))) == NULL) {
		DPRINTF((APWARN, "contextEntry_get: malloc failure\n"));
		FreeOID(context_instance);
		context_instance = NULL;
		return ((VarBind *) NULL);
	    }

	    for (i = 0; i < context_instance->length; i++) {
		context_instance->oid_ptr[i] =
		    incoming->oid_ptr[i + object->oid.length];
	    }
	}
	else {
	    if ((context_instance = MakeOIDFromDot("0.0")) == NULL) {
		DPRINTF((APWARN, "contextEntry_get: malloc failure on 0.0\n"));
		return ((VarBind *) NULL);
	    }
	}
    }
    else {
	if ((context_instance = MakeOIDFromDot("0.0")) == NULL) {
	    DPRINTF((APWARN, "contextEntry_get: malloc failure on 0.0\n"));
	    return ((VarBind *) NULL);
	}
    }

    /*
     * Now scan the context table
     */

    if (arg != -1) {
	if (searchType == EXACT) {
	    for (i = 0; i < num_contexts; i++) {
		if (contexts[i].context == NULL) {
		    continue;
		}
		if ((CmpOID(contexts[i].context->contextIdentity,
			    context_instance) == 0)) {
		    best = contexts[i].context->contextIdentity;
		    found = i;
		    break;
		}
	    }			/* for */
	}			/* if searchType */
	else {			/* searchType */
	    best = NULL;
	    for (i = 0; i < num_contexts; i++) {
		if (contexts[i].context == NULL) {
		    continue;
		}
		/*
		 * best = thisone if ((incoming > thisone) && (thisone <
		 * best) && (entry is valid))
		 */
		if ((CmpOID(contexts[i].context->contextIdentity,
			    context_instance) > 0) && ((best == NULL) ||
			       (CmpOID(contexts[i].context->contextIdentity,
				       best) < 0))) {
		    best = contexts[i].context->contextIdentity;
		    found = i;
		}		/* if match */
	    }			/* for */
	}			/* else searchType */

	FreeOID(context_instance);
	context_instance = NULL;

	if (searchType == EXACT) {
	    if (i == num_contexts) {	/* Not found by the end of the table */
		DPRINTF((APTRACE, "contextEntry_get: exact search failed\n"));
		return ((VarBind *) NULL);
	    }
	}

	else {			/* searchType == NEXT */
	    if (best == NULL) {
		DPRINTF((APTRACE, "contextEntry_get: next search failed\n"));
		return ((VarBind *) NULL);
	    }
	}

    }				/* if arg != -1 */

    if ((null_oid = MakeOIDFromDot("0.0")) == NULL) {
	DPRINTF((APWARN, "contextEntry_get: malloc failure on null_oid.\n"));
	return ((VarBind *) NULL);
    }

    switch (arg) {

#ifdef I_contextIndex
      case I_contextIndex:
	dp = (void *) &contexts[found].context->contextIndex;
	break;
#endif				/* I_contextIndex */

#ifdef I_contextLocal
      case I_contextLocal:
	dp = (void *) &contexts[found].context->contextLocal;
	break;
#endif				/* I_contextLocal */

#ifdef I_contextViewIndex
      case I_contextViewIndex:
	/*
	 * Has not been initialized yet.
	 */
	if (contexts[found].context->contextViewIndex == -1) {
	    FreeOID(null_oid);
	    null_oid = NULL;
	    return ((VarBind *) NULL);
	}
	else {
	    dp = (void *) &contexts[found].context->contextViewIndex;
	}
	break;
#endif				/* I_contextViewIndex */

#ifdef I_contextLocalEntity
      case I_contextLocalEntity:
	if ((dp = (void *) CloneOctetString(contexts[found].context->contextLocalEntity)) ==
	    (void *) NULL) {
	    DPRINTF((APWARN, "contextEntry_get: Cannot allocate memory for contextLocalEntity\n"));
	    FreeOID(null_oid);
	    null_oid = NULL;
	    return ((VarBind *) NULL);
	}
	break;
#endif				/* I_contextLocalEntity */

#ifdef I_contextLocalTime
      case I_contextLocalTime:
	if (contexts[found].context->contextLocalTime == C_CURRENT_TIME) {
	    dp = (void *) CloneOID(currentTimeOID);
	}
	else if (contexts[found].context->contextLocalTime == C_RESTART_TIME) {
	    dp = (void *) CloneOID(restartTimeOID);
	}
	else {			/* cacheTime.n */
	    if ((localTimeOID = MakeOIDFromDot("1")) == NULL) {
		DPRINTF((APWARN, "contextEntry_get: Cannot allocate memory for localTimeOID\n"));
		FreeOID(null_oid);
		null_oid = NULL;
		return ((VarBind *) NULL);
	    }
	    localTimeOID->oid_ptr[0] =
		contexts[found].context->contextLocalTime;

	    dp = (void *) CatOID(cacheTimeOID, localTimeOID);
	    FreeOID(localTimeOID);
	    localTimeOID = NULL;
	}
	if (dp == (void *) NULL) {
	    DPRINTF((APWARN, "contextEntry_get: Cannot allocate memory for contextLocalTime\n"));
	    FreeOID(null_oid);
	    null_oid = NULL;
	    return ((VarBind *) NULL);
	}
	break;
#endif				/* I_contextLocalTime */

#ifdef I_contextProxyDstParty
      case I_contextProxyDstParty:
	/*
	 * This is a proxy context entry
	 */
	if (contexts[found].context->contextViewIndex == 0) {
	    if (contexts[found].context->contextProxyDstParty == NULL) {
		DPRINTF((APTRACE, "contextEntry_get: No value for contextProxyDstParty\n"));
		FreeOID(null_oid);
		null_oid = NULL;
		return ((VarBind *) NULL);
	    }
	    if ((dp = (void *) CloneOID(contexts[found].context->contextProxyDstParty)) ==
		(void *) NULL) {
		DPRINTF((APWARN, "contextEntry_get: Cannot allocate memory \
for contextProxyDstParty\n"));
		FreeOID(null_oid);
		null_oid = NULL;
		return ((VarBind *) NULL);
	    }
	}
	else if (contexts[found].context->contextViewIndex == -1) {
	    if (contexts[found].context->contextProxyDstParty == NULL) {
		DPRINTF((APTRACE, "contextEntry_get: No value for contextProxyDstParty\n"));
		FreeOID(null_oid);
		null_oid = NULL;
		return ((VarBind *) NULL);
	    }
	    if ((dp = (void *) CloneOID(contexts[found].context->contextProxyDstParty)) ==
		(void *) NULL) {
		DPRINTF((APWARN, "contextEntry_get: Cannot allocate memory for contextProxyDstParty\n"));
		FreeOID(null_oid);
		null_oid = NULL;
		return ((VarBind *) NULL);
	    }
	}
	/*
	 * Local context. Value is 0.0
	 */
	else {
	    if ((dp = (void *) CloneOID(null_oid)) == (void *) NULL) {
		DPRINTF((APWARN, "contextEntry_get: Cannot allocate memory for contextProxyDstParty\n"));
		FreeOID(null_oid);
		null_oid = NULL;
		return ((VarBind *) NULL);
	    }
	}
	break;
#endif				/* I_contextProxyDstParty */

#ifdef I_contextProxySrcParty
      case I_contextProxySrcParty:
	/*
	 * This is a proxy context entry
	 */
	if (contexts[found].context->contextViewIndex == 0) {
	    if (contexts[found].context->contextProxySrcParty == NULL) {
		DPRINTF((APTRACE, "contextEntry_get: No value for contextProxySrcParty\n"));
		FreeOID(null_oid);
		null_oid = NULL;
		return ((VarBind *) NULL);
	    }
	    if ((dp = (void *) CloneOID(contexts[found].context->contextProxySrcParty)) ==
		(void *) NULL) {
		DPRINTF((APWARN, "contextEntry_get: Cannot allocate memory for contextProxySrcParty\n"));
		FreeOID(null_oid);
		null_oid = NULL;
		return ((VarBind *) NULL);
	    }
	}
	else if (contexts[found].context->contextViewIndex == -1) {
	    if (contexts[found].context->contextProxySrcParty == NULL) {
		DPRINTF((APTRACE, "contextEntry_get: No value for contextProxySrcParty\n"));
		FreeOID(null_oid);
		null_oid = NULL;
		return ((VarBind *) NULL);
	    }
	    if ((dp = (void *) CloneOID(contexts[found].context->contextProxySrcParty)) ==
		(void *) NULL) {
		DPRINTF((APWARN, "contextEntry_get: Cannot allocate memory for contextProxySrcParty\n"));
		FreeOID(null_oid);
		null_oid = NULL;
		return ((VarBind *) NULL);
	    }
	}
	/*
	 * Local context. Value is 0.0
	 */
	else {
	    if ((dp = (void *) CloneOID(null_oid)) == (void *) NULL) {
		DPRINTF((APWARN, "contextEntry_get: Cannot allocate memory for contextProxySrcParty\n"));
		FreeOID(null_oid);
		null_oid = NULL;
		return ((VarBind *) NULL);
	    }
	}
	break;
#endif				/* I_contextProxySrcParty */

#ifdef I_contextProxyContext
      case I_contextProxyContext:
	/*
	 * This is a proxy context entry
	 */
	if (contexts[found].context->contextViewIndex == 0) {
	    if (contexts[found].context->contextProxyContext == NULL) {
		DPRINTF((APTRACE, "contextEntry_get: No value for contextProxyContext\n"));
		FreeOID(null_oid);
		null_oid = NULL;
		return ((VarBind *) NULL);
	    }
	    if ((dp = (void *) CloneOID(contexts[found].context->contextProxyContext)) ==
		(void *) NULL) {
		DPRINTF((APWARN, "contextEntry_get: Cannot allocate memory for contextProxyContext\n"));
		FreeOID(null_oid);
		null_oid = NULL;
		return ((VarBind *) NULL);
	    }
	}
	else if (contexts[found].context->contextViewIndex == -1) {
	    if (contexts[found].context->contextProxyContext == NULL) {
		DPRINTF((APTRACE, "contextEntry_get: No value for contextProxyContext\n"));
		FreeOID(null_oid);
		null_oid = NULL;
		return ((VarBind *) NULL);
	    }
	    if ((dp = (void *) CloneOID(contexts[found].context->contextProxyContext)) ==
		(void *) NULL) {
		DPRINTF((APWARN, "contextEntry_get: Cannot allocate memory for contextProxyContext\n"));
		FreeOID(null_oid);
		null_oid = NULL;
		return ((VarBind *) NULL);
	    }
	}
	/*
	 * Local context. Value is 0.0
	 */
	else {
	    if ((dp = (void *) CloneOID(null_oid)) == (void *) NULL) {
		DPRINTF((APWARN, "contextEntry_get: Cannot allocate memory for contextProxyContext\n"));
		FreeOID(null_oid);
		null_oid = NULL;
		return ((VarBind *) NULL);
	    }
	}
	break;
#endif				/* I_contextProxyContext */

#ifdef I_contextStorageType
      case I_contextStorageType:
	dp = (void *) &contexts[found].context->contextStorageType;
	break;
#endif				/* I_contextStorageType */

#ifdef I_contextStatus
      case I_contextStatus:
	bad_row = FALSE;
	/*
	 * Check to see if this row needs to revert to NOT_READY.
	 */
	if ((contexts[found].context->contextStatus != NOT_READY) &&
	    (contexts[found].context->contextLocal == SR_LOCAL)) {

	    if (contexts[found].context->contextViewIndex > 0) {
		view_pos = GetViewEntry(contexts[found].context->contextViewIndex);
		if (view_pos == -1) {
		    if (contexts[found].context->contextStatus == ACTIVE) {
			contexts[found].last_active = GetTimeNow() / 100;
			partyMibNotActiveFlag = TRUE;
		    }
		    contexts[found].context->contextStatus = NOT_READY;
		}
	    }

	}
	dp = (void *) &contexts[found].context->contextStatus;
	break;
#endif				/* I_contextStatus */

      default:
	DPRINTF((APWARN, "contextEntry_get: Illegal variable.\n"));
	FreeOID(null_oid);
	null_oid = NULL;
	return ((VarBind *) NULL);
    }				/* switch */

    FreeOID(null_oid);
    null_oid = NULL;
    return (MakeVarBind(object, best, dp));

}				/* contextEntry_get() */

#ifdef SETS
static void contextEntry_freex SR_PROTOTYPE((CONTEXT_TABLE *data));

static void
contextEntry_freex(data)
    CONTEXT_TABLE  *data;
{
    if (data != NULL) {

	if (data->context_instance != NULL) {
	    FreeOID(data->context_instance);
	    data->context_instance = NULL;
	}
	if (data->context != NULL) {
	    if (data->context->contextLocalEntity != NULL) {
		FreeOctetString(data->context->contextLocalEntity);
		data->context->contextLocalEntity = NULL;
	    }

	    if (data->context->contextLocalTime != NULL) {
		FreeOID(data->context->contextLocalTime);
		data->context->contextLocalTime = NULL;
	    }
	    if (data->context->contextProxyDstParty != NULL) {
		FreeOID(data->context->contextProxyDstParty);
		data->context->contextProxyDstParty = NULL;
	    }
	    if (data->context->contextProxySrcParty != NULL) {
		FreeOID(data->context->contextProxySrcParty);
		data->context->contextProxySrcParty = NULL;
	    }
	    if (data->context->contextProxyContext != NULL) {
		FreeOID(data->context->contextProxyContext);
		data->context->contextProxyContext = NULL;
	    }
	    free((char *) data->context);
	    data->context = NULL;
	}
	free((char *) data);
	data = NULL;
    }				/* if (data != NULL) */
}				/* contextEntry_freex() */

/*----------------------------------------------------------------------
 * Cleanup after contextEntry set/undo.
 *----------------------------------------------------------------------*/
static int contextEntry_cleanup SR_PROTOTYPE((doList_t *trash));

static int
contextEntry_cleanup(trash)
    doList_t       *trash;
{
    contextEntry_freex(trash->data);

#ifdef SR_SNMPv2
    contextEntry_freex(trash->undodata);
#endif				/* SR_SNMPv2 */

    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *----------------------------------------------------------------------*/
int
contextEntry_test(incoming, object, value, dolist_head, doCur, contextInfo)
    OID            *incoming;
    ObjectInfo     *object;
    ObjectSyntax   *value;
    doList_t       *dolist_head;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    int             instLength = incoming->length - object->oid.length;
    int             i, return_val;
    int             found, good_row;
    int             name_found;
    int             index;
    doList_t       *dp;
    CONTEXT_TABLE  *context;
    OID            *context_instance;
    OID            *best, *null_oid;

    index = -1;
    found = -1;
    good_row = -1;

    /*
     * Validate the object instance. 1) It should have a length > 0
     * (InitialContextID.a.b.c.d.num) 2) Validate the contextIdentity.
     */

    if (instLength <= 0) {
	DPRINTF((APTRACE, "contextEntry_test: Invalid instance.\n"));
	return (NO_CREATION_ERROR);
    }

    /*
     * Determine instance OID -- first sub-field after name
     */
    if (CmpOIDClass(incoming, &object->oid) == 0) {
	if ((context_instance = (OID *) malloc(sizeof(OID))) == NULL) {
	    DPRINTF((APWARN, "contextEntry_test: malloc failure on context_instance.\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	context_instance->oid_ptr = NULL;
	context_instance->length = instLength;

	if ((context_instance->oid_ptr = (unsigned long *)
	malloc((unsigned) (context_instance->length * sizeof(unsigned long))
	       )) == NULL) {
	    DPRINTF((APWARN, "contextEntry_test: malloc failure on context_instance->length.\n"));
	    FreeOID(context_instance);
	    context_instance = NULL;
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}

	for (i = 0; i < context_instance->length; i++) {
	    context_instance->oid_ptr[i] =
		incoming->oid_ptr[i + object->oid.length];
	}
    }
    else {
	if ((context_instance = MakeOIDFromDot("0.0")) == NULL) {
	    DPRINTF((APWARN, "contextEntry_test: malloc failure on 0.0.\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
    }

    /*
     * Now scan the context table
     */

    name_found = -1;
    best = (OID *) NULL;

    for (i = 0; i < num_contexts; i++) {
	if (contexts[i].context == NULL) {
	    continue;
	}
	if ((CmpOID(contexts[i].context->contextIdentity,
		    context_instance) == 0)) {
	    best = contexts[i].context->contextIdentity;
	    name_found = i;
	    break;
	}
    }				/* for */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = dolist_head; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == contextEntry_set) &&
	    (((CONTEXT_TABLE *) (dp->data)) != (CONTEXT_TABLE *) NULL)) {
	    /*
	     * If best is non-null, a match was found.  If best matches a
	     * previous do-list element, the two elements are related and are
	     * part of an entry in the table.
	     */
	    if ((((CONTEXT_TABLE *) (dp->data))->context_instance !=
		 (OID *) NULL) && (best != (OID *) NULL)) {
		if (CmpOID(((CONTEXT_TABLE *) (dp->data))->context_instance,
			   best) == 0) {
		    found = 1;
		    break;
		}
	    }
	    /*
	     * If best is null(no entry in the table), but the instance for
	     * this do-list element matches a previous do-list element, the
	     * two elements are related, and they need to be added to the
	     * table.
	     */
	    else if ((((CONTEXT_TABLE *) (dp->data))->context_instance !=
		      (OID *) NULL) && (best == (OID *) NULL)) {
		if (CmpOID(((CONTEXT_TABLE *) (dp->data))->context_instance,
			   context_instance) == 0) {
		    found = 1;
		    break;
		}
	    }			/* else if */
	}			/* if dp->setMethod */
    }				/* for (dp = dolist_head . . . */

    /*
     * If a related do-list element was found, mark the one created for this
     * SET request with a NULL setMethod (this invalidates it).
     * 
     * Otherwise, there does not exist a related do-list element so fill-in the
     * do-list element with all known/default values.
     */

    if (!found) {
	dp = doCur;
	if ((dp->data = (void *) malloc((unsigned) sizeof(CONTEXT_TABLE))) == NULL) {
	    DPRINTF((APWARN, "contextEntry_test: Cannot allocate memory for CONTEXT_TABLE.\n"));
	    FreeOID(context_instance);
	    context_instance = NULL;
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset((char *) dp->data, 0, sizeof(CONTEXT_TABLE));

	if ((((CONTEXT_TABLE *) (dp->data))->context =
	     (contextEntry_t *) malloc((unsigned) sizeof(contextEntry_t))) == NULL) {
	    DPRINTF((APWARN, "contextEntry_test: Cannot allocate memory for contextEntry_t.\n"));
	    FreeOID(context_instance);
	    context_instance = NULL;
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset((char *) ((CONTEXT_TABLE *) (dp->data))->context, 0, sizeof(contextEntry_t));

	dp->setMethod = contextEntry_set;
	dp->cleanupMethod = contextEntry_cleanup;
	dp->state = UNKNOWN;

	/*
	 * Try to fill in reasonable default values for this new context
	 * entry.
	 */

	if (name_found == -1) {	/* new row in the table */
	    /*
	     * If there are SR_MAX_INDEX rows already in the table, or if the
	     * configuration file has an entry with contextIndex =
	     * SR_MAX_INDEX(65535), no more rows can be created. So, if you
	     * have three rows in the context table with contextIndex = 1,
	     * 299, and 65535 respectively, no more entries can be created.
	     * The code will eventually look for the smallest available
	     * number and use that as the contextIndex field.  But until
	     * then, it uses the biggest contextIndex value plus one for the
	     * next new row's contextIndex value.
	     * 
	     * So, if you had 2 rows in the table at startup, with contextIndex
	     * = 5 and 20, max_context_index would be set to 21 and used as
	     * the contextIndex.  The max_context_index field will not change
	     * when rows are deleted unless the agent is stopped and
	     * restarted (i.e., reread configuration file).
	     */
	    if (max_context_index > SR_MAX_INDEX) {
		DPRINTF((APWARN, "contextEntry_test: Cannot add a row.\n"));
		FreeOID(context_instance);
		context_instance = NULL;
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }

	    if ((((CONTEXT_TABLE *) (dp->data))->context_instance =
		 (OID *) CloneOID(context_instance)) == (OID *) NULL) {
		DPRINTF((APWARN, "contextEntry_test: Cannot allocate memory for context_instance.\n"));
		FreeOID(context_instance);
		context_instance = NULL;
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }
	    FreeOID(context_instance);
	    context_instance = NULL;

	    ((CONTEXT_TABLE *) (dp->data))->context->contextLocal = SR_LOCAL;
	    ((CONTEXT_TABLE *) (dp->data))->context->contextViewIndex = -1;

	    if ((((CONTEXT_TABLE *) (dp->data))->context->contextLocalEntity =
		 MakeOctetStringFromText("")) ==
		(OctetString *) NULL) {
		DPRINTF((APWARN,
			 "contextEntry_test: Cannot allocate memory for contextLocalEntity.\n"));
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }

	    if ((((CONTEXT_TABLE *) (dp->data))->context->contextLocalTime =
		 CloneOID(currentTimeOID)) == (OID *) NULL) {
		DPRINTF((APWARN,
			 "contextEntry_test: Cannot allocate memory for contextLocalTime.\n"));
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }

	    ((CONTEXT_TABLE *) (dp->data))->context->contextProxyDstParty = NULL;
	    ((CONTEXT_TABLE *) (dp->data))->context->contextProxySrcParty = NULL;
	    ((CONTEXT_TABLE *) (dp->data))->context->contextProxyContext = NULL;
	    ((CONTEXT_TABLE *) (dp->data))->context->contextStorageType = NONVOLATILE;
	    ((CONTEXT_TABLE *) (dp->data))->context->contextStatus = DESTROY;

	    SET_VALID(I_contextViewIndex, ((CONTEXT_TABLE *) (dp->data))->context->valid);
	    SET_VALID(I_contextLocal, ((CONTEXT_TABLE *) (dp->data))->context->valid);
	    SET_VALID(I_contextLocalEntity, ((CONTEXT_TABLE *) (dp->data))->context->valid);
	    SET_VALID(I_contextLocalTime, ((CONTEXT_TABLE *) (dp->data))->context->valid);
	    SET_VALID(I_contextStorageType, ((CONTEXT_TABLE *) (dp->data))->context->valid);
	    SET_VALID(I_contextStatus, ((CONTEXT_TABLE *) (dp->data))->context->valid);
	}

	else {			/* the row already exists in the table */
	    FreeOID(context_instance);
	    context_instance = NULL;

	    if ((((CONTEXT_TABLE *) (dp->data))->context_instance =
		 (OID *) CloneOID(contexts[name_found].context->contextIdentity)) ==
		(OID *) NULL) {
		DPRINTF((APWARN, "contextEntry_test: Cannot allocate memory for context_instance\n"));
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }

	    ((CONTEXT_TABLE *) (dp->data))->context->contextStatus =
		contexts[name_found].context->contextStatus;
	    ((CONTEXT_TABLE *) (dp->data))->context->contextViewIndex =
		contexts[name_found].context->contextViewIndex;
	    ((CONTEXT_TABLE *) (dp->data))->context->contextLocal =
		contexts[name_found].context->contextLocal;

	    if (contexts[name_found].context->contextProxyDstParty != NULL) {
		if ((((CONTEXT_TABLE *) (dp->data))->context->contextProxyDstParty =
		     (OID *) CloneOID(contexts[name_found].context->contextProxyDstParty)) ==
		    (OID *) NULL) {
		    DPRINTF((APWARN, "contextEntry_test: Cannot allocate memory for contextProxyDstParty.\n"));
		    return (RESOURCE_UNAVAILABLE_ERROR);
		}
	    }
	    else {
		((CONTEXT_TABLE *) (dp->data))->context->contextProxyDstParty = NULL;
	    }

	    if (contexts[name_found].context->contextProxySrcParty != NULL) {
		if ((((CONTEXT_TABLE *) (dp->data))->context->contextProxySrcParty =
		     (OID *) CloneOID(contexts[name_found].context->contextProxySrcParty)) ==
		    (OID *) NULL) {
		    DPRINTF((APWARN, "contextEntry_test: Cannot allocate memory for contextProxySrcParty.\n"));
		    return (RESOURCE_UNAVAILABLE_ERROR);
		}
	    }
	    else {
		((CONTEXT_TABLE *) (dp->data))->context->contextProxySrcParty = NULL;
	    }

	    if (contexts[name_found].context->contextProxyContext != NULL) {
		if ((((CONTEXT_TABLE *) (dp->data))->context->contextProxyContext =
		     (OID *) CloneOID(contexts[name_found].context->contextProxyContext)) ==
		    (OID *) NULL) {
		    DPRINTF((APWARN, "contextEntry_test: Cannot allocate memory for contextProxyContext.\n"));
		    return (RESOURCE_UNAVAILABLE_ERROR);
		}
	    }
	    else {
		((CONTEXT_TABLE *) (dp->data))->context->contextProxyContext = NULL;
	    }
	}			/* row already in table */
    }				/* if (!found) */
    else {
	FreeOID(context_instance);
	context_instance = NULL;
    }
    /*
     * Add the SET request to the do-list element.  Test the validity of the
     * value at this point.
     */

    context = (CONTEXT_TABLE *) (dp->data);

    if ((null_oid = MakeOIDFromDot("0.0")) ==
	(OID *) NULL) {
	DPRINTF((APTRACE, "contextEntry_test: could not make null_oid for proxy dst.\n"));
	return (RESOURCE_UNAVAILABLE_ERROR);
    }

    switch (object->nominator) {

#ifdef I_contextLocal
      case I_contextLocal:
	if ((value->sl_value != SR_LOCAL) && (value->sl_value != SR_REMOTE)) {
	    FreeOID(null_oid);
	    null_oid = NULL;
	    return (WRONG_VALUE_ERROR);
	}
	context->context->contextLocal = value->sl_value;
	SET_VALID(I_contextLocal, context->context->valid);
	break;
#endif				/* I_contextLocal */

#ifdef I_contextViewIndex
      case I_contextViewIndex:

	if ((value->sl_value < 1) || (value->sl_value > 65535)) {
	    FreeOID(null_oid);
	    null_oid = NULL;
	    return (WRONG_VALUE_ERROR);
	}

	context->context->contextViewIndex = value->sl_value;

	/*
	 * If contextViewIndex > 0, set contextProxyDstParty,
	 * contextProxySrcParty, and contextProxyContext to 0.0
	 */
	if (context->context->contextViewIndex > 0) {
	    if (context->context->contextProxyDstParty != NULL) {
		if (CmpOID(context->context->contextProxyDstParty,
			   null_oid) != 0) {
		    FreeOID(context->context->contextProxyDstParty);
		    context->context->contextProxyDstParty = NULL;
		    if ((context->context->contextProxyDstParty =
			 CloneOID(null_oid)) == (OID *) NULL) {
			FreeOID(null_oid);
			null_oid = NULL;
			DPRINTF((APTRACE, "contextEntry_test: could not clone null_oid for proxy dst.\n"));
			return (RESOURCE_UNAVAILABLE_ERROR);
		    }
		    SET_VALID(I_contextProxyDstParty, context->context->valid);
		}
	    }
	    else {
		if ((context->context->contextProxyDstParty =
		     CloneOID(null_oid)) == (OID *) NULL) {
		    FreeOID(null_oid);
		    null_oid = NULL;
		    DPRINTF((APTRACE, "contextEntry_test: could not clone null_oid for proxy dst.\n"));
		    return (RESOURCE_UNAVAILABLE_ERROR);
		}
		SET_VALID(I_contextProxyDstParty, context->context->valid);
	    }

	    if (context->context->contextProxySrcParty != NULL) {
		if (CmpOID(context->context->contextProxySrcParty,
			   null_oid) != 0) {
		    FreeOID(context->context->contextProxySrcParty);
		    context->context->contextProxySrcParty = NULL;
		    if ((context->context->contextProxySrcParty =
			 CloneOID(null_oid)) == (OID *) NULL) {
			FreeOID(null_oid);
			null_oid = NULL;
			DPRINTF((APTRACE, "contextEntry_test: could not clone null_oid for proxy src.\n"));
			return (RESOURCE_UNAVAILABLE_ERROR);
		    }
		    SET_VALID(I_contextProxySrcParty, context->context->valid);
		}
	    }
	    else {
		if ((context->context->contextProxySrcParty =
		     CloneOID(null_oid)) == (OID *) NULL) {
		    FreeOID(null_oid);
		    null_oid = NULL;
		    DPRINTF((APTRACE, "contextEntry_test: could not clone null_oid for proxy src.\n"));
		    return (RESOURCE_UNAVAILABLE_ERROR);
		}
		SET_VALID(I_contextProxySrcParty, context->context->valid);
	    }

	    if (context->context->contextProxyContext != NULL) {
		if (CmpOID(context->context->contextProxyContext,
			   null_oid) != 0) {
		    FreeOID(context->context->contextProxyContext);
		    context->context->contextProxyContext = NULL;
		    if ((context->context->contextProxyContext =
			 CloneOID(null_oid)) == (OID *) NULL) {
			FreeOID(null_oid);
			null_oid = NULL;
			DPRINTF((APTRACE, "contextEntry_test: could not clone null_oid for proxy context.\n"));
			return (RESOURCE_UNAVAILABLE_ERROR);
		    }
		    SET_VALID(I_contextProxyContext, context->context->valid);
		}
	    }
	    else {
		if ((context->context->contextProxyContext =
		     CloneOID(null_oid)) == (OID *) NULL) {
		    FreeOID(null_oid);
		    null_oid = NULL;
		    DPRINTF((APTRACE, "contextEntry_test: could not clone null_oid for proxy context.\n"));
		    return (RESOURCE_UNAVAILABLE_ERROR);
		}
		SET_VALID(I_contextProxyContext, context->context->valid);
	    }
	}			/* if (contextViewIndex > 0) */

	SET_VALID(I_contextViewIndex, context->context->valid);
	break;
#endif				/* I_contextViewIndex */

#ifdef I_contextLocalEntity
      case I_contextLocalEntity:
	if (context->context->contextLocalEntity != NULL) {
	    FreeOctetString(context->context->contextLocalEntity);
	    context->context->contextLocalEntity = NULL;
	}
	if ((context->context->contextLocalEntity =
	     CloneOctetString(value->os_value)) == (OctetString *) NULL) {
	    DPRINTF((APWARN, "contextEntry_test: malloc for contextLocalEntity failed.\n"));
	    FreeOID(null_oid);
	    null_oid = NULL;
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	SET_VALID(I_contextLocalEntity, context->context->valid);
	break;
#endif				/* I_contextLocalEntity */

#ifdef I_contextLocalTime
      case I_contextLocalTime:
	if ((CmpOID(value->oid_value, currentTimeOID) != 0) &&
	    (CmpOID(value->oid_value, restartTimeOID) != 0) &&
	    ((CmpOIDClass(value->oid_value, cacheTimeOID) != 0) ||
	     ((value->oid_value->length - 1) != cacheTimeOID->length))) {
	    FreeOID(null_oid);
	    null_oid = NULL;
	    return (WRONG_VALUE_ERROR);
	}
	if (context->context->contextLocalTime != NULL) {
	    FreeOID(context->context->contextLocalTime);
	    context->context->contextLocalTime = NULL;
	}
	if ((context->context->contextLocalTime =
	     CloneOID(value->oid_value)) == (OID *) NULL) {
	    DPRINTF((APWARN, "contextEntry_test: malloc for contextLocalTime failed.\n"));
	    FreeOID(null_oid);
	    null_oid = NULL;
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	SET_VALID(I_contextLocalTime, context->context->valid);
	break;
#endif				/* I_contextLocalTime */

#ifdef I_contextProxyDstParty
      case I_contextProxyDstParty:

	if (CmpOID(value->oid_value, null_oid) != 0) {
	    FreeOID(null_oid);
	    null_oid = NULL;
	    return (WRONG_VALUE_ERROR);
	}

	if (context->context->contextProxyDstParty != NULL) {
	    FreeOID(context->context->contextProxyDstParty);
	    context->context->contextProxyDstParty = NULL;
	}
	if ((context->context->contextProxyDstParty =
	     CloneOID(value->oid_value)) == (OID *) NULL) {
	    DPRINTF((APWARN, "contextEntry_test: malloc for contextProxyDstParty failed.\n"));
	    FreeOID(null_oid);
	    null_oid = NULL;
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	SET_VALID(I_contextProxyDstParty, context->context->valid);
	break;
#endif				/* I_contextProxyDstParty */

#ifdef I_contextProxySrcParty
      case I_contextProxySrcParty:

	if (CmpOID(value->oid_value, null_oid) != 0) {
	    FreeOID(null_oid);
	    null_oid = NULL;
	    return (WRONG_VALUE_ERROR);
	}

	if (context->context->contextProxySrcParty != NULL) {
	    FreeOID(context->context->contextProxySrcParty);
	    context->context->contextProxySrcParty = NULL;
	}
	if ((context->context->contextProxySrcParty =
	     CloneOID(value->oid_value)) == (OID *) NULL) {
	    DPRINTF((APWARN, "contextEntry_test: malloc for contextProxySrcParty failed.\n"));
	    FreeOID(null_oid);
	    null_oid = NULL;
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	SET_VALID(I_contextProxySrcParty, context->context->valid);
	break;
#endif				/* I_contextProxySrcParty */

#ifdef I_contextProxyContext
      case I_contextProxyContext:

	if (CmpOID(value->oid_value, null_oid) != 0) {
	    FreeOID(null_oid);
	    null_oid = NULL;
	    return (WRONG_VALUE_ERROR);
	}

	if (context->context->contextProxyContext != NULL) {
	    FreeOID(context->context->contextProxyContext);
	    context->context->contextProxyContext = NULL;
	}
	if ((context->context->contextProxyContext =
	     CloneOID(value->oid_value)) == (OID *) NULL) {
	    DPRINTF((APWARN, "contextEntry_test: malloc for contextProxyContext failed.\n"));
	    FreeOID(null_oid);
	    null_oid = NULL;
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	SET_VALID(I_contextProxyContext, context->context->valid);
	break;
#endif				/* I_contextProxyContext */

#ifdef I_contextStorageType
      case I_contextStorageType:
	if ((value->sl_value != OTHER) && (value->sl_value != VOLATILE) &&
	    (value->sl_value != NONVOLATILE) &&
	    (value->sl_value != PERMANENT)) {
	    FreeOID(null_oid);
	    null_oid = NULL;
	    return (WRONG_VALUE_ERROR);
	}

	context->context->contextStorageType = value->sl_value;
	SET_VALID(I_contextStorageType, context->context->valid);
	break;
#endif				/* I_contextStorageType */

#ifdef I_contextStatus
      case I_contextStatus:
	if ((return_val = set_row_status(value->sl_value, name_found,
		       &(dp->state), &(context->context->contextStatus))) !=
	    NO_ERROR) {
	    DPRINTF((APTRACE, "contextEntry_test: set_row_status returned error %d\n",
		     return_val));
	    FreeOID(null_oid);
	    null_oid = NULL;
	    return (return_val);
	}
	SET_VALID(I_contextStatus, context->context->valid);
	break;
#endif				/* I_contextStatus */

      default:
	DPRINTF((APWARN, "contextEntry_test: Internal error. (test switch)\n"));
	FreeOID(null_oid);
	null_oid = NULL;
	return (NO_ACCESS_ERROR);
	break;
    }				/* switch */

    /*
     * Determine if all fields in the row are valid.
     */
    if (context->context->contextLocal == SR_REMOTE) {
	good_row = TRUE;
    }
    else {
	if (context->context->contextViewIndex > 0) {
	    if (GetViewEntry(context->context->contextViewIndex) != -1) {
		good_row = TRUE;
	    }
	    else {
		good_row = FALSE;
	    }
	}
	else if (context->context->contextViewIndex < 0) {
	    good_row = FALSE;
	}

    }

    FreeOID(null_oid);
    null_oid = NULL;

    if (name_found == -1) {
	switch (context->context->contextStatus) {
	  case CREATE_AND_WAIT:
	    if (good_row == TRUE) {
		context->context->contextStatus = NOT_IN_SERVICE;
	    }
	    else {
		context->context->contextStatus = NOT_READY;
	    }
	    SET_VALID(I_contextStatus, context->context->valid);
	    dp->state = ADD_MODIFY;
	    break;
	  case CREATE_AND_GO:
	    if (good_row == TRUE) {
		dp->state = ADD_MODIFY;
	    }
	    else {
		dp->state = CREATE_AND_GO_STATE;
	    }
	    break;
	  case DESTROY:
	    dp->state = DELETE;
	    break;
	  case NOT_IN_SERVICE:
	    if (good_row == FALSE) {
		context->context->contextStatus = NOT_READY;
		SET_VALID(I_contextStatus, context->context->valid);
	    }
	    dp->state = ADD_MODIFY;
	    break;
	  case NOT_READY:
	    if (good_row == TRUE) {
		context->context->contextStatus = NOT_IN_SERVICE;
		SET_VALID(I_contextStatus, context->context->valid);
	    }
	    dp->state = ADD_MODIFY;
	    break;
	  default:
	    DPRINTF((APWARN, "contextEntry_test: Invalid contextStatus value.\n"));
	    return (INCONSISTENT_VALUE_ERROR);
	    break;
	}			/* end switch */
    }				/* if (name_found == -1) */

    else {			/* row already exists */
	switch (context->context->contextStatus) {
	  case NOT_IN_SERVICE:
	    if (good_row == TRUE) {
		dp->state = ADD_MODIFY;
	    }
	    else {
		dp->state = NOT_READY_STATE;
	    }
	    break;
	  case DESTROY:
	    dp->state = DELETE;
	    break;
	  case NOT_READY:
	    if (good_row == TRUE) {
		context->context->contextStatus = NOT_IN_SERVICE;
		SET_VALID(I_contextStatus, context->context->valid);
	    }
	    dp->state = ADD_MODIFY;
	    break;
	  case ACTIVE:
	    if (good_row == TRUE) {
		dp->state = ADD_MODIFY;
	    }
	    else {
		dp->state = NOT_READY_STATE;
	    }
	    break;
	  default:
	    DPRINTF((APWARN, "contextEntry_test: Invalid value for context->context->contextStatus\n"));
	    return (INCONSISTENT_VALUE_ERROR);
	    break;
	}			/* end switch */
    }				/* else */

    return (NO_ERROR);

}				/* contextEntry_test() */

/*----------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *
 * Note: In this case all related items are contained in the
 *    structure pointed to by "doCur->data," but in the more
 *    general case, this routine may need to scan the do-list to
 *    determine if there are other "related" objects. This is
 *    not recommended but is included for maximum flexibility.
 *----------------------------------------------------------------------*/
int
contextEntry_set(doHead, doCur, contextInfo)
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{

    SR_FNAME("contextEntry_set")
    CONTEXT_TABLE  *context;
    V2_CONTEXT_TABLE *temp_ptr;
    CONTEXT        *new_context;
    OID            *name;
    int             i;
    int             found, new_entry;
    int             open_slot;

    context = (CONTEXT_TABLE *) (doCur->data);
    name = context->context_instance;
    new_entry = FALSE;
    temp_ptr = NULL;
    new_context = NULL;


    switch (doCur->state) {
      case DELETE:
	for (i = 0; i < num_contexts; i++) {
	    if (contexts[i].context == NULL) {
		continue;
	    }
	    if (CmpOID(contexts[i].context->contextIdentity,
		       name) == 0) {
		DeleteContextElement(contexts[i].context);
		contexts[i].context = NULL;
		(void) WriteContextFile();
		return (NO_ERROR);
	    }
	}
	break;
      case ADD_MODIFY:
	open_slot = -1;
	found = 0;
	for (i = 0; i < num_contexts; i++) {
	    if ((contexts[i].context == NULL) && (open_slot == -1)) {
		open_slot = i;
	    }
	    if (contexts[i].context == NULL) {
		continue;
	    }

	    if (((CmpOID(contexts[i].context->contextIdentity, name)) == 0)) {
		found = i;
		break;
	    }
	}

	/*
	 * If the context name doesn't match any in the table, a new entry
	 * must be created.
	 */
	if (i == num_contexts) {
	    if (max_context_index > SR_MAX_INDEX) {
		DPRINTF((APWARN, "contextEntry_set: Cannot add a row.\n"));
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }
	    new_entry = TRUE;
	    if (!(new_context = (CONTEXT *) malloc((unsigned) sizeof(CONTEXT)))) {
		DPRINTF((APWARN, "%s: Cannot allocate memory for new context entry.\n", FName));
		return (GEN_ERROR);
	    }
	    memset((char *) new_context, 0, sizeof(CONTEXT));

	    if (open_slot == -1) {	/* Totally new entry needed */
		/*
		 * realloc context table.
		 */
		num_contexts++;
		if (!(temp_ptr = (V2_CONTEXT_TABLE *) realloc((char *) contexts,
		   (unsigned) (num_contexts * sizeof(V2_CONTEXT_TABLE))))) {
		    DPRINTF((APWARN, "%s: Cannot reallocate context ptr table.\n", FName));
		    free((char *) new_context);
		    new_context = NULL;
		    num_contexts--;
		    return (GEN_ERROR);
		}
		contexts = temp_ptr;
		temp_ptr = NULL;
		found = num_contexts - 1;
		contexts[found].context = new_context;
	    }
	    else {		/* reuse old, invalidated entry */
		found = open_slot;
		contexts[found].context = new_context;
	    }			/* else */

	    if ((contexts[found].context->contextIdentity =
		 CloneOID(name)) == (OID *) NULL) {
		DPRINTF((APWARN, "%s: Cannot allocate memory for contextIdentity\n", FName));
		free((char *) new_context);
		new_context = NULL;
		contexts[found].context = NULL;
		return (GEN_ERROR);
	    }
	    contexts[found].last_active = GetTimeNow() / 100;
	    contexts[found].context->contextIndex = max_context_index;
	    if (max_context_index <= SR_MAX_INDEX) {
		max_context_index++;
	    }
	    contexts[found].context->contextLocalEntity = NULL;
	    contexts[found].context->contextProxyDstParty = NULL;
	    contexts[found].context->contextProxySrcParty = NULL;
	    contexts[found].context->contextProxyContext = NULL;

	}			/* if i == num_contexts */


	if (VALID(I_contextLocal, context->context->valid)) {
	    contexts[found].context->contextLocal = context->context->contextLocal;
	}

	if (VALID(I_contextViewIndex, context->context->valid)) {
	    contexts[found].context->contextViewIndex =
		context->context->contextViewIndex;
	}

	if (VALID(I_contextLocalEntity, context->context->valid)) {
	    if (contexts[found].context->contextLocalEntity != NULL) {
		FreeOctetString(contexts[found].context->contextLocalEntity);
		contexts[found].context->contextLocalEntity = NULL;
	    }
	    if ((contexts[found].context->contextLocalEntity =
		 CloneOctetString(context->context->contextLocalEntity)) ==
		(OctetString *) NULL) {
		DPRINTF((APWARN, "contextEntry_set: malloc failure for contextLocalEntity.\n"));
		if (new_entry == TRUE) {
		    FreeContextElement(new_context);
		    contexts[found].context = NULL;
		}

		return (GEN_ERROR);
	    }
	}

	if (VALID(I_contextLocalTime, context->context->valid)) {
	    if (CmpOID(context->context->contextLocalTime,
		       currentTimeOID) == 0) {
		contexts[found].context->contextLocalTime = C_CURRENT_TIME;
	    }
	    else if (CmpOID(context->context->contextLocalTime,
			    restartTimeOID) == 0) {
		contexts[found].context->contextLocalTime = C_RESTART_TIME;
	    }
	    else if (CmpOIDClass(context->context->contextLocalTime,
				 cacheTimeOID) == 0) {
		contexts[found].context->contextLocalTime =
		    (int) context->context->contextLocalTime->oid_ptr[CACHE_TIME_LENGTH];
	    }
	}

	if (VALID(I_contextProxyDstParty, context->context->valid)) {
	    if (contexts[found].context->contextProxyDstParty != NULL) {
		FreeOID(contexts[found].context->contextProxyDstParty);
		contexts[found].context->contextProxyDstParty = NULL;
	    }
	    if ((contexts[found].context->contextProxyDstParty =
		 CloneOID(context->context->contextProxyDstParty)) == (OID *) NULL) {
		DPRINTF((APWARN, "contextEntry_set: malloc failure for contextProxyDstParty.\n"));
		if (new_entry == TRUE) {
		    FreeContextElement(new_context);
		    contexts[found].context = NULL;
		}
		return (GEN_ERROR);
	    }
	}

	if (VALID(I_contextProxySrcParty, context->context->valid)) {
	    if (contexts[found].context->contextProxySrcParty != NULL) {
		FreeOID(contexts[found].context->contextProxySrcParty);
		contexts[found].context->contextProxySrcParty = NULL;
	    }
	    if ((contexts[found].context->contextProxySrcParty =
		 CloneOID(context->context->contextProxySrcParty)) == (OID *) NULL) {
		DPRINTF((APWARN, "contextEntry_set: malloc failure for contextProxySrcParty.\n"));
		if (new_entry == TRUE) {
		    FreeContextElement(new_context);
		    contexts[found].context = NULL;
		}
		return (GEN_ERROR);
	    }
	}

	if (VALID(I_contextProxyContext, context->context->valid)) {
	    if (contexts[found].context->contextProxyContext != NULL) {
		FreeOID(contexts[found].context->contextProxyContext);
		contexts[found].context->contextProxyContext = NULL;
	    }
	    if ((contexts[found].context->contextProxyContext =
		 CloneOID(context->context->contextProxyContext)) == (OID *) NULL) {
		DPRINTF((APWARN, "contextEntry_set: malloc failure for contextProxyContext.\n"));
		if (new_entry == TRUE) {
		    FreeContextElement(new_context);
		    contexts[found].context = NULL;
		}
		return (GEN_ERROR);
	    }
	}

	if (VALID(I_contextStorageType, context->context->valid)) {
	    contexts[found].context->contextStorageType =
		context->context->contextStorageType;
	}

	if (VALID(I_contextStatus, context->context->valid)) {
	    if (context->context->contextStatus == CREATE_AND_GO) {
		contexts[found].context->contextStatus = ACTIVE;
	    }
	    else {
		if ((contexts[found].context->contextStatus == ACTIVE) &&
		    (context->context->contextStatus == NOT_IN_SERVICE)) {
		    contexts[found].last_active = GetTimeNow() / 100;
		}
		contexts[found].context->contextStatus = context->context->contextStatus;
	    }
	    if (contexts[found].context->contextStatus == ACTIVE) {
		contexts[found].last_active = GetTimeNow() / 100;
	    }
	}			/* if (VALID(I_contextStatus ..... ) */

	if (contexts[found].context->contextStatus != ACTIVE) {
	    partyMibNotActiveFlag = TRUE;
	}
	break;
    }				/* end switch */

    if (new_entry == TRUE) {
	ContextInsertSort(new_context);
	new_context = NULL;
    }

    (void) WriteContextFile();

    return (NO_ERROR);

}				/* contextEntry_set() */

#endif				/* SETS */

#endif				/* SR_SNMPv2 */
