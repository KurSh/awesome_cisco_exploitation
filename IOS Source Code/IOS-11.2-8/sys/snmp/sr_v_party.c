/************************************************************************
 *                                                                      *
 *                              NOTE WELL                               *
 * This is vendor-supplied and vendor-supported code.  Do not make any  *
 * modifications to this code without the knowledge and consent of the  *
 * SNMP agent group.                                                    *
 *                                                                      *
 ************************************************************************/
/* $Id: sr_v_party.c,v 3.2.60.2 1996/04/19 17:46:58 jjohnson Exp $
 * $Source: /release/112/cvs/Xsys/snmp/sr_v_party.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * February 1994, SNMP Research
 *
 * Copyright (c) 1994-1996 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_v_party.c,v $
 * Revision 3.2.60.2  1996/04/19  17:46:58  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.2.60.1  1996/03/18  21:49:15  gstovall
 * Branch: California_branch
 * Elvis has left the building.  He headed out to California, and took the
 * port ready changes with him.
 *
 * Revision 3.2.24.2  1996/03/07  12:34:18  mdb
 * Branch: DeadKingOnAThrone_branch
 * cisco and ANSI/POSIX libraries.
 *
 * Revision 3.2.24.1  1996/02/20  17:15:37  dstine
 * Branch: DeadKingOnAThrone_branch
 *           Sync from DeadKingOnAThrone_baseline_960122 to
 *                     DeadKingOnAThrone_baseline_960213
 *
 * Revision 3.2  1995/11/17  19:02:05  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  13:18:37  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.1  1995/06/07  22:51:25  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */
/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

/*
 *                PROPRIETARY NOTICE
 *
 * This software is an unpublished work subject to a confidentiality agreement
 * and is protected by copyright and trade secret law.  Unauthorized copying,
 * redistribution or other use of this work is prohibited.
 *
 * The above notice of copyright on this source code product does not indicate
 * any actual or intended publication of such source code.
 *
 */

#if (! ( defined(lint) ) && defined(SR_RCSID))
static char     rcsid[] = "v_party.c,v 1.12 1995/02/06 18:11:49 battle Exp";
#endif				/* (! ( defined(lint) ) && defined(SR_RCSID)) */

/*
 * Revision History:
 *
 * v_party.c,v
 * Revision 1.12  1995/02/06  18:11:49  battle
 * Changes for vrtx.
 *
 * Revision 1.11  1994/11/09  14:53:31  pearson
 * Removed an ifdef SR_SNMPv1 from the GET code for partyTDomain which caused that column of the party to be truncated if rfc1157 domain parties were present.
 *
 * Revision 1.10  1994/10/28  17:32:33  vaughn
 * Placed new copyright in the file
 *
 * Revision 1.9  1994/10/26  21:58:56  vaughn
 * Changed copyrights to the new copyright structure
 *
 * Revision 1.8  1994/09/30  16:11:38  battle
 * hprt changes
 *
 * Revision 1.7  1994/08/04  15:37:50  battle
 * pSOS 2.0 changes
 *
 * Revision 1.6  1994/04/18  18:28:55  battle
 * pSOS changes
 *
 * Revision 1.5  1994/02/14  16:42:33  pearson
 * Updated copyright notices for 1994.
 *
 * AMP
 *
 * Revision 1.4  1994/02/08  18:44:02  reid
 * added support for WinSock
 *
 * Revision 1.3  1993/12/23  18:38:52  battle
 * Added cvs headers to all .c and .h files.
 *
 *
 *  2-May-92 MGH
 *  Method routines for party and partySecrets table.
 *
 *  9-July-92 MRD
 *  Ifdef the whole thing - this allows for dumb makefiles that
 *  try to compile this file even when security is not used.
 *
 *  7-Aug-92 MGH
 *  Modified the set for partyTAddress to change the value for
 *  partyLocation appropriately.
 *
 *  11-Aug-92 MGH
 *  Modified partyEntry_set to save changes to the configuration file.
 *
 *  27-Aug-92 MGH
 *  Modified partyEntry_set() to return values for smpTrapNumbers, which
 *  is a variable that AUGMENTS the partyEntry table.  partyEntryset() also
 *  returns the appropriate value for partyAuthProtocol and partyPrivProtocol
 *  if the partyTDomain is equal to rfc1157Domain (trivial SNMP).
 *
 *  16-Sep-92 DLB
 *  Added #define ntohs(x) (x) for DGUX.
 *
 *  3-Dec-92 MGH
 *  Made sure that the priv, domain, and partyDiscriminator elements of the
 *  party table get set to a default value when a new row is created (see
 *  partyEntry_set).
 *
 * 9-Dec-1992 DLB
 *   Lint nits.
 *
 * 10-Dec-92 KWK
 *   PKG doesn't have an netinet/in.h
 *
 * 21-Dec-92 MGH
 *   Changed all calls of CmpNOID() to CmpOID().
 *   Added the changes from the new security drafts.
 *
 * 7-Jan-93 MGH
 * Changed partyEntry_get to reflect the new security drafts.
 *
 * 20-Jan-93 MGH
 * Started changing partyEntry_test and partyEntry_set to reflect the
 * current SNMPv2 drafts.
 *
 * 29-Jan-93 MGH
 * Added partyCloneFrom.
 *
 * 9-Feb-93 MGH
 * Added check in partyEntry_test to ensure that the partyAuthClock is
 * never set to a value above MAX_CLOCK_VALUE - partyAuthLifetime.
 *
 * 24-Mar-93 MGH
 * Started converting internal representation of partyTDomain and partyCloneFrom
 * from OIDs to integers.
 *
 * 30-Mar-93 MGH
 * Added boundary checking code for partyAuthClock.
 *
 * 13-Apr-93 MGH
 * Added code to allow the partyAuthClock to be set back to zero for
 * existing rows (ACTIVE or NOT_IN_SERVICE) if the partyAuthPrivate key
 * is also changed.
 *
 * 7-May-1993 MGH
 * Changed the name of the reqId parameter to serialNum.
 *
 * 10-May-93 MGH
 * Changed all references to EXPORT to match the new compliance levels in
 * RFC 1447.
 *
 * 17-May-93 MGH
 * Code maintenance and added header blocks to all routines.
 *
 * 2-June-93 MGH
 * Changed call to WriteParties().  There are now no arguments in the call.
 *
 * 11-June-93 MGH
 * Changed the method of accessing the party table.  There is now an array
 * of pointers that point to separately malloced party structures.  When
 * adding a new party row, the new party row is malloced separately, and
 * the array is realloced if another entry in the array is needed.
 * Should be able to add as many new party rows as memory will allow.
 *
 * Also had the partyEntry_test routine set dp->state to DELETE if
 * partyStatus is set to DESTROY. Added case statement to partyEntry_set.
 *
 * 18-June-93 MGH
 * Added an external global variable, partyMibNotActiveFlag.  It's set to
 * TRUE if there are any non active rows in the table.
 *
 * 28-June-1993 MGH
 * Changed all references of "asod" to "contextInfo".  The
 * variable is now a ContextInfo variable.
 *
 * 1-July-1993 MGH
 * Added a check to partyEntry_test() and partyEntry_set() to ensure that
 * a new row will have a unique partyIndex field.  For now, the partyIndex
 * field for a new row is assigned the value of the biggest current
 * partyIndex plus one.  The max_party_index variable holds that value,
 * and its value cannot decrease during run-time if rows are deleted. The
 * code will eventually use the smallest available partyIndex value.
 *
 * 20-July-1993 DAR
 * Removed searchType parameter to calls to scalar k_ get routines
 * Added nominator parameter to all calls to k_ get routines.
 * Removed valid paramter from all calls to k_ set routines.
 * changed test methods to use valid field defined in snmptype.h
 *
 * 26-July-1993 MGH
 * Added an external global variable, writePartyFlag.  It's set to TRUE if
 * a set succeeds on the party table.  Moved the call of WriteParties()
 * from partyEntry_set() up 4 levels to main.c (after sending response packet).
 *
 */

#include "master.h"
#include <ciscolib.h>




#include "sr_snmpd.h"

#ifdef SR_SNMPv2


#include "sr_diag.h"
#include "sr_snmpv2mib.h"


typedef struct _V2_PARTY_TABLE {
    partyEntry_t   *party;
    OID            *party_instance;
}               V2_PARTY_TABLE;

extern int      partyMibNotActiveFlag;
extern int      writePartyFlag;

/*----------------------------------------------------------------------
 * Retrieve data from the partyEntry group.
 * This is performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *----------------------------------------------------------------------*/
VarBind        *
partyEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{

    int             instLength = incoming->length - object->oid.length;
    int             arg = -1;
    int             i;
    int             found;
    void           *dp;
    OID            *party_instance;
    OID            *best;
    unsigned long   now;

    found = -1;
    best = NULL;
    dp = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of the form:
     * InitialPartyId.a.b.c.d.num, where a.b.c.d is the IP address for the
     * party.
     * 
     * A NEXT search  requires that the requested object does not
     * lexicographically precede the current object type.
     */


    switch (searchType) {
      case EXACT:
	if (instLength > 0) {
	    arg = object->nominator;
	}
	else {
	    return ((VarBind *) NULL);
	}
	break;

      case NEXT:
	arg = object->nominator;
	break;

      default:
	DPRINTF((APWARN, "snmpd: Internal error. (invalid search type in \
partyEntry_get -- %d)\n", searchType));
    }				/* switch */

    /*
     * Retrieve the data from the party database and return  instance if
     * successful.
     */

    /*
     * Determine instance OID -- first sub-field after name
     */
    if (CmpOIDClass(incoming, &object->oid) == 0) {
	if (instLength > 0) {
	    if ((party_instance = (OID *) malloc(sizeof(OID))) == NULL) {
		DPRINTF((APWARN, "partyEntry_get: malloc failure\n"));
		return ((VarBind *) NULL);
	    }
	    party_instance->oid_ptr = NULL;
	    party_instance->length = instLength;

	    if ((party_instance->oid_ptr = (unsigned long *)
		 malloc((unsigned) (party_instance->length * sizeof(unsigned long)))) == NULL) {
		DPRINTF((APWARN, "partyEntry_get: malloc failure\n"));
		FreeOID(party_instance);
		party_instance = NULL;
		return ((VarBind *) NULL);
	    }

	    for (i = 0; i < party_instance->length; i++) {
		party_instance->oid_ptr[i] =
		    incoming->oid_ptr[i + object->oid.length];
	    }
	}
	else {
	    if ((party_instance = MakeOIDFromDot("0.0")) == NULL) {
		DPRINTF((APWARN, "partyEntry_get: malloc failure for 0.0\n"));
		return ((VarBind *) NULL);
	    }

	}
    }
    else {
	if ((party_instance = MakeOIDFromDot("0.0")) == NULL) {
	    DPRINTF((APWARN, "partyEntry_get: malloc failure for 0.0\n"));
	    return ((VarBind *) NULL);
	}
    }

    /*
     * Now scan the party table
     */

    if (arg != -1) {
	if (searchType == EXACT) {
	    for (i = 0; i < num_parties; i++) {
		if (parties[i].party == NULL) {
		    continue;
		}
		if ((CmpOID(parties[i].party->partyIdentity,
			    party_instance) == 0)) {
		    best = parties[i].party->partyIdentity;
		    found = i;
		    break;
		}
	    }			/* for */
	}			/* if searchType */
	else {			/* searchType */
	    best = NULL;
	    for (i = 0; i < num_parties; i++) {
		if (parties[i].party == NULL) {
		    continue;
		}
		/*
		 * best = thisone if ((incoming > thisone) && (thisone <
		 * best) && (entry is valid))
		 */
		if ((CmpOID(parties[i].party->partyIdentity, party_instance) > 0)
		    && ((best == NULL) || (CmpOID(parties[i].party->partyIdentity,
						  best) < 0))) {
		    best = parties[i].party->partyIdentity;
		    found = i;
		}		/* if match */
	    }			/* for */
	}			/* else searchType */

	FreeOID(party_instance);
	party_instance = NULL;

	if (searchType == EXACT) {
	    if (i == num_parties) {	/* Not found by the end of the table */
		DPRINTF((APTRACE, "partyEntry_get: Exact search failed.\n"));
		return ((VarBind *) NULL);
	    }
	}

	else {			/* searchType == NEXT */
	    if (best == NULL) {
		DPRINTF((APTRACE, "partyEntry_get: Next search failed.\n"));
		return ((VarBind *) NULL);
	    }
	}

    }				/* if arg != -1 */

    switch (arg) {

#ifdef I_partyIndex
      case I_partyIndex:
	dp = (void *) &parties[found].party->partyIndex;
	break;
#endif				/* I_partyIndex */

#ifdef I_partyTDomain
      case I_partyTDomain:
	if (parties[found].party->partyTDomain == SNMP_UDP_DOMAIN) {
	    dp = (void *) CloneOID(snmpUDPDomainOID);
	}
	else if (parties[found].party->partyTDomain == RFC_1157_DOMAIN) {
	    dp = (void *) CloneOID(rfc1157DomainOID);
	}

	if (dp == (void *) NULL) {
	    DPRINTF((APWARN, "partyEntry_get: Cannot allocate memory for partyTDomain\n"));
	    return ((VarBind *) NULL);
	}
	break;
#endif				/* I_partyTDomain */

#ifdef I_partyTAddress
      case I_partyTAddress:
	if ((dp = (void *) CloneOctetString(parties[found].party->partyTAddress)) ==
	    (void *) NULL) {
	    DPRINTF((APWARN, "partyEntry_get: Cannot allocate memory for partyTAddress\n"));
	    return ((VarBind *) NULL);
	}
	break;
#endif				/* I_partyTAddress */

#ifdef I_partyMaxMessageSize
      case I_partyMaxMessageSize:
	dp = (void *) &parties[found].party->partyMaxMessageSize;
	break;
#endif				/* I_partyMaxMessageSize */

#ifdef I_partyLocal
      case I_partyLocal:
	dp = (void *) &parties[found].party->partyLocal;
	break;
#endif				/* I_partyLocal */

#ifdef I_partyAuthProtocol
      case I_partyAuthProtocol:
	if (parties[found].party->partyAuthProtocol == NOAUTH_AUTHENTICATION) {
	    if ((dp = (void *) CloneOID(noAuthOID)) == (void *) NULL) {
		DPRINTF((APWARN, "partyEntry_get: Cannot allocate memory for noAuthOID\n"));
		return ((VarBind *) NULL);
	    }
	}

#ifdef SR_SNMPv1
	else if (parties[found].party->partyTDomain == RFC_1157_DOMAIN) {
	    if ((dp = (void *) CloneOID(rfc1157noAuthOID)) == (void *) NULL) {
		DPRINTF((APWARN, "partyEntry_get: Cannot allocate memory for rfc1157noAuthOID\n"));
		return ((VarBind *) NULL);
	    }
	}
#endif				/* SR_SNMPv1 */

#ifndef SR_UNSECURABLE
	else if (parties[found].party->partyAuthProtocol == MD5_SNMPv2_AUTHENTICATION) {
	    if ((dp = (void *) CloneOID(md5AuthOID)) == (void *) NULL) {
		DPRINTF((APWARN, "partyEntry_get: Cannot allocate memory for md5AuthOID\n"));
		return ((VarBind *) NULL);
	    }
	}
#endif				/* SR_UNSECURABLE */

	else {
	    if ((dp = (void *) MakeOIDFromDot("0.0")) == NULL) {
		DPRINTF((APWARN, "partyEntry_get: Cannot allocate memory for 0.0\n"));
		return ((VarBind *) NULL);
	    }
	}
	break;
#endif				/* I_partyAuthProtocol */

#ifdef I_partyAuthClock
      case I_partyAuthClock:
	/* Check for clock overflow */

	now = GetTimeNow() / 100;

	if (basetime > (MAX_CLOCK_VALUE - now)) {
	    now = MAX_CLOCK_VALUE;
	}
	else {
	    now = now + basetime;
	    if (parties[found].party->partyAuthClock > (MAX_CLOCK_VALUE - now)) {
		now = MAX_CLOCK_VALUE;
	    }
	    else {
		now = now + parties[found].party->partyAuthClock;
	    }
	}
	dp = (void *) &now;
	break;
#endif				/* I_partyAuthClock */

#ifdef I_partyAuthPrivate
      case I_partyAuthPrivate:
	if (parties[found].party->partyAuthPrivate != NULL) {
	    if ((dp = (void *) MakeOctetStringFromText("")) ==
		(void *) NULL) {
		DPRINTF((APWARN, "partyEntry_get: Cannot allocate memory for partyAuthPrivate\n"));
		return ((VarBind *) NULL);
	    }
	}
	else {
	    DPRINTF((APTRACE, "partyEntry_get: partyAuthPrivate is NULL.\n"));
	    return ((VarBind *) NULL);
	}

	break;
#endif				/* I_partyAuthPrivate */

#ifdef I_partyAuthPublic
      case I_partyAuthPublic:
	if ((dp = (void *) CloneOctetString(parties[found].party->partyAuthPublic)) ==
	    (void *) NULL) {
	    DPRINTF((APWARN, "partyEntry_get: Cannot allocate memory for partyAuthPublic\n"));
	    return ((VarBind *) NULL);
	}
	break;
#endif				/* I_partyAuthPublic */

#ifdef I_partyAuthLifetime
      case I_partyAuthLifetime:
	dp = (void *) &parties[found].party->partyAuthLifetime;
	break;
#endif				/* I_partyAuthLifetime */

#ifdef I_partyPrivProtocol
      case I_partyPrivProtocol:
	if ((parties[found].party->partyPrivProtocol == NOPRIV) ||
	    (parties[found].party->partyTDomain == RFC_1157_DOMAIN)) {
	    if ((dp = (void *) CloneOID(noPrivOID)) == (void *) NULL) {
		DPRINTF((APWARN, "partyEntry_get: Cannot allocate memory for noPrivOID\n"));
		return ((VarBind *) NULL);
	    }
	}

#ifndef SR_UNSECURABLE

#ifndef SR_NO_PRIVACY
	else if (parties[found].party->partyPrivProtocol == DESPRIV) {
	    if ((dp = (void *) CloneOID(desPrivOID)) == (void *) NULL) {
		DPRINTF((APWARN, "partyEntry_get: Cannot allocate memory for desPrivOID\n"));
		return ((VarBind *) NULL);
	    }
	}
#endif				/* SR_NO_PRIVACY */

#endif				/* SR_UNSECURABLE */

	else {
	    if ((dp = (void *) MakeOIDFromDot("0.0")) == NULL) {
		DPRINTF((APWARN, "partyEntry_get: Cannot allocate memory for 0.0\n"));
		return ((VarBind *) NULL);
	    }
	}
	break;
#endif				/* I_partyPrivProtocol */

#ifdef I_partyPrivPrivate
      case I_partyPrivPrivate:
	if (parties[found].party->partyPrivPrivate != NULL) {
	    if ((dp = (void *) MakeOctetStringFromText("")) ==
		(void *) NULL) {
		DPRINTF((APWARN, "partyEntry_get: Cannot allocate memory for partyPrivPrivate\n"));
		return ((VarBind *) NULL);
	    }
	}
	else {
	    DPRINTF((APTRACE, "partyEntry_get: partyPrivPrivate is NULL.\n"));
	    return ((VarBind *) NULL);
	}
	break;
#endif				/* I_partyPrivPrivate */

#ifdef I_partyPrivPublic
      case I_partyPrivPublic:
	if ((dp = (void *) CloneOctetString(parties[found].party->partyPrivPublic)) ==
	    (void *) NULL) {
	    DPRINTF((APWARN, "partyEntry_get: Cannot allocate memory for partyPrivPublic\n"));
	    return ((VarBind *) NULL);
	}
	break;
#endif				/* I_partyPrivPublic */

#ifdef I_partyCloneFrom
      case I_partyCloneFrom:
	if ((dp = (void *) MakeOIDFromDot("0.0")) ==
	    (void *) NULL) {
	    DPRINTF((APWARN, "partyEntry_get: Cannot allocate memory for partyCloneFrom\n"));
	    return ((VarBind *) NULL);
	}
	break;
#endif				/* I_partyCloneFrom */

#ifdef I_partyStorageType
      case I_partyStorageType:
	dp = (void *) &parties[found].party->partyStorageType;
	break;
#endif				/* I_partyMemoryType */


#ifdef I_partyStatus
      case I_partyStatus:
	dp = (void *) &parties[found].party->partyStatus;
	break;
#endif				/* I_partyStatus */

#ifdef I_snmpTrapNumbers
      case I_snmpTrapNumbers:
	dp = (void *) &parties[found].party->snmpTrapNumbers;
	break;
#endif				/* I_snmpTrapNumbers */

      default:
	DPRINTF((APWARN, "partyEntry_get: Invalid variable request.\n"));
	return ((VarBind *) NULL);
    }				/* switch */

    return (MakeVarBind(object, best, dp));

}				/* partyEntry_get() */

#ifdef SETS
static void partyEntry_freex SR_PROTOTYPE((V2_PARTY_TABLE *data));

static void
partyEntry_freex(data)
    V2_PARTY_TABLE *data;
{

    if (data != NULL) {

	if (data->party_instance != NULL) {
	    FreeOID(data->party_instance);
	    data->party_instance = NULL;
	}
	if (data->party != NULL) {
	    if (data->party->partyTDomain != NULL) {
		FreeOID(data->party->partyTDomain);
		data->party->partyTDomain = NULL;
	    }
	    if (data->party->partyTAddress != NULL) {
		FreeOctetString(data->party->partyTAddress);
		data->party->partyTAddress = NULL;
	    }
	    if (data->party->partyAuthProtocol != NULL) {
		FreeOID(data->party->partyAuthProtocol);
		data->party->partyAuthProtocol = NULL;
	    }
	    if (data->party->partyAuthPublic != NULL) {
		FreeOctetString(data->party->partyAuthPublic);
		data->party->partyAuthPublic = NULL;
	    }
	    if (data->party->partyCloneFrom != NULL) {
		FreeOID(data->party->partyCloneFrom);
		data->party->partyCloneFrom = NULL;
	    }
	    if (data->party->partyPrivProtocol != NULL) {
		FreeOID(data->party->partyPrivProtocol);
		data->party->partyPrivProtocol = NULL;
	    }
	    if (data->party->partyPrivPublic != NULL) {
		FreeOctetString(data->party->partyPrivPublic);
		data->party->partyPrivPublic = NULL;
	    }
	    if (data->party->partyAuthPrivate != NULL) {
		FreeOctetString(data->party->partyAuthPrivate);
		data->party->partyAuthPrivate = NULL;
	    }
	    if (data->party->partyPrivPrivate != NULL) {
		FreeOctetString(data->party->partyPrivPrivate);
		data->party->partyPrivPrivate = NULL;
	    }
	    free((char *) data->party);
	    data->party = NULL;
	}			/* if (data->party != NULL) */

	free((char *) data);
	data = NULL;

    }
}				/* partyEntry_freex() */

/*----------------------------------------------------------------------
 * Cleanup after partyEntry set/undo.
 *----------------------------------------------------------------------*/
static int partyEntry_cleanup SR_PROTOTYPE((doList_t *trash));

static int
partyEntry_cleanup(trash)
    doList_t       *trash;
{
    partyEntry_freex(trash->data);

#ifdef SR_SNMPv2
    partyEntry_freex(trash->undodata);
#endif				/* SR_SNMPv2 */

    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *----------------------------------------------------------------------*/
int
partyEntry_test(incoming, object, value, dolist_head, doCur, contextInfo)
    OID            *incoming;
    ObjectInfo     *object;
    ObjectSyntax   *value;
    doList_t       *dolist_head;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    int             instLength = incoming->length - object->oid.length;
    int             i, return_val;
    int             found, name_found;
    int             clone_index;
    unsigned long   now, delta;
    doList_t       *dp;
    V2_PARTY_TABLE *party;
    OID            *party_instance;
    OID            *best;


    /*
     * Validate the object instance. 1) It should have a length > 0
     * (InitialPartyID.a.b.c.d.num) 2) Validate the partyIdentity.
     */

    if (instLength <= 0) {
	DPRINTF((APTRACE, "partyEntry_test: Invalid instance\n"));
	return (NO_CREATION_ERROR);
    }

    /*
     * Determine instance OID -- first sub-field after name
     */
    if (CmpOIDClass(incoming, &object->oid) == 0) {
	if ((party_instance = (OID *) malloc(sizeof(OID))) == NULL) {
	    DPRINTF((APWARN, "partyEntry_test: malloc failure on party_instance\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	party_instance->oid_ptr = NULL;
	party_instance->length = instLength;

	if ((party_instance->oid_ptr = (unsigned long *)
	     malloc((unsigned) (party_instance->length * sizeof(unsigned long)))) == NULL) {
	    DPRINTF((APWARN, "partyEntry_test: malloc failure on party_instance->length\n"));
	    FreeOID(party_instance);
	    party_instance = NULL;
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}

	for (i = 0; i < party_instance->length; i++) {
	    party_instance->oid_ptr[i] =
		incoming->oid_ptr[i + object->oid.length];
	}
    }
    else {
	if ((party_instance = MakeOIDFromDot("0.0")) == NULL) {
	    DPRINTF((APWARN, "partyEntry_test: malloc failure on 0.0\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}

    }

    /*
     * Now scan the party table
     */
    name_found = -1;
    best = (OID *) NULL;

    for (i = 0; i < num_parties; i++) {
	if (parties[i].party == NULL) {
	    continue;
	}
	if ((CmpOID(parties[i].party->partyIdentity,
		    party_instance) == 0)) {
	    best = parties[i].party->partyIdentity;
	    name_found = i;
	    break;
	}
    }				/* for */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = dolist_head; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == partyEntry_set) &&
	    (((V2_PARTY_TABLE *) (dp->data)) != (V2_PARTY_TABLE *) NULL)) {
	    /*
	     * If best is non-null, a match was found.  If best matches a
	     * previous do-list element, the two elements are related and are
	     * part of an entry in the table.
	     */
	    if ((((V2_PARTY_TABLE *) (dp->data))->party_instance !=
		 (OID *) NULL) && (best != (OID *) NULL)) {
		if (CmpOID(((V2_PARTY_TABLE *) (dp->data))->party_instance,
			   best) == 0) {
		    found = 1;
		    break;
		}
	    }
	    /*
	     * If best is null(no entry in the table), but the instance for
	     * this do-list element matches a previous do-list element, the
	     * two elements are related, and they need to be added to the
	     * table.
	     */
	    else if ((((V2_PARTY_TABLE *) (dp->data))->party_instance !=
		      (OID *) NULL) && (best == (OID *) NULL)) {
		if (CmpOID(((V2_PARTY_TABLE *) (dp->data))->party_instance,
			   party_instance) == 0) {
		    found = 1;
		    break;
		}
	    }			/* else if */
	}			/* if dp->setMethod */
    }				/* for (dp = dolist_head . . . */

    /*
     * If a related do-list element was found, mark the one created for this
     * SET request with a NULL setMethod (this invalidates it).
     * 
     * Otherwise, there does not exist a related do-list element so fill-in the
     * do-list element with all known/default values.
     */

    if (!found) {
	dp = doCur;
	if ((dp->data = (void *) malloc((unsigned) sizeof(V2_PARTY_TABLE))) == NULL) {
	    DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for V2_PARTY_TABLE\n"));
	    FreeOID(party_instance);
	    party_instance = NULL;
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset((char *) dp->data, 0, sizeof(V2_PARTY_TABLE));

	if ((((V2_PARTY_TABLE *) (dp->data))->party =
	(partyEntry_t *) malloc((unsigned) sizeof(partyEntry_t))) == NULL) {
	    DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for partyEntry_t\n"));
	    FreeOID(party_instance);
	    party_instance = NULL;
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset((char *) ((V2_PARTY_TABLE *) (dp->data))->party, 0, sizeof(partyEntry_t));
	dp->setMethod = partyEntry_set;
	dp->cleanupMethod = partyEntry_cleanup;
	dp->state = UNKNOWN;

	/*
	 * Try to fill in reasonable default values for this new party entry.
	 */

	if (name_found == -1) {	/* new row in the table */
	    /*
	     * If there are SR_MAX_INDEX rows already in the table, or if the
	     * configuration file has an entry with partyIndex =
	     * SR_MAX_INDEX(65535), no more rows can be created. So, if you
	     * have three rows in the party table with partyIndex = 1, 299,
	     * and 65535 respectively, no more entries can be created.  The
	     * code will eventually look for the smallest available number
	     * and use that as the partyIndex field.  But until then, it uses
	     * the biggest partyIndex value plus one for the next new row's
	     * partyIndex value.
	     * 
	     * So, if you had 2 rows in the table at startup, with partyIndex =
	     * 5 and 20, max_party_index would be set to 21 and used as the
	     * partyIndex.  The max_party_index field will not change when
	     * rows are deleted unless the agent is stopped and restarted
	     * (i.e., reread configuration file).
	     */
	    if (max_party_index > SR_MAX_INDEX) {
		DPRINTF((APWARN, "partyEntry_test: Cannot add a row.\n"));
		FreeOID(party_instance);
		party_instance = NULL;
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }

	    if ((((V2_PARTY_TABLE *) (dp->data))->party_instance =
		 (OID *) CloneOID(party_instance)) == (OID *) NULL) {
		DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for new party_instance\n"));
		FreeOID(party_instance);
		party_instance = NULL;
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }

	    FreeOID(party_instance);
	    party_instance = NULL;

	    if ((((V2_PARTY_TABLE *) (dp->data))->party->partyTDomain =
		 (OID *) CloneOID(snmpUDPDomainOID)) == (OID *) NULL) {
		DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for partyTDomain\n"));
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }

	    if ((((V2_PARTY_TABLE *) (dp->data))->party->partyTAddress =
	       MakeOctetStringFromText("123456")) == (OctetString *) NULL) {
		DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for partyTAddress\n"));
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }
	    for (i = 0; i < TADDR_LEN; i++) {
		((V2_PARTY_TABLE *) (dp->data))->party->partyTAddress->octet_ptr[i] = '\0';
	    }

	    ((V2_PARTY_TABLE *) (dp->data))->party->partyAuthClock = 0;
	    ((V2_PARTY_TABLE *) (dp->data))->party->partyLocal = SR_REMOTE;
	    ((V2_PARTY_TABLE *) (dp->data))->party->snmpTrapNumbers = 0;

	    ((V2_PARTY_TABLE *) (dp->data))->party->partyMaxMessageSize = 484;

	    ((V2_PARTY_TABLE *) (dp->data))->party->partyCloneFrom = NULL;

	    ((V2_PARTY_TABLE *) (dp->data))->party->partyAuthPrivate = NULL;

	    ((V2_PARTY_TABLE *) (dp->data))->party->partyPrivPrivate = NULL;

	    ((V2_PARTY_TABLE *) (dp->data))->party->partyStatus = DESTROY;

	    ((V2_PARTY_TABLE *) (dp->data))->party->partyStorageType =
		NONVOLATILE;

	    SET_ALL_VALID(((V2_PARTY_TABLE *) (dp->data))->party->valid);
	    CLR_VALID(I_partyAuthLifetime, ((V2_PARTY_TABLE *) (dp->data))->party->valid);
	    CLR_VALID(I_partyAuthProtocol, ((V2_PARTY_TABLE *) (dp->data))->party->valid);
	    CLR_VALID(I_partyAuthPublic, ((V2_PARTY_TABLE *) (dp->data))->party->valid);
	    CLR_VALID(I_partyAuthPrivate, ((V2_PARTY_TABLE *) (dp->data))->party->valid);
	    CLR_VALID(I_partyPrivProtocol, ((V2_PARTY_TABLE *) (dp->data))->party->valid);
	    CLR_VALID(I_partyPrivPublic, ((V2_PARTY_TABLE *) (dp->data))->party->valid);
	    CLR_VALID(I_partyPrivPrivate, ((V2_PARTY_TABLE *) (dp->data))->party->valid);
	    CLR_VALID(I_partyCloneFrom, ((V2_PARTY_TABLE *) (dp->data))->party->valid);
	}

	else {			/* the row already exists in the table */
	    FreeOID(party_instance);
	    party_instance = NULL;
	    if ((((V2_PARTY_TABLE *) (dp->data))->party_instance =
		 CloneOID(parties[name_found].party->partyIdentity)) == (OID *) NULL) {
		DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for party_instance\n"));
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }

	    ((V2_PARTY_TABLE *) (dp->data))->party->partyStatus =
		parties[name_found].party->partyStatus;
	    if (parties[name_found].party->partyAuthPrivate != NULL) {
		if ((((V2_PARTY_TABLE *) (dp->data))->party->partyAuthPrivate =
		     CloneOctetString(parties[name_found].party->partyAuthPrivate)) ==
		    (OctetString *) NULL) {
		    DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for partyAuthPrivate\n"));
		    return (RESOURCE_UNAVAILABLE_ERROR);
		}
		if (parties[name_found].party->partyStatus != NOT_READY) {
		    SET_VALID(I_partyAuthPrivate, ((V2_PARTY_TABLE *) (dp->data))->party->valid);
		}
	    }
	    else {
		((V2_PARTY_TABLE *) (dp->data))->party->partyAuthPrivate = NULL;
	    }
	    if (parties[name_found].party->partyPrivPrivate != NULL) {
		if ((((V2_PARTY_TABLE *) (dp->data))->party->partyPrivPrivate =
		     CloneOctetString(parties[name_found].party->partyPrivPrivate)) ==
		    (OctetString *) NULL) {
		    DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for partyPrivPrivate\n"));
		    return (RESOURCE_UNAVAILABLE_ERROR);
		}
		if (parties[name_found].party->partyStatus != NOT_READY) {
		    SET_VALID(I_partyPrivPrivate, ((V2_PARTY_TABLE *) (dp->data))->party->valid);
		}
	    }
	    else {
		((V2_PARTY_TABLE *) (dp->data))->party->partyPrivPrivate = NULL;
	    }
	    /*
	     * For partyCloneFrom, a value of -2 means uninitialized, -1
	     * means a value of "0.0", and anything >= 0 is an index into the
	     * party table.
	     */
	    if (parties[name_found].party->partyCloneFrom != -2) {
		if (parties[name_found].party->partyCloneFrom == -1) {
		    if ((((V2_PARTY_TABLE *) (dp->data))->party->partyCloneFrom =
			 MakeOIDFromDot("0.0")) == (OID *) NULL) {
			DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for partyCloneFrom\n"));
			return (RESOURCE_UNAVAILABLE_ERROR);
		    }
		}
		else {
		    if ((parties[name_found].party->partyCloneFrom < num_parties) &&
			(parties[parties[name_found].party->partyCloneFrom].party->partyStatus == ACTIVE)) {
			if ((((V2_PARTY_TABLE *) (dp->data))->party->partyCloneFrom =
			     CloneOID(parties[parties[name_found].party->partyCloneFrom].party->partyIdentity)) == (OID *) NULL) {
			    DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for partyCloneFrom\n"));
			    return (RESOURCE_UNAVAILABLE_ERROR);
			}
		    }
		    else {
			if ((((V2_PARTY_TABLE *) (dp->data))->party->partyCloneFrom =
			     MakeOIDFromDot("0.0")) == (OID *) NULL) {
			    DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for partyCloneFrom\n"));
			    return (RESOURCE_UNAVAILABLE_ERROR);
			}
		    }
		}
		if (((V2_PARTY_TABLE *) (dp->data))->party->partyCloneFrom ==
		    (OID *) NULL) {
		    DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for partyCloneFrom\n"));
		    return (RESOURCE_UNAVAILABLE_ERROR);
		}
	    }
	    else {
		((V2_PARTY_TABLE *) (dp->data))->party->partyCloneFrom = NULL;
	    }
	}			/* else if */

    }				/* if (!found) */
    else {
	FreeOID(party_instance);
	party_instance = NULL;
    }
    /*
     * Add the SET request to the do-list element.  Test the validity of the
     * value at this point.
     */

    party = (V2_PARTY_TABLE *) (dp->data);

    switch (object->nominator) {

#ifdef I_partyTDomain
      case I_partyTDomain:
	if (party->party->partyTDomain != (OID *) NULL) {
	    FreeOID(party->party->partyTDomain);
	    party->party->partyTDomain = NULL;
	}
	if ((CmpOID(value->oid_value, rfc1157DomainOID) != 0) &&
	    (CmpOID(value->oid_value, snmpUDPDomainOID) != 0)) {
	    DPRINTF((APTRACE, "partyEntry_test: partyTDomain not valid.\n"));
	    return (WRONG_VALUE_ERROR);
	}

	if ((party->party->partyTDomain = CloneOID(value->oid_value)) ==
	    (OID *) NULL) {
	    DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for partyTDomain\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	SET_VALID(I_partyTDomain, party->party->valid);
	break;
#endif				/* I_partyTDomain */

#ifdef I_partyTAddress
      case I_partyTAddress:
	if (value->os_value->length != TADDR_LEN) {
	    /* 4 for address, 2 for port */
	    DPRINTF((APTRACE, "partyEntry_test: Invalid partyTAddress length (%d)\n",
		     value->os_value->length));
	    return (WRONG_LENGTH_ERROR);
	}

	if (party->party->partyTAddress != (OctetString *) NULL) {
	    FreeOctetString(party->party->partyTAddress);
	    party->party->partyTAddress = NULL;
	}

	if ((party->party->partyTAddress =
	     CloneOctetString(value->os_value)) == (OctetString *) NULL) {
	    DPRINTF((APWARN, "partyEntry_test: malloc failure for partyTAddress\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}

	SET_VALID(I_partyTAddress, party->party->valid);
	break;
#endif				/* I_partyTAddress */

#ifdef I_partyLocal
      case I_partyLocal:
	if ((value->sl_value != SR_LOCAL) &&
	    (value->sl_value != SR_REMOTE)) {
	    DPRINTF((APTRACE, "partyEntry_test: Invalid value for partyLocal: %d\n",
		     value->sl_value));
	    return (WRONG_VALUE_ERROR);
	}
	party->party->partyLocal = value->sl_value;
	SET_VALID(I_partyLocal, party->party->valid);
	break;
#endif				/* I_partyLocal */

#ifdef I_partyAuthProtocol
      case I_partyAuthProtocol:
	if (name_found == -1) {

#ifndef SR_UNSECURABLE
	    if ((CmpOID(value->oid_value, noAuthOID) != 0) &&
		(CmpOID(value->oid_value, md5AuthOID) != 0)) {
#else				/* SR_UNSECURABLE */
	    if (CmpOID(value->oid_value, noAuthOID) != 0) {
#endif				/* SR_UNSECURABLE */

		DPRINTF((APTRACE, "partyEntry_test: Invalid value for partyAuthProtocol\n"));
		return (WRONG_VALUE_ERROR);
	    }

	    if (party->party->partyAuthProtocol != (OID *) NULL) {
		FreeOID(party->party->partyAuthProtocol);
		party->party->partyAuthProtocol = NULL;
	    }
	    if ((party->party->partyAuthProtocol =
		 CloneOID(value->oid_value)) == (OID *) NULL) {
		DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for partyAuthProtocol\n"));
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }
	    SET_VALID(I_partyAuthProtocol, party->party->valid);
	}			/* if (name_found == -1) */
	else {
	    DPRINTF((APTRACE, "partyEntry_test: Invalid value for partyAuthProtocol\n"));
	    return (INCONSISTENT_VALUE_ERROR);
	}
	break;
#endif				/* I_partyAuthProtocol */

#ifdef I_partyAuthClock
      case I_partyAuthClock:

	/* Check for clock overflow */

	now = GetTimeNow() / 100;
	if (basetime > (MAX_CLOCK_VALUE - now)) {
	    now = MAX_CLOCK_VALUE;
	}
	else {
	    now = now + basetime;
	}

	/*
	 * The clock cannot be set backwards unless it is set to 0. If the
	 * clock is set backwards, the party authprivate key must also be
	 * changed.
	 */
	if (name_found != -1) {
	    if (parties[name_found].party->partyAuthClock < (MAX_CLOCK_VALUE - now)) {
		if (((now + parties[name_found].party->partyAuthClock) > value->ul_value) &&
		    (value->ul_value != 0)) {
		    DPRINTF((APTRACE, "partyEntry_test: Invalid value for partyAuthClock\n"));
		    return (WRONG_VALUE_ERROR);
		}
	    }
	    else {
		now = MAX_CLOCK_VALUE;
		if ((now > value->ul_value) && (value->ul_value != 0)) {
		    DPRINTF((APTRACE, "partyEntry_test: Invalid value for partyAuthClock\n"));
		    return (WRONG_VALUE_ERROR);
		}
	    }
	}
	else {
	    if ((now > value->ul_value) && (value->ul_value != 0)) {
		DPRINTF((APTRACE, "partyEntry_test: Invalid value for partyAuthClock\n"));
		return (WRONG_VALUE_ERROR);
	    }
	}

	if (value->ul_value != 0) {
	    delta = value->ul_value - now;
	}
	else {
	    delta = 0;

#ifndef SR_UNSECURABLE
	    /*
	     * Need to set partyStatus to something appropriate here to
	     * indicate that the clock has been set backward and that the
	     * partyAuthPrivate value needs to be set to a new value.
	     */
	    if ((name_found != -1) &&
		((parties[name_found].party->partyStatus == ACTIVE) ||
	      (parties[name_found].party->partyStatus == NOT_IN_SERVICE)) &&
		(parties[name_found].party->partyAuthProtocol == MD5_SNMPv2_AUTHENTICATION)) {
		dp->state = CLOCK_SET_BACKWARDS_STATE;
	    }
#endif				/* SR_UNSECURABLE */
	}
	/*
	 * The clock cannot be set above MAX_CLOCK_VALUE - lifetime.
	 */
	if (name_found != -1) {
	    if (value->ul_value > (MAX_CLOCK_VALUE -
			    parties[name_found].party->partyAuthLifetime)) {
		DPRINTF((APTRACE, "partyEntry_test: partyAuthClock value too big.\n"));
		return (WRONG_VALUE_ERROR);
	    }
	}
	else {
	    if (value->ul_value > (MAX_CLOCK_VALUE -
				   party->party->partyAuthLifetime)) {
		DPRINTF((APTRACE, "partyEntry_test: partyAuthClock value too big.\n"));
		return (WRONG_VALUE_ERROR);
	    }
	}

	party->party->partyAuthClock = delta;
	SET_VALID(I_partyAuthClock, party->party->valid);
	break;
#endif				/* I_partyAuthClock */

#ifdef I_partyAuthPublic
      case I_partyAuthPublic:

#ifndef SR_UNSECURABLE
	/*
	 * MD5 does not use the public auth. key, so this can be set to
	 * anything.  It can be used to see if a set on the private auth. key
	 * worked by sending a set for this variable too.
	 */
#endif				/* SR_UNSECURABLE */

	if (value->os_value->length > KEY_LENGTH) {
	    DPRINTF((APTRACE, "partyEntry_test: partyAuthPublic length too big: %d.\n",
		     value->os_value->length));
	    return (WRONG_LENGTH_ERROR);
	}

	if (party->party->partyAuthPublic != (OctetString *) NULL) {
	    FreeOctetString(party->party->partyAuthPublic);
	    party->party->partyAuthPublic = NULL;
	}
	if ((party->party->partyAuthPublic =
	     CloneOctetString(value->os_value)) == (OctetString *) NULL) {
	    DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for partyAuthPublic\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	SET_VALID(I_partyAuthPublic, party->party->valid);
	break;
#endif				/* I_partyAuthPublic */

#ifdef I_partyAuthLifetime
      case I_partyAuthLifetime:
	if (name_found == -1) {
	    if (value->sl_value < 0) {
		DPRINTF((APTRACE, "partyEntry_test: Negative value for partyAuthLifetime: %d\n",
			 value->sl_value));
		return (WRONG_VALUE_ERROR);
	    }
	    party->party->partyAuthLifetime = value->sl_value;
	    SET_VALID(I_partyAuthLifetime, party->party->valid);
	}
	else {
	    return (INCONSISTENT_VALUE_ERROR);
	}
	break;
#endif				/* I_partyAuthLifetime */

#ifdef I_partyPrivProtocol
      case I_partyPrivProtocol:
	if (name_found == -1) {

#ifndef SR_UNSECURABLE

#ifndef SR_NO_PRIVACY
	    if ((CmpOID(value->oid_value, noPrivOID) != 0) &&
		(CmpOID(value->oid_value, desPrivOID) != 0)) {
#else				/* SR_NO_PRIVACY */
	    if (CmpOID(value->oid_value, noPrivOID) != 0) {
#endif				/* SR_NO_PRIVACY */

#else				/* SR_UNSECURABLE */
	    if (CmpOID(value->oid_value, noPrivOID) != 0) {
#endif				/* SR_UNSECURABLE */

		DPRINTF((APTRACE, "partyEntry_test: Bad value for partyPrivProtocol.\n"));

#ifndef SR_UNSECURABLE

#ifndef SR_NO_PRIVACY
		return (WRONG_VALUE_ERROR);	/* must be noPriv or des */
#else				/* SR_NO_PRIVACY */
		return (WRONG_VALUE_ERROR);	/* must be noPriv */
#endif				/* SR_NO_PRIVACY */

#else				/* SR_UNSECURABLE */
		return (WRONG_VALUE_ERROR);	/* must be noPriv */
#endif				/* SR_UNSECURABLE */
	    }

	    if (party->party->partyPrivProtocol != (OID *) NULL) {
		FreeOID(party->party->partyPrivProtocol);
		party->party->partyPrivProtocol = NULL;
	    }
	    if ((party->party->partyPrivProtocol =
		 (OID *) CloneOID(value->oid_value)) == (OID *) NULL) {
		DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for partyPrivProtocol\n"));
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }
	    SET_VALID(I_partyPrivProtocol, party->party->valid);
	}
	else {
	    return (INCONSISTENT_VALUE_ERROR);
	}
	break;
#endif				/* I_partyPrivProtocol */

#ifdef I_partyPrivPublic
      case I_partyPrivPublic:

#ifndef SR_UNSECURABLE

#ifndef SR_NO_PRIVACY
	/*
	 * DES does not use the public privacy key, so this can be set to
	 * anything.  It can be used to see if a set on the private privacy
	 * key worked by sending a set for this variable, too.
	 */
#endif				/* SR_NO_PRIVACY */

#endif				/* SR_UNSECURABLE */

	if (value->os_value->length > KEY_LENGTH) {
	    DPRINTF((APTRACE, "partyEntry_test: Invalid length for partyPrivPublic: %d\n",
		     value->os_value->length));
	    return (WRONG_LENGTH_ERROR);
	}
	if (party->party->partyPrivPublic != (OctetString *) NULL) {
	    FreeOctetString(party->party->partyPrivPublic);
	    party->party->partyPrivPublic = NULL;
	}
	if ((party->party->partyPrivPublic =
	     CloneOctetString(value->os_value)) == (OctetString *) NULL) {
	    DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for partyPrivPublic\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	SET_VALID(I_partyPrivPublic, party->party->valid);
	break;
#endif				/* I_partyPrivPublic */

#ifdef I_partyMaxMessageSize
      case I_partyMaxMessageSize:
	if ((value->sl_value < 484) || (value->sl_value > 65507)) {
	    DPRINTF((APTRACE, "partyEntry_test: Bad value for partyMaxMessageSize: %d\n",
		     value->sl_value));
	    return (WRONG_VALUE_ERROR);
	}

	party->party->partyMaxMessageSize = value->sl_value;
	SET_VALID(I_partyMaxMessageSize, party->party->valid);
	break;
#endif				/* I_partyMaxMessageSize */

#ifdef I_partyCloneFrom
      case I_partyCloneFrom:
	if ((clone_index = GetPartyEntry(value->oid_value)) == -1) {
	    DPRINTF((APTRACE, "partyEntry_test: partyClone party does not exist.\n"));
	    return (INCONSISTENT_VALUE_ERROR);
	}
	if (name_found == -1) {
	    if ((party->party->partyStatus != NOT_READY) &&
		(party->party->partyStatus != CREATE_AND_GO) &&
		(party->party->partyStatus != DESTROY)) {
		DPRINTF((APTRACE, "partyEntry_test: The row already exists (partyCloneFrom).\n"));
		return (INCONSISTENT_VALUE_ERROR);
	    }
	}
	else {			/* existing row */
	    if ((parties[name_found].party->partyStatus != NOT_READY) &&
		(parties[name_found].party->partyStatus != CREATE_AND_GO) &&
		(parties[name_found].party->partyStatus != DESTROY)) {
		DPRINTF((APTRACE, "partyEntry_test: The row already exists (partyCloneFrom).\n"));
		return (INCONSISTENT_VALUE_ERROR);
	    }
	}
	/*
	 * The partyCloneFrom field can be written only once.
	 */
	if (party->party->partyCloneFrom != (OID *) NULL) {
	    DPRINTF((APTRACE, "partyEntry_test: partyCloneFrom already exists.\n"));
	    return (INCONSISTENT_VALUE_ERROR);
	}
	if ((party->party->partyCloneFrom =
	     CloneOID(value->oid_value)) == (OID *) NULL) {
	    DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for partyCloneFrom\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	if (!VALID(I_partyAuthProtocol, party->party->valid)) {
	    if (party->party->partyAuthProtocol != NULL) {
		FreeOID(party->party->partyAuthProtocol);
		party->party->partyAuthProtocol = NULL;
	    }
	    if (parties[clone_index].party->partyAuthProtocol == NOAUTH_AUTHENTICATION) {
		if ((party->party->partyAuthProtocol =
		     CloneOID(noAuthOID)) == (OID *) NULL) {
		    DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for cloned auth protocol\n"));
		    return (RESOURCE_UNAVAILABLE_ERROR);
		}
	    }

#ifndef SR_UNSECURABLE
	    else if (parties[clone_index].party->partyAuthProtocol ==
		     MD5_SNMPv2_AUTHENTICATION) {
		if ((party->party->partyAuthProtocol =
		     CloneOID(md5AuthOID)) == (OID *) NULL) {
		    DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for cloned auth protocol\n"));
		    return (RESOURCE_UNAVAILABLE_ERROR);
		}
	    }
#endif				/* SR_UNSECURABLE */

	    else {		/* invalid value */
		DPRINTF((APTRACE, "partyEntry_test: invalid value for cloned auth protocol\n"));
		return (INCONSISTENT_VALUE_ERROR);
	    }
	    SET_VALID(I_partyAuthProtocol, party->party->valid);
	}			/* if partyAuthProtocol not valid */

	if (!VALID(I_partyPrivProtocol, party->party->valid)) {
	    if (party->party->partyPrivProtocol != NULL) {
		FreeOID(party->party->partyPrivProtocol);
		party->party->partyPrivProtocol = NULL;
	    }
	    if (parties[clone_index].party->partyPrivProtocol == NOPRIV) {
		if ((party->party->partyPrivProtocol =
		     CloneOID(noPrivOID)) == (OID *) NULL) {
		    DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for cloned priv protocol\n"));
		    return (RESOURCE_UNAVAILABLE_ERROR);
		}
	    }

#ifndef SR_UNSECURABLE

#ifndef SR_NO_PRIVACY
	    else if (parties[clone_index].party->partyPrivProtocol == DESPRIV) {
		if ((party->party->partyPrivProtocol =
		     CloneOID(desPrivOID)) == (OID *) NULL) {
		    DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for cloned priv protocol\n"));
		    return (RESOURCE_UNAVAILABLE_ERROR);
		}
	    }
#endif				/* SR_NO_PRIVACY */

#endif				/* SR_UNSECURABLE */

	    else {		/* invalid value */
		DPRINTF((APTRACE, "partyEntry_test: invalid value for cloned priv protocol\n"));
		return (INCONSISTENT_VALUE_ERROR);
	    }
	    SET_VALID(I_partyPrivProtocol, party->party->valid);
	}			/* if partyPrivProtocol not valid */

	if (!VALID(I_partyAuthPublic, party->party->valid)) {
	    if (party->party->partyAuthPublic != NULL) {
		FreeOctetString(party->party->partyAuthPublic);
		party->party->partyAuthPublic = NULL;
	    }
	    if ((party->party->partyAuthPublic =
	    CloneOctetString(parties[clone_index].party->partyAuthPublic)) ==
		(OctetString *) NULL) {
		DPRINTF((APWARN, "partyEntry_test: cannot clone party auth public.\n"));
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }
	    SET_VALID(I_partyAuthPublic, party->party->valid);
	}

	if (!VALID(I_partyPrivPublic, party->party->valid)) {
	    if (party->party->partyPrivPublic != NULL) {
		FreeOctetString(party->party->partyPrivPublic);
		party->party->partyPrivPublic = NULL;
	    }
	    if ((party->party->partyPrivPublic =
	    CloneOctetString(parties[clone_index].party->partyPrivPublic)) ==
		(OctetString *) NULL) {
		DPRINTF((APWARN, "partyEntry_test: cannot clone party priv public.\n"));
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }
	    SET_VALID(I_partyPrivPublic, party->party->valid);
	}

	if (!VALID(I_partyAuthLifetime, party->party->valid)) {
	    party->party->partyAuthLifetime =
		parties[clone_index].party->partyAuthLifetime;
	    SET_VALID(I_partyAuthLifetime, party->party->valid);
	}

	if (party->party->partyAuthPrivate == NULL) {
	    if ((party->party->partyAuthPrivate =
		 CloneOctetString(parties[clone_index].party->partyAuthPrivate)) ==
		(OctetString *) NULL) {
		DPRINTF((APWARN, "partyEntry_test: cannot clone party auth private.\n"));
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }
	}
	else {
	    for (i = 0; i < KEY_LENGTH; i++) {
		party->party->partyAuthPrivate->octet_ptr[i] ^=
		    parties[clone_index].party->partyAuthPrivate->octet_ptr[i];
	    }
	    SET_VALID(I_partyAuthPrivate, party->party->valid);
	}

	if (party->party->partyPrivPrivate == NULL) {
	    if ((party->party->partyPrivPrivate =
		 CloneOctetString(parties[clone_index].party->partyPrivPrivate)) ==
		(OctetString *) NULL) {
		DPRINTF((APWARN, "partyEntry_test: cannot clone party priv private.\n"));
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }
	}
	else {
	    for (i = 0; i < KEY_LENGTH; i++) {
		party->party->partyPrivPrivate->octet_ptr[i] ^=
		    parties[clone_index].party->partyPrivPrivate->octet_ptr[i];
	    }
	    SET_VALID(I_partyPrivPrivate, party->party->valid);
	}

	SET_VALID(I_partyCloneFrom, party->party->valid);
	break;
#endif				/* I_partyCloneFrom */

#ifdef I_partyStorageType
      case I_partyStorageType:
	if ((value->sl_value != OTHER) && (value->sl_value != VOLATILE) &&
	    (value->sl_value != NONVOLATILE) &&
	    (value->sl_value != PERMANENT)) {
	    DPRINTF((APTRACE, "partyEntry_test: Bad value for partyStorageType: %d.\n",
		     value->sl_value));
	    return (WRONG_VALUE_ERROR);
	}

	party->party->partyStorageType = value->sl_value;
	SET_VALID(I_partyStorageType, party->party->valid);
	break;
#endif				/* I_partyStorageType */

#ifdef I_partyAuthPrivate
      case I_partyAuthPrivate:

#ifndef SR_UNSECURABLE
	/*
	 * For MD5, the private auth. key must have a length of 16.
	 */
#endif				/* SR_UNSECURABLE */

	if (value->os_value->length != KEY_LENGTH) {
	    DPRINTF((APTRACE, "partyEntry_test: Wrong length for partyAuthPrivate: %d.\n",
		     value->os_value->length));
	    return (WRONG_LENGTH_ERROR);
	}

	if (party->party->partyAuthPrivate == NULL) {
	    if ((party->party->partyAuthPrivate =
		 CloneOctetString(value->os_value)) == NULL) {
		DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for partyAuthPrivate\n"));
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }
	}
	else {
	    for (i = 0; i < KEY_LENGTH; i++) {
		party->party->partyAuthPrivate->octet_ptr[i] ^=
		    value->os_value->octet_ptr[i];
	    }
	}

	SET_VALID(I_partyAuthPrivate, party->party->valid);
	break;
#endif				/* I_partyAuthPrivate */

#ifdef I_partyPrivPrivate
      case I_partyPrivPrivate:

#ifndef SR_UNSECURABLE

#ifndef SR_NO_PRIVACY
	/*
	 * For DES, the private privacy key must have a length of 16.
	 */
#endif				/* SR_NO_PRIVACY */

#endif				/* SR_UNSECURABLE */

	if (value->os_value->length != KEY_LENGTH) {
	    DPRINTF((APTRACE, "partyEntry_test: Wrong length for partyPrivPrivate: %d.\n",
		     value->os_value->length));
	    return (WRONG_LENGTH_ERROR);
	}

	if (party->party->partyPrivPrivate == NULL) {
	    if ((party->party->partyPrivPrivate =
		 CloneOctetString(value->os_value)) == NULL) {
		DPRINTF((APWARN, "partyEntry_test: Cannot allocate memory for partyPrivPrivate\n"));
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }
	}
	else {
	    for (i = 0; i < KEY_LENGTH; i++) {
		party->party->partyPrivPrivate->octet_ptr[i] ^=
		    value->os_value->octet_ptr[i];
	    }
	}

	SET_VALID(I_partyPrivPrivate, party->party->valid);
	break;
#endif				/* I_partyPrivPrivate */

#ifdef I_partyStatus
      case I_partyStatus:
	if ((return_val = set_row_status(value->sl_value, name_found,
			     &(dp->state), &(party->party->partyStatus))) !=
	    NO_ERROR) {
	    return (return_val);
	}
	SET_VALID(I_partyStatus, party->party->valid);
	break;
#endif				/* I_partyStatus */

      default:
	DPRINTF((APWARN, "partyEntry_test: Internal error. (test switch)\n"));
	return (NO_ACCESS_ERROR);
	break;
    }				/* switch */

    /*
     * Determine if all fields in the row are valid
     */

    if (name_found == -1) {
	switch (party->party->partyStatus) {
	  case CREATE_AND_WAIT:
	    party->party->partyStatus =
		(long) party_create_check(party->party->partyAuthProtocol,
					  party->party->partyAuthPrivate,
					  party->party->partyPrivProtocol,
					  party->party->partyPrivPrivate,
					  party->party->partyCloneFrom,
			     ((V2_PARTY_TABLE *) (dp->data))->party->valid);

	    SET_VALID(I_partyStatus, party->party->valid);
	    dp->state = ADD_MODIFY;
	    break;
	  case CREATE_AND_GO:
	    dp->state = party_status_check(party->party->partyAuthProtocol,
					   party->party->partyAuthPrivate,
					   party->party->partyPrivProtocol,
					   party->party->partyPrivPrivate,
					   party->party->partyCloneFrom,
			     ((V2_PARTY_TABLE *) (dp->data))->party->valid);

	    break;
	  case DESTROY:
	    dp->state = DELETE;
	    break;
	  case NOT_IN_SERVICE:
	    if ((return_val =
		 party_service_check(party->party->partyAuthProtocol,
				     party->party->partyAuthPrivate,
				     party->party->partyPrivProtocol,
				     party->party->partyPrivPrivate,
				     party->party->partyCloneFrom,
		    ((V2_PARTY_TABLE *) (dp->data))->party->valid)) != -1) {
		party->party->partyStatus = NOT_READY;
		SET_VALID(I_partyStatus, party->party->valid);
	    }
	    dp->state = ADD_MODIFY;
	    break;
	  case NOT_READY:
	    if ((return_val =
		 not_ready_check(party->party->partyAuthProtocol,
				 party->party->partyAuthPrivate,
				 party->party->partyPrivProtocol,
				 party->party->partyPrivPrivate,
				 party->party->partyCloneFrom,
		    ((V2_PARTY_TABLE *) (dp->data))->party->valid)) != -1) {
		party->party->partyStatus = NOT_IN_SERVICE;
		SET_VALID(I_partyStatus, party->party->valid);
	    }
	    dp->state = ADD_MODIFY;
	    break;
	  default:
	    DPRINTF((APWARN, "partyEntry_test: Very strange, invalid partyStatus value.\n"));
	    return (INCONSISTENT_VALUE_ERROR);
	    break;
	}			/* end switch */
    }				/* if (name_found == -1) */

    else {			/* the row exists */
	switch (party->party->partyStatus) {
	  case NOT_IN_SERVICE:
	    dp->state =
		not_in_service_check(parties[name_found].party->partyAuthProtocol,
				     party->party->partyAuthPrivate,
			       parties[name_found].party->partyPrivProtocol,
				     party->party->partyPrivPrivate,
				     party->party->partyCloneFrom,
			      ((V2_PARTY_TABLE *) (dp->data))->party->valid,
				     dp->state, name_found);

	    break;
	  case DESTROY:
	    dp->state = DELETE;
	    break;
	  case NOT_READY:
	    if ((return_val =
		 party_not_ready_check(parties[name_found].party->partyAuthProtocol,
				       party->party->partyAuthPrivate,
			       parties[name_found].party->partyPrivProtocol,
				       party->party->partyPrivPrivate,
				       party->party->partyCloneFrom,
		    ((V2_PARTY_TABLE *) (dp->data))->party->valid)) != -1) {
		party->party->partyStatus = NOT_IN_SERVICE;
		SET_VALID(I_partyStatus, party->party->valid);
	    }
	    dp->state = ADD_MODIFY;
	    break;
	  case ACTIVE:
	    if ((return_val =
	    party_active_check(parties[name_found].party->partyAuthProtocol,
			       party->party->partyAuthPrivate,
			       parties[name_found].party->partyPrivProtocol,
			       party->party->partyPrivPrivate,
			       party->party->partyCloneFrom,
			       ((V2_PARTY_TABLE *) (dp->data))->party->valid, dp->state, name_found)) != -1) {
		dp->state = ADD_MODIFY;
	    }
	    break;
	  default:
	    DPRINTF((APWARN, "partyEntry_test: Invalid value for party->party->partyStatus\n"));
	    return (INCONSISTENT_VALUE_ERROR);
	    break;
	}			/* end switch */
    }				/* else */

    DPRINTF((APTRACE, "partyEntry_test: Completed successfully.\n"));
    return (NO_ERROR);

}				/* partyEntry_test() */

/*----------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *
 * Note: In this case all related items are contained in the
 *    structure pointed to by "doCur->data," but in the more
 *    general case, this routine may need to scan the do-list to
 *    determine if there are other "related" objects. This is
 *    not recommended but is included for maximum flexibility.
 *----------------------------------------------------------------------*/
int
partyEntry_set(doHead, doCur, contextInfo)
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{

    SR_FNAME("partyEntry_set")
    V2_PARTY_TABLE *party;
    PARTY_TABLE    *temp_ptr;
    PARTY          *new_party;
    OID            *name;
    int             i;
    int             found, new_entry;
    int             open_slot;

    found = -1;
    new_entry = FALSE;
    new_party = NULL;
    temp_ptr = NULL;
    party = (V2_PARTY_TABLE *) (doCur->data);
    name = party->party_instance;

    switch (doCur->state) {
      case DELETE:
	for (i = 0; i < num_parties; i++) {
	    if (parties[i].party == NULL) {
		continue;
	    }
	    if (CmpOID(parties[i].party->partyIdentity, name) == 0) {
		DeletePartyElement(parties[i].party);
		parties[i].party = NULL;
		writePartyFlag = TRUE;
		return (NO_ERROR);
	    }
	}
	break;
      case ADD_MODIFY:
	open_slot = -1;
	for (i = 0; i < num_parties; i++) {
	    if ((parties[i].party == NULL) && (open_slot == -1)) {
		open_slot = i;
	    }
	    if (parties[i].party == NULL) {
		continue;
	    }
	    if (((CmpOID(parties[i].party->partyIdentity,
			 name)) == 0)) {
		found = i;
		break;
	    }
	}
	/*
	 * If the party name doesn't match any in the table, a new entry must
	 * be created.
	 */
	if (i == num_parties) {
	    if (max_party_index > SR_MAX_INDEX) {
		DPRINTF((APWARN, "partyEntry_set: Cannot add a row.\n"));
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }
	    new_entry = TRUE;
	    if (!(new_party = (PARTY *) malloc((unsigned) sizeof(PARTY)))) {
		DPRINTF((APWARN, "%s: Cannot allocate memory for new party entry\n", FName));
		return (GEN_ERROR);
	    }
	    memset((char *) new_party, 0, sizeof(PARTY));

	    if (open_slot == -1) {	/* Totally new entry needed */
		/*
		 * realloc party ptr table.
		 */
		num_parties++;
		if (!(temp_ptr = (PARTY_TABLE *) realloc((char *) parties,
			 (unsigned) (num_parties * sizeof(PARTY_TABLE))))) {
		    DPRINTF((APWARN, "%s: Cannot reallocate memory for party \
ptr table.\n", FName));
		    free((char *) new_party);
		    new_party = NULL;
		    num_parties--;
		    return (GEN_ERROR);
		}
		parties = temp_ptr;
		temp_ptr = NULL;
		found = num_parties - 1;

		parties[found].party = new_party;
	    }

	    else {		/* reuse old, invalidated entry */
		found = open_slot;
		parties[found].party = new_party;
	    }			/* else */

	    if ((parties[found].party->partyIdentity = CloneOID(name)) ==
		(OID *) NULL) {
		DPRINTF((APWARN, "%s: Cannot allocate memory for partyIdentity\n", FName));
		free((char *) new_party);
		new_party = NULL;
		parties[found].party = NULL;
		return (GEN_ERROR);
	    }

	    parties[found].party->partyIndex = max_party_index;
	    if (max_party_index <= SR_MAX_INDEX) {
		max_party_index++;
	    }
	    parties[found].party->partyTAddress = NULL;
	    parties[found].party->partyAuthPublic = NULL;
	    parties[found].party->partyAuthPrivate = NULL;
	    parties[found].party->partyPrivPublic = NULL;
	    parties[found].party->partyPrivPrivate = NULL;
	    parties[found].last_active = GetTimeNow() / 100;
	    parties[found].party->partyCloneFrom = -2;
	    parties[found].party->privs = SR_READ_ONLY;
	    parties[found].party->domain = SNMPv2_DOMAIN;

#ifndef SR_UNSECURABLE
	    parties[found].party->partyAuthProtocol = MD5_SNMPv2_AUTHENTICATION;
#else				/* SR_UNSECURABLE */
	    parties[found].party->partyAuthProtocol = NOAUTH_AUTHENTICATION;
#endif				/* SR_UNSECURABLE */

	    parties[found].party->partyPrivProtocol = NOPRIV;
	    parties[found].party->partyAuthLifetime = 300;

	    if ((parties[found].party->partyAuthPublic =
		 MakeOctetStringFromText("")) == (OctetString *) NULL) {
		DPRINTF((APWARN, "%s: Could not make partyAuthPublic.\n", FName));
		FreePartyElement(new_party);
		parties[found].party = NULL;
		return (GEN_ERROR);
	    }
	    if ((parties[found].party->partyPrivPublic =
		 MakeOctetStringFromText("")) == (OctetString *) NULL) {
		DPRINTF((APWARN, "%s: Could not make partyPrivPublic.\n", FName));
		FreePartyElement(new_party);
		parties[found].party = NULL;
		return (GEN_ERROR);
	    }

	}			/* if i == num_parties */

	if (VALID(I_partyTDomain, party->party->valid)) {
	    if (CmpOID(party->party->partyTDomain, snmpUDPDomainOID) == 0) {
		parties[found].party->partyTDomain = SNMP_UDP_DOMAIN;
	    }

#ifdef SR_SNMPv1
	    else if (CmpOID(party->party->partyTDomain, rfc1157DomainOID) == 0) {
		parties[found].party->partyTDomain = RFC_1157_DOMAIN;
	    }
#endif				/* SR_SNMPv1 */
	}

	if (VALID(I_partyTAddress, party->party->valid)) {
	    if (parties[found].party->partyTAddress != (OctetString *) NULL) {
		FreeOctetString(parties[found].party->partyTAddress);
		parties[found].party->partyTAddress = NULL;
	    }

	    if ((parties[found].party->partyTAddress =
		 CloneOctetString(party->party->partyTAddress)) == NULL) {
		DPRINTF((APWARN, "partyEntry_set: malloc failure for partyTAddress\n"));
		if (new_entry == TRUE) {
		    FreePartyElement(new_party);
		    parties[found].party = NULL;
		}

		return (GEN_ERROR);
	    }

	    bcopy((char *) &parties[found].party->partyTAddress->octet_ptr[TADDR_LEN - 2],
		  (char *) &parties[found].party->partyTPort, sizeof(unsigned short));

	    parties[found].party->partyTPort = parties[found].party->partyTPort;	/* Already in Network
											 * Byte Order */
	}

	if (VALID(I_partyAuthProtocol, party->party->valid)) {
	    if (CmpOID(party->party->partyAuthProtocol, noAuthOID) == 0) {
		parties[found].party->partyAuthProtocol = NOAUTH_AUTHENTICATION;
		if (parties[found].party->partyPrivProtocol == NOPRIV) {
		    parties[found].party->partyDiscriminator = 1;
		    parties[found].party->privs = SR_READ_ONLY;
		}
	    }

#ifndef SR_UNSECURABLE
	    else if (CmpOID(party->party->partyAuthProtocol,
			    md5AuthOID) == 0) {
		parties[found].party->partyAuthProtocol = MD5_SNMPv2_AUTHENTICATION;
		if (parties[found].party->partyPrivProtocol == NOPRIV) {
		    parties[found].party->partyDiscriminator = 3;
		    parties[found].party->privs = SR_READ_ONLY;
		}

#ifndef SR_NO_PRIVACY
		else if (parties[found].party->partyPrivProtocol == DESPRIV) {
		    parties[found].party->partyDiscriminator = 5;
		    parties[found].party->privs = SR_READ_WRITE;
		}
#endif				/* SR_NO_PRIVACY */
	    }
#endif				/* SR_UNSECURABLE */
	}

	if (VALID(I_partyAuthClock, party->party->valid)) {
	    parties[found].party->partyAuthClock = party->party->partyAuthClock;
	}

	if (VALID(I_partyAuthPublic, party->party->valid)) {
	    if (parties[found].party->partyAuthPublic != (OctetString *) NULL) {
		FreeOctetString(parties[found].party->partyAuthPublic);
		parties[found].party->partyAuthPublic = NULL;
	    }
	    if ((parties[found].party->partyAuthPublic =
		 CloneOctetString(party->party->partyAuthPublic)) == NULL) {
		DPRINTF((APWARN, "partyEntry_set: malloc failure for partyAuthPublic\n"));
		if (new_entry == TRUE) {
		    FreePartyElement(new_party);
		    parties[found].party = NULL;
		}

		return (GEN_ERROR);
	    }
	}

	if (VALID(I_partyAuthLifetime, party->party->valid)) {
	    parties[found].party->partyAuthLifetime = party->party->partyAuthLifetime;
	}

	if (VALID(I_partyPrivProtocol, party->party->valid)) {
	    if (CmpOID(party->party->partyPrivProtocol, noPrivOID) == 0) {
		parties[found].party->partyPrivProtocol = NOPRIV;
		if (parties[found].party->partyAuthProtocol == NOAUTH_AUTHENTICATION) {
		    parties[found].party->partyDiscriminator = 1;
		    parties[found].party->privs = SR_READ_ONLY;
		}

#ifndef SR_UNSECURABLE
		else if (parties[found].party->partyAuthProtocol == MD5_SNMPv2_AUTHENTICATION) {
		    parties[found].party->partyDiscriminator = 3;
		    parties[found].party->privs = SR_READ_ONLY;
		}
#endif				/* SR_UNSECURABLE */
	    }

#ifndef SR_UNSECURABLE

#ifndef SR_NO_PRIVACY
	    else if (CmpOID(party->party->partyPrivProtocol, desPrivOID) == 0) {
		parties[found].party->partyPrivProtocol = DESPRIV;
		if (parties[found].party->partyAuthProtocol == MD5_SNMPv2_AUTHENTICATION) {
		    parties[found].party->partyDiscriminator = 5;
		    parties[found].party->privs = SR_READ_WRITE;
		}
	    }
#endif				/* SR_NO_PRIVACY */

#endif				/* SR_UNSECURABLE */
	}

	if (VALID(I_partyPrivPublic, party->party->valid)) {
	    if (parties[found].party->partyPrivPublic != (OctetString *) NULL) {
		FreeOctetString(parties[found].party->partyPrivPublic);
		parties[found].party->partyPrivPublic = NULL;
	    }
	    if ((parties[found].party->partyPrivPublic =
		 CloneOctetString(party->party->partyPrivPublic)) == NULL) {
		DPRINTF((APWARN, "partyEntry_set: malloc failure for partyPrivPublic\n"));
		if (new_entry == TRUE) {
		    FreePartyElement(new_party);
		    parties[found].party = NULL;
		}
		return (GEN_ERROR);
	    }
	}

	if (VALID(I_partyMaxMessageSize, party->party->valid)) {
	    parties[found].party->partyMaxMessageSize =
		party->party->partyMaxMessageSize;
	}

	if (VALID(I_partyCloneFrom, party->party->valid)) {
	    parties[found].party->partyCloneFrom =
		GetPartyEntry(party->party->partyCloneFrom);

	    if (parties[found].party->partyAuthPrivate != NULL) {
		FreeOctetString(parties[found].party->partyAuthPrivate);
		parties[found].party->partyAuthPrivate = NULL;
	    }
	    if ((parties[found].party->partyAuthPrivate =
		 CloneOctetString(party->party->partyAuthPrivate)) ==
		(OctetString *) NULL) {
		DPRINTF((APWARN, "%s: Could not make partyAuthPrivate.\n", FName));
		if (new_entry == TRUE) {
		    FreePartyElement(new_party);
		    parties[found].party = NULL;
		}

		return (GEN_ERROR);
	    }
	    if (parties[found].party->partyPrivPrivate != NULL) {
		FreeOctetString(parties[found].party->partyPrivPrivate);
		parties[found].party->partyPrivPrivate = NULL;
	    }
	    if ((parties[found].party->partyPrivPrivate =
		 CloneOctetString(party->party->partyPrivPrivate)) ==
		(OctetString *) NULL) {
		DPRINTF((APWARN, "%s: Could not make partyPrivPrivate.\n", FName));
		if (new_entry == TRUE) {
		    FreePartyElement(new_party);
		    parties[found].party = NULL;
		}
		return (GEN_ERROR);
	    }
	}			/* if (VALID(I_partyCloneFrom, .....)) */

	if (VALID(I_partyAuthPrivate, party->party->valid)) {

	    if (parties[found].party->partyAuthPrivate != NULL) {
		FreeOctetString(parties[found].party->partyAuthPrivate);
		parties[found].party->partyAuthPrivate = NULL;
	    }

	    if ((parties[found].party->partyAuthPrivate =
		 CloneOctetString(party->party->partyAuthPrivate)) == NULL) {
		DPRINTF((APWARN, "partyEntry_set: malloc failure for partyAuthPrivate\n"));
		if (new_entry == TRUE) {
		    FreePartyElement(new_party);
		    parties[found].party = NULL;
		}
		return (GEN_ERROR);
	    }
	}

	if (VALID(I_partyPrivPrivate, party->party->valid)) {

	    if (parties[found].party->partyPrivPrivate != NULL) {
		FreeOctetString(parties[found].party->partyPrivPrivate);
		parties[found].party->partyPrivPrivate = NULL;
	    }

	    if ((parties[found].party->partyPrivPrivate =
		 CloneOctetString(party->party->partyPrivPrivate)) == NULL) {
		DPRINTF((APWARN, "partyEntry_set: malloc failure for partyPrivPrivate\n"));
		if (new_entry == TRUE) {
		    FreePartyElement(new_party);
		    parties[found].party = NULL;
		}
		return (GEN_ERROR);
	    }
	}

	if (VALID(I_partyLocal, party->party->valid)) {
	    parties[found].party->partyLocal = party->party->partyLocal;
	}

	if (VALID(I_partyStorageType, party->party->valid)) {
	    parties[found].party->partyStorageType = party->party->partyStorageType;
	}

	if (VALID(I_partyStatus, party->party->valid)) {
	    if (party->party->partyStatus == CREATE_AND_GO) {
		parties[found].party->partyStatus = ACTIVE;
	    }
	    else {
		if ((parties[found].party->partyStatus == ACTIVE) &&
		    (party->party->partyStatus == NOT_IN_SERVICE)) {
		    parties[found].last_active = GetTimeNow() / 100;
		}
		parties[found].party->partyStatus = party->party->partyStatus;
	    }
	    if (parties[found].party->partyStatus == ACTIVE) {
		parties[found].last_active = GetTimeNow() / 100;
	    }
	}			/* if (VALID(I_partyStatus ... */

	if (parties[found].party->partyStatus != ACTIVE) {
	    partyMibNotActiveFlag = TRUE;
	}
	break;
    }				/* switch */

    if (new_entry == TRUE) {
	PartyInsertSort(new_party);
	new_party = NULL;
    }

    writePartyFlag = TRUE;

    DPRINTF((APTRACE, "partyEntry_set: completed successfully.\n"));
    return (NO_ERROR);

}				/* partyEntry_set() */

/*
 * set_row_status: This routine is used by the security table's test routines
 *                 to check the validity of the manager's request to set the
 *                 row status field to the value they specified.  Each of
 *                 these tables use the RowStatus textual convention (see
 *                 RFC 1443 - Textual Conventions).
 *
 * Arguments: value  - What the manager wants the row status field to be.
 *            exists - Is this a new row or not (-1 means new row).
 *            state  - The state field of the element in the do list.
 *            status - The current value for the row status field.
 *
 * Returns: WRONG_VALUE_ERROR        - if trying to set status to an invalid
 *                                     state.
 *          INCONSISTENT_VALUE_ERROR - inconsistent value for row status field.
 *          NO_ERROR                 - on success.
 */

int
set_row_status(value, exists, state, status)
    int             value;
    int             exists;
    int            *state;
    long           *status;
{

    if ((value != ACTIVE) && (value != NOT_IN_SERVICE) &&
	(value != CREATE_AND_GO) && (value != CREATE_AND_WAIT) &&
	(value != DESTROY)) {

	DPRINTF((APTRACE, "set_row_status: Invalid value for row status field: %d\n",
		 value));
	return (WRONG_VALUE_ERROR);
    }
    /*
     * If this is a new row, make sure the manager is setting status to an
     * appropriate value.
     */
    if (exists == -1) {
	if ((value == NOT_IN_SERVICE) || (value == ACTIVE)) {
	    DPRINTF((APWARN, "set_row_status: Inconsistent value for row status field.\n"));
	    return (INCONSISTENT_VALUE_ERROR);
	}
	/*
	 * Set state equal to CREATE_AND_GO_STATE.  Then an INCONSISTENT
	 * value error can be returned from do_sets() if all the necessary
	 * columns are not set.
	 */
	if (value == CREATE_AND_GO) {
	    *state = CREATE_AND_GO_STATE;
	}
	*status = value;
    }

    /* Already exists in the table */
    else {
	switch (*status) {
	  case NOT_READY:
	    if ((value != DESTROY) && (value != ACTIVE) &&
		(value != NOT_IN_SERVICE)) {
		DPRINTF((APWARN, "set_row_status: Inconsistent value for row status field.\n"));
		return (INCONSISTENT_VALUE_ERROR);
	    }
	    /*
	     * If the manager wants to set the status to ACTIVE, the agent
	     * must go through the varbind list to see if the required
	     * columns will be set. If not enough is set, return
	     * INCONSISTENT_VALUE.  This check is made in pass 2 of
	     * do_sets().
	     */
	    if (value == ACTIVE) {
		*state = NOT_READY_STATE;
	    }
	    else if (value == NOT_IN_SERVICE) {
		*state = NOT_IN_SERVICE_STATE;
	    }
	    *status = value;
	    break;
	  case NOT_IN_SERVICE:
	  case ACTIVE:
	    if ((value == CREATE_AND_GO) || (value == CREATE_AND_WAIT)) {
		DPRINTF((APWARN, "set_row_status: Inconsistent value for row status field.\n"));
		return (INCONSISTENT_VALUE_ERROR);
	    }
	    *status = value;
	    break;
	  default:		/* should not happen */
	    DPRINTF((APWARN, "set_row_status: invalid status: %d\n", *status));
	    return (INCONSISTENT_VALUE_ERROR);
	    break;
	}			/* end switch */
    }				/* end else */

    DPRINTF((APTRACE, "set_row_status: completed successfully.\n"));
    return (NO_ERROR);

}				/* set_row_status() */


/*
 * party_create_check: This routine is called by the partyEntry_test routine
 *                     when the partyStatus field is equal to CREATE_AND_WAIT.
 *                     This routine checks to see whether the partyStatus
 *                     field should be set to NOT_READY or NOT_IN_SERVICE.
 *                     This routine is only called when a new row is being
 *                     added.
 *
 * Arguments: AuthProtocol - What kind of authentication is being used?
 *            AuthPrivate  - Value for partyAuthPrivate key.
 *            PrivProtocol - What kind of encryption is being used?
 *            PrivPrivate  - Value for partyPrivPrivate key.
 *            party_clone  - Value for partyCloneFrom field.
 *            valid        - What fields in the row are set?
 *
 * Returns: NOT_READY      - if partyStatus should be set to NOT_READY.
 *          NOT_IN_SERVICE - if partyStatus should be set to NOT_IN_SERVICE.
 */
int
party_create_check(AuthProtocol, AuthPrivate, PrivProtocol, PrivPrivate,
		   party_clone, valid)
    OID            *AuthProtocol;
    OctetString    *AuthPrivate;
    OID            *PrivProtocol;
    OctetString    *PrivPrivate;
    OID            *party_clone;
    char           *valid;
{

    if (party_clone == NULL) {
	DPRINTF((APTRACE, "party_create_check: party_clone is NULL.\n"));
	return (NOT_READY);
    }

#ifndef SR_UNSECURABLE
    if (CmpOID(AuthProtocol, md5AuthOID) == 0) {
	if ((AuthPrivate != NULL) && (VALID(I_partyAuthPrivate, valid))) {

#ifndef SR_NO_PRIVACY
	    if (CmpOID(PrivProtocol, desPrivOID) == 0) {
		if ((PrivPrivate != NULL) && (VALID(I_partyPrivPrivate, valid))) {
		    return (NOT_IN_SERVICE);
		}
		else {
		    return (NOT_READY);
		}
	    }
	    else {
		return (NOT_IN_SERVICE);
	    }
#else				/* SR_NO_PRIVACY */
	    return (NOT_IN_SERVICE);
#endif				/* SR_NO_PRIVACY */
	}			/* if (AuthPrivate != NULL) */
	else {
	    return (NOT_READY);
	}
    }				/* CmpOID(....) */
    else {
	return (NOT_IN_SERVICE);
    }
#else				/* SR_UNSECURABLE */
    return (NOT_IN_SERVICE);
#endif				/* SR_UNSECURABLE */

}				/* party_create_check() */

/*
 * party_status_check: This routine is called by the partyEntry_test routine
 *                     when the partyStatus field is equal to CREATE_AND_GO.
 *                     This routine checks to see whether the new row is
 *                     ready to go ACTIVE (all required columns in the table
 *                     are set. This routine is only called when a new row is
 *                     being added.
 *
 * Arguments: AuthProtocol - What kind of authentication is being used?
 *            AuthPrivate  - Value for partyAuthPrivate key.
 *            PrivProtocol - What kind of encryption is being used?
 *            PrivPrivate  - Value for partyPrivPrivate key.
 *            party_clone  - Value for partyCloneFrom field.
 *            valid        - What fields in the row are set?
 *
 * Returns: CREATE_AND_GO_STATE - If the row is not ready to go active.
 *          ADD_MODIFY          - If the row is ready to become active.
 */
int
party_status_check(AuthProtocol, AuthPrivate, PrivProtocol, PrivPrivate,
		   party_clone, valid)
    OID            *AuthProtocol;
    OctetString    *AuthPrivate;
    OID            *PrivProtocol;
    OctetString    *PrivPrivate;
    OID            *party_clone;
    char           *valid;
{

    if (party_clone == NULL) {
	DPRINTF((APTRACE, "party_status_check: party_clone is NULL.\n"));
	return (CREATE_AND_GO_STATE);
    }

#ifndef SR_UNSECURABLE
    /*
     * If AuthProtocol = md5AuthProtocol, AuthPrivate must be non-NULL.
     */

#ifndef SR_NO_PRIVACY
    /* If PrivProtocol = desPrivProtocol, * PrivPrivate must be non-NULL. */
#endif				/* SR_NO_PRIVACY */

    /* If these cases are met, return ADD_MODIFY. */

    if (CmpOID(AuthProtocol, md5AuthOID) == 0) {
	if ((AuthPrivate != NULL) && (VALID(I_partyAuthPrivate, valid))) {

#ifndef SR_NO_PRIVACY
	    if (CmpOID(PrivProtocol, desPrivOID) == 0) {
		if ((PrivPrivate != NULL) && (VALID(I_partyPrivPrivate, valid))) {
		    return (ADD_MODIFY);
		}
		else {
		    return (CREATE_AND_GO_STATE);
		}
	    }
	    else {
		return (ADD_MODIFY);
	    }
#else				/* SR_NO_PRIVACY */
	    return (ADD_MODIFY);
#endif				/* SR_NO_PRIVACY */
	}			/* if (AuthPrivate != NULL) */
	else {
	    return (CREATE_AND_GO_STATE);
	}
    }				/* CmpOID(....) */
    else {
	return (ADD_MODIFY);
    }
#else				/* SR_UNSECURABLE */
    return (ADD_MODIFY);
#endif				/* SR_UNSECURABLE */

}				/* party_status_check() */


/*
 * party_service_check: This routine is called by the partyEntry_test routine
 *                      when the partyStatus field is equal to NOT_IN_SERVICE.
 *                      This routine checks to see whether the new row is
 *                      ready to go to NOT_IN_SERVICE (all required columns in
 *                      the table are set. This routine is only called when a
 *                      new row is being added.
 *
 * Arguments: AuthProtocol - What kind of authentication is being used?
 *            AuthPrivate  - Value for partyAuthPrivate key.
 *            PrivProtocol - What kind of encryption is being used?
 *            PrivPrivate  - Value for partyPrivPrivate key.
 *            party_clone  - Value for partyCloneFrom field.
 *            valid        - What fields in the row are set?
 *
 * Returns: NOT_READY - If the row is not ready to go to NOT_IN_SERVICE.
 *          -1        - If the row is ready to go to NOT_IN_SERVICE.
 */

int
party_service_check(AuthProtocol, AuthPrivate, PrivProtocol, PrivPrivate,
		    party_clone, valid)
    OID            *AuthProtocol;
    OctetString    *AuthPrivate;
    OID            *PrivProtocol;
    OctetString    *PrivPrivate;
    OID            *party_clone;
    char           *valid;
{

    if (party_clone == NULL) {
	DPRINTF((APTRACE, "party_service_check: party_clone is NULL.\n"));
	return (NOT_READY);
    }

#ifndef SR_UNSECURABLE
    if (CmpOID(AuthProtocol, md5AuthOID) == 0) {
	if ((AuthPrivate != NULL) && (VALID(I_partyAuthPrivate, valid))) {

#ifndef SR_NO_PRIVACY
	    if (CmpOID(PrivProtocol, desPrivOID) == 0) {
		if ((PrivPrivate == NULL) || (!VALID(I_partyPrivPrivate, valid))) {
		    return (NOT_READY);
		}
	    }
#endif				/* SR_NO_PRIVACY */
	}			/* if (AuthPrivate != NULL) */
	else {
	    return (NOT_READY);
	}
    }				/* CmpOID(....) */
#endif				/* SR_UNSECURABLE */

    return (-1);

}				/* party_service_check() */


/*
 * not_ready_check: This routine is called by the partyEntry_test routine
 *                  when the partyStatus field is equal to NOT_READY.
 *                  This routine checks to see whether the new row is
 *                  ready to go to NOT_IN_SERVICE (all required columns in
 *                  the table are set. This routine is only called when a
 *                  new row is being added.
 *
 * Arguments: AuthProtocol - What kind of authentication is being used?
 *            AuthPrivate  - Value for partyAuthPrivate key.
 *            PrivProtocol - What kind of encryption is being used?
 *            PrivPrivate  - Value for partyPrivPrivate key.
 *            party_clone  - Value for partyCloneFrom field.
 *            valid        - What fields in the row are set?
 *
 * Returns: NOT_IN_SERVICE - If the row is ready to go to NOT_IN_SERVICE.
 *          -1             - partyStatus should stay NOT_READY.
 */
int
not_ready_check(AuthProtocol, AuthPrivate, PrivProtocol, PrivPrivate,
		party_clone, valid)
    OID            *AuthProtocol;
    OctetString    *AuthPrivate;
    OID            *PrivProtocol;
    OctetString    *PrivPrivate;
    OID            *party_clone;
    char           *valid;
{

    if (party_clone == NULL) {
	DPRINTF((APTRACE, "not_ready_check: party_clone is NULL.\n"));
	return (-1);
    }

#ifndef SR_UNSECURABLE
    if (CmpOID(AuthProtocol, md5AuthOID) == 0) {
	if ((AuthPrivate != NULL) && (VALID(I_partyAuthPrivate, valid))) {

#ifndef SR_NO_PRIVACY
	    if (CmpOID(PrivProtocol, desPrivOID) == 0) {
		if ((PrivPrivate != NULL) && (VALID(I_partyPrivPrivate, valid))) {
		    return (NOT_IN_SERVICE);
		}
	    }
	    else {
		return (NOT_IN_SERVICE);
	    }
#else				/* SR_NO_PRIVACY */
	    return (NOT_IN_SERVICE);
#endif				/* SR_NO_PRIVACY */
	}			/* if (AuthPrivate != NULL) */
    }				/* CmpOID(....) */
    else {
	return (NOT_IN_SERVICE);
    }
#else				/* SR_UNSECURABLE */
    return (NOT_IN_SERVICE);
#endif				/* SR_UNSECURABLE */

    return (-1);
}				/* not_ready_check() */


/*
 * not_in_service_check: This routine is called by the partyEntry_test routine
 *                       when the partyStatus field is equal to NOT_IN_SERVICE.
 *                       This routine checks to see whether the row is
 *                       ready to go to NOT_IN_SERVICE (all required columns in
 *                       the table are set. This routine is only called when a
 *                       row exists in the party table.
 *
 * Arguments: AuthProtocol - What kind of authentication is being used?
 *            AuthPrivate  - Value for partyAuthPrivate key.
 *            PrivProtocol - What kind of encryption is being used?
 *            PrivPrivate  - Value for partyPrivPrivate key.
 *            party_clone  - Value for partyCloneFrom field.
 *            valid        - What fields in the row are set?
 *            state        - current state of element in the do-list.
 *            index        - index for current entry in the party table.
 *
 * Returns: NOT_IN_SERVICE_STATE      - If the row is not ready to go to
 *                                      NOT_IN_SERVICE.
 *          ADD_MODIFY                - If the row is ready to go to
 *                                      NOT_IN_SERVICE.
 *          CLOCK_SET_BACKWARDS_STATE - If the partyAuthClock has been set back
 *                                      to zero and the partyAuthPrivate key
 *                                      has not been changed accordingly.
 */
int
not_in_service_check(AuthProtocol, AuthPrivate, PrivProtocol, PrivPrivate,
		     party_clone, valid, state, index)
    long            AuthProtocol;
    OctetString    *AuthPrivate;
    long            PrivProtocol;
    OctetString    *PrivPrivate;
    OID            *party_clone;
    char           *valid;
    int             state;
    int             index;
{

    if (party_clone == NULL) {
	DPRINTF((APTRACE, "not_in_service_check: party_clone is NULL.\n"));
	return (NOT_IN_SERVICE_STATE);
    }

#ifndef SR_UNSECURABLE
    if (AuthProtocol == MD5_SNMPv2_AUTHENTICATION) {
	if (parties[index].party->partyAuthPrivate != NULL) {
	    if ((state == CLOCK_SET_BACKWARDS_STATE) &&
		((!VALID(I_partyAuthPrivate, valid)) ||
		 (memcmp((char *) AuthPrivate->octet_ptr,
		 (char *) parties[index].party->partyAuthPrivate->octet_ptr,
			 MD5_DIGEST_SIZE) == 0))) {
		return (CLOCK_SET_BACKWARDS_STATE);
	    }
	}
	else {
	    if ((state == CLOCK_SET_BACKWARDS_STATE) &&
		(!VALID(I_partyAuthPrivate, valid))) {
		return (CLOCK_SET_BACKWARDS_STATE);
	    }
	}
    }
#endif				/* SR_UNSECURABLE */

#ifndef SR_UNSECURABLE
    if (AuthProtocol == MD5_SNMPv2_AUTHENTICATION) {
	if ((AuthPrivate != NULL) && (VALID(I_partyAuthPrivate, valid))) {

#ifndef SR_NO_PRIVACY
	    if (PrivProtocol == DESPRIV) {
		if ((PrivPrivate != NULL) && (VALID(I_partyPrivPrivate, valid))) {
		    return (ADD_MODIFY);
		}
		else {
		    return (NOT_IN_SERVICE_STATE);
		}
	    }
	    else {
		return (ADD_MODIFY);
	    }
#else				/* SR_NO_PRIVACY */
	    return (ADD_MODIFY);
#endif				/* SR_NO_PRIVACY */
	}			/* if (AuthPrivate != NULL) */
	else {
	    return (NOT_IN_SERVICE_STATE);
	}
    }				/* if (AuthProtocol ... ) */
    else {
	return (ADD_MODIFY);
    }
#else				/* SR_UNSECURABLE */
    return (ADD_MODIFY);
#endif				/* SR_UNSECURABLE */

}				/* not_in_service_check() */


/*
 * party_active_check: This routine is called by the partyEntry_test routine
 *                     when the partyStatus field is equal to ACTIVE.
 *                     This routine checks to see whether the row is
 *                     ready to go (or stay) ACTIVE (all required
 *                     columns in the table are set. This routine is only
 *                     called when a row exists in the party table.
 *
 * Arguments: AuthProtocol - What kind of authentication is being used?
 *            AuthPrivate  - Value for partyAuthPrivate key.
 *            PrivProtocol - What kind of encryption is being used?
 *            PrivPrivate  - Value for partyPrivPrivate key.
 *            party_clone  - Value for partyCloneFrom field.
 *            valid        - What fields in the row are set?
 *            state        - current state of element in the do-list.
 *            index        - index for current entry in the party table.
 *
 * Returns: -1         - If the row is not ready to go ACTIVE.
 *          ADD_MODIFY - If the row is ready to go (or stay) ACTIVE.
 */

int
party_active_check(AuthProtocol, AuthPrivate, PrivProtocol, PrivPrivate,
		   party_clone, valid, state, index)
    long            AuthProtocol;
    OctetString    *AuthPrivate;
    long            PrivProtocol;
    OctetString    *PrivPrivate;
    OID            *party_clone;
    char           *valid;
    int             state;
    int             index;
{

    if (party_clone == NULL) {
	DPRINTF((APTRACE, "party_active_check: party_clone is NULL.\n"));
	return (-1);
    }

#ifndef SR_UNSECURABLE
    if (AuthProtocol == MD5_SNMPv2_AUTHENTICATION) {
	if (parties[index].party->partyAuthPrivate != NULL) {
	    if ((state == CLOCK_SET_BACKWARDS_STATE) &&
		((!VALID(I_partyAuthPrivate, valid)) ||
		 (memcmp((char *) AuthPrivate->octet_ptr,
		 (char *) parties[index].party->partyAuthPrivate->octet_ptr,
			 MD5_DIGEST_SIZE) == 0))) {
		return (-1);
	    }
	}
	else {
	    if ((state == CLOCK_SET_BACKWARDS_STATE) &&
		(!VALID(I_partyAuthPrivate, valid))) {
		return (-1);
	    }
	}
    }
#endif				/* SR_UNSECURABLE */

#ifndef SR_UNSECURABLE
    if (AuthProtocol == MD5_SNMPv2_AUTHENTICATION) {
	if ((AuthPrivate != NULL) && (VALID(I_partyAuthPrivate, valid))) {

#ifndef SR_NO_PRIVACY
	    if (PrivProtocol == DESPRIV) {
		if ((PrivPrivate != NULL) && (VALID(I_partyPrivPrivate, valid))) {
		    return (ADD_MODIFY);
		}
	    }
	    else {
		return (ADD_MODIFY);
	    }
#else				/* SR_NO_PRIVACY */
	    return (ADD_MODIFY);
#endif				/* SR_NO_PRIVACY */
	}			/* if (AuthPrivate != NULL ....) */
    }				/* if(AuthProtocol == ...) */
    else {
	return (ADD_MODIFY);
    }
#else				/* SR_UNSECURABLE */
    return (ADD_MODIFY);
#endif				/* SR_UNSECURABLE */

    return (-1);

}				/* party_active_check() */

/*
 * party_not_ready_check: This routine is called by the partyEntry_test routine
 *                        when the partyStatus field is equal to NOT_READY.
 *                        This routine checks to see whether the row is
 *                        ready to go to NOT_IN_SERVICE or whether it should
 *                        stay NOT_READY. This routine is only called when
 *                        the row already exists in the party table.
 *
 * Arguments: AuthProtocol - What kind of authentication is being used?
 *            AuthPrivate  - Value for partyAuthPrivate key.
 *            PrivProtocol - What kind of encryption is being used?
 *            PrivPrivate  - Value for partyPrivPrivate key.
 *            party_clone  - Value for partyCloneFrom field.
 *            valid        - What fields in the row are set?
 *
 * Returns: -1             - If the row should stay NOT_READY.
 *          NOT_IN_SERVICE - If the row is ready to go to NOT_IN_SERVICE.
 */
int
party_not_ready_check(AuthProtocol, AuthPrivate, PrivProtocol, PrivPrivate,
		      party_clone, valid)
    long            AuthProtocol;
    OctetString    *AuthPrivate;
    long            PrivProtocol;
    OctetString    *PrivPrivate;
    OID            *party_clone;
    char           *valid;
{

    if (party_clone == NULL) {
	DPRINTF((APTRACE, "party_not_ready_check: party_clone is NULL.\n"));
	return (-1);
    }

#ifndef SR_UNSECURABLE
    if (AuthProtocol == MD5_SNMPv2_AUTHENTICATION) {
	if ((AuthPrivate != NULL) && (VALID(I_partyAuthPrivate, valid))) {

#ifndef SR_NO_PRIVACY
	    if (PrivProtocol == DESPRIV) {
		if ((PrivPrivate != NULL) && (VALID(I_partyPrivPrivate, valid))) {
		    return (NOT_IN_SERVICE);
		}
	    }
	    else {
		return (NOT_IN_SERVICE);
	    }
#else				/* SR_NO_PRIVACY */
	    return (NOT_IN_SERVICE);
#endif				/* SR_NO_PRIVACY */
	}			/* if (AuthPrivate != NULL) */
    }				/* if (AuthProtocol ==
				 * MD5_SNMPv2_AUTHENTICATION) */
    else {
	return (NOT_IN_SERVICE);
    }
#else				/* SR_UNSECURABLE */
    return (NOT_IN_SERVICE);
#endif				/* SR_UNSECURABLE */

    return (-1);
}				/* party_not_ready_check() */

#endif				/* SETS */

#endif				/* SR_SNMPv2 */
