/************************************************************************
 *                                                                      *
 *                              NOTE WELL                               *
 * This is vendor-supplied and vendor-supported code.  Do not make any  *
 * modifications to this code without the knowledge and consent of the  *
 * SNMP agent group.                                                    *
 *                                                                      *
 ************************************************************************/
/* $Id: sr_v_snmpv2.c,v 3.2.62.1 1996/04/19 17:47:00 jjohnson Exp $
 * $Source: /release/112/cvs/Xsys/snmp/sr_v_snmpv2.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * February 1994, SNMP Research
 *
 * Copyright (c) 1994-1996 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_v_snmpv2.c,v $
 * Revision 3.2.62.1  1996/04/19  17:47:00  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.2  1995/11/17  19:02:09  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  13:18:39  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.1  1995/06/07  22:51:27  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */
/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

/*
 *                PROPRIETARY NOTICE
 *
 * This software is an unpublished work subject to a confidentiality agreement
 * and is protected by copyright and trade secret law.  Unauthorized copying,
 * redistribution or other use of this work is prohibited.
 *
 * The above notice of copyright on this source code product does not indicate
 * any actual or intended publication of such source code.
 *
 */

#if (! ( defined(lint) ) && defined(SR_RCSID))
static char     rcsid[] = "v_snmpv2.c,v 1.11 1995/02/06 18:11:52 battle Exp";
#endif				/* (! ( defined(lint) ) && defined(SR_RCSID)) */

/*
 * Revision History:
 *
 * v_snmpv2.c,v
 * Revision 1.11  1995/02/06  18:11:52  battle
 * Changes for vrtx.
 *
 * Revision 1.10  1994/10/28  17:32:35  vaughn
 * Placed new copyright in the file
 *
 * Revision 1.9  1994/10/26  21:58:58  vaughn
 * Changed copyrights to the new copyright structure
 *
 * Revision 1.8  1994/09/30  16:11:41  battle
 * hprt changes
 *
 * Revision 1.7  1994/04/18  18:28:57  battle
 * pSOS changes
 *
 * Revision 1.6  1994/03/03  15:42:20  vaughn
 * Changed 0's in DPRINTF to APALWAYS.
 *
 * Revision 1.5  1994/02/14  16:42:36  pearson
 * Updated copyright notices for 1994.
 *
 * AMP
 *
 * Revision 1.4  1994/01/27  22:09:44  hecht
 * 1/27/94 MGH
 * Changed the object instance test at the beginning of snmpSet_test() to make
 * sure that the instance of snmpSetSerialNum is 0 (i.e., snmpSetSerialNo.0).
 *
 * Revision 1.3  1993/12/23  18:38:54  battle
 * Added cvs headers to all .c and .h files.
 *
 *
 * 18-Jan-93  MGH
 *     Create file.
 *
 * 7-May-93 MGH
 * Changed the name of the reqId parameter to serialNum.
 *
 * 18-May-93 MGH
 * Changed #include <diag.h> to #include "diag.h"
 *
 * 28-June-1993 MGH
 * Changed all references of "asod" to "contextInfo".  The
 * variable is now a ContextInfo variable. Changed the first error code
 * return in snmpTrap_test from "NO_ACCESS" to "NO_CREATION".
 *
 * 20-Jul-1993 DAR
 *   Removed searchType parameter to calls to scalar k_ get routines
 *   Added nominator parameter to all calls to k_ get routines.
 *   Removed valid paramter from all calls to k_ set routines.
 */

#include "master.h"

#include "sr_snmpd.h"
#include "sr_diag.h"
#include "sr_snmpv2mib.h"

#ifdef SR_SNMPv2

/*----------------------------------------------------------------------
 * Retrieve data from the snmpStats group. This is performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *----------------------------------------------------------------------*/
VarBind        *
snmpStats_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = -1;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1 and the single
     * instance element be 0.
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    switch (searchType) {
      case EXACT:
	if (instLength == 1 && incoming->oid_ptr[incoming->length - 1] == 0) {
	    arg = object->nominator;
	}
	break;

      case NEXT:
	if (instLength <= 0) {
	    arg = object->nominator;
	}
	break;

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error. (invalid search type in \
snmpStats_get -- %d\n", searchType));
    }

    if (arg == -1) {
	return ((VarBind *) NULL);
    }
    else {
	return (MakeVarBind(object, &ZeroOid, SR_OFFSET(&snmpStatsData, arg)));
    }
}				/* snmpStats_get() */


/*----------------------------------------------------------------------
 * Retrieve data from the snmpV1 stats group. This is performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *----------------------------------------------------------------------*/
VarBind        *
snmpV1_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = -1;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1 and the single
     * instance element be 0.
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    switch (searchType) {
      case EXACT:
	if (instLength == 1 && incoming->oid_ptr[incoming->length - 1] == 0) {
	    arg = object->nominator;
	}
	break;

      case NEXT:
	if (instLength <= 0) {
	    arg = object->nominator;
	}
	break;
      default:
	DPRINTF((APALWAYS, "snmpd: Internal error. (invalid search type in \
snmpV1_get -- %d\n", searchType));
    }

    if (arg == -1) {
	return ((VarBind *) NULL);
    }
    else {
	return (MakeVarBind(object, &ZeroOid, SR_OFFSET(&snmpV1Data, arg)));
    }
}				/* snmpV1_get() */


/*----------------------------------------------------------------------
 * Retrieve data from the snmpTrap group. This is performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *----------------------------------------------------------------------*/
VarBind        *
snmpTrap_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = -1;
    void           *dp;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1 and the single
     * instance element be 0.
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    switch (searchType) {
      case EXACT:
	if (instLength == 1 && incoming->oid_ptr[incoming->length - 1] == 0) {
	    arg = object->nominator;
	}
	break;

      case NEXT:
	if (instLength <= 0) {
	    arg = object->nominator;
	}
	break;

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error. (invalid search type in \
snmpTrap_get -- %d\n", searchType));
    }

    switch (arg) {

#ifdef I_snmpV2EnableAuthenTraps
      case I_snmpV2EnableAuthenTraps:
	dp = (void *) &snmpTrapData.snmpV2EnableAuthenTraps;
	break;
#endif				/* I_snmpV2EnableAuthenTraps */

      default:
	return ((VarBind *) NULL);
    }				/* switch */

    return (MakeVarBind(object, &ZeroOid, dp));
}				/* snmpTrap_get() */


#ifdef SETS
/*-------------------------------------------------------------------------
 * Free the snmptrap data object
 *-------------------------------------------------------------------------*/
void snmpTrap_free SR_PROTOTYPE((snmpTrap_t *data));

void
snmpTrap_free(data)
    snmpTrap_t     *data;
{
    if (data != NULL) {
	free((char *) data);
    }

}				/* snmpTrap_free() */

/*----------------------------------------------------------------------
 * Cleanup after snmpTrap set/undo.
 *----------------------------------------------------------------------*/
static int snmpTrap_cleanup SR_PROTOTYPE((doList_t *trash));

static int
snmpTrap_cleanup(trash)
    doList_t       *trash;
{
    snmpTrap_free(trash->data);

#ifdef SR_SNMPv2
    snmpTrap_free(trash->undodata);
#endif				/* SR_SNMPv2 */

    return NO_ERROR;
}


/*----------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *----------------------------------------------------------------------*/
int
snmpTrap_test(incoming, object, value, doHead, doCur, contextInfo)
    OID            *incoming;
    ObjectInfo     *object;
    ObjectSyntax   *value;
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    int             inst_length = incoming->length - object->oid.length;

    /*
     * Validate the object instance: 1) It must be of length 1 2) and the
     * instance must be 0.
     */

    if (inst_length != 1 || incoming->oid_ptr[incoming->length - 1] != 0) {
	DPRINTF((APTRACE, "snmpd: Invalid instance\n"));
	return (NO_CREATION_ERROR);
    }

    /*
     * Add the SET request to the do-list element. Test the validity of the
     * value at this point.
     */

    (doCur->data) = (void *) malloc(sizeof(snmpTrap_t));
    if (doCur->data == (void *) NULL) {
	DPRINTF((APALWAYS, "snmpd: cannot allocate memory\n"));
	return (GEN_ERROR);
    }
    ZERO_VALID(((snmpTrap_t *) (doCur->data))->valid);

    doCur->setMethod = snmpTrap_set;
    doCur->cleanupMethod = snmpTrap_cleanup;
    doCur->state = UNKNOWN;

    switch (object->nominator) {

#ifdef I_snmpV2EnableAuthenTraps
      case I_snmpV2EnableAuthenTraps:
	if (value->sl_value != SNMPv2_TRAPS_ENABLED &&
	    value->sl_value != SNMPv2_TRAPS_DISABLED) {

	    return (WRONG_VALUE_ERROR);
	}

	SET_VALID(I_snmpV2EnableAuthenTraps, ((snmpTrap_t *) (doCur->data))->valid);
	((snmpTrap_t *) (doCur->data))->snmpV2EnableAuthenTraps = value->sl_value;
	break;
#endif				/* I_snmpV2EnableAuthenTraps */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator \
in snmpTrap_test)\n"));
	return (GEN_ERROR);
    }				/* switch */

    doCur->state = ADD_MODIFY;

    return (NO_ERROR);
}				/* snmpTrap_test() */


/*----------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *
 * Note: In this case all related items are contained in the
 *    structure pointed to by "doCur->data," but in the more
 *    general case, this routine may need to scan the do-list to
 *    determine if there are other "related" objects. This is
 *    not recommended but is included for maximum flexibility.
*----------------------------------------------------------------------*/
int
snmpTrap_set(doHead, doCur, contextInfo)
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    snmpTrapData.snmpV2EnableAuthenTraps =
	((snmpTrap_t *) doCur->data)->snmpV2EnableAuthenTraps;

    return (NO_ERROR);
}				/* snmpTrap_set() */

#endif				/* SETS */

/*----------------------------------------------------------------------
 * Retrieve data from the snmpOR group. This is performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *----------------------------------------------------------------------*/
VarBind        *
snmpOR_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = -1;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1 and the single
     * instance element be 0.
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    switch (searchType) {
      case EXACT:
	if (instLength == 1 && incoming->oid_ptr[incoming->length - 1] == 0) {
	    arg = object->nominator;
	}
	break;

      case NEXT:
	if (instLength <= 0) {
	    arg = object->nominator;
	}
	break;

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error. (invalid search type in \
snmpOR_get -- %d\n", searchType));
    }

    if (arg == -1) {
	return ((VarBind *) NULL);
    }
    else {
	return (MakeVarBind(object, &ZeroOid, SR_OFFSET(&snmpORData, arg)));
    }
}				/* snmpOR_get() */

/*----------------------------------------------------------------------
 * Retrieve data from the snmpOREntry group. This is performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *----------------------------------------------------------------------*/
VarBind        *
snmpOREntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    ortype         *orp = NULL;
    void           *dp;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            snmpORIndex;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1.
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
        if (instLength != 1) {
            return ((VarBind *) NULL);
        }
        carry = 0;
    } else {
        carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &snmpORIndex, searchType, &carry)) < 0) {
        arg = -1;
    }
    if (carry) {
        arg = -1;
    }

    /*
     * Retrieve the data from the kernel-maintained list
     */
    if (arg != -1) {

	for (orp = (ortype *)object_resourcesQ.qhead; orp; orp = orp->next) {
	    /*
	     * an exact match is always the best match
	     */
	    if (orp->or_idx == snmpORIndex)
		break;

	    /*
	     * Are we looking for an exact match?
	     */
	    if (searchType == EXACT) {
		/*
		 * yes, have we gone too far?
		 */
		if (orp->or_idx > snmpORIndex) {
		    /*
		     * yep, must be a missing instance
		     */
		    orp = NULL;
		    break;
		}
		/*
		 * otherwise, keep looking for the exact match
		 */
		continue;
	    }

	    /*
	     * Is this the guy large enough to be the next match?
	     */
	    if (orp->or_idx > snmpORIndex) {
		/*
		 * yep, so he's the next
		 */
		break;
	    }
	}

	/*
	 * Did we get what we were looking for?
	 */
	if (orp) {
	    /*
	     * Build instance information
	     */
	    inst.oid_ptr = buffer;
	    inst.length = 1;
	    inst.oid_ptr[0] = orp->or_idx;
	} else {
	    arg = -1;
	}
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_snmpORID
    case I_snmpORID:
        dp = MakeOID(orp->or_oid->oid_ptr, orp->or_oid->length);
        break;
#endif				/* I_snmpORID */


#ifdef I_snmpORDescr
    case I_snmpORDescr:
        dp = MakeOctetString(orp->or_descr, strlen(orp->or_descr));
        break;
#endif				/* I_snmpORDescr */

    default:
        return ((VarBind *) NULL);

    }                           /* switch */

    return (MakeVarBind(object, &inst, dp));

}				/* snmpOREntry_get() */


/*----------------------------------------------------------------------
 * Retrieve data from the snmpSet group. This is performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *----------------------------------------------------------------------*/
VarBind        *
snmpSet_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = -1;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1 and the single
     * instance element be 0.
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    switch (searchType) {
      case EXACT:
	if (instLength == 1 && incoming->oid_ptr[incoming->length - 1] == 0) {
	    arg = object->nominator;
	}
	break;

      case NEXT:
	if (instLength <= 0) {
	    arg = object->nominator;
	}
	break;

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error. (invalid search type in \
snmpSet_get -- %d\n", searchType));
    }

    if (arg == -1) {
	return ((VarBind *) NULL);
    }
    else {
	return (MakeVarBind(object, &ZeroOid, SR_OFFSET(&snmpSetData, arg)));
    }
}				/* snmpSet_get() */


#ifdef SETS
void snmpSet_free SR_PROTOTYPE((snmpSet_t *data));

void
snmpSet_free(data)
    snmpSet_t           *data;
{
    if (data != NULL) {
	free(data);
    }
}

/*----------------------------------------------------------------------
 * Cleanup after snmpSet set/undo.
 *----------------------------------------------------------------------*/
static int snmpSet_cleanup SR_PROTOTYPE((doList_t *trash));

static int
snmpSet_cleanup(trash)
    doList_t       *trash;
{
    snmpSet_free(trash->data);

#ifdef SR_SNMPv2
    snmpSet_free(trash->undodata);
#endif				/* SR_SNMPv2 */

    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *----------------------------------------------------------------------*/
int
snmpSet_test(incoming, object, value, doHead, doCur, contextInfo)
    OID            *incoming;
    ObjectInfo     *object;
    ObjectSyntax   *value;
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    int             inst_length = incoming->length - object->oid.length;

    /*
     * Validate the object instance: 1) It must be of length 1 2) and the
     * instance must be 0.
     */

    if (inst_length != 1 || incoming->oid_ptr[incoming->length - 1] != 0) {
	DPRINTF((APTRACE, "snmpd: Invalid instance\n"));
	return (NO_CREATION_ERROR);
    }

    /*
     * Add the SET request to the do-list element. Test the validity of the
     * value at this point.
     */

    if (((doCur->data) = (void *) malloc(sizeof(snmpSet_t))) == NULL) {
	DPRINTF((APALWAYS, "snmpd: cannot allocate memory\n"));
	return (GEN_ERROR);
    }
    ZERO_VALID(((snmpSet_t *) (doCur->data))->valid);

    doCur->setMethod = snmpSet_set;
    doCur->cleanupMethod = snmpSet_cleanup;
    doCur->state = UNKNOWN;

    switch (object->nominator) {

#ifdef I_snmpSetSerialNo
      case I_snmpSetSerialNo:
	if (value->sl_value != snmpSetData.snmpSetSerialNo) {

	    return (INCONSISTENT_VALUE_ERROR);
	}

	SET_VALID(I_snmpSetSerialNo, ((snmpSet_t *) (doCur->data))->valid);
	((snmpSet_t *) (doCur->data))->snmpSetSerialNo = value->sl_value;
	break;
#endif

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator \
in snmpSet_test)\n"));
	return (GEN_ERROR);
    }

    doCur->state = ADD_MODIFY;

    return (NO_ERROR);
}				/* snmpSet_test() */


/*----------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *----------------------------------------------------------------------*/
int
snmpSet_set(doHead, doCur, contextInfo)
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    if (snmpSetData.snmpSetSerialNo == 2147483647) {	/* wraps */
	snmpSetData.snmpSetSerialNo = 0;
    }
    else {
	snmpSetData.snmpSetSerialNo++;
    }

    return (NO_ERROR);
}

#endif				/* SETS */

#endif				/* SR_SNMPv2 */
