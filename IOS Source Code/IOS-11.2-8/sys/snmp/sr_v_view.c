/************************************************************************
 *                                                                      *
 *                              NOTE WELL                               *
 * This is vendor-supplied and vendor-supported code.  Do not make any  *
 * modifications to this code without the knowledge and consent of the  *
 * SNMP agent group.                                                    *
 *                                                                      *
 ************************************************************************/
/* $Id: sr_v_view.c,v 3.2.60.1 1996/04/19 17:47:01 jjohnson Exp $
 * $Source: /release/112/cvs/Xsys/snmp/sr_v_view.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * February 1994, SNMP Research
 *
 * Copyright (c) 1994-1996 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_v_view.c,v $
 * Revision 3.2.60.1  1996/04/19  17:47:01  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.2  1995/11/17  19:02:11  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  13:18:41  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.1  1995/06/07  22:51:30  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */
/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

/*
 *                PROPRIETARY NOTICE
 *
 * This software is an unpublished work subject to a confidentiality agreement
 * and is protected by copyright and trade secret law.  Unauthorized copying,
 * redistribution or other use of this work is prohibited.
 *
 * The above notice of copyright on this source code product does not indicate
 * any actual or intended publication of such source code.
 *
 */

#if (! ( defined(lint) ) && defined(SR_RCSID))
static char     rcsid[] = "v_view.c,v 1.10 1995/02/06 18:11:56 battle Exp";
#endif				/* (! ( defined(lint) ) && defined(SR_RCSID)) */

/*
 * Revision History:
 *
 * v_view.c,v
 * Revision 1.10  1995/02/06  18:11:56  battle
 * Changes for vrtx.
 *
 * Revision 1.9  1994/10/28  17:32:38  vaughn
 * Placed new copyright in the file
 *
 * Revision 1.8  1994/10/26  21:59:01  vaughn
 * Changed copyrights to the new copyright structure
 *
 * Revision 1.7  1994/09/30  16:11:46  battle
 * hprt changes
 *
 * Revision 1.6  1994/08/04  15:37:55  battle
 * pSOS 2.0 changes
 *
 * Revision 1.5  1994/04/18  18:28:58  battle
 * pSOS changes
 *
 * Revision 1.4  1994/02/14  16:42:39  pearson
 * Updated copyright notices for 1994.
 *
 * AMP
 *
 * Revision 1.3  1993/12/23  18:38:57  battle
 * Added cvs headers to all .c and .h files.
 *
 *
 *  23-Jun-92 MGH
 *  method routines for view table.
 *
 *  9-July-92 MRD
 *  Ifdef the whole thing - this allows for dumb makefiles that
 *  try to compile this file even when security is not used.
 *
 *  14-Aug-92 MGH
 *  Added call to WriteViewFile() in viewEntry_set to save view table
 *  information.
 *
 *  21-Dec-92 MGH
 *  Changed calls of CmpNOID() to CmpOID().
 *  Started implementing the new security changes.
 *
 *  7-Jan-93 MGH
 *  Continued implementing the new security changes (viewEntry_get is virtually
 *  back to what it was in SMP.
 *
 *  25-Jan-93 MGH
 *  Retooled viewEntry_test and viewEntry_set for the new security drafts.
 *
 *  7-May-1993 MGH
 *  Changed the name of the reqId parameter to serialNum.
 *
 *  28-May-1993 MGH
 *  Code maintenance
 *
 *  2-June-1993 MGH
 *  Changed the call to WriteViewFile.  There are no parameters in the call
 *  anymore.
 *
 * 15-June-93 MGH
 * Changed the method of accessing the view table.  There is now an array
 * of pointers that point to separately malloced view structures.  When
 * adding a new view row, the new view row is malloced separately, and
 * the array is realloced if another entry in the array is needed.
 * Should be able to add as many new view rows as memory will allow.
 *
 * Also had the viewEntry_test routine set dp->state to DELETE if
 * viewStatus is set to DESTROY. Added case statement to viewEntry_set.
 *
 * 17-June-93 MGH
 * Added call to RecomputeViewVectors() in viewEntry_set().
 *
 * 18-June-93 MGH
 * Added an external global variable, partyMibNotActiveFlag.  It's set to
 * TRUE if there are any non active rows in the table.
 *
 * 28-June-1993 MGH
 * Changed all references of "asod" to "contextInfo".  The
 * variable is now a ContextInfo variable.
 *
 * 20-Jul-1993 DAR
 *   Removed searchType parameter to calls to scalar k_ get routines
 *   Added nominator parameter to all calls to k_ get routines.
 *   Removed valid paramter from all calls to k_ set routines.
 *   changed test methods to use valid field defined in snmptype.h
 */

#include "master.h"

#include "sr_snmpd.h"

#ifdef	SR_SNMPv2

#include "sr_diag.h"
#include "sr_snmpv2mib.h"


extern int      partyMibNotActiveFlag;

typedef struct _VIEW_TABLE {
    viewEntry_t    *mib_view;
    OID            *view_instance;
}               VIEW_TABLE;

/*----------------------------------------------------------------------
 * Retrieve data from the viewEntry group. This is performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *----------------------------------------------------------------------*/
VarBind        *
viewEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
    SR_FNAME("viewEntry_get")
    int             instLength = incoming->length - object->oid.length;
    int             arg = -1;
    int             i;
    int             found;
    unsigned long   index_inst[5];
    void           *dp;
    OID            *view_instance;
    OID            *viewInst;
    OID            *indexInst;
    OID            *best;
    VarBind        *retval;

    found = -1;
    best = NULL;

    /*
     * Check the object instance
     * 
     * An EXACT search requires that the instance be of the form:
     * viewIndex.viewSubtree, where viewIndex is a unique integer referred to
     * in the context table and viewSubtree identifies a family of possible
     * subtrees.
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    switch (searchType) {
      case EXACT:
	if (instLength > 1) {
	    arg = object->nominator;
	}
	else {
	    return ((VarBind *) NULL);
	}
	break;

      case NEXT:
	arg = object->nominator;
	break;
      default:
	DPRINTF((APWARN, "snmpd: Internal error. Invalid search type in \
%s -- %d\n", FName, searchType));
    }				/* switch */


    /*
     * Retrieve the data from the view table and return the instance if
     * successful.
     */

    /*
     * Determine instance OID -- first sub-field after name
     */

    if (CmpOIDClass(incoming, &object->oid) == 0) {
	if (instLength > 0) {
	    if ((view_instance = (OID *) malloc(sizeof(OID))) == NULL) {
		DPRINTF((APWARN, "viewEntry_get: malloc failure\n"));
		return ((VarBind *) NULL);
	    }
	    view_instance->oid_ptr = NULL;
	    view_instance->length = instLength;

	    if ((view_instance->oid_ptr = (unsigned long *)
		 malloc((unsigned) (view_instance->length *
				    sizeof(unsigned long)))) == NULL) {
		DPRINTF((APWARN, "viewEntry_get: malloc failure\n"));
		FreeOID(view_instance);
		view_instance = NULL;
		return ((VarBind *) NULL);
	    }

	    for (i = 0; i < view_instance->length; i++) {
		view_instance->oid_ptr[i] = incoming->oid_ptr[i + object->oid.length];
	    }
	}
	else {
	    if ((view_instance = MakeOIDFromDot("0.0")) == NULL) {
		DPRINTF((APWARN, "viewEntry_get: malloc failure for 0.0\n"));
		return ((VarBind *) NULL);
	    }
	}
    }
    else {
	if ((view_instance = MakeOIDFromDot("0.0")) == NULL) {
	    DPRINTF((APWARN, "viewEntry_get: malloc failure for 0.0\n"));
	    return ((VarBind *) NULL);
	}
    }


    /*
     * Now scan the view table
     */

    if (arg != -1) {
	indexInst = NULL;
	viewInst = NULL;
	if (searchType == EXACT) {
	    for (i = 0; i < num_views; i++) {
		if (party_views[i].mib_view == NULL) {
		    continue;
		}
		index_inst[0] = (unsigned long) party_views[i].mib_view->viewIndex;
		FreeOID(indexInst);
		indexInst = NULL;
		FreeOID(viewInst);
		viewInst = NULL;
		if ((indexInst = (OID *) MakeOID(index_inst, (short) 1)) ==
		    NULL) {
		    DPRINTF((APWARN, "viewEntry_get: malloc failure for indexInst\n"));
		    FreeOID(view_instance);
		    view_instance = NULL;
		    return ((VarBind *) NULL);
		}

		if ((viewInst = (OID *) CatOID(indexInst,
			   party_views[i].mib_view->viewSubtree)) == NULL) {
		    DPRINTF((APWARN, "viewEntry_get: malloc failure for viewInst\n"));
		    FreeOID(view_instance);
		    view_instance = NULL;
		    FreeOID(indexInst);
		    indexInst = NULL;
		    return ((VarBind *) NULL);
		}

		FreeOID(indexInst);
		indexInst = NULL;
		/*
		 * The instances must match and the view entry must be valid.
		 */
		if ((CmpOID(viewInst, view_instance) == 0)) {
		    if ((best = CloneOID(viewInst)) == NULL) {
			DPRINTF((APWARN, "viewEntry_get: malloc failure for best\n"));
			FreeOID(view_instance);
			view_instance = NULL;
			FreeOID(viewInst);
			viewInst = NULL;
			return ((VarBind *) NULL);
		    }
		    found = i;
		    break;
		}
	    }			/* for */
	}			/* if searchType */

	else {			/* searchType == NEXT */
	    best = NULL;
	    indexInst = NULL;
	    viewInst = NULL;
	    for (i = 0; i < num_views; i++) {
		if (party_views[i].mib_view == NULL) {
		    continue;
		}
		index_inst[0] = (unsigned long) party_views[i].mib_view->viewIndex;
		FreeOID(indexInst);
		indexInst = NULL;
		FreeOID(viewInst);
		viewInst = NULL;
		if ((indexInst = (OID *) MakeOID(index_inst, (short) 1)) ==
		    NULL) {
		    DPRINTF((APWARN, "viewEntry_get: malloc failure for indexInst\n"));
		    FreeOID(view_instance);
		    view_instance = NULL;
		    return ((VarBind *) NULL);
		}

		if ((viewInst = (OID *) CatOID(indexInst,
			   party_views[i].mib_view->viewSubtree)) == NULL) {
		    DPRINTF((APWARN, "viewEntry_get: malloc failure for viewInst\n"));
		    FreeOID(view_instance);
		    view_instance = NULL;
		    FreeOID(indexInst);
		    indexInst = NULL;
		    return ((VarBind *) NULL);
		}

		/*
		 * best = thisone if ((incoming > thisone) && (thisone <
		 * best) && (valid entry))
		 */
		if ((CmpOID(viewInst, view_instance) > 0)
		    && ((best == NULL) || (CmpOID(viewInst,
						  best) < 0))) {

		    FreeOID(best);
		    best = NULL;
		    if ((best = (OID *) CloneOID(viewInst)) == NULL) {
			DPRINTF((APWARN, "viewEntry_get: malloc failure for best\n"));
			FreeOID(view_instance);
			view_instance = NULL;
			FreeOID(indexInst);
			indexInst = NULL;
			FreeOID(viewInst);
			viewInst = NULL;
			return ((VarBind *) NULL);
		    }
		    found = i;
		}		/* if match */
	    }			/* for */
	}			/* else searchType */

	FreeOID(view_instance);
	view_instance = NULL;
	FreeOID(indexInst);
	indexInst = NULL;
	FreeOID(viewInst);
	viewInst = NULL;

	if (searchType == EXACT) {
	    if (i == num_views) {	/* Not found by the end of the table */
		DPRINTF((APTRACE, "viewEntry_get: exact search failed\n"));
		return ((VarBind *) NULL);
	    }
	}

	else {
	    if (best == NULL) {
		DPRINTF((APTRACE, "viewEntry_get: next search failed\n"));
		return ((VarBind *) NULL);
	    }
	}
    }				/* if arg != -1 */

    switch (arg) {

#ifdef I_viewMask
      case I_viewMask:
	if ((dp = (void *) CloneOctetString(party_views[found].mib_view->viewMask)) ==
	    (void *) NULL) {
	    DPRINTF((APWARN, "snmpd: malloc failure in viewEntry_get()\n"));
	    return ((VarBind *) NULL);
	}
	break;
#endif				/* I_viewMask */

#ifdef I_viewType
      case I_viewType:
	dp = (void *) &party_views[found].mib_view->viewType;
	break;
#endif				/* I_viewType */

#ifdef I_viewStorageType
      case I_viewStorageType:
	dp = (void *) &party_views[found].mib_view->viewStorageType;
	break;
#endif				/* I_viewStorageType */

#ifdef I_viewStatus
      case I_viewStatus:
	dp = (void *) &party_views[found].mib_view->viewStatus;
	break;
#endif				/* I_viewStatus */

      default:
	return ((VarBind *) NULL);
    }				/* switch */

    retval = MakeVarBind(object, best, dp);
    FreeOID(best);
    best = NULL;

    return (retval);

}				/* viewEntry_get() */

#ifdef SETS
static void
viewEntry_freex SR_PROTOTYPE((VIEW_TABLE *data));

static void
viewEntry_freex(data)
    VIEW_TABLE     *data;
{

    if (data != NULL) {

	if (data->view_instance != NULL) {
	    FreeOID(data->view_instance);
	    data->view_instance = NULL;
	}

	if (data->mib_view != NULL) {
	    if (data->mib_view->viewMask != NULL) {
		FreeOctetString(data->mib_view->viewMask);
		data->mib_view->viewMask = NULL;
	    }
	    free((char *) data->mib_view);
	    data->mib_view = NULL;
	}
	free((char *) data);
	data = NULL;
    }
}				/* viewEntry_freex() */

/*----------------------------------------------------------------------
 * Cleanup after viewEntry set/undo.
 *----------------------------------------------------------------------*/
static int viewEntry_cleanup SR_PROTOTYPE((doList_t *trash));

static int
viewEntry_cleanup(trash)
    doList_t       *trash;
{
    viewEntry_freex(trash->data);

#ifdef SR_SNMPv2
    viewEntry_freex(trash->undodata);
#endif				/* SR_SNMPv2 */

    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *----------------------------------------------------------------------*/
int
viewEntry_test(incoming, object, value, dolist_head, doCur, contextInfo)
    OID            *incoming;
    ObjectInfo     *object;
    ObjectSyntax   *value;
    doList_t       *dolist_head;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    SR_FNAME("viewEntry_test")
    int             instLength = incoming->length - object->oid.length;
    int             i;
    int             found, return_val;
    int             name_found;
    unsigned long   index_inst[5];
    doList_t       *dp;
    VIEW_TABLE     *view_entry;
    OID            *view_instance;
    OID            *viewInst, *indexInst;
    OID            *best;

    /*
     * Validate the object instance. 1) It should have a length >= 2
     * (viewIndex.viewSubtree). 2) Validate the view_instance.
     */
    if (instLength < 2) {
	DPRINTF((APTRACE, "snmpd: Invalid instance in %s\n", FName));
	return (NO_CREATION_ERROR);
    }

    /*
     * Determine instance OID -- first sub-field after name
     */
    if (CmpOIDClass(incoming, &object->oid) == 0) {
	if ((view_instance = (OID *) malloc(sizeof(OID))) == NULL) {
	    DPRINTF((APWARN, "viewEntry_test: malloc failure for view_instance\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	view_instance->oid_ptr = NULL;
	view_instance->length = instLength;

	if ((view_instance->oid_ptr = (unsigned long *)
	     malloc((unsigned) (view_instance->length *
				sizeof(unsigned long)))) == NULL) {
	    DPRINTF((APWARN, "viewEntry_test: malloc failure for view_instance->oid_ptr\n"));
	    FreeOID(view_instance);
	    view_instance = NULL;
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}

	for (i = 0; i < view_instance->length; i++) {
	    view_instance->oid_ptr[i] =
		incoming->oid_ptr[i + object->oid.length];
	}
    }
    else {
	if ((view_instance = MakeOIDFromDot("0.0")) == NULL) {
	    DPRINTF((APWARN, "viewEntry_test: malloc failure for view_instance\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
    }

    /*
     * Now scan the view table
     */
    name_found = -1;
    best = (OID *) NULL;
    indexInst = NULL;
    viewInst = NULL;

    for (i = 0; i < num_views; i++) {
	if (party_views[i].mib_view == NULL) {
	    continue;
	}
	index_inst[0] = (unsigned long) party_views[i].mib_view->viewIndex;
	FreeOID(indexInst);
	indexInst = NULL;
	FreeOID(viewInst);
	viewInst = NULL;
	if ((indexInst = (OID *) MakeOID(index_inst, (short) 1)) == NULL) {
	    DPRINTF((APWARN, "viewEntry_test: malloc failure for indexInst\n"));
	    FreeOID(view_instance);
	    view_instance = NULL;
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	if ((viewInst = (OID *) CatOID(indexInst, party_views[i].mib_view->viewSubtree)) == NULL) {
	    DPRINTF((APWARN, "viewEntry_test: malloc failure for viewInst\n"));
	    FreeOID(view_instance);
	    view_instance = NULL;
	    FreeOID(indexInst);
	    indexInst = NULL;
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	FreeOID(indexInst);
	indexInst = NULL;

	/*
	 * The instances must match.
	 */
	if ((CmpOID(viewInst, view_instance) == 0)) {
	    if ((best = CloneOID(viewInst)) == NULL) {
		DPRINTF((APTRACE, "viewEntry_test: Cannot clone viewInst.\n"));
		FreeOID(view_instance);
		view_instance = NULL;
		FreeOID(viewInst);
		viewInst = NULL;
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }

	    name_found = i;
	    break;
	}

    }				/* for */

    FreeOID(indexInst);
    indexInst = NULL;
    FreeOID(viewInst);
    viewInst = NULL;

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = dolist_head; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == viewEntry_set) &&
	    (((VIEW_TABLE *) (dp->data)) != (VIEW_TABLE *) NULL)) {
	    /*
	     * If best is non-null, a match was found.  If best matches a
	     * previous do-list element, the two elements are related and are
	     * part of an entry in the table.
	     */
	    if ((((VIEW_TABLE *) (dp->data))->view_instance != (OID *) NULL) &&
		(best != (OID *) NULL)) {
		if (CmpOID(((VIEW_TABLE *) (dp->data))->view_instance,
			   best) == 0) {
		    found = 1;
		    break;
		}
	    }
	    /*
	     * If best is null(no entry in the table), but the instance for
	     * this do-list element matches a previous do-list element, the
	     * two elements are related, and they need to be added to the
	     * table.
	     */
	    else if ((((VIEW_TABLE *) (dp->data))->view_instance != (OID *) NULL) &&
		     (best == (OID *) NULL)) {
		if (CmpOID(((VIEW_TABLE *) (dp->data))->view_instance,
			   view_instance) == 0) {
		    found = 1;
		    break;
		}
	    }			/* else if */
	}			/* if (dp->setMethod ... */
    }				/* for (dp = dolist_head ... */

    /*
     * If a related do-list element was found, mark the one created for this
     * SET request with a NULL setMethod (this invalidates it).
     * 
     * Otherwise, there does not exist a related do-list element so fill-in the
     * do-list element with all known/default values.
     */

    if (!found) {
	dp = doCur;
	if ((dp->data = (void *) malloc((unsigned) sizeof(VIEW_TABLE))) == NULL) {
	    DPRINTF((APWARN, "%s: Cannot allocate memory for dp->data\n", FName));
	    FreeOID(view_instance);
	    view_instance = NULL;
	    FreeOID(best);
	    best = NULL;
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset((char *) dp->data, 0, sizeof(VIEW_TABLE));

	if ((((VIEW_TABLE *) (dp->data))->mib_view =
	     (viewEntry_t *) malloc(sizeof(viewEntry_t))) == NULL) {
	    DPRINTF((APWARN, "%s: Cannot allocate memory for viewEntry_t\n", FName));
	    FreeOID(view_instance);
	    view_instance = NULL;
	    FreeOID(best);
	    best = NULL;
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset((char *) ((VIEW_TABLE *) (dp->data))->mib_view, 0, sizeof(viewEntry_t));

	dp->setMethod = viewEntry_set;
	dp->cleanupMethod = viewEntry_cleanup;
	dp->state = UNKNOWN;

	/*
	 * Try to fill in reasonable default values for this new view entry.
	 */

	if (name_found == -1) {
	    if ((((VIEW_TABLE *) (dp->data))->view_instance =
		 CloneOID(view_instance)) == (OID *) NULL) {
		DPRINTF((APWARN, "%s: Cannot allocate memory for view_instance\n",
			 FName));
		FreeOID(view_instance);
		view_instance = NULL;
		FreeOID(best);
		best = NULL;
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }
	    FreeOID(view_instance);
	    view_instance = NULL;
	    FreeOID(best);
	    best = NULL;

	    if ((((VIEW_TABLE *) (dp->data))->mib_view->viewMask =
		 MakeOctetStringFromText("")) ==
		(OctetString *) NULL) {
		DPRINTF((APWARN, "%s: Cannot allocate memory for viewMask\n", FName));
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }

	    ((VIEW_TABLE *) (dp->data))->mib_view->viewType = INCLUDED;
	    ((VIEW_TABLE *) (dp->data))->mib_view->viewStorageType = NONVOLATILE;
	    ((VIEW_TABLE *) (dp->data))->mib_view->viewStatus = DESTROY;

	    SET_ALL_VALID(((VIEW_TABLE *) (dp->data))->mib_view->valid);
	}

	else {
	    if ((((VIEW_TABLE *) (dp->data))->view_instance =
		 CloneOID(best)) == (OID *) NULL) {
		DPRINTF((APWARN, "%s: Cannot allocate memory for view_instance\n",
			 FName));
		FreeOID(view_instance);
		view_instance = NULL;
		FreeOID(best);
		best = NULL;
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }
	    FreeOID(view_instance);
	    view_instance = NULL;
	    FreeOID(best);
	    best = NULL;

	    if ((((VIEW_TABLE *) (dp->data))->mib_view->viewMask =
	    CloneOctetString(party_views[name_found].mib_view->viewMask)) ==
		(OctetString *) NULL) {
		DPRINTF((APWARN, "%s: Cannot allocate memory for viewMask\n", FName));
		return (RESOURCE_UNAVAILABLE_ERROR);
	    }
	    ((VIEW_TABLE *) (dp->data))->mib_view->viewType =
		party_views[name_found].mib_view->viewType;

	    ((VIEW_TABLE *) (dp->data))->mib_view->viewStorageType =
		party_views[name_found].mib_view->viewStorageType;

	    ((VIEW_TABLE *) (dp->data))->mib_view->viewStatus =
		party_views[name_found].mib_view->viewStatus;
	}
    }				/* if (!found) */
    else {
	FreeOID(view_instance);
	view_instance = NULL;
	FreeOID(best);
	best = NULL;
    }

    view_entry = (VIEW_TABLE *) (dp->data);

    switch (object->nominator) {

#ifdef I_viewMask
      case I_viewMask:
	if (value->os_value->length > MASK_LENGTH) {
	    return (WRONG_LENGTH_ERROR);
	}

	if (view_entry->mib_view->viewMask != (OctetString *) NULL) {
	    FreeOctetString(view_entry->mib_view->viewMask);
	    view_entry->mib_view->viewMask = NULL;
	}

	if ((view_entry->mib_view->viewMask =
	     CloneOctetString(value->os_value)) == NULL) {
	    DPRINTF((APWARN, "%s: Cannot allocate memory for viewMask\n", FName));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}

	SET_VALID(I_viewMask, view_entry->mib_view->valid);
	break;
#endif				/* I_viewMask */

#ifdef I_viewType
      case I_viewType:
	if ((value->sl_value != INCLUDED) && (value->sl_value != EXCLUDED)) {
	    DPRINTF((APTRACE, "viewEntry_test: bad value for viewType.\n"));
	    return (WRONG_VALUE_ERROR);
	}
	view_entry->mib_view->viewType = value->sl_value;
	SET_VALID(I_viewType, view_entry->mib_view->valid);
	break;
#endif				/* I_viewType */

#ifdef I_viewStorageType
      case I_viewStorageType:
	if ((value->sl_value != OTHER) && (value->sl_value != VOLATILE) &&
	    (value->sl_value != NONVOLATILE) &&
	    (value->sl_value != PERMANENT)) {
	    return (WRONG_VALUE_ERROR);
	}
	view_entry->mib_view->viewStorageType = value->sl_value;
	SET_VALID(I_viewStorageType, view_entry->mib_view->valid);
	break;
#endif				/* I_viewStorageType */

#ifdef I_viewStatus
      case I_viewStatus:
	if ((return_val = set_row_status(value->sl_value, name_found,
		      &(dp->state), &(view_entry->mib_view->viewStatus))) !=
	    NO_ERROR) {
	    return (return_val);
	}
	SET_VALID(I_viewStatus, view_entry->mib_view->valid);
	break;
#endif				/* I_viewStatus */

      default:
	DPRINTF((APWARN, "snmpd: Internal error. (test called on \
readOnly or unsupported object in %s)\n", FName));
	return (NO_ACCESS_ERROR);
	break;
    }				/* switch */
    /*
     * Determine if all the fields of this row are now valid.
     */
    if (name_found == -1) {	/* adding a row */
	switch (view_entry->mib_view->viewStatus) {
	  case CREATE_AND_WAIT:
	  case NOT_READY:
	    view_entry->mib_view->viewStatus = NOT_IN_SERVICE;
	    SET_VALID(I_viewStatus, view_entry->mib_view->valid);
	    dp->state = ADD_MODIFY;
	    break;
	  case DESTROY:
	    dp->state = DELETE;
	    break;
	  case CREATE_AND_GO:
	  case NOT_IN_SERVICE:
	    dp->state = ADD_MODIFY;
	    break;
	  default:
	    DPRINTF((APWARN, "viewEntry_test: Invalid viewStatus value.\n"));
	    return (INCONSISTENT_VALUE_ERROR);
	    break;
	}			/* end switch */
    }
    else {			/* modifying an existing row */
	switch (view_entry->mib_view->viewStatus) {
	  case DESTROY:
	    dp->state = DELETE;
	    break;
	  default:
	    dp->state = ADD_MODIFY;
	    break;
	}
    }

    return (NO_ERROR);

}				/* viewEntry_test() */


/*----------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *
 * Note: In this case all related items are contained in the
 *    structure pointed to by "doCur->data," but in the more
 *    general case, this routine may need to scan the do-list to
 *    determine if there are other "related" objects. This is
 *    not recommended but is included for maximum flexibility.
 *----------------------------------------------------------------------*/
int
viewEntry_set(doHead, doCur, contextInfo)
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{

    SR_FNAME("viewEntry_set")
    VIEW_TABLE     *view_entry;
    V2_VIEW        *temp_ptr;
    MIB_VIEW       *new_view;
    OID            *view_instance;
    OID            *viewInst, *indexInst;
    int             i;
    int             found, new_entry;
    int             open_slot;
    unsigned long   index_inst[5];
    long            viewIndex;

    view_entry = (VIEW_TABLE *) (doCur->data);
    view_instance = view_entry->view_instance;

    new_entry = FALSE;
    temp_ptr = NULL;
    new_view = NULL;
    indexInst = NULL;
    viewInst = NULL;
    viewIndex = -1;
    found = -1;

    switch (doCur->state) {
      case DELETE:
	viewInst = NULL;
	indexInst = NULL;
	for (i = 0; i < num_views; i++) {
	    if (party_views[i].mib_view == NULL) {
		continue;
	    }
	    index_inst[0] = (unsigned long) party_views[i].mib_view->viewIndex;
	    FreeOID(indexInst);
	    indexInst = NULL;
	    FreeOID(viewInst);
	    viewInst = NULL;
	    if ((indexInst = (OID *) MakeOID(index_inst, (short) 1)) == NULL) {
		DPRINTF((APWARN, "%s: Cannot malloc indexInst, delete failed\n"));
		return (GEN_ERROR);
	    }
	    if ((viewInst = (OID *) CatOID(indexInst, party_views[i].mib_view->viewSubtree)) == NULL) {
		DPRINTF((APWARN, "%s: Cannot malloc viewInst, delete failed\n"));
		FreeOID(indexInst);
		indexInst = NULL;
		return (GEN_ERROR);
	    }
	    FreeOID(indexInst);
	    indexInst = NULL;

	    if (CmpOID(viewInst, view_instance) == 0) {
		FreeOID(viewInst);
		viewInst = NULL;
		viewIndex = party_views[i].mib_view->viewIndex;
		if (DeleteViewElement(party_views[i].mib_view) == -1) {
		    DPRINTF((APWARN, "%s: delete failed.\n", FName));
		    return (GEN_ERROR);
		}
		party_views[i].mib_view = NULL;
		(void) WriteViewFile();

		RecomputeViewVectors(viewIndex);

		return (NO_ERROR);
	    }
	}
	FreeOID(viewInst);
	viewInst = NULL;
	break;
      case ADD_MODIFY:
	open_slot = -1;
	viewInst = NULL;
	indexInst = NULL;
	for (i = 0; i < num_views; i++) {
	    if ((party_views[i].mib_view == NULL) && (open_slot == -1)) {
		open_slot = i;
	    }
	    if (party_views[i].mib_view == NULL) {
		continue;
	    }
	    index_inst[0] = (unsigned long) party_views[i].mib_view->viewIndex;
	    FreeOID(indexInst);
	    indexInst = NULL;
	    FreeOID(viewInst);
	    viewInst = NULL;
	    if ((indexInst = (OID *) MakeOID(index_inst, (short) 1)) == NULL) {
		DPRINTF((APWARN, "%s: Cannot malloc indexInst, delete failed.\n"));
		return (GEN_ERROR);
	    }
	    if ((viewInst = (OID *) CatOID(indexInst,
			   party_views[i].mib_view->viewSubtree)) == NULL) {
		DPRINTF((APWARN, "%s: Cannot malloc viewInst, delete failed.\n"));
		FreeOID(indexInst);
		indexInst = NULL;
		return (GEN_ERROR);
	    }
	    FreeOID(indexInst);
	    indexInst = NULL;

	    if (((CmpOID(viewInst, view_instance)) == 0)) {
		found = i;
		break;
	    }
	}
	FreeOID(viewInst);
	viewInst = NULL;

	/*
	 * If the view_instance doesn't match any in the table, a new row
	 * must be added to the table.
	 */

	if (i == num_views) {
	    new_entry = TRUE;
	    if (!(new_view = (MIB_VIEW *) malloc((unsigned) sizeof(MIB_VIEW)))) {
		DPRINTF((APWARN, "%s: Cannot allocate memory for new view entry.\n", FName));
		return (GEN_ERROR);
	    }
	    memset((char *) new_view, 0, sizeof(MIB_VIEW));

	    if (open_slot == -1) {	/* Totally new entry needed */
		/*
		 * realloc view ptr table.
		 */
		num_views++;
		if (!(temp_ptr = (V2_VIEW *) realloc((char *) party_views,
			       (unsigned) (num_views * sizeof(V2_VIEW))))) {
		    DPRINTF((APWARN, "%s: Cannot reallocate memory for view ptr table.\n", FName));
		    free((char *) new_view);
		    new_view = NULL;
		    num_views--;
		    return (GEN_ERROR);
		}
		party_views = temp_ptr;
		temp_ptr = NULL;
		found = num_views - 1;

		party_views[found].mib_view = new_view;
	    }

	    else {		/* reuse old, invalidated entry */
		found = open_slot;
		party_views[found].mib_view = new_view;
	    }
	    party_views[found].mib_view->viewIndex = view_instance->oid_ptr[0];
	    party_views[found].last_active = GetTimeNow() / 100;

	    if ((party_views[found].mib_view->viewSubtree =
		 MakeOIDSubLen(view_instance)) == (OID *) NULL) {
		DPRINTF((APWARN, "%s: Cannot malloc viewSubtree\n"));
		FreeViewElement(new_view);
		party_views[found].mib_view = NULL;
		return (GEN_ERROR);
	    }
	}

	viewIndex = view_instance->oid_ptr[0];

	if (VALID(I_viewMask, view_entry->mib_view->valid)) {
	    if (party_views[found].mib_view->viewMask != (OctetString *) NULL) {
		FreeOctetString(party_views[found].mib_view->viewMask);
		party_views[found].mib_view->viewMask = NULL;
	    }

	    if ((party_views[found].mib_view->viewMask =
		 CloneOctetString(view_entry->mib_view->viewMask)) ==
		(OctetString *) NULL) {
		DPRINTF((APWARN, "%s: Cannot allocate viewMask\n", FName));

		if (new_entry == TRUE) {
		    DPRINTF((APWARN, "%s: new view entry not created.\n", FName));
		    FreeViewElement(new_view);
		    party_views[found].mib_view = NULL;
		}

		return (GEN_ERROR);
	    }

	}

	if (VALID(I_viewType, view_entry->mib_view->valid)) {
	    party_views[found].mib_view->viewType = view_entry->mib_view->viewType;
	}

	if (VALID(I_viewStorageType, view_entry->mib_view->valid)) {
	    party_views[found].mib_view->viewStorageType =
		view_entry->mib_view->viewStorageType;
	}

	if (VALID(I_viewStatus, view_entry->mib_view->valid)) {
	    if (view_entry->mib_view->viewStatus == CREATE_AND_GO) {
		party_views[found].mib_view->viewStatus = ACTIVE;
	    }
	    else {
		if ((party_views[found].mib_view->viewStatus == ACTIVE) &&
		    (view_entry->mib_view->viewStatus == NOT_IN_SERVICE)) {
		    party_views[found].last_active = GetTimeNow() / 100;
		}
		party_views[found].mib_view->viewStatus = view_entry->mib_view->viewStatus;
	    }
	    if (party_views[found].mib_view->viewStatus == ACTIVE) {
		party_views[found].last_active = GetTimeNow() / 100;
	    }
	}

	if (party_views[found].mib_view->viewStatus != ACTIVE) {
	    partyMibNotActiveFlag = TRUE;
	}
	break;
    }				/* end switch */

    if (new_entry == TRUE) {
	if (ViewInsertSort(new_view) == -1) {
	    DPRINTF((APWARN, "viewEntry_set: Could not insert new view \
element into linked list.  "));
	    DPRINTF((APWARN, " Set failed!\n"));
	    FreeViewElement(new_view);
	    party_views[found].mib_view = NULL;
	    return (GEN_ERROR);
	}
    }

    (void) WriteViewFile();

    RecomputeViewVectors(viewIndex);

    return (NO_ERROR);

}				/* viewEntry_set() */

#endif				/* SETS */

#endif				/* SR_SNMPv2 */
