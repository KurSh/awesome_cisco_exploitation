/* $Id: c4000_atmzr_sunipdh.c,v 3.6.12.1 1996/03/18 22:00:44 gstovall Exp $
 * $Source: /release/111/cvs/Xsys/src-c4000/c4000_atmzr_sunipdh.c,v $
 *------------------------------------------------------------------
 * C4000 router family ATMizer SUNI-PDH PLIM (DS3/E3) driver.
 *
 * May, 1995  Walter R. Friedrich
 *
 * Copyright (c) 1995-1997 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: c4000_atmzr_sunipdh.c,v $
 * Revision 3.6.12.1  1996/03/18  22:00:44  gstovall
 * Branch: California_branch
 * Elvis has left the building.  He headed out to California, and took the
 * port ready changes with him.
 *
 * Revision 3.4.12.3  1996/03/13  02:00:40  dstine
 * Branch: DeadKingOnAThrone_branch
 *         - commit IDB cleanups
 *
 * Revision 3.4.12.2  1996/03/07  10:43:52  mdb
 * Branch: DeadKingOnAThrone_branch
 * cisco and ANSI/POSIX libraries.
 *
 * Revision 3.4.12.1  1996/02/20  17:57:47  dstine
 * Branch: DeadKingOnAThrone_branch
 *           Sync from DeadKingOnAThrone_baseline_960122 to
 *                     DeadKingOnAThrone_baseline_960213
 *
 * Revision 3.6  1996/02/13  08:15:54  dstine
 * CSCdi48797:  Extraneous definitions in interface_private.h
 *
 * Revision 3.5  1996/02/01  06:09:20  hampton
 * Migrate files out of the parser directory.  [CSCdi47717]
 *   Step 2: Change all files which reference the moved parser files to
 *   point to their new locations.
 *
 * Revision 3.4  1996/01/06  03:23:13  hampton
 * Remove extraneous includes of if_timer.h.  Rename if_timer.h and move
 * it to the 'os' directory.  [CSCdi46482]
 *
 * Revision 3.3  1995/11/17  18:45:08  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.2  1995/11/17  00:32:10  gstovall
 * Ladies and gentlemen, I introduce to you, the port ready commit.
 *
 * Revision 3.1  1995/11/09  13:26:21  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.5  1995/08/28  15:47:55  wfried
 * CSCdi39408:  ATM interface up decision should be based on more than
 * just LOS
 * Declare interface up only if PLCP framing or Cell delineation is
 * recognized for E3/DS3 interfaces.
 *
 * Revision 2.4  1995/08/10  23:31:31  wfried
 * CSCdi37608:  oam f5 cells generated by 4500 are not recognized by
 * analyzer
 * Changed ATM code to pass VC pointer for OAM cells and other related
 * changes
 *
 * Revision 2.3  1995/07/14  19:33:22  wfried
 * CSCdi37118:  Wrong SONET OC-3 bandwidth being reported on ATM interface
 * Remove extra interface bandwidth setting which was overwriting the
 * correct value.
 *
 * Revision 2.2  1995/06/27  00:31:02  wfried
 * CSCdi36069:  Performance tuning and changes on controller screen for
 * new interfac
 * Included more interface status in the show controller output,
 * forced ATM receiving packets to start at 16 byte boundaries for
 * better DBUS utilization, and made some fastswitching optimizations.
 * Created new ATM interface loopback command options and renamed E3
 * framing modes to reflect current terminology
 *
 * Revision 2.1  1995/06/07  22:56:10  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */


/*******************************************************************
			Include Files
 *******************************************************************/

#include "master.h"
#include "sys_registry.h"
#include "fastswitch_registry.h"
#include "media_registry.h"
#include "subsys.h"
#include "interface_private.h"
#include "packet.h"
#include "config.h"
#include "parser.h"
#include "../ui/debug.h"
#include "../ui/parse_util.h"
#include "../atm/parser_defs_atm.h"
#include "address.h"
#include "logger.h"
#include "../os/buffers.h"
#include "../if/network.h"
#include "../if/atm_debug.h"
#include "../if/atm.h"
#include "../les/if_les.h"
#include "c4000_atmzr.h"


/*******************************************************************
			Definitions
 *******************************************************************/



/*******************************************************************
			Variables
 *******************************************************************/

regs_block_db_t atmzr_sunipdh_regs[] = {
    { "cfgr",		0x0000 },/* Configuration Register */
    { "ier",		0x0001 },/* Interrupt Enable Register */
    { "isr",		0x0002 },/* Interrupt Status Register */
    { "ctlr",		0x0003 },/* Control Register */
    { "imrr",		0x0004 },/* Identification and Master Reset Register */
    { "dlcr",		0x0005 },/* Data Link Control Register */
    { "rboc_cier",	0x0006 },/* RBOC Configuration/Interrupt Enable Reg */
    { "rboc_isr",	0x0007 },/* RBOC Interrupt Status Register */
    { "t3frmr_cfgr",	0x0008 },/* DS3 FRMR Configuration Register */
    { "t3frmr_ier",	0x0009 },/* DS3 FRMR Interrupt Enable Register */
    { "t3frmr_isr",	0x000A },/* DS3 FRMR Interrupt Status Register */
    { "t3frmr_statr",	0x000B },/* DS3 FRMR Status Register */
    { "rfdl_cfgr",	0x000C },/* RFDL Configuration Register */
    { "rfdl_esr",	0x000D },/* RFDL Enable/Status Register */
    { "rfdl_statr",	0x000E },/* RFDL Status Register */
    { "rfdl_datar",	0x000F },/* RFDL Data Register */
    { "pmon_pmr",	0x0010 },/* PMON Change of PMON Performance Meters Rg */
    { "pmon_iesr",	0x0011 },/* PMON Interrupt Enable/Status Register */
    { "pmon_lcvec0r",	0x0014 },/* PMON Line Code Viol Event Count LSB Reg */
    { "pmon_lcvec1r",	0x0015 },/* PMON Line Code Viol Event Count MSB Reg */
    { "pmon_fbeec0r",	0x0016 },/* PMON Framing Bit Error Event Count LSB Rg */
    { "pmon_fbeec1r",	0x0017 },/* PMON Framing Bit Error Event Count MSB Rg */
    { "pmon_sezdc0r",	0x0018 },/* PMON Sum Excessive Zero Det Count LSB Reg */
    { "pmon_sezdc1r",	0x0019 },/* PMON Sum Excessive Zero Det Count MSB Reg */
    { "pmon_peec0r",	0x001A },/* PMON Parity Error Event Count LSB Reg */
    { "pmon_peec1r",	0x001B },/* PMON Parity Error Event Count MSB Reg */
    { "pmon_ppeec0r",	0x001C },/* PMON Path Parity Error Event Count LSB Rg */
    { "pmon_ppeec1r",	0x001D },/* PMON Path Parity Error Event Count MSB Rg */
    { "pmon_febeec0r",	0x001E },/* PMON FEBE Event Count LSB Register */
    { "pmon_febeec1r",	0x001F },/* PMON FEBE Event Count MSB Register */
    { "t3tran_cfgr",	0x0020 },/* DS3 TRAN Configuration Register */
    { "t3tran_diagr",	0x0021 },/* DS3 TRAN Diagnostics Register */
    { "xfdl_cfgr",	0x0024 },/* XFDL Configuration Register */
    { "xfdl_isr",	0x0025 },/* XFDL Interrupt Status Register */
    { "xfdl_txdatar",	0x0026 },/* XFDL Transmit Data Register */
    { "xboc_coder",	0x0027 },/* XBOC Code Register */
    { "splr_cfgr",	0x0028 },/* SPLR Configuration Register */
    { "splr_ier",	0x0029 },/* SPLR Interrupt Enable Register */
    { "splr_isr",	0x002A },/* SPLR Interrupt Status Register */
    { "splr_statr",	0x002B },/* SPLR Status Register */
    { "splt_cfgr",	0x002C },/* SPLT Configuration Register */
    { "splt_ctlr",	0x002D },/* SPLT Control Register */
    { "splt_diagr",	0x002E },/* SPLT Diagnostics and G1 Octet Register */
    { "splt_f1r",	0x002F },/* SPLT F1 Octet Register */
    { "cppm_locmr",	0x0030 },/* CPPM Loss of Clock Meters Register */
    { "cppm_copmr",	0x0031 },/* CPPM Change of CPPM Performance Meters Rg */
    { "cppm_b1ec0r",	0x0032 },/* CPPM B1 Error Count LSB Register */
    { "cppm_b1ec1r",	0x0033 },/* CPPM B1 Error Count MSB Register */
    { "cppm_feec0r",	0x0034 },/* CPPM Framing Error Event Count LSB Reg */
    { "cppm_feec1r",	0x0035 },/* CPPM Framing Error Event Count MSB Reg */
    { "cppm_febec0r",	0x0036 },/* CPPM FEBE Count LSB Register */
    { "cppm_febec1r",	0x0037 },/* CPPM FEBE Count MSB Register */
    { "cppm_hcsec0r",	0x0038 },/* CPPM HCS Error Count LSB Register */
    { "cppm_hcsec1r",	0x0039 },/* CPPM HCS Error Count MSB Register */
    { "cppm_iucc0r",	0x003A },/* CPPM Idle/Unassigned Cell Count LSB Reg */
    { "cppm_iucc1r",	0x003B },/* CPPM Idle/Unassigned Cell Count MSB Reg */
    { "cppm_rcc0r",	0x003C },/* CPPM Receive Cell Count LSB Register */
    { "cppm_rcc1r",	0x003D },/* CPPM Receive Cell Count MSB Register */
    { "cppm_tcc0r",	0x003E },/* CPPM Transmit Cell Count LSB Register */
    { "cppm_tcc1r",	0x003F },/* CPPM Transmit Cell Count MSB Register */
    { "rxcp_ctlr",	0x0040 },/* RXCP Control Register */
    { "rxcp_frcr",	0x0041 },/* RXCP Framing Control Register */
    { "rxcp_iesr",	0x0042 },/* RXCP Interrupt Enable/Status Register */
    { "rxcp_iucph1r",	0x0043 },/* RXCP Idle/Unass Cell Pattern: H1 Octet Rg */
    { "rxcp_iucph2r",	0x0044 },/* RXCP Idle/Unass Cell Pattern: H2 Octet Rg */
    { "rxcp_iucph3r",	0x0045 },/* RXCP Idle/Unass Cell Pattern: H3 Octet Rg */
    { "rxcp_iucph4r",	0x0046 },/* RXCP Idle/Unass Cell Pattern: H4 Octet Rg */
    { "rxcp_iucmh1r",	0x0047 },/* RXCP Idle/Unass Cell Mask: H1 Octet Reg */
    { "rxcp_iucmh2r",	0x0048 },/* RXCP Idle/Unass Cell Mask: H2 Octet Reg */
    { "rxcp_iucmh3r",	0x0049 },/* RXCP Idle/Unass Cell Mask: H3 Octet Reg */
    { "rxcp_iucmh4r",	0x004A },/* RXCP Idle/Unass Cell Mask: H4 Octet Reg */
    { "rxcp_upcph1r",	0x004B },/* RXCP User-Program Cell Patt: H1 Octet Reg */
    { "rxcp_upcph2r",	0x004C },/* RXCP User-Program Cell Patt: H2 Octet Reg */
    { "rxcp_upcph3r",	0x004D },/* RXCP User-Program Cell Patt: H3 Octet Reg */
    { "rxcp_upcph4r",	0x004E },/* RXCP User-Program Cell Patt: H4 Octet Reg */
    { "rxcp_upcmh1r",	0x004F },/* RXCP User-Program Cell Mask: H1 Octet Reg */
    { "rxcp_upcmh2r",	0x0050 },/* RXCP User-Program Cell Mask: H2 Octet Reg */
    { "rxcp_upcmh3r",	0x0051 },/* RXCP User-Program Cell Mask: H3 Octet Reg */
    { "rxcp_upcmh4r",	0x0052 },/* RXCP User-Program Cell Mask: H4 Octet Reg */
    { "rxcp_hcscsr",	0x0053 },/* RXCP HCS Control/Status Register */
    { "rxcp_lctctr",	0x0054 },/* RXCP LCD Count Threshold Register */
    { "txcp_ctlr",	0x0058 },/* TXCP Control Register */
    { "txcp_iesr",	0x0059 },/* TXCP Interrupt Enable/Status Register */
    { "txcp_iucph1r",	0x005A },/* TXCP Idle/Unass Cell Pattern: H1 Octet Rg */
    { "txcp_iucph2r",	0x005B },/* TXCP Idle/Unass Cell Pattern: H2 Octet Rg */
    { "txcp_iucph3r",	0x005C },/* TXCP Idle/Unass Cell Pattern: H3 Octet Rg */
    { "txcp_iucph4r",	0x005D },/* TXCP Idle/Unass Cell Pattern: H4 Octet Rg */
    { "txcp_iucph5r",	0x005E },/* TXCP Idle/Unass Cell Pattern: H5 Octet Rg */
    { "txcp_iucpr",	0x005F },/* TXCP Idle/Unass Cell Payload Register */
    { "e3frmr_foptr",	0x0060 },/* E3 FRMR Framing Options Register */
    { "e3frmr_moptr",	0x0061 },/* E3 FRMR Maintenance Options Register */
    { "e3frmr_fier",	0x0062 },/* E3 FRMR Interrupt Enable Register */
    { "e3frmr_fiisr",	0x0063 },/* E3 FRMR Interrupt Indication/Status Reg */
    { "e3frmr_meier",	0x0064 },/* E3 FRMR Maintenance Event Intr Enable Reg */
    { "e3frmr_meiir",	0x0065 },/* E3 FRMR Maintenance Event Intr Indic Reg */
    { "e3frmr_mesr",	0x0066 },/* E3 FRMR Maintenance Event Status Register */
    { "e3tran_foptr",	0x0068 },/* E3 TRAN Framing Options Register */
    { "e3tran_sdoptr",	0x0069 },/* E3 TRAN Status and Diagnostic Options Reg */
    { "e3tran_bip8emr",	0x006A },/* E3 TRAN BIP-8 Error Mask Reg */
    { "e3tran_maoptr",	0x006B },/* E3 TRAN Maintenance and Adapt Options Reg */
    { "ttb_ctlr",	0x006C },/* TTB Control Register */
    { "ttb_ttisr",	0x006D },/* TTB Trail Trace Identifier Status Reg */
    { "ttb_iar",	0x006E },/* TTB Indirect Address Register */
    { "ttb_idr",	0x006F },/* TTB Indirect Data Register */
    { "ttb_eptlr",	0x0070 },/* TTB Expected Payload Type Label Register */
    { "ttb_ptlcsr",	0x0071 },/* TTB Payload Type Label Control/Status Reg */
    { "sffpcsr",	0x0074 },/* Sync FIFO Parity Control/Status Register */
    { "pcr",		0x0080 },/* PLIM Control Register */
    { NULL,		0x0000 }
};

 
/*******************************************************************
			Functions
 *******************************************************************/


/*
 * a t m z r _ s u n i p d h _ d s 3 _ i n i t  ( )
 *
 * SUNI-PDH PLIM control structures initialization for DS3 operation.
 */
void
atmzr_sunipdh_ds3_init (hwidbtype *idb)		/* Interface HW IDB ptr */
{
    atmzr_instance_t            *ds;            /* ATMizer dabase pointer */

    /*
     * Initialize local variables and
     * register the PLIM functions
     */
    ds = (atmzr_instance_t *)INSTANCE;
    ds->plim_linerate = PDH_DS3_LINERATE;
    ds->plim_reset = atmzr_sunipdh_ds3_reset;
    ds->plim_show_regs = atmzr_sunipdh_show_regs;
    ds->plim_inthand = atmzr_sunipdh_ds3_inthand;

    /*
     * Initialize global idb variables
     */
    set_default_interface_bandwidth(idb->firstsw, PDH_DS3_LINERATE);
}


/*
 * a t m z r _ s u n i p d h _ e 3 _ i n i t  ( )
 *
 * SUNI-PDH PLIM control structures initialization for E3 operation.
 */
void
atmzr_sunipdh_e3_init (hwidbtype *idb)		/* Interface HW IDB ptr */
{
    atmzr_instance_t            *ds;            /* ATMizer dabase pointer */

    /*
     * Initialize local variables and
     * register the PLIM functions
     */
    ds = (atmzr_instance_t *)INSTANCE;
    ds->plim_linerate = PDH_E3_LINERATE;
    ds->plim_reset = atmzr_sunipdh_e3_reset;
    ds->plim_show_regs = atmzr_sunipdh_show_regs;
    ds->plim_inthand = atmzr_sunipdh_e3_inthand;

    /*
     * Initialize global idb variables
     */
    set_default_interface_bandwidth(idb->firstsw, PDH_E3_LINERATE);
}


/*
 * a t m z r _ s u n i p d h _ s h o w _ r e g s  ( )
 *
 * SUNI-PDH PLIM show PLIM registers.
 */
void
atmzr_sunipdh_show_regs (hwidbtype *idb)	/* Interface HW IDB ptr */
{
    vshort			*rbp;		/* Registers base pointer */
    regs_block_db_t		*dbp;		/* Registers database pointer */
    ushort			indx;		/* Auxiliar index */

    /*
     * Initialize local variables
     */
    rbp = (vshort *)&((atmzr_instance_t *)INSTANCE)->nim_regs->plim;
    dbp = &atmzr_sunipdh_regs[0];

    /*
     * Print all registers (4 per line)
     */
    while (dbp->reg_name) {
	indx = 4;
	printf ("\n  ");
	for (indx=0; indx<4 && dbp->reg_name; indx++) {
	    printf ("%s 0x%02X, ", dbp->reg_name,
				   (uchar)(*(rbp + dbp->reg_offset)));
	    dbp++;
	}
    }
}


/*
 * a t m z r _ s u n i p d h _ d s 3 _ r e s e t  ( )
 *
 * SUNI-PDH PLIM chip reset and initialization for DS3 operation.
 * For now, only the DS3 M23 PLCP mode is being enabled.
 */
void
atmzr_sunipdh_ds3_reset (hwidbtype *idb)	/* Interface HW IDB ptr */
{
    atmzr_instance_t            *ds;            /* ATMizer dabase pointer */
    suni_pdh_t			*rp;		/* SUNI-PDH registers ptr */
    vshort			cfgr, pcr;	/* Auxiliar register copy */

    /*
     * Initialize local variables
     */
    ds = (atmzr_instance_t *)INSTANCE;
    rp = &ds->nim_regs->plim_sunipdh;
    cfgr = 0;
    pcr = PDH_PCR_INTCLK_WR | PDH_PCR_LTH_T3SHORT_WR;

    /*
     * Reset PLIM
     * After reseting the SUNI chip, we need to wait for it to
     * initialize since it runs an internal microcode. The time
     * to wait is not clear yet, and will be adjusted/optimized
     * later.
     */
    rp->imrr = PDH_IMR_RESET;
    WASTETIME(1);
    rp->imrr = 0;
    WASTETIME(8);

    /*
     * Set chip configuration
     */

    /* Set configuration register */
    if (idb->atm_db->txclock == ATM_CLOCK_LINE) {
	/* Set Tx Clock to Line */
	cfgr |= PDH_CFG_LOOPT;
	pcr &= ~PDH_PCR_INTCLK_WR;
    }
    /* Select loopback mode (if any) */
    if (idb->loopback) {
	switch (idb->ext_loop_type) {
	case ATM_LOOP_LINE:			/* Physical line loopback */
	    cfgr |= PDH_CFG_LLB;
	    idb->inloopback = TRUE;
	    break;
	case ATM_LOOP_PAYL:			/* Loop timed payload loop */
	    cfgr |= PDH_CFG_PLB;
	    idb->inloopback = TRUE;
	    break;
	case ATM_LOOP_CELL:			/* Loop timed cell loopback */
	    cfgr |= (PDH_CFG_CLB | PDH_CFG_LOOPT);
	    idb->inloopback = TRUE;
	    break;
	case ATM_LOOP_DIAG:			/* Internal diagnostics loop */
	    cfgr |= PDH_CFG_DLB;
	    idb->inloopback = TRUE;
	    break;
	case ATM_LOOP_TEST:			/* Special cell loopback */
	    cfgr |= PDH_CFG_CLB;
	    cfgr &= ~PDH_CFG_LOOPT;
	    idb->inloopback = TRUE;
	    break;
	default:
	    idb->inloopback = FALSE;
	}
    } else {
	idb->inloopback = FALSE;
    }
    rp->cfgr = cfgr;
    rp->pcr = pcr;

    /*
     * Select several control options:
     *     Insert/Enable HCS polynomial
     *     Filter Idle/Unasigned cells 
     *     Enable cell payload scrambling/discr (if enabled)
     */
    rp->rxcp_ctlr = (idb->atm_db->flags & ATM_FLAG_DS3SCRAM) ?
	PDH_RXCP_CTL_HCSADD | PDH_RXCP_CTL_BLOCK | PDH_RXCP_CTL_DSCR :
	PDH_RXCP_CTL_HCSADD | PDH_RXCP_CTL_BLOCK;
    rp->txcp_ctlr = (idb->atm_db->flags & ATM_FLAG_DS3SCRAM) ?
	PDH_TXCP_CTL_HCSINS | PDH_TXCP_CTL_HCSADD | PDH_TXCP_CTL_SCR :
	PDH_TXCP_CTL_HCSINS | PDH_TXCP_CTL_HCSADD;

    /* Configure the framing mode (G751 with PLCP framing as default) */
    switch (idb->atm_db->ds3_framing) {
    case ATM_FRAMING_DS3CBITADM:
	rp->t3frmr_cfgr = PDH_T3FRMR_CFG_CBE;
	rp->t3tran_cfgr = PDH_T3TRAN_CFG_CBIT;
	rp->splr_cfgr = 0;
	rp->splt_cfgr = 0;
	rp->rxcp_frcr = PDH_RXCP_FRC_DELIN;
	break;
    case ATM_FRAMING_DS3M23ADM:
	rp->t3frmr_cfgr = 0;
	rp->t3tran_cfgr = 0;
	rp->splr_cfgr = 0;
	rp->splt_cfgr = 0;
	rp->rxcp_frcr = PDH_RXCP_FRC_DELIN;
	break;
    case ATM_FRAMING_DS3CBITPLCP:
	rp->t3frmr_cfgr = PDH_T3FRMR_CFG_CBE;
	rp->t3tran_cfgr = PDH_T3TRAN_CFG_CBIT;
	rp->splr_cfgr = PDH_SPLR_CFG_PLCPEN;
	rp->splt_cfgr = PDH_SPLT_CFG_PLCPEN;
	rp->rxcp_frcr = 0;
	break;
    case ATM_FRAMING_DS3M23PLCP:
    default:
	rp->t3frmr_cfgr = 0;
	rp->t3tran_cfgr = 0;
	rp->splr_cfgr = PDH_SPLR_CFG_PLCPEN;
	rp->splt_cfgr = PDH_SPLT_CFG_PLCPEN;
	rp->rxcp_frcr = 0;
	break;
    }


    /*
     * Initialize cell registers
     */

    /* Select Idle/Unasigned cell pattern and filtering */
    rp->txcp_iucph1r = 0x00;
    rp->txcp_iucph2r = 0x00;
    rp->txcp_iucph3r = 0x00;
    rp->txcp_iucph4r = 0x01;
    rp->txcp_iucph5r = 0x52;
    rp->rxcp_iucph1r = 0x00;
    rp->rxcp_iucph2r = 0x00;
    rp->rxcp_iucph3r = 0x00;
    rp->rxcp_iucph4r = 0x01;
    rp->rxcp_iucmh1r = 0xFF;
    rp->rxcp_iucmh2r = 0xFF;
    rp->rxcp_iucmh3r = 0xFF;
    rp->rxcp_iucmh4r = 0xFF;

    /* Setup the user programmable cell header registers */
    rp->rxcp_upcph1r = 0x00;
    rp->rxcp_upcph2r = 0x00;
    rp->rxcp_upcph3r = 0x00;
    rp->rxcp_upcph4r = 0x00;
    rp->rxcp_upcmh1r = 0xFF;
    rp->rxcp_upcmh2r = 0xFF;
    rp->rxcp_upcmh3r = 0xFF;
    rp->rxcp_upcmh4r = 0xFF;

    /* Send the FERFE/RAI when detecting Loss of signal */
    rp->dlcr = PDH_DLC_LOSEN;
 
    /* Enable reception of FERFE interrupts and enable the FRMR
     * block of interrupts for it to work.
     */
    rp->t3frmr_ier = PDH_T3FRMR_IE_FERFE;
    rp->ier = PDH_IE_FRMRE ;

    /*
     * Enable line state change interrupts
     *    PDH_T3FRMR_IE_OOFE	DS3 Out of Frame (PLCP Framed mode)
     *    PDH_RXCP_FRC_LCDE	Loss of Cell Delineation (Direct Mapping)
     */
    switch (idb->atm_db->ds3_framing) {
    case ATM_FRAMING_DS3CBITPLCP:
    case ATM_FRAMING_DS3M23PLCP:
        rp->splr_ier = PDH_SPLR_IE_OOFE;
        rp->ier |= PDH_IE_SPLRE;

    /* Send FERFE/RAI when detecting OOF */
        rp->dlcr |= PDH_DLC_OOFEN;
	break;
    case ATM_FRAMING_DS3CBITADM:
    case ATM_FRAMING_DS3M23ADM:
	rp->rxcp_iesr = PDH_RXCP_IES_OOCDE;
        rp->ier |= PDH_IE_RXCPE;

    /* Send FERFE/RAI when detecting Loss of Cell Deleneation */
        rp->dlcr |= PDH_DLC_LCDEN;
    }
}


/*
 * a t m z r _ s u n i p d h _ e 3 _ r e s e t  ( )
 *
 * SUNI-PDH PLIM chip reset and initialization for E3 operation.
 *
 * We support 3 framing modes for E3:
 *     G751 PLCP = G751 with PLCP framing (default mode)
 *     G751 ADM  = G751 Direct mapping of ATM cells (i.e. without PLCP framing)
 *     G832 ADM  = G832 Direct mapping of ATM cells
 *
 *     The old AIP supported two modes known as:
 *         ATM_FRAMING_UNFRAMED = G751 PLCP
 *         ATM_FRAMING_G804     = G832 ADM
 */
void
atmzr_sunipdh_e3_reset (hwidbtype *idb)	/* Interface HW IDB ptr */
{
    atmzr_instance_t            *ds;            /* ATMizer dabase pointer */
    suni_pdh_t			*rp;		/* SUNI-PDH registers ptr */
    vshort			cfgr, pcr;	/* Auxiliar register copy */

    /*
     * Initialize local variables
     */
    ds = (atmzr_instance_t *)INSTANCE;
    rp = &ds->nim_regs->plim_sunipdh;
    cfgr = PDH_CFG_E3ENBL;
    pcr = PDH_PCR_INTCLK_WR | PDH_PCR_LTH_E3_WR;

    /*
     * Reset PLIM
     * After reseting the SUNI chip, we need to wait for it to
     * initialize since it runs an internal microcode. The time
     * to wait is not clear yet, and will be adjusted/optimized
     * later.
     */
    rp->imrr = PDH_IMR_RESET;
    WASTETIME(1);
    rp->imrr = 0;
    WASTETIME(8);

    /*
     * Set chip configuration
     */

    /* Set configuration register */
    if (idb->atm_db->txclock == ATM_CLOCK_LINE) {
	/* Set Tx Clock to Line */
	cfgr |= PDH_CFG_LOOPT;
	pcr &= ~PDH_PCR_INTCLK_WR;
    }
    /* Select loopback mode (if any) */
    if (idb->loopback) {
        switch (idb->ext_loop_type) {
        case ATM_LOOP_LINE:
            cfgr |= PDH_CFG_LLB;
            idb->inloopback = TRUE;
            break;
        case ATM_LOOP_PAYL:
            cfgr |= PDH_CFG_PLB;
            idb->inloopback = TRUE;
            break;
        case ATM_LOOP_CELL:
            cfgr |= PDH_CFG_CLB;
            idb->inloopback = TRUE;
            break;
        case ATM_LOOP_DIAG:
            cfgr |= PDH_CFG_DLB;
            idb->inloopback = TRUE;
            break;
        default:
            idb->inloopback = FALSE;
        }
    } else {
        idb->inloopback = FALSE;
    }
    rp->cfgr = cfgr;
    rp->pcr = pcr;

    /* Set several control options */
    rp->rxcp_ctlr = PDH_RXCP_CTL_HCSADD |	/* Enable HCS polynomial */
		    PDH_RXCP_CTL_BLOCK |	/* Filter Idle/Unasigned cell */
		    PDH_RXCP_CTL_DSCR;		/* Enable cell payload discr */
    rp->txcp_ctlr = PDH_TXCP_CTL_HCSINS |	/* Insert HCS */
		    PDH_TXCP_CTL_HCSADD |	/* Enable HCS polynomial */
		    PDH_TXCP_CTL_SCR;		/* Enable cell payload scramb */

    /* Configure the framing mode (G751 with PLCP framing as default) */
    switch (idb->atm_db->e3_framing) {
    case ATM_FRAMING_E3G832ADM:			/* Also known as G.804 */
	rp->splr_cfgr = PDH_SPLR_CFG_FORM_E3 | PDH_SPLR_CFG_EXT;
	rp->splt_cfgr = PDH_SPLT_CFG_FORM_E3 | PDH_SPLT_CFG_EXT;
	rp->rxcp_frcr = PDH_RXCP_FRC_DELIN;
	rp->e3frmr_foptr = PDH_E3FRMR_FOPT_FR_G832;
	rp->e3frmr_moptr = PDH_E3FRMR_MOPT_WORDBIP;
	rp->e3tran_foptr = PDH_E3TRAN_FOPT_FR_G832;
	rp->e3tran_sdoptr = 0;
	break;
    case ATM_FRAMING_E3G751ADM:
	rp->splr_cfgr = PDH_SPLR_CFG_FORM_E3;
	rp->splt_cfgr = PDH_SPLT_CFG_FORM_E3;
	rp->rxcp_frcr = PDH_RXCP_FRC_DELIN;
	rp->e3frmr_foptr = 0;
	rp->e3frmr_moptr = PDH_E3FRMR_MOPT_PYLDJST;
	rp->e3tran_foptr = 0;
	rp->e3tran_sdoptr = PDH_E3TRAN_SDOPT_PYLDJ | PDH_E3TRAN_SDOPT_NATUSE;
	break;
    case ATM_FRAMING_E3G751PLCP:		/* Also known as Unframed!? */
    default:
	rp->splr_cfgr = PDH_SPLR_CFG_FORM_E3 | PDH_SPLR_CFG_PLCPEN;
	rp->splt_cfgr = PDH_SPLT_CFG_FORM_E3 | PDH_SPLT_CFG_PLCPEN;
	rp->rxcp_frcr = 0;
	rp->e3frmr_foptr = 0;
	rp->e3frmr_moptr = PDH_E3FRMR_MOPT_PYLDJST;
	rp->e3tran_foptr = 0;
	rp->e3tran_sdoptr = PDH_E3TRAN_SDOPT_PYLDJ | PDH_E3TRAN_SDOPT_NATUSE;
	break;
    }

    /*
     * Initialize cell registers
     */

    /* Select Idle/Unasigned cell pattern and filtering */
    rp->txcp_iucph1r = 0x00;
    rp->txcp_iucph2r = 0x00;
    rp->txcp_iucph3r = 0x00;
    rp->txcp_iucph4r = 0x01;
    rp->txcp_iucph5r = 0x52;
    rp->rxcp_iucph1r = 0x00;
    rp->rxcp_iucph2r = 0x00;
    rp->rxcp_iucph3r = 0x00;
    rp->rxcp_iucph4r = 0x01;
    rp->rxcp_iucmh1r = 0xFF;
    rp->rxcp_iucmh2r = 0xFF;
    rp->rxcp_iucmh3r = 0xFF;
    rp->rxcp_iucmh4r = 0xFF;

    /* Setup the user programmable cell header registers */
    rp->rxcp_upcph1r = 0x00;
    rp->rxcp_upcph2r = 0x00;
    rp->rxcp_upcph3r = 0x00;
    rp->rxcp_upcph4r = 0x00;
    rp->rxcp_upcmh1r = 0xFF;
    rp->rxcp_upcmh2r = 0xFF;
    rp->rxcp_upcmh3r = 0xFF;
    rp->rxcp_upcmh4r = 0xFF;

    /*
     * Reset the pm7345 internal tx and rx fifo, and force the
     * E3 framer block to reframe
     */
    rp->txcp_ctlr |= PDH_TXCP_CTL_FIFORST;
    rp->txcp_ctlr &= ~PDH_TXCP_CTL_FIFORST;
    rp->rxcp_ctlr |= PDH_RXCP_CTL_FIFORST;
    rp->rxcp_ctlr &= ~PDH_RXCP_CTL_FIFORST;
    rp->e3frmr_foptr |= PDH_E3FRMR_FOPT_REFR;
    rp->e3frmr_foptr &= ~PDH_E3FRMR_FOPT_REFR;

    /* Send the FERFE/RAI when detecting Loss of signal */
    rp->dlcr = PDH_DLC_LOSEN;

    /* Enable reception of FERFE interrupts and enable the FRMR
     * block of interrupts for it to work.
     */
    rp->e3frmr_meier |= PDH_E3FRMR_MEIE_FERFE;
    rp->ier = PDH_IE_FRMRE ;

    /*
     * Enable line state change interrupts
     *    PDH_E3FRMR_FIE_OOFE	E3 Out of Frame (PLCP Framed mode)
     *    PDH_RXCP_FRC_LCDE	Loss of Cell Delineation (Direct Mapping)
     */
    switch (idb->atm_db->e3_framing) {
    case ATM_FRAMING_E3G832ADM:
    case ATM_FRAMING_E3G751ADM:
	rp->rxcp_iesr = PDH_RXCP_IES_OOCDE;
        rp->ier |= PDH_IE_RXCPE;

    /* Send FERFE/RAI when detecting Loss of Cell Delineation */
        rp->dlcr |= PDH_DLC_LCDEN;
	break;
    case ATM_FRAMING_E3G751PLCP:
        rp->splr_ier = PDH_SPLR_IE_OOFE;
        rp->ier |= PDH_IE_SPLRE;

    /* Send FERFE/RAI when detecting OOF */
        rp->dlcr |= PDH_DLC_OOFEN;
	break;
    }
}


/*
 * a t m z r _ s u n i p d h _ d s 3 _ i n t h a n d  ( )
 *
 * SUNI-PDH PLIM interrupt handler.
 * The PLIM interrupt is one of the HI-IRQ interrupts
 * coming from the NIM when operating in DS3 mode.
 */
void
atmzr_sunipdh_ds3_inthand (hwidbtype *idb)		/* Interface HW IDB ptr */
{
    atmzr_instance_t            *ds;            /* ATMizer dabase pointer */
    suni_pdh_t                  *rp;            /* SUNI-PDH registers ptr */
    enum IDB_STATES             newstate;       /* New interface state */
    ushort                      dummy;          /* Auxiliar variable */
 
    /*
     * Initialize local variables and
     * register the PLIM Interrupt Handler
     */
    ds = (atmzr_instance_t *)INSTANCE;
    rp = &ds->nim_regs->plim_sunipdh;
    newstate = IDBS_DOWN;

    if(rp->isr & PDH_IS_FRMRI) {
    /* if its a framer block interrupt check for FERFE/RAI */
	dummy = rp->t3frmr_isr;
        if(!(rp->t3frmr_statr & PDH_T3FRMR_STAT_FERFV) && ds->nim_operational) 
                 newstate = IDBS_UP; 
    } else {  

     /*
      * Clear the interrupt and check line state.
      * For modes with an underlying frame, the loss of frame state
      * will be used to indicate line down. For direct mapping, the
      * loss of cell delineation will be used instead.
      */
      switch (idb->atm_db->ds3_framing) {
        case ATM_FRAMING_DS3CBITPLCP:
        case ATM_FRAMING_DS3M23PLCP:
          dummy = rp->splr_isr;
	  if (!(rp->splr_statr & PDH_SPLR_STAT_OOFV) && ds->nim_operational)
	      newstate = IDBS_UP;
	  break;
        case ATM_FRAMING_DS3CBITADM:
        case ATM_FRAMING_DS3M23ADM:
          dummy = rp->rxcp_iesr;
	  if (!(rp->rxcp_ctlr & PDH_RXCP_CTL_OOCDV) && ds->nim_operational)
	      newstate = IDBS_UP;
	  break;
      }
    }
    /*
     * Update interface state
     */
    if ((idb->state != newstate) && (idb->state != IDBS_ADMINDOWN)) {
        net_cstate(idb, newstate);
        idb->counters.transitions++;
    }
}


/*
 * a t m z r _ s u n i p d h _ e 3 _ i n t h a n d  ( )
 *
 * SUNI-PDH PLIM interrupt handler.
 * The PLIM interrupt is one of the HI-IRQ interrupts
 * coming from the NIM when operating in E3 mode.
 */
void
atmzr_sunipdh_e3_inthand (hwidbtype *idb)	/* Interface HW IDB ptr */
{
    atmzr_instance_t            *ds;            /* ATMizer dabase pointer */
    suni_pdh_t			*rp;		/* SUNI-PDH registers ptr */
    enum IDB_STATES		newstate;	/* New interface state */
    ushort                      dummy;          /* Auxiliar variable */

    /*
     * Initialize local variables and
     * register the PLIM Interrupt Handler
     */
    ds = (atmzr_instance_t *)INSTANCE;
    rp = &ds->nim_regs->plim_sunipdh;
    newstate = IDBS_DOWN;

    if(rp->isr & PDH_IS_FRMRI) {
    /* if its a framer block interrupt check for FERFE/RAI */
        dummy = rp->e3frmr_meiir;
        if(!(rp->e3frmr_mesr & PDH_E3FRMR_MES_FERFRAI) && ds->nim_operational)
                 newstate = IDBS_UP;
    } else {
     /*
      * Clear the interrupt and check line state.
      * For modes with an underlying frame, the loss of frame state
      * will be used to indicate line down. For direct mapping, the
      * loss of cell delineation will be used instead.
      */
      switch (idb->atm_db->e3_framing) {
        case ATM_FRAMING_E3G751PLCP:
          dummy = rp->splr_isr;
	  if (!(rp->splr_statr & PDH_SPLR_STAT_OOFV) && ds->nim_operational)
	      newstate = IDBS_UP;
	  break;
        case ATM_FRAMING_E3G751ADM:
        case ATM_FRAMING_E3G832ADM:
          dummy = rp->rxcp_iesr;
	  if (!(rp->rxcp_ctlr & PDH_RXCP_CTL_OOCDV) && ds->nim_operational)
	      newstate = IDBS_UP;
	  break;
      }
    }

    /*
     * Update interface state
     */
    if ((idb->state != newstate) && (idb->state != IDBS_ADMINDOWN)) {
        net_cstate(idb, newstate);
        idb->counters.transitions++;
    }
}

