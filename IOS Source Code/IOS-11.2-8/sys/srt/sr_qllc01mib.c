/* $Id: sr_qllc01mib.c,v 3.5.8.5 1996/07/01 18:46:28 hampton Exp $
 * $Source: /release/112/cvs/Xsys/srt/sr_qllc01mib.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * June 1994, Duane DeCapite (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1994-1996 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_qllc01mib.c,v $
 * Revision 3.5.8.5  1996/07/01  18:46:28  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.5.8.4  1996/05/21  10:05:27  thille
 * CSCdi51599:  multiple /interface/ literals bloat code.
 * Branch: California_branch
 * Save another 392 bytes by doing away with duplicate literals.
 *
 * Revision 3.5.8.3  1996/05/21  06:41:07  mordock
 * Branch: California_branch
 * Improve snmp modularity via creating services to register interfaces
 * and chassis cards.
 * Add syslog mib.
 *
 * Revision 3.5.8.2  1996/04/19  17:48:24  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.5.8.1  1996/03/18  22:11:09  gstovall
 * Branch: California_branch
 * Elvis has left the building.  He headed out to California, and took the
 * port ready changes with him.
 *
 * Revision 3.4.14.3  1996/03/16  07:38:29  gstovall
 * Branch: DeadKingOnAThrone_branch
 * Make the king aware of V111_1_3.
 *
 * Revision 3.4.14.2  1996/03/13  02:02:29  dstine
 * Branch: DeadKingOnAThrone_branch
 *         - commit IDB cleanups
 *
 * Revision 3.4.14.1  1996/02/20  18:49:00  dstine
 * Branch: DeadKingOnAThrone_branch
 *           Sync from DeadKingOnAThrone_baseline_960122 to
 *                     DeadKingOnAThrone_baseline_960213
 *
 * Revision 3.5  1996/02/28  22:31:48  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.4  1995/12/14  08:28:01  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.3  1995/11/17  18:56:19  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.2  1995/11/17  00:42:35  gstovall
 * Ladies and gentlemen, I introduce to you, the port ready commit.
 *
 * Revision 3.1  1995/11/09  13:32:07  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.3  1995/10/10  00:36:35  bchan
 * CSCdi41738:  QLLC mib object query crashes the router
 *
 * Revision 2.2  1995/07/17  07:34:25  bchan
 * CSCdi34760:  Ifindex usage incorrect
 *
 * Revision 2.1  1995/06/07  23:01:54  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */


/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include "../ui/common_strings.h"
#include "interface_private.h"
#include "../snmp/snmp_api.h"
#include "snmp_interface.h"   
#include "sr_qllc01mib.h"
#include "sr_qllc01mib-mib.h"
#include "../snmp/snmp_registry.h"
#include "../snmp/ifmib_registry.h"
#include "../x25/x25.h"
#include "address.h"
#include "logger.h"
#include "../if/tring.h"
#include "../if/tring_common.h"
#include "../if/network.h"
#include "../llc2/llc2.h"
#include "../x25/x25.h"
#include "../x25/x25_address.h"
#include "../x25/x25_proto.h"
#include "../if/rif.h"
#include "../srt/srb.h"
#include "../srt/rsrb.h"
#include "../util/fsm.h"
#include "../srt/lack2fsm.h"
#include "../cls/clsi_msg.h"
#include "../util/avl.h"
#include "../srt/qllc.h"
#include "../srt/lnx.h"

static lcitype* GetLciFromIndex(int searchType, long ifIndex, 
                         long vc, hwidbtype** hwidb);

void
init_qllcmib (void)
{
    load_mib (qllc01mib_OidList, qllc01mib_OidListNum);
    load_oid(qllc01mib_oid_table);
}
/*---------------------------------------------------------------------

 * Retrieve data from the qllcLSAdminEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/ 

VarBind *
qllcLSAdminEntry_get (
     OID *incoming,
     ObjectInfo *object,
     int searchType,
     ContextInfo *contextInfo,
     int serialNum)
{
    int instLength = incoming->length - object->oid.length;
    int arg = object->nominator;
    void *dp;
    qllcLSAdminEntry_t *data = 0;
    unsigned long buffer[2];
    OID inst;
    int carry;
    long qllcLSAdminIfIndex;
    long qllcLSAdminLciVcIndex;


    /*
     * Check the object instance.
     *
     * An EXACT search requires that the instance be of length 2 
     *
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 2) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    } if ((InstToInt(incoming, 1 + object->oid.length, &qllcLSAdminLciVcIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &qllcLSAdminIfIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */ if ((arg == -1) || (data = k_qllcLSAdminEntry_get(serialNum, contextInfo, arg, searchType, qllcLSAdminIfIndex, qllcLSAdminLciVcIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	   * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 2;
	inst.oid_ptr[0] = data->qllcLSAdminIfIndex;
	inst.oid_ptr[1] = data->qllcLSAdminLciVcIndex;
    }				       /*
				          * Build the the variable binding for the variable that will be returned.
				        */
     switch (arg) {

#ifdef I_qllcLSAdminIfIndex
    case I_qllcLSAdminIfIndex:
	dp = &data->qllcLSAdminIfIndex;
	break;
#endif /*
          I_qllcLSAdminIfIndex 
        */

#ifdef I_qllcLSAdminLciVcIndex
    case I_qllcLSAdminLciVcIndex:
	dp = &data->qllcLSAdminLciVcIndex;
	break;
#endif /*
          I_qllcLSAdminLciVcIndex 
        */

#ifdef I_qllcLSAdminCircuitType
    case I_qllcLSAdminCircuitType:
	dp = &data->qllcLSAdminCircuitType;
	break;
#endif /*
          I_qllcLSAdminCircuitType 
        */

#ifdef I_qllcLSAdminRole
    case I_qllcLSAdminRole:
	dp = &data->qllcLSAdminRole;
	break;
#endif /*
          I_qllcLSAdminRole 
        */

#ifdef I_qllcLSAdminX25Add
    case I_qllcLSAdminX25Add:
	dp = MakeOctetString(data->qllcLSAdminX25Add->octet_ptr, data->qllcLSAdminX25Add->length);
	break;
#endif /*
          I_qllcLSAdminX25Add 
        */

#ifdef I_qllcLSAdminModulo
    case I_qllcLSAdminModulo:
	dp = &data->qllcLSAdminModulo;
	break;
#endif /*
          I_qllcLSAdminModulo 
        */

#ifdef I_qllcLSAdminLgX25
    case I_qllcLSAdminLgX25:
	dp = &data->qllcLSAdminLgX25;
	break;
#endif /*
          I_qllcLSAdminLgX25 
        */

    default:
	return ((VarBind *) NULL);

    }				       /*
				          switch 
				        */
    return (MakeVarBind(object, &inst, dp));

}
#ifdef SETS
/*----------------------------------------------------------------------
 * Free the qllcLSAdminEntry data object.
 *---------------------------------------------------------------------*/ 

void
qllcLSAdminEntry_free (qllcLSAdminEntry_t *data)
{
    if (data != NULL) {
	if (data->qllcLSAdminX25Add != NULL) {
	    FreeOctetString(data->qllcLSAdminX25Add);
	}
	free ((char *) data);
    }
}
/*----------------------------------------------------------------------

 * cleanup after qllcLSAdminEntry set/undo
 *---------------------------------------------------------------------*/ 

static int
qllcLSAdminEntry_cleanup (doList_t *trash)
{
    qllcLSAdminEntry_free(trash->data);
#ifdef SR_SNMPv2
    qllcLSAdminEntry_free(trash->undodata);
#endif /*
          SR_SNMPv2 
        */
    return NO_ERROR;
}
/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/ 

int
qllcLSAdminEntry_test (
     OID *incoming,
     ObjectInfo *object,
     ObjectSyntax *value,
     doList_t *doHead,
     doList_t *doCur,
     ContextInfo *contextInfo)
{
    int instLength = incoming->length - object->oid.length;
    doList_t *dp;
    int found = 0;
    int carry = 0;
    qllcLSAdminEntry_t *qllcLSAdminEntry;
    long qllcLSAdminIfIndex;
    long qllcLSAdminLciVcIndex;

    /*
       * Validate the object instance
       *
     */
    if (instLength != 2) {
	return NO_CREATION_ERROR;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &qllcLSAdminIfIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, 1 + object->oid.length, &qllcLSAdminLciVcIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    qllcLSAdminEntry = k_qllcLSAdminEntry_get(-1, contextInfo, object->nominator, EXACT, qllcLSAdminIfIndex, qllcLSAdminLciVcIndex);

#ifndef qllcLSAdminEntry_READ_CREATE

    if (qllcLSAdminEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif /*
          qllcLSAdminEntry_READ_CREATE 
     *//*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */ found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == qllcLSAdminEntry_set) &&
	    (((qllcLSAdminEntry_t *) (dp->data)) != NULL) &&
	    (((qllcLSAdminEntry_t *) (dp->data))->qllcLSAdminIfIndex == qllcLSAdminIfIndex) &&
	    (((qllcLSAdminEntry_t *) (dp->data))->qllcLSAdminLciVcIndex == qllcLSAdminLciVcIndex)) {

	    found = 1;
	    break;
	}
    } if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof (qllcLSAdminEntry_t))) == NULL) {
	    DPRINTF ((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof (qllcLSAdminEntry_t));

	dp->setMethod = qllcLSAdminEntry_set;
	dp->cleanupMethod = qllcLSAdminEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif /*
          SR_SNMPv2 
        */
	dp->state = UNKNOWN;

	SET_VALID (I_qllcLSAdminIfIndex, ((qllcLSAdminEntry_t *) (dp->data))->valid);
	((qllcLSAdminEntry_t *) (dp->data))->qllcLSAdminIfIndex = qllcLSAdminIfIndex;

	SET_VALID (I_qllcLSAdminLciVcIndex, ((qllcLSAdminEntry_t *) (dp->data))->valid);
	((qllcLSAdminEntry_t *) (dp->data))->qllcLSAdminLciVcIndex = qllcLSAdminLciVcIndex;

#ifdef qllcLSAdminEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (qllcLSAdminEntry != NULL) {
	    /*
	       use existing values as default values 
	     */
	    memcpy(dp->data, qllcLSAdminEntry, sizeof (qllcLSAdminEntry_t));

	    SET_ALL_VALID (((qllcLSAdminEntry_t *) (dp->data))->valid);

	    ((qllcLSAdminEntry_t *) (dp->data))->qllcLSAdminX25Add =
		CloneOctetString(qllcLSAdminEntry->qllcLSAdminX25Add);

	} else {


	    /*
	       Fill in default values here 
	     */


	}
#endif /*
          qllcLSAdminEntry_READ_CREATE 
        */ 
    }
    switch (object->nominator) {

#ifdef I_qllcLSAdminIfIndex
    case I_qllcLSAdminIfIndex:

	SET_VALID (I_qllcLSAdminIfIndex, ((qllcLSAdminEntry_t *) (dp->data))->valid);

	((qllcLSAdminEntry_t *) (dp->data))->qllcLSAdminIfIndex = value->sl_value;
	break;
#endif /*
          I_qllcLSAdminIfIndex 
        */

#ifdef I_qllcLSAdminLciVcIndex
    case I_qllcLSAdminLciVcIndex:

	SET_VALID (I_qllcLSAdminLciVcIndex, ((qllcLSAdminEntry_t *) (dp->data))->valid);

	((qllcLSAdminEntry_t *) (dp->data))->qllcLSAdminLciVcIndex = value->sl_value;
	break;
#endif /*
          I_qllcLSAdminLciVcIndex 
        */

#ifdef I_qllcLSAdminCircuitType
    case I_qllcLSAdminCircuitType:

	SET_VALID (I_qllcLSAdminCircuitType, ((qllcLSAdminEntry_t *) (dp->data))->valid);

	((qllcLSAdminEntry_t *) (dp->data))->qllcLSAdminCircuitType = value->sl_value;
	break;
#endif /*
          I_qllcLSAdminCircuitType 
        */

#ifdef I_qllcLSAdminRole
    case I_qllcLSAdminRole:

	SET_VALID (I_qllcLSAdminRole, ((qllcLSAdminEntry_t *) (dp->data))->valid);

	((qllcLSAdminEntry_t *) (dp->data))->qllcLSAdminRole = value->sl_value;
	break;
#endif /*
          I_qllcLSAdminRole 
        */

#ifdef I_qllcLSAdminX25Add
    case I_qllcLSAdminX25Add:

	SET_VALID (I_qllcLSAdminX25Add, ((qllcLSAdminEntry_t *) (dp->data))->valid);

	if (((qllcLSAdminEntry_t *) (dp->data))->qllcLSAdminX25Add != NULL) {
	    FreeOctetString(((qllcLSAdminEntry_t *) (dp->data))->qllcLSAdminX25Add);
	}
	((qllcLSAdminEntry_t *) (dp->data))->qllcLSAdminX25Add =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif /*
          I_qllcLSAdminX25Add 
        */

#ifdef I_qllcLSAdminModulo
    case I_qllcLSAdminModulo:

	SET_VALID (I_qllcLSAdminModulo, ((qllcLSAdminEntry_t *) (dp->data))->valid);

	((qllcLSAdminEntry_t *) (dp->data))->qllcLSAdminModulo = value->sl_value;
	break;
#endif /*
          I_qllcLSAdminModulo 
        */

#ifdef I_qllcLSAdminLgX25
    case I_qllcLSAdminLgX25:

	SET_VALID (I_qllcLSAdminLgX25, ((qllcLSAdminEntry_t *) (dp->data))->valid);

	((qllcLSAdminEntry_t *) (dp->data))->qllcLSAdminLgX25 = value->sl_value;
	break;
#endif /*
          I_qllcLSAdminLgX25 
        */

    default:
	DPRINTF ((APALWAYS, "snmpd: Internal error (invalid nominator in qllcLSAdminEntry_test)\n"));
	return (GEN_ERROR);

    }      /* switch   */
    
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}
/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/ int
qllcLSAdminEntry_set (doHead, doCur, contextInfo)
     doList_t *doHead;
     doList_t *doCur;
     ContextInfo *contextInfo;
{
    return (k_qllcLSAdminEntry_set((qllcLSAdminEntry_t *) (doCur->data),
				    contextInfo, doCur->state));
}
#endif /*  SETS */

/*---------------------------------------------------------------------
 * Retrieve data from the qllcLSOperEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/ 

VarBind *
qllcLSOperEntry_get (
     OID *incoming,
     ObjectInfo *object,
     int searchType,
     ContextInfo *contextInfo,
     int serialNum)
{
    int instLength = incoming->length - object->oid.length;
    int arg = object->nominator;
    void *dp;
    qllcLSOperEntry_t *data = 0;
    unsigned long buffer[2];
    OID inst;
    int carry;
    long qllcLSOperIfIndex;
    long qllcLSOperLciVcIndex;


    /*
     * Check the object instance.
     *
     * An EXACT search requires that the instance be of length 2 
     *
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 2) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    } if ((InstToInt(incoming, 1 + object->oid.length, &qllcLSOperLciVcIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &qllcLSOperIfIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */ if ((arg == -1) || (data = k_qllcLSOperEntry_get(serialNum, contextInfo, arg, searchType, qllcLSOperIfIndex, qllcLSOperLciVcIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	   * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 2;
	inst.oid_ptr[0] = data->qllcLSOperIfIndex;
	inst.oid_ptr[1] = data->qllcLSOperLciVcIndex;
    }				       /*
				          * Build the the variable binding for the variable that will be returned.
				        */
    switch (arg) {

#ifdef I_qllcLSOperIfIndex
    case I_qllcLSOperIfIndex:
	dp = &data->qllcLSOperIfIndex;
	break;
#endif /*    I_qllcLSOperIfIndex   */

#ifdef I_qllcLSOperLciVcIndex
    case I_qllcLSOperLciVcIndex:
	dp = &data->qllcLSOperLciVcIndex;
	break;
#endif /*
          I_qllcLSOperLciVcIndex 
        */


#ifdef I_qllcLSOperCircuitType
    case I_qllcLSOperCircuitType:
	dp = &data->qllcLSOperCircuitType;
	break;
#endif /*
          I_qllcLSOperCircuitType 
        */

#ifdef I_qllcLSOperRole
    case I_qllcLSOperRole:
	dp = &data->qllcLSOperRole;
	break;
#endif /*
          I_qllcLSOperRole 
        */

#ifdef I_qllcLSOperX25Add
    case I_qllcLSOperX25Add:
	dp = MakeOctetString(data->qllcLSOperX25Add->octet_ptr, data->qllcLSOperX25Add->length);
	break;
#endif /*
          I_qllcLSOperX25Add 
        */

#ifdef I_qllcLSOperModulo
    case I_qllcLSOperModulo:
	dp = &data->qllcLSOperModulo;
	break;
#endif /*
          I_qllcLSOperModulo 
        */

#ifdef I_qllcLSOperState
    case I_qllcLSOperState:
	dp = &data->qllcLSOperState;
	break;
#endif /*
          I_qllcLSOperState 
        */

#ifdef I_qllcLSOperDsap
    case I_qllcLSOperDsap:
	dp = &data->qllcLSOperDsap;
	break;
#endif /*
          I_qllcLSOperDsap 
        */

#ifdef I_qllcLSOperSsap
    case I_qllcLSOperSsap:
	dp = &data->qllcLSOperSsap;
	break;
#endif /*
          I_qllcLSOperSsap 
        */

#ifdef I_qllcLSOperLgX25
    case I_qllcLSOperLgX25:
	dp = &data->qllcLSOperLgX25;
	break;
#endif /*
          I_qllcLSOperLgX25 
        */

#ifdef I_qllcLSOperXid
    case I_qllcLSOperXid:
	dp = MakeOctetString(data->qllcLSOperXid->octet_ptr, data->qllcLSOperXid->length);
	break;
#endif /*
          I_qllcLSOperXid 
        */

    default:
	return ((VarBind *) NULL);

    }				       /*
				          switch 
				        */ 
   return (MakeVarBind(object, &inst, dp));

}
/*---------------------------------------------------------------------
 * Retrieve data from the qllcLSStatsEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/ 

VarBind *
qllcLSStatsEntry_get (
     OID *incoming,
     ObjectInfo *object,
     int searchType,
     ContextInfo *contextInfo,
     int serialNum)
{
    int instLength = incoming->length - object->oid.length;
    int arg = object->nominator;
    void *dp;
    qllcLSStatsEntry_t *data = 0;
    unsigned long buffer[2];
    OID inst;
    int carry;
    long qllcLSStatsIfIndex;
    long qllcLSStatsLciVcIndex;


    /*
     * Check the object instance.
     *
     * An EXACT search requires that the instance be of length 2 
     *
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 2) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    } if ((InstToInt(incoming, 1 + object->oid.length, &qllcLSStatsLciVcIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &qllcLSStatsIfIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */ if ((arg == -1) || (data = k_qllcLSStatsEntry_get(serialNum, contextInfo, arg, searchType, qllcLSStatsIfIndex, qllcLSStatsLciVcIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	   * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 2;
	inst.oid_ptr[0] = data->qllcLSStatsIfIndex;
	inst.oid_ptr[1] = data->qllcLSStatsLciVcIndex;
    }				       /*
				          * Build the the variable binding for the variable that will be returned.
				        */
     switch (arg) {

#ifdef I_qllcLSStatsIfIndex
    case I_qllcLSStatsIfIndex:
	dp = &data->qllcLSStatsIfIndex;
	break;
#endif /*
          I_qllcLSStatsIfIndex 
        */

#ifdef I_qllcLSStatsLciVcIndex
    case I_qllcLSStatsLciVcIndex:
	dp = &data->qllcLSStatsLciVcIndex;
	break;
#endif /*
          I_qllcLSStatsLciVcIndex 
        */

#ifdef I_qllcLSStatsXidIn
    case I_qllcLSStatsXidIn:
	dp = &data->qllcLSStatsXidIn;
	break;
#endif /*
          I_qllcLSStatsXidIn 
        */

#ifdef I_qllcLSStatsXidOut
    case I_qllcLSStatsXidOut:
	dp = &data->qllcLSStatsXidOut;
	break;
#endif /*
          I_qllcLSStatsXidOut 
        */

#ifdef I_qllcLSStatsTestIn
    case I_qllcLSStatsTestIn:
	dp = &data->qllcLSStatsTestIn;
	break;
#endif /*
          I_qllcLSStatsTestIn 
        */

#ifdef I_qllcLSStatsTestOut
    case I_qllcLSStatsTestOut:
	dp = &data->qllcLSStatsTestOut;
	break;
#endif /*
          I_qllcLSStatsTestOut 
        */

#ifdef I_qllcLSStatsQuenchOff
    case I_qllcLSStatsQuenchOff:
	dp = &data->qllcLSStatsQuenchOff;
	break;
#endif /*
          I_qllcLSStatsQuenchOff 
        */

#ifdef I_qllcLSStatsQuenchOn
    case I_qllcLSStatsQuenchOn:
	dp = &data->qllcLSStatsQuenchOn;
	break;
#endif /*
          I_qllcLSStatsQuenchOn 
        */

#ifdef I_qllcLSStatsInPaks
    case I_qllcLSStatsInPaks:
	dp = &data->qllcLSStatsInPaks;
	break;
#endif /*
          I_qllcLSStatsInPaks 
        */

#ifdef I_qllcLSStatsOutPaks
    case I_qllcLSStatsOutPaks:
	dp = &data->qllcLSStatsOutPaks;
	break;
#endif /*
          I_qllcLSStatsOutPaks 
        */

#ifdef I_qllcLSStatsInBytes
    case I_qllcLSStatsInBytes:
	dp = &data->qllcLSStatsInBytes;
	break;
#endif /*
          I_qllcLSStatsInBytes 
        */

#ifdef I_qllcLSStatsOutBytes
    case I_qllcLSStatsOutBytes:
	dp = &data->qllcLSStatsOutBytes;
	break;
#endif /*
          I_qllcLSStatsOutBytes 
        */

#ifdef I_qllcLSStatsNumRcvQsms
    case I_qllcLSStatsNumRcvQsms:
	dp = &data->qllcLSStatsNumRcvQsms;
	break;
#endif /*
          I_qllcLSStatsNumRcvQsms 
        */

#ifdef I_qllcLSStatsNumSndQsms
    case I_qllcLSStatsNumSndQsms:
	dp = &data->qllcLSStatsNumSndQsms;
	break;
#endif /*
          I_qllcLSStatsNumSndQsms 
        */

#ifdef I_qllcLSStatsNumRcvDiscs
    case I_qllcLSStatsNumRcvDiscs:
	dp = &data->qllcLSStatsNumRcvDiscs;
	break;
#endif /*
          I_qllcLSStatsNumRcvDiscs 
        */

#ifdef I_qllcLSStatsNumSndDiscs
    case I_qllcLSStatsNumSndDiscs:
	dp = &data->qllcLSStatsNumSndDiscs;
	break;
#endif /*
          I_qllcLSStatsNumSndDiscs 
        */

#ifdef I_qllcLSStatsNumRcvDms
    case I_qllcLSStatsNumRcvDms:
	dp = &data->qllcLSStatsNumRcvDms;
	break;
#endif /*
          I_qllcLSStatsNumRcvDms 
        */

#ifdef I_qllcLSStatsNumSndDms
    case I_qllcLSStatsNumSndDms:
	dp = &data->qllcLSStatsNumSndDms;
	break;
#endif /*
          I_qllcLSStatsNumSndDms 
        */

#ifdef I_qllcLSStatsNumRcvFrmrs
    case I_qllcLSStatsNumRcvFrmrs:
	dp = &data->qllcLSStatsNumRcvFrmrs;
	break;
#endif /*
          I_qllcLSStatsNumRcvFrmrs 
        */

#ifdef I_qllcLSStatsNumSndFrmrs
    case I_qllcLSStatsNumSndFrmrs:
	dp = &data->qllcLSStatsNumSndFrmrs;
	break;
#endif /*
          I_qllcLSStatsNumSndFrmrs 
        */

#ifdef I_qllcLSStatsNumDrops
    case I_qllcLSStatsNumDrops:
	dp = &data->qllcLSStatsNumDrops;
	break;
#endif /*
          I_qllcLSStatsNumDrops 
        */

#ifdef I_qllcLSStatsNumErrs
    case I_qllcLSStatsNumErrs:
	dp = &data->qllcLSStatsNumErrs;
	break;
#endif /*
          I_qllcLSStatsNumErrs 
        */

    default:
	return ((VarBind *) NULL);

    }
    return (MakeVarBind(object, &inst, dp));

}


qllcLSAdminEntry_t *
k_qllcLSAdminEntry_get (
     int serialNum,
     ContextInfo *contextInfo,
     int nominator,
     int searchType,
     long qllcLSAdminIfIndex,
     long qllcLSAdminLciVcIndex)
{
    static qllcLSAdminEntry_t qllcLSAdminEntryData;
    static OctetString x25Addr;
    hwidbtype *hwidb;
    
    lcitype* lci = GetLciFromIndex(searchType, qllcLSAdminIfIndex,
          qllcLSAdminLciVcIndex, &hwidb);
    
    if (lci == 0)
       return 0;
 
    qllcLSAdminEntryData.qllcLSAdminIfIndex =  hwidb->snmp_if_index;
    qllcLSAdminEntryData.qllcLSAdminLciVcIndex = lci->lci_lci;

    qllcLSAdminEntryData.qllcLSAdminCircuitType = IS_LCI_PVC(hwidb, lci->lci_lci)?
        D_qllcLSAdminCircuitType_permanentVC:D_qllcLSAdminCircuitType_switchedVC;
    qllcLSAdminEntryData.qllcLSAdminRole = D_qllcLSAdminRole_peerToPeer;
    qllcLSAdminEntryData.qllcLSAdminX25Add = &x25Addr;
    x25Addr.length = lci->lci_src_addr.length;
    x25Addr.octet_ptr = lci->lci_src_addr.x121_addr;
    qllcLSAdminEntryData.qllcLSAdminModulo = 
       hwidb->x25_modulo == X25_MOD8? D_qllcLSAdminModulo_modulo8:
                                      D_qllcLSAdminModulo_modulo128;
     ;

    /* the largest frame is stored at lnx */
    qllcLSAdminEntryData.qllcLSAdminLgX25 = lci->qllc->lnx?
            lci->qllc->lnx->lnx_dlc_maxbtu: 0;

    return (&qllcLSAdminEntryData);
}
#ifdef SETS 

int
k_qllcLSAdminEntry_set (data, contextInfo, function)
     qllcLSAdminEntry_t *data;
     ContextInfo *contextInfo;
     int function;
{

    return (GEN_ERROR);
}
#endif /*  SETS */ 

qllcLSOperEntry_t *
k_qllcLSOperEntry_get (
     int serialNum,
     ContextInfo *contextInfo,
     int nominator,
     int searchType,
     long qllcLSOperIfIndex,
     long qllcLSOperLciVcIndex)
{

  static int qllcState[] = {D_qllcLSOperState_lsStateClosed, 
                          D_qllcLSOperState_lsStateOpening,
                          D_qllcLSOperState_lsStateRecovery,
                          D_qllcLSOperState_lsStateClosing,
                          D_qllcLSOperState_lsStateOpened
		       };
    static qllcLSOperEntry_t qllcLSOperEntryData;
    static OctetString x25Addr;
    hwidbtype *hwidb;
    
    lcitype* lci = GetLciFromIndex(searchType, qllcLSOperIfIndex,
          qllcLSOperLciVcIndex, &hwidb);
    
    if (lci == 0)
       return 0;

    qllcLSOperEntryData.qllcLSOperIfIndex = hwidb->snmp_if_index;
    qllcLSOperEntryData.qllcLSOperLciVcIndex = lci->lci_lci;

    qllcLSOperEntryData.qllcLSOperCircuitType = IS_LCI_PVC(hwidb, lci->lci_lci)?
        D_qllcLSAdminCircuitType_permanentVC:D_qllcLSAdminCircuitType_switchedVC;
    if (lci->qllc)
       qllcLSOperEntryData.qllcLSOperRole = lci->qllc->primaryRole?
            D_qllcLSOperRole_primary: D_qllcLSOperRole_secondary;
    else
       qllcLSOperEntryData.qllcLSOperRole = 0;
       
    x25Addr.length = lci->lci_dst_addr.length;
    x25Addr.octet_ptr = lci->lci_dst_addr.x121_addr;
    qllcLSOperEntryData.qllcLSOperX25Add = &x25Addr;
    qllcLSOperEntryData.qllcLSOperModulo = X25_MOD8? D_qllcLSOperModulo_modulo8:
                                      D_qllcLSOperModulo_modulo128;;
    qllcLSOperEntryData.qllcLSOperState = qllcState[lci->qllc->qllc_state];
    qllcLSOperEntryData.qllcLSOperLgX25 = lci->qllc->lnx?
            lci->qllc->lnx->lnx_dlc_maxbtu: 0;
;

    return (&qllcLSOperEntryData);
}

qllcLSStatsEntry_t *
k_qllcLSStatsEntry_get (
     int serialNum,
     ContextInfo *contextInfo,
     int nominator,
     int searchType,
     long qllcLSStatsIfIndex,
     long qllcLSStatsLciVcIndex)
{
    static qllcLSStatsEntry_t qllcLSStatsEntryData;
    hwidbtype *hwidb;
    qllctype* qllc;
    
    lcitype* lci = GetLciFromIndex(searchType, qllcLSStatsIfIndex,
          qllcLSStatsLciVcIndex, &hwidb);
    
    if (lci == 0)
       return 0;

    qllcLSStatsEntryData.qllcLSStatsIfIndex = hwidb->snmp_if_index;
    qllcLSStatsEntryData.qllcLSStatsLciVcIndex = lci->lci_lci;
    qllc = lci->qllc;

    qllcLSStatsEntryData.qllcLSStatsXidIn = qllc->qllcStat.qllc_xidin;
    qllcLSStatsEntryData.qllcLSStatsXidOut = qllc->qllcStat.qllc_xidout;
    qllcLSStatsEntryData.qllcLSStatsTestIn =qllc->qllcStat.qllc_testin;
    qllcLSStatsEntryData.qllcLSStatsTestOut =qllc->qllcStat.qllc_testout;
    qllcLSStatsEntryData.qllcLSStatsQuenchOff =qllc->qllcStat.qllc_quenchoff;
    qllcLSStatsEntryData.qllcLSStatsQuenchOn =qllc->qllcStat.qllc_quenchon;
    qllcLSStatsEntryData.qllcLSStatsInPaks =qllc->qllcStat.qllc_inpaks;
    qllcLSStatsEntryData.qllcLSStatsOutPaks =qllc->qllcStat.qllc_outpaks;
    qllcLSStatsEntryData.qllcLSStatsInBytes =qllc->qllcStat.qllc_inbytes;
    qllcLSStatsEntryData.qllcLSStatsOutBytes =qllc->qllcStat.qllc_outbytes;
    qllcLSStatsEntryData.qllcLSStatsNumRcvQsms =qllc->qllcStat.qllc_numrcvqsms;
    qllcLSStatsEntryData.qllcLSStatsNumSndQsms =qllc->qllcStat.qllc_numsndqsms;
    qllcLSStatsEntryData.qllcLSStatsNumRcvDiscs =qllc->qllcStat.qllc_numrcvdiscs;
    qllcLSStatsEntryData.qllcLSStatsNumSndDiscs =qllc->qllcStat.qllc_numsnddiscs;
    qllcLSStatsEntryData.qllcLSStatsNumRcvDms =qllc->qllcStat.qllc_numrcvdms;
    qllcLSStatsEntryData.qllcLSStatsNumSndDms =qllc->qllcStat.qllc_numsnddms;
    qllcLSStatsEntryData.qllcLSStatsNumRcvFrmrs =qllc->qllcStat.qllc_numrcvfrmrs;
    qllcLSStatsEntryData.qllcLSStatsNumSndFrmrs =qllc->qllcStat.qllc_numsndfrmrs;
    qllcLSStatsEntryData.qllcLSStatsNumDrops =qllc->qllcStat.qllc_numdrops;
    qllcLSStatsEntryData.qllcLSStatsNumErrs =qllc->qllcStat.qllc_numerrs;

    return (&qllcLSStatsEntryData);
}

/*
 **********************************************************************
 *
 * KERNEL CODE begins here.  Above is all generated by SNMP Research
 * compiler.  Below code does the real work in getting the router
 * information.  
 *
 * First come the utility helper routines.
 *
 **********************************************************************
 */

/* return TRUE if there is vc is  configured */
static boolean snmp_lci_idb_tester (hwidbtype *idb, long* vc)
{
   lcitype          *lci;
   
   if (is_x25(idb)){
       if (*vc != 0)
           (*vc)--;
       while ((lci = x25_lci_lookup_next(idb, *vc, 0)) != NULL){
           *vc = lci->lci_lci;
           if (lci->qllc != NULL)    /* Is this qllc ? */
              return TRUE;           /* yes, else continue scanning */
       }
   }
   return FALSE;      /* cant find one */
}


static lcitype* GetLciFromIndex(int searchType, long ifIndex, long vc, hwidbtype** hwidbP)
{
   hwidbtype* hwidb = reg_invoke_ifmib_2indices_get(0, searchType, ifIndex,
						    snmp_lci_idb_tester, &vc);
   *hwidbP = hwidb;
   return hwidb != NULL?  x25_lci_lookup(hwidb, vc, 0) : NULL;
}

      
