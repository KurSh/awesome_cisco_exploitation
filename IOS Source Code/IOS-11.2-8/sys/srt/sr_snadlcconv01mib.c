/* $Id: sr_snadlcconv01mib.c,v 3.5.8.4 1996/07/01 18:46:31 hampton Exp $
 * $Source: /release/112/cvs/Xsys/srt/sr_snadlcconv01mib.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * October 1994, Mauro D. Zallocco (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1994-1997 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_snadlcconv01mib.c,v $
 * Revision 3.5.8.4  1996/07/01  18:46:31  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.5.8.3  1996/05/17  12:14:10  ppearce
 * Merge IbuMod into Calif
 *
 * Revision 3.4.32.4  1996/05/06  00:01:45  ppearce
 * Sync to IbuMod_Calif_baseline_960504
 *
 * Revision 3.4.32.3  1996/04/26  07:58:50  dstine
 * Branch: IbuMod_Calif_branch
 * - commit of IBU modularity work, phase 1.
 *
 * Revision 3.4.32.2  1996/04/03  21:59:39  ppearce
 * Sync to IbuMod_Calif_baseline_960402
 *
 * Revision 3.4.32.1  1996/03/17  18:50:07  ppearce
 * Sync IbuMod_Calif_branch to V111_1_3
 *
 * Revision 3.5.8.2  1996/04/19  17:48:26  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.5.8.1  1996/03/18  22:11:13  gstovall
 * Branch: California_branch
 * Elvis has left the building.  He headed out to California, and took the
 * port ready changes with him.
 *
 * Revision 3.4.14.3  1996/03/16  07:38:35  gstovall
 * Branch: DeadKingOnAThrone_branch
 * Make the king aware of V111_1_3.
 *
 * Revision 3.4.14.2  1996/03/07  10:51:23  mdb
 * Branch: DeadKingOnAThrone_branch
 * cisco and ANSI/POSIX libraries.
 *
 * Revision 3.4.14.1  1996/02/20  18:49:21  dstine
 * Branch: DeadKingOnAThrone_branch
 *           Sync from DeadKingOnAThrone_baseline_960122 to
 *                     DeadKingOnAThrone_baseline_960213
 *
 * Revision 3.5  1996/02/29  16:30:47  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.4  1995/12/14  08:28:04  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.3  1995/11/17  18:56:36  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.2  1995/11/17  00:42:40  gstovall
 * Ladies and gentlemen, I introduce to you, the port ready commit.
 *
 * Revision 3.1  1995/11/09  13:32:16  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.3  1995/07/17  07:34:32  bchan
 * CSCdi34760:  Ifindex usage incorrect
 *
 * Revision 2.2  1995/06/28  09:31:37  smackie
 * Repair widespread subsystem header braindamage. (CSCdi23568)
 *
 *   o Fix subsystem entry points to be foo(subsystype *) not foo(void)
 *   o Repair nonsensical and redundant subsystem sequences
 *   o Use NULL where no property is required
 *
 * Revision 2.1  1995/06/07  23:02:06  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */


/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include <string.h>
#include <ciscolib.h>
#include "interface_generic.h"
#include "ieee.h"
#include "../snmp/snmp_api.h"
#include "sr_snadlcconv01mib.h"
#include "sr_snadlcconv01mib-mib.h"
#include "../x25/x25.h"
#include "address.h"
#include "logger.h"
#include "../if/tring.h"
#include "../if/tring_common.h"
#include "../if/network.h"
#include "../llc2/llc2.h"
#include "../x25/x25.h"
#include "../x25/x25_address.h"
#include "../x25/x25_proto.h"
#include "../if/rif.h"
#include "../srt/srb.h"
#include "../srt/rsrb.h"
#include "../util/fsm.h"
#include "../srt/lack2fsm.h"
#include "../ibm/sdlc.h"
#include "../cls/clsi_msg.h"		/* for declarations used in qllc.h */
#include "../util/avl.h"
#include "../srt/qllc.h"
#include "../srt/lnx.h"

static lnxtype* GetLciFromIndex(int searchType, OctetString* macAddr);
static int GetConversionType(lnxtype* lnx);

static unsigned char macAddress[6];
static OctetString snmpMac = {macAddress, 6};
static unsigned char macPartner[6];
static OctetString partnerMac = {macPartner, 6};

/* LnxGetNext uses brutal search to find the next macAddr data. Once
 * macAddr is threaded with order, then the macAddr can just be a
 * simple search
 */
static lnxtype* LnxGetNext(uchar* macAddr);

void
init_snadlcconvmib (void)
{
    load_mib(snadlcconv01mib_OidList, snadlcconv01mib_OidListNum);
    load_oid(snadlcconv01mib_oid_table);
}
/*---------------------------------------------------------------------

 * Retrieve data from the convQllcAdminEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/ 

#define MAXBUFSIZE 32

VarBind *
convQllcAdminEntry_get (
     OID *incoming,
     ObjectInfo *object,
     int searchType,
     ContextInfo *contextInfo,
     int serialNum)
{
/*    int instLength = incoming->length - object->oid.length; */
    int arg = object->nominator;
    void *dp;
    convQllcAdminEntry_t *data = 0;
    unsigned long buffer[MAXBUFSIZE];
    OID inst;
    int carry;
    int i;
    OctetString *convQllcAdminVirtualMac;
    int convQllcAdminVirtualMac_offset;
    int index;
    int final_index;

    convQllcAdminVirtualMac_offset = object->oid.length;
    final_index = convQllcAdminVirtualMac_offset + 6;

    if (searchType == EXACT) {
	if (final_index != incoming->length) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    } if ((InstToFixedOctetString(incoming, convQllcAdminVirtualMac_offset, &convQllcAdminVirtualMac, searchType, &carry, 6)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */ if ((arg == -1) || (data = k_convQllcAdminEntry_get(serialNum, contextInfo, arg, searchType, convQllcAdminVirtualMac)) == NULL) {
	arg = -1;
    } else {
	/*
	   * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	for (i = 0; i < data->convQllcAdminVirtualMac->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->convQllcAdminVirtualMac->octet_ptr[i];
	} 
	inst.length = index;
    } if (convQllcAdminVirtualMac != NULL) {
	FreeOctetString(convQllcAdminVirtualMac);
    }
    /*
       * Build the the variable binding for the variable that will be returned.
     */ 
    switch (arg) {

#ifdef I_convQllcAdminVirtualMac
    case I_convQllcAdminVirtualMac:
	dp = MakeOctetString(data->convQllcAdminVirtualMac->octet_ptr, data->convQllcAdminVirtualMac->length);
	break;
#endif /*
          I_convQllcAdminVirtualMac 
        */

#ifdef I_convQllcAdminConvertionType
    case I_convQllcAdminConvertionType:
	dp = &data->convQllcAdminConvertionType;
	break;
#endif /*
          I_convQllcAdminConvertionType 
        */

#ifdef I_convQllcAdminSdlcAdd
    case I_convQllcAdminSdlcAdd:
	dp = &data->convQllcAdminSdlcAdd;
	break;
#endif /*
          I_convQllcAdminSdlcAdd 
        */

#ifdef I_convQllcAdminPartner
    case I_convQllcAdminPartner:
	dp = MakeOctetString(data->convQllcAdminPartner->octet_ptr, data->convQllcAdminPartner->length);
	break;
#endif /*
          I_convQllcAdminPartner 
        */

#ifdef I_convQllcAdminThisRing
    case I_convQllcAdminThisRing:
	dp = &data->convQllcAdminThisRing;
	break;
#endif /*
          I_convQllcAdminThisRing 
        */

#ifdef I_convQllcAdminBridgeNum
    case I_convQllcAdminBridgeNum:
	dp = &data->convQllcAdminBridgeNum;
	break;
#endif /*
          I_convQllcAdminBridgeNum 
        */

#ifdef I_convQllcAdminTargetRing
    case I_convQllcAdminTargetRing:
	dp = &data->convQllcAdminTargetRing;
	break;
#endif /*
          I_convQllcAdminTargetRing 
        */

#ifdef I_convQllcAdminLargestSDLC
    case I_convQllcAdminLargestSDLC:
	dp = &data->convQllcAdminLargestSDLC;
	break;
#endif /*
          I_convQllcAdminLargestSDLC 
        */

#ifdef I_convQllcAdminLargestLLC2
    case I_convQllcAdminLargestLLC2:
	dp = &data->convQllcAdminLargestLLC2;
	break;
#endif /*
          I_convQllcAdminLargestLLC2 
        */

#ifdef I_convQllcAdminLSDsap
    case I_convQllcAdminLSDsap:
	dp = &data->convQllcAdminLSDsap;
	break;
#endif /*
          I_convQllcAdminLSDsap 
        */

#ifdef I_convQllcAdminLSSsap
    case I_convQllcAdminLSSsap:
	dp = &data->convQllcAdminLSSsap;
	break;
#endif /*
          I_convQllcAdminLSSsap 
        */

#ifdef I_convQllcAdminLSXid
    case I_convQllcAdminLSXid:
	dp = MakeOctetString(data->convQllcAdminLSXid->octet_ptr, data->convQllcAdminLSXid->length);
	break;
#endif /*
          I_convQllcAdminLSXid 
        */

    default:
	return ((VarBind *) NULL);

    }				       /*
				          switch 
				        */
   return (MakeVarBind(object, &inst, dp));

}
#ifdef SETS
/*----------------------------------------------------------------------
 * Free the convQllcAdminEntry data object.
 *---------------------------------------------------------------------*/

void
convQllcAdminEntry_free (convQllcAdminEntry_t *data)
{
    if (data != NULL) {
	if (data->convQllcAdminVirtualMac != NULL) {
	    FreeOctetString(data->convQllcAdminVirtualMac);
	}
	if (data->convQllcAdminPartner != NULL) {
	    FreeOctetString(data->convQllcAdminPartner);
	}
	if (data->convQllcAdminLSXid != NULL) {
	    FreeOctetString(data->convQllcAdminLSXid);
	}
	free ((char *) data);
    }
}
/*----------------------------------------------------------------------

 * cleanup after convQllcAdminEntry set/undo
 *---------------------------------------------------------------------*/ 

static int
convQllcAdminEntry_cleanup (doList_t *trash)
{
    convQllcAdminEntry_free(trash->data);
#ifdef SR_SNMPv2
    convQllcAdminEntry_free(trash->undodata);
#endif /*
          SR_SNMPv2 
        */
    return NO_ERROR;
}
/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/ 

int
convQllcAdminEntry_test (
     OID *incoming,
     ObjectInfo *object,
     ObjectSyntax *value,
     doList_t *doHead,
     doList_t *doCur,
     ContextInfo *contextInfo)
{
    doList_t *dp;
    int found = 0;
    int carry = 0;
    convQllcAdminEntry_t *convQllcAdminEntry;
    OctetString *convQllcAdminVirtualMac;
    int convQllcAdminVirtualMac_offset;
    int final_index;

    /*
       * Validate the object instance
       *
     */
    convQllcAdminVirtualMac_offset = object->oid.length;
    final_index = convQllcAdminVirtualMac_offset + 6;

    if (final_index != incoming->length) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToFixedOctetString(incoming, convQllcAdminVirtualMac_offset, &convQllcAdminVirtualMac, EXACT, &carry, 6)) < 0) {
	return (NO_CREATION_ERROR);
    }
    convQllcAdminEntry = k_convQllcAdminEntry_get(-1, contextInfo, object->nominator, EXACT, convQllcAdminVirtualMac);

#ifndef convQllcAdminEntry_READ_CREATE

    if (convQllcAdminEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif /*
          convQllcAdminEntry_READ_CREATE 
     *//*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */ found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == convQllcAdminEntry_set) &&
	    (((convQllcAdminEntry_t *) (dp->data)) != NULL) &&
	    (((convQllcAdminEntry_t *) (dp->data))->convQllcAdminVirtualMac == convQllcAdminVirtualMac)) {

	    found = 1;
	    break;
	}
    } if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof (convQllcAdminEntry_t))) == NULL) {
	    DPRINTF ((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof (convQllcAdminEntry_t));

	dp->setMethod = convQllcAdminEntry_set;
	dp->cleanupMethod = convQllcAdminEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif /*
          SR_SNMPv2 
        */
	dp->state = UNKNOWN;

	SET_VALID (I_convQllcAdminVirtualMac, ((convQllcAdminEntry_t *) (dp->data))->valid);
	((convQllcAdminEntry_t *) (dp->data))->convQllcAdminVirtualMac = convQllcAdminVirtualMac;

#ifdef convQllcAdminEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (convQllcAdminEntry != NULL) {
	    /*
	       use existing values as default values 
	     */
	    memcpy(dp->data, convQllcAdminEntry, sizeof(convQllcAdminEntry_t));

	    SET_ALL_VALID (((convQllcAdminEntry_t *) (dp->data))->valid);

	    ((convQllcAdminEntry_t *) (dp->data))->convQllcAdminVirtualMac =
		CloneOctetString(convQllcAdminEntry->convQllcAdminVirtualMac);

	    ((convQllcAdminEntry_t *) (dp->data))->convQllcAdminPartner =
		CloneOctetString(convQllcAdminEntry->convQllcAdminPartner);

	    ((convQllcAdminEntry_t *) (dp->data))->convQllcAdminLSXid =
		CloneOctetString(convQllcAdminEntry->convQllcAdminLSXid);

	} else {


	    /*
	       Fill in default values here 
	     */


	}
#endif /*
          convQllcAdminEntry_READ_CREATE 
        */ 
    }
    switch (object->nominator) {

#ifdef I_convQllcAdminVirtualMac
    case I_convQllcAdminVirtualMac:

	SET_VALID (I_convQllcAdminVirtualMac, ((convQllcAdminEntry_t *) (dp->data))->valid);

	if (((convQllcAdminEntry_t *) (dp->data))->convQllcAdminVirtualMac != NULL) {
	    FreeOctetString(((convQllcAdminEntry_t *) (dp->data))->convQllcAdminVirtualMac);
	}
	((convQllcAdminEntry_t *) (dp->data))->convQllcAdminVirtualMac =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif /*
          I_convQllcAdminVirtualMac 
        */

#ifdef I_convQllcAdminConvertionType
    case I_convQllcAdminConvertionType:

	SET_VALID (I_convQllcAdminConvertionType, ((convQllcAdminEntry_t *) (dp->data))->valid);

	((convQllcAdminEntry_t *) (dp->data))->convQllcAdminConvertionType = value->sl_value;
	break;
#endif /*
          I_convQllcAdminConvertionType 
        */

#ifdef I_convQllcAdminSdlcAdd
    case I_convQllcAdminSdlcAdd:

	SET_VALID (I_convQllcAdminSdlcAdd, ((convQllcAdminEntry_t *) (dp->data))->valid);

	((convQllcAdminEntry_t *) (dp->data))->convQllcAdminSdlcAdd = value->sl_value;
	break;
#endif /*
          I_convQllcAdminSdlcAdd 
        */

#ifdef I_convQllcAdminPartner
    case I_convQllcAdminPartner:

	SET_VALID (I_convQllcAdminPartner, ((convQllcAdminEntry_t *) (dp->data))->valid);

	if (((convQllcAdminEntry_t *) (dp->data))->convQllcAdminPartner != NULL) {
	    FreeOctetString(((convQllcAdminEntry_t *) (dp->data))->convQllcAdminPartner);
	}
	((convQllcAdminEntry_t *) (dp->data))->convQllcAdminPartner =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif /*
          I_convQllcAdminPartner 
        */

#ifdef I_convQllcAdminThisRing
    case I_convQllcAdminThisRing:

	SET_VALID (I_convQllcAdminThisRing, ((convQllcAdminEntry_t *) (dp->data))->valid);

	((convQllcAdminEntry_t *) (dp->data))->convQllcAdminThisRing = value->sl_value;
	break;
#endif /*
          I_convQllcAdminThisRing 
        */

#ifdef I_convQllcAdminBridgeNum
    case I_convQllcAdminBridgeNum:

	SET_VALID (I_convQllcAdminBridgeNum, ((convQllcAdminEntry_t *) (dp->data))->valid);

	((convQllcAdminEntry_t *) (dp->data))->convQllcAdminBridgeNum = value->sl_value;
	break;
#endif /*
          I_convQllcAdminBridgeNum 
        */

#ifdef I_convQllcAdminTargetRing
    case I_convQllcAdminTargetRing:

	SET_VALID (I_convQllcAdminTargetRing, ((convQllcAdminEntry_t *) (dp->data))->valid);

	((convQllcAdminEntry_t *) (dp->data))->convQllcAdminTargetRing = value->sl_value;
	break;
#endif /*
          I_convQllcAdminTargetRing 
        */

#ifdef I_convQllcAdminLargestSDLC
    case I_convQllcAdminLargestSDLC:

	SET_VALID (I_convQllcAdminLargestSDLC, ((convQllcAdminEntry_t *) (dp->data))->valid);

	((convQllcAdminEntry_t *) (dp->data))->convQllcAdminLargestSDLC = value->sl_value;
	break;
#endif /*
          I_convQllcAdminLargestSDLC 
        */

#ifdef I_convQllcAdminLargestLLC2
    case I_convQllcAdminLargestLLC2:

	SET_VALID (I_convQllcAdminLargestLLC2, ((convQllcAdminEntry_t *) (dp->data))->valid);

	((convQllcAdminEntry_t *) (dp->data))->convQllcAdminLargestLLC2 = value->sl_value;
	break;
#endif /*
          I_convQllcAdminLargestLLC2 
        */

#ifdef I_convQllcAdminLSDsap
    case I_convQllcAdminLSDsap:

	SET_VALID (I_convQllcAdminLSDsap, ((convQllcAdminEntry_t *) (dp->data))->valid);

	((convQllcAdminEntry_t *) (dp->data))->convQllcAdminLSDsap = value->sl_value;
	break;
#endif /*
          I_convQllcAdminLSDsap 
        */

#ifdef I_convQllcAdminLSSsap
    case I_convQllcAdminLSSsap:

	SET_VALID (I_convQllcAdminLSSsap, ((convQllcAdminEntry_t *) (dp->data))->valid);

	((convQllcAdminEntry_t *) (dp->data))->convQllcAdminLSSsap = value->sl_value;
	break;
#endif /*
          I_convQllcAdminLSSsap 
        */

#ifdef I_convQllcAdminLSXid
    case I_convQllcAdminLSXid:

	SET_VALID (I_convQllcAdminLSXid, ((convQllcAdminEntry_t *) (dp->data))->valid);

	if (((convQllcAdminEntry_t *) (dp->data))->convQllcAdminLSXid != NULL) {
	    FreeOctetString(((convQllcAdminEntry_t *) (dp->data))->convQllcAdminLSXid);
	}
	((convQllcAdminEntry_t *) (dp->data))->convQllcAdminLSXid =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif /*
          I_convQllcAdminLSXid 
        */

    default:
	DPRINTF ((APALWAYS, "snmpd: Internal error (invalid nominator in convQllcAdminEntry_test)\n"));
	return (GEN_ERROR);

    }				       /*
				          switch 
				        */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}
/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/ 

int
convQllcAdminEntry_set (doHead, doCur, contextInfo)
     doList_t *doHead;
     doList_t *doCur;
     ContextInfo *contextInfo;
{
    return (k_convQllcAdminEntry_set((convQllcAdminEntry_t *) (doCur->data),
				     contextInfo, doCur->state));
}
#endif /*
          SETS 
 *//*---------------------------------------------------------------------
 * Retrieve data from the convQllcOperEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/ 

VarBind *
convQllcOperEntry_get (
     OID *incoming,
     ObjectInfo *object,
     int searchType,
     ContextInfo *contextInfo,
     int serialNum)
{
    int arg = object->nominator;
    void *dp;
    convQllcOperEntry_t *data = 0;
    unsigned long buffer[MAXBUFSIZE];
    OID inst;
    int carry;
    int i;
    OctetString *convQllcOperVirtualMac;
    int convQllcOperVirtualMac_offset;
    int index;
    int final_index;

    convQllcOperVirtualMac_offset = object->oid.length;
    final_index = convQllcOperVirtualMac_offset + 6;

    if (searchType == EXACT) {
	if (final_index != incoming->length) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    } if ((InstToFixedOctetString(incoming, convQllcOperVirtualMac_offset, &convQllcOperVirtualMac, searchType, &carry, 6)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */ if ((arg == -1) || (data = k_convQllcOperEntry_get(serialNum, contextInfo, arg, searchType, convQllcOperVirtualMac)) == NULL) {
	arg = -1;
    } else {
	/*
	   * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	for (i = 0; i < data->convQllcOperVirtualMac->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->convQllcOperVirtualMac->octet_ptr[i];
	} inst.length = index;
    } if (convQllcOperVirtualMac != NULL) {
	FreeOctetString(convQllcOperVirtualMac);
    }
    /*
       * Build the the variable binding for the variable that will be returned.
     */
     switch (arg) {

#ifdef I_convQllcOperVirtualMac
    case I_convQllcOperVirtualMac:
	dp = MakeOctetString(data->convQllcOperVirtualMac->octet_ptr, data->convQllcOperVirtualMac->length);
	break;
#endif /*
          I_convQllcOperVirtualMac 
        */

#ifdef I_convQllcOperPartner
    case I_convQllcOperPartner:
	dp = MakeOctetString(data->convQllcOperPartner->octet_ptr, data->convQllcOperPartner->length);
	break;
#endif /*
          I_convQllcOperPartner 
        */

#ifdef I_convQllcOperConvertionType
    case I_convQllcOperConvertionType:
	dp = &data->convQllcOperConvertionType;
	break;
#endif /*
          I_convQllcOperConvertionType 
        */

#ifdef I_convQllcOperSdlcAdd
    case I_convQllcOperSdlcAdd:
	dp = &data->convQllcOperSdlcAdd;
	break;
#endif /*
          I_convQllcOperSdlcAdd 
        */

#ifdef I_convQllcOperLnxState
    case I_convQllcOperLnxState:
	dp = &data->convQllcOperLnxState;
	break;
#endif /*
          I_convQllcOperLnxState 
        */

#ifdef I_convQllcOperThisRing
    case I_convQllcOperThisRing:
	dp = &data->convQllcOperThisRing;
	break;
#endif /*
          I_convQllcOperThisRing 
        */

#ifdef I_convQllcOperBridgeNum
    case I_convQllcOperBridgeNum:
	dp = &data->convQllcOperBridgeNum;
	break;
#endif /*
          I_convQllcOperBridgeNum 
        */

#ifdef I_convQllcOperTargetRing
    case I_convQllcOperTargetRing:
	dp = &data->convQllcOperTargetRing;
	break;
#endif /*
          I_convQllcOperTargetRing 
        */

#ifdef I_convQllcOperLargestSDLC
    case I_convQllcOperLargestSDLC:
	dp = &data->convQllcOperLargestSDLC;
	break;
#endif /*
          I_convQllcOperLargestSDLC 
        */

#ifdef I_convQllcOperLargestLLC2
    case I_convQllcOperLargestLLC2:
	dp = &data->convQllcOperLargestLLC2;
	break;
#endif /*
          I_convQllcOperLargestLLC2 
        */

#ifdef I_convQllcOperLsIfIndex
    case I_convQllcOperLsIfIndex:
	dp = &data->convQllcOperLsIfIndex;
	break;
#endif /*
          I_convQllcOperLsIfIndex 
        */

#ifdef I_convQllcOperLsChIndex
    case I_convQllcOperLsChIndex:
	dp = &data->convQllcOperLsChIndex;
	break;
#endif /*
          I_convQllcOperLsChIndex 
        */

#ifdef I_convQllcOperLSDsap
    case I_convQllcOperLSDsap:
	dp = &data->convQllcOperLSDsap;
	break;
#endif /*
          I_convQllcOperLSDsap 
        */

#ifdef I_convQllcOperLSSsap
    case I_convQllcOperLSSsap:
	dp = &data->convQllcOperLSSsap;
	break;
#endif /*
          I_convQllcOperLSSsap 
        */

#ifdef I_convQllcOperLSXid
    case I_convQllcOperLSXid:
	dp = MakeOctetString(data->convQllcOperLSXid->octet_ptr, data->convQllcOperLSXid->length);
	break;
#endif /*
          I_convQllcOperLSXid 
        */

#ifdef I_convQllcOperLsLciVcIndex
    case I_convQllcOperLsLciVcIndex:
       dp = (void *) (&data->convQllcOperLsLciVcIndex);
       break;
#endif /* I_convQllcOperLsLciVcIndex */


    default:
	return ((VarBind *) NULL);

    }				       /*
				          switch 
				        */ 
   return (MakeVarBind(object, &inst, dp));

}

convQllcAdminEntry_t *
k_convQllcAdminEntry_get (
     int serialNum,
     ContextInfo *contextInfo,
     int nominator,
     int searchType,
     OctetString *convQllcAdminVirtualMac)
{
    static convQllcAdminEntry_t convQllcAdminEntryData;
    static uchar xidData[LNX_XID_SIZE];
    static OctetString xid = {xidData, LNX_XID_SIZE};
    lnxtype* lnx = GetLciFromIndex(searchType, convQllcAdminVirtualMac);

    if (lnx == 0)
       return 0;
   
    convQllcAdminEntryData.convQllcAdminVirtualMac = &snmpMac;
    ieee_copy(lnx->vmac_addr, macAddress);

    convQllcAdminEntryData.convQllcAdminConversionType = 
         GetConversionType(lnx);
         
    convQllcAdminEntryData.convQllcAdminSdlcAdd = 0;
       
    convQllcAdminEntryData.convQllcAdminPartner = &partnerMac;

    if (lnx->configured_prtnr){
       ieee_copy(lnx->prtnr, macPartner);
    }
    else
       ieee_zero(macPartner);
    convQllcAdminEntryData.convQllcAdminThisRing = lnx->this_ring;
    convQllcAdminEntryData.convQllcAdminBridgeNum = lnx->bridge_num;
    convQllcAdminEntryData.convQllcAdminTargetRing = lnx->target_ring;
    
    convQllcAdminEntryData.convQllcAdminLargestSDLC = 0;
    convQllcAdminEntryData.convQllcAdminLargestLLC2 = 0;
    if (lnx->llc){
       convQllcAdminEntryData.convQllcAdminLargestLLC2 = lnx->lnx_net_maxbtu;
    }
    else if (lnx->sdlcp){
       convQllcAdminEntryData.convQllcAdminLargestSDLC = lnx->lnx_net_maxbtu;
    }
    convQllcAdminEntryData.convQllcAdminLSDsap = lnx->dsap;
    convQllcAdminEntryData.convQllcAdminLSSsap = lnx->ssap;
    convQllcAdminEntryData.convQllcAdminLSXid = &xid;
    if (lnx->xid_valid){
       memcpy(xidData, lnx->xid, LNX_XID_SIZE);
    }
    else
       memset(xidData, 0, LNX_XID_SIZE);

    return (&convQllcAdminEntryData);
}
#ifdef SETS 

int
k_convQllcAdminEntry_set (
     convQllcAdminEntry_t *data,
     ContextInfo *contextInfo,
     int function)
{

    return (GEN_ERROR);
}
#endif /*
          SETS 
        */ 

convQllcOperEntry_t *
k_convQllcOperEntry_get (
     int serialNum,
     ContextInfo *contextInfo,
     int nominator,
     int searchType,
     OctetString *convQllcOperVirtualMac)
{
    static convQllcOperEntry_t convQllcOperEntryData;
    static uchar xidData[LNX_XID_SIZE];
    static OctetString xid = {xidData, LNX_XID_SIZE};
    static convState[] = {
          D_convQllcOperLnxState_lnxDisconnect,
          D_convQllcOperLnxState_lnxDwQllc,
          D_convQllcOperLnxState_lnxAwQllcPri,
          D_convQllcOperLnxState_lnxAwNetQllcSec,
          D_convQllcOperLnxState_lnxNetContactPending,
          D_convQllcOperLnxState_lnxDwNet,
          D_convQllcOperLnxState_lnxAwNet,
          D_convQllcOperLnxState_lnxAwQllcSec,
          D_convQllcOperLnxState_lnxAwConnect};

    lcitype* lci;
    lnxtype* lnx = GetLciFromIndex(searchType, convQllcOperVirtualMac);

    if (lnx == 0)
       return 0;

    convQllcOperEntryData.convQllcOperVirtualMac = &snmpMac;
    ieee_copy(lnx->vmac_addr, macAddress);
    convQllcOperEntryData.convQllcOperConversionType = 
         GetConversionType(lnx);
         
    convQllcOperEntryData.convQllcOperSdlcAdd = 0;
       
    convQllcOperEntryData.convQllcOperLnxState = 
          convState[lnx->lnx_state];
    
    convQllcOperEntryData.convQllcOperPartner = &partnerMac;
    
    if (lnx->configured_prtnr){
       ieee_copy(lnx->prtnr, macPartner);
    }
    else
       ieee_zero(macPartner);

    convQllcOperEntryData.convQllcOperThisRing = lnx->this_ring;
    convQllcOperEntryData.convQllcOperBridgeNum = lnx->bridge_num;
    convQllcOperEntryData.convQllcOperTargetRing = lnx->target_ring;
    
    convQllcOperEntryData.convQllcOperLargestSDLC = 0;
    convQllcOperEntryData.convQllcOperLargestLLC2 = 0;
    if (lnx->llc){
       convQllcOperEntryData.convQllcOperLargestLLC2 = lnx->lnx_net_maxbtu;
    }
    else if (lnx->sdlcp){
       convQllcOperEntryData.convQllcOperLargestSDLC = lnx->lnx_net_maxbtu;
    }
    /* Find the IfIndex regardless if qllc defined */

    convQllcOperEntryData.convQllcOperLsIfIndex = lnx->idb->hwptr->snmp_if_index;
    if (lnx->qllc && (lci = lnx->qllc->lci) != 0) {
       convQllcOperEntryData.convQllcOperLsLciVcIndex = lci->lci_lci;
    }
    else
       convQllcOperEntryData.convQllcOperLsLciVcIndex = 0;

    convQllcOperEntryData.convQllcOperLSDsap = lnx->dsap;
    convQllcOperEntryData.convQllcOperLSSsap = lnx->ssap;
    convQllcOperEntryData.convQllcOperLSXid = &xid;
    if (lnx->xid_valid){
       memcpy(xidData, lnx->xid, LNX_XID_SIZE);
    }
    else
       memset(xidData, 0, LNX_XID_SIZE);

    return (&convQllcOperEntryData);
}


/*
 **********************************************************************
 *
 * KERNEL CODE begins here.  Above is all generated by SNMP Research
 * compiler.  Below code does the real work in getting the router
 * information.  
 *
 * First come the utility helper routines.
 *
 **********************************************************************
 */

static lnxtype* GetLciFromIndex(int searchType, OctetString*  macAddr)
{
    return (searchType == NEXT)? 
       LnxGetNext(macAddr->octet_ptr): lnx_by_macaddr(macAddr->octet_ptr);
}


static int GetConversionType(lnxtype* lnx)
{
   
   if (lnx->llc)
      return D_convQllcAdminConversionType_llc;
      
   if (lnx->sdlcp)
      return D_convQllcAdminConversionType_sdlc;

   if (lnx->lnx_lak_enable)
      return D_convQllcAdminConversionType_localAck;
      
   return D_convQllcAdminConversionType_unknown;      /* dont know */
}

extern lnxtype		*lnx_hash_table[LNX_HASH_SIZE];

static lnxtype* LnxGetNext(uchar* macAddr)
{
   int n;
   static uchar maxMacAddr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
   uchar* curMacAddr = maxMacAddr;

   lnxtype* bestLnx = 0;
   lnxtype* lnx;

   for (n = 0; n < LNX_HASH_SIZE; n++){
      for (lnx = lnx_hash_table[n]; lnx; lnx = lnx->next_hash) {
         if ((ieee_compare(lnx->vmac_addr, macAddr) >= 0) &&
              ieee_compare(curMacAddr, lnx->vmac_addr) >= 0){
                 curMacAddr = lnx->vmac_addr;
                 bestLnx = lnx;
         }
      }
   }
   return bestLnx;
}
         
            
      
