/* $Id: sr_tbmib.c,v 3.8.18.9 1996/08/26 15:13:00 ppearce Exp $
 * $Source: /release/112/cvs/Xsys/srt/sr_tbmib.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * This is rfc1493
 *
 * April 1994, Kenny Roberts (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1994-1997 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_tbmib.c,v $
 * Revision 3.8.18.9  1996/08/26  15:13:00  ppearce
 * CSCdi66582:  Implement SRB vector table to cut size of SRB_CORE subsys
 * Branch: California_branch
 *
 * Revision 3.8.18.8  1996/08/13  02:24:55  gstovall
 * CSCdi39484:  Giant packets output on ethernet interface
 * Branch: California_branch
 * Make sure we drop giants, even if they are just a wee bit too big.
 *
 * Revision 3.8.18.7  1996/07/09  06:06:01  ppearce
 * CSCdi59527: inlines waste code space
 * Branch: California_branch
 *   Just say "no" to inline abuse - SRB subblock inlines removed
 *
 * Revision 3.8.18.6  1996/07/03  20:43:59  thille
 * CSCdi61860: Implement Jeffs glass of slim-fast for snmp
 * Branch: California_branch
 * Take hunk of common code from many mib files, make it a procedure in
 * snmp_util.c and call it from the mibs.  Save 1640 bytes.
 *
 * Revision 3.8.18.5  1996/07/01  18:46:36  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.8.18.4  1996/05/17  12:14:16  ppearce
 * Merge IbuMod into Calif
 *
 * Revision 3.8.4.3  1996/05/06  00:01:48  ppearce
 * Sync to IbuMod_Calif_baseline_960504
 *
 * Revision 3.8.4.2  1996/04/26  15:23:39  ppearce
 * IBU modularity - SRB subblock (part 1)
 * Branch: IbuMod_Calif_branch
 *
 * Revision 3.8.4.1  1996/04/03  21:59:46  ppearce
 * Sync to IbuMod_Calif_baseline_960402
 *
 * Revision 3.8.18.3  1996/05/07  06:27:10  jjohnson
 * CSCdi56718:  spurious access when retrieving dot1dStpRootPort
 * Branch: California_branch
 *
 * Revision 3.8.18.2  1996/04/19  17:48:28  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.8.18.1  1996/03/18  22:11:17  gstovall
 * Branch: California_branch
 * Elvis has left the building.  He headed out to California, and took the
 * port ready changes with him.
 *
 * Revision 3.7.2.3  1996/03/13  02:02:35  dstine
 * Branch: DeadKingOnAThrone_branch
 *         - commit IDB cleanups
 *
 * Revision 3.7.2.2  1996/03/07  10:51:26  mdb
 * Branch: DeadKingOnAThrone_branch
 * cisco and ANSI/POSIX libraries.
 *
 * Revision 3.7.2.1  1996/02/20  18:49:32  dstine
 * Branch: DeadKingOnAThrone_branch
 *           Sync from DeadKingOnAThrone_baseline_960122 to
 *                     DeadKingOnAThrone_baseline_960213
 *
 * Revision 3.8  1996/02/08  23:00:55  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.7  1996/01/22  07:16:45  mdb
 * CSCdi47065:  misuse of NULL macro in IOS sources
 *
 * Revision 3.6  1996/01/18  15:53:12  anke
 * CSCdi46969:  Change empty req and/or seq strings in SUBSYS_HEADERs to
 *              NULL
 *              Five bytes saved is five bytes earned
 *
 * Revision 3.5  1996/01/11  01:09:35  snyder
 * CSCdi46677:  dot1dBaseBridgeAddress returns Fs instead of unique addr
 *              needs to consider more than SBE interfaces
 *
 * Revision 3.4  1995/12/14  08:28:06  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.3  1995/11/17  18:56:49  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.2  1995/11/17  00:42:45  gstovall
 * Ladies and gentlemen, I introduce to you, the port ready commit.
 *
 * Revision 3.1  1995/11/09  13:32:23  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.3  1995/07/17  07:34:34  bchan
 * CSCdi34760:  Ifindex usage incorrect
 *
 * Revision 2.2  1995/06/28  09:31:42  smackie
 * Repair widespread subsystem header braindamage. (CSCdi23568)
 *
 *   o Fix subsystem entry points to be foo(subsystype *) not foo(void)
 *   o Repair nonsensical and redundant subsystem sequences
 *   o Use NULL where no property is required
 *
 * Revision 2.1  1995/06/07  23:02:14  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

#define MAXBUFSIZE 90   /* figure real later */

/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include "subsys.h"
#include "../snmp/snmp_api.h"
#include <ciscolib.h>

#include "sr_tbmib.h"
#include "sr_tbmib-mib.h"

#include "interface_private.h"
#include "packet.h"
#include "../if/ether.h"
#include "span.h"
#include "bridge.h"
#include "srb_core.h"
#include "srb_core_registry.h"


static uchar largest_tr_macaddr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
static uchar zero_macaddress[]    = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};


static uchar *dot1d_smallmacaddr (void);
static int dot1d_brports (void);
static hwidbtype * br_dot1d (long *port, int old_next);
static idbtype * br_dot1d_Idb (long *baseport, int old_next);
static spantype * br_dot1d_Span (void);
static btetype * br_dot1d_Stn (char *addr, int old_next);


void
init_tbmib (subsystype *subsys)
{
    load_mib(tbmib_OidList, tbmib_OidListNum);
    load_oid(tbmib_oid_table);
}

/*---------------------------------------------------------------------
 * Retrieve data from the dot1dBase family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
dot1dBase_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             arg;
    void           *dp;
    dot1dBase_t    *data=NULL;


    arg = snmp_scalar_instance(incoming, object, searchType);

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_dot1dBase_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_dot1dBaseBridgeAddress
      case I_dot1dBaseBridgeAddress:
	dp = MakeOctetString(data->dot1dBaseBridgeAddress->octet_ptr, data->dot1dBaseBridgeAddress->length);
	break;
#endif				       /* I_dot1dBaseBridgeAddress */

#ifdef I_dot1dBaseNumPorts
      case I_dot1dBaseNumPorts:
	dp = &data->dot1dBaseNumPorts;
	break;
#endif				       /* I_dot1dBaseNumPorts */

#ifdef I_dot1dBaseType
      case I_dot1dBaseType:
	dp = &data->dot1dBaseType;
	break;
#endif				       /* I_dot1dBaseType */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the dot1dBasePortEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
dot1dBasePortEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    dot1dBasePortEntry_t *data=NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            dot1dBasePort;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &dot1dBasePort, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_dot1dBasePortEntry_get(serialNum, contextInfo, arg, searchType, dot1dBasePort)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->dot1dBasePort;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_dot1dBasePort
      case I_dot1dBasePort:
	dp = &data->dot1dBasePort;
	break;
#endif				       /* I_dot1dBasePort */

#ifdef I_dot1dBasePortIfIndex
      case I_dot1dBasePortIfIndex:
	dp = &data->dot1dBasePortIfIndex;
	break;
#endif				       /* I_dot1dBasePortIfIndex */

#ifdef I_dot1dBasePortCircuit
      case I_dot1dBasePortCircuit:
	dp = MakeOID(data->dot1dBasePortCircuit->oid_ptr, data->dot1dBasePortCircuit->length);
	break;
#endif				       /* I_dot1dBasePortCircuit */

#ifdef I_dot1dBasePortDelayExceededDiscards
      case I_dot1dBasePortDelayExceededDiscards:
	dp = &data->dot1dBasePortDelayExceededDiscards;
	break;
#endif				       /* I_dot1dBasePortDelayExceededDiscards
				        *  */

#ifdef I_dot1dBasePortMtuExceededDiscards
      case I_dot1dBasePortMtuExceededDiscards:
	dp = &data->dot1dBasePortMtuExceededDiscards;
	break;
#endif				       /* I_dot1dBasePortMtuExceededDiscards */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the dot1dStp family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
dot1dStp_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             arg;
    void           *dp;
    dot1dStp_t     *data=NULL;


    arg = snmp_scalar_instance(incoming, object, searchType);

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_dot1dStp_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_dot1dStpProtocolSpecification
      case I_dot1dStpProtocolSpecification:
	dp = &data->dot1dStpProtocolSpecification;
	break;
#endif				       /* I_dot1dStpProtocolSpecification */

#ifdef I_dot1dStpPriority
      case I_dot1dStpPriority:
	dp = &data->dot1dStpPriority;
	break;
#endif				       /* I_dot1dStpPriority */

#ifdef I_dot1dStpTimeSinceTopologyChange
      case I_dot1dStpTimeSinceTopologyChange:
	dp = &data->dot1dStpTimeSinceTopologyChange;
	break;
#endif				       /* I_dot1dStpTimeSinceTopologyChange */

#ifdef I_dot1dStpTopChanges
      case I_dot1dStpTopChanges:
	dp = &data->dot1dStpTopChanges;
	break;
#endif				       /* I_dot1dStpTopChanges */

#ifdef I_dot1dStpDesignatedRoot
      case I_dot1dStpDesignatedRoot:
	dp = MakeOctetString(data->dot1dStpDesignatedRoot->octet_ptr, data->dot1dStpDesignatedRoot->length);
	break;
#endif				       /* I_dot1dStpDesignatedRoot */

#ifdef I_dot1dStpRootCost
      case I_dot1dStpRootCost:
	dp = &data->dot1dStpRootCost;
	break;
#endif				       /* I_dot1dStpRootCost */

#ifdef I_dot1dStpRootPort
      case I_dot1dStpRootPort:
	dp = &data->dot1dStpRootPort;
	break;
#endif				       /* I_dot1dStpRootPort */

#ifdef I_dot1dStpMaxAge
      case I_dot1dStpMaxAge:
	dp = &data->dot1dStpMaxAge;
	break;
#endif				       /* I_dot1dStpMaxAge */

#ifdef I_dot1dStpHelloTime
      case I_dot1dStpHelloTime:
	dp = &data->dot1dStpHelloTime;
	break;
#endif				       /* I_dot1dStpHelloTime */

#ifdef I_dot1dStpHoldTime
      case I_dot1dStpHoldTime:
	dp = &data->dot1dStpHoldTime;
	break;
#endif				       /* I_dot1dStpHoldTime */

#ifdef I_dot1dStpForwardDelay
      case I_dot1dStpForwardDelay:
	dp = &data->dot1dStpForwardDelay;
	break;
#endif				       /* I_dot1dStpForwardDelay */

#ifdef I_dot1dStpBridgeMaxAge
      case I_dot1dStpBridgeMaxAge:
	dp = &data->dot1dStpBridgeMaxAge;
	break;
#endif				       /* I_dot1dStpBridgeMaxAge */

#ifdef I_dot1dStpBridgeHelloTime
      case I_dot1dStpBridgeHelloTime:
	dp = &data->dot1dStpBridgeHelloTime;
	break;
#endif				       /* I_dot1dStpBridgeHelloTime */

#ifdef I_dot1dStpBridgeForwardDelay
      case I_dot1dStpBridgeForwardDelay:
	dp = &data->dot1dStpBridgeForwardDelay;
	break;
#endif				       /* I_dot1dStpBridgeForwardDelay */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the dot1dStp data object.
 *---------------------------------------------------------------------*/
void
dot1dStp_free(dot1dStp_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after dot1dStp set/undo
 *---------------------------------------------------------------------*/
static int
dot1dStp_cleanup(doList_t *trash)
{
    dot1dStp_free(trash->data);
#ifdef SR_SNMPv2
    dot1dStp_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
dot1dStp_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    /*VarBind        *vb = (VarBind *) NULL;*/
    int             found;
    /*int             carry = 0;
    dot1dStp_t     *dot1dStp;*/

    /*
     * Validate the object instance: 1) It must be of length 1  2) and the
     * instance must be 0.
     */
    if (instLength != 1 || incoming->oid_ptr[incoming->length - 1] != 0) {
	return (NO_CREATION_ERROR);
    }
    found = 0;

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(dot1dStp_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(dot1dStp_t));

	dp->setMethod = dot1dStp_set;
	dp->cleanupMethod = dot1dStp_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

    }
    switch (object->nominator) {

#ifdef I_dot1dStpPriority
      case I_dot1dStpPriority:

	if (value->sl_value > 65535)
	    return(WRONG_VALUE_ERROR);	

	SET_VALID(I_dot1dStpPriority, ((dot1dStp_t *) (dp->data))->valid);

	((dot1dStp_t *) (dp->data))->dot1dStpPriority = value->sl_value;
	break;
#endif				       /* I_dot1dStpPriority */

#ifdef I_dot1dStpBridgeMaxAge
      case I_dot1dStpBridgeMaxAge:

	if (! ( (value->sl_value % 100)==0 && value->sl_value >= 600 
		&& value->sl_value <= 4000))
	    return(WRONG_VALUE_ERROR);	

	SET_VALID(I_dot1dStpBridgeMaxAge, ((dot1dStp_t *) (dp->data))->valid);

	((dot1dStp_t *) (dp->data))->dot1dStpBridgeMaxAge = value->sl_value;
	break;
#endif				       /* I_dot1dStpBridgeMaxAge */

#ifdef I_dot1dStpBridgeHelloTime
      case I_dot1dStpBridgeHelloTime:

	if (! ( (value->sl_value % 100)==0 && value->sl_value >= 100 
		&& value->sl_value <= 1000))
	    return(WRONG_VALUE_ERROR);	

	SET_VALID(I_dot1dStpBridgeHelloTime, ((dot1dStp_t *) (dp->data))->valid);

	((dot1dStp_t *) (dp->data))->dot1dStpBridgeHelloTime = value->sl_value;
	break;
#endif				       /* I_dot1dStpBridgeHelloTime */

#ifdef I_dot1dStpBridgeForwardDelay
      case I_dot1dStpBridgeForwardDelay:

	if (! ( (value->sl_value % 100)==0 && value->sl_value >= 400 
		&& value->sl_value <= 3000))
	    return(WRONG_VALUE_ERROR);	

	SET_VALID(I_dot1dStpBridgeForwardDelay, ((dot1dStp_t *) (dp->data))->valid);

	((dot1dStp_t *) (dp->data))->dot1dStpBridgeForwardDelay = value->sl_value;
	break;
#endif				       /* I_dot1dStpBridgeForwardDelay */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in dot1dStp_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
dot1dStp_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_dot1dStp_set((dot1dStp_t *) (doCur->data),
			   contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the dot1dStpPortEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
dot1dStpPortEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    dot1dStpPortEntry_t *data=NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            dot1dStpPort;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &dot1dStpPort, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_dot1dStpPortEntry_get(serialNum, contextInfo, arg, searchType, dot1dStpPort)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->dot1dStpPort;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_dot1dStpPort
      case I_dot1dStpPort:
	dp = &data->dot1dStpPort;
	break;
#endif				       /* I_dot1dStpPort */

#ifdef I_dot1dStpPortPriority
      case I_dot1dStpPortPriority:
	dp = &data->dot1dStpPortPriority;
	break;
#endif				       /* I_dot1dStpPortPriority */

#ifdef I_dot1dStpPortState
      case I_dot1dStpPortState:
	dp = &data->dot1dStpPortState;
	break;
#endif				       /* I_dot1dStpPortState */

#ifdef I_dot1dStpPortEnable
      case I_dot1dStpPortEnable:
	dp = &data->dot1dStpPortEnable;
	break;
#endif				       /* I_dot1dStpPortEnable */

#ifdef I_dot1dStpPortPathCost
      case I_dot1dStpPortPathCost:
	dp = &data->dot1dStpPortPathCost;
	break;
#endif				       /* I_dot1dStpPortPathCost */

#ifdef I_dot1dStpPortDesignatedRoot
      case I_dot1dStpPortDesignatedRoot:
	dp = MakeOctetString(data->dot1dStpPortDesignatedRoot->octet_ptr, data->dot1dStpPortDesignatedRoot->length);
	break;
#endif				       /* I_dot1dStpPortDesignatedRoot */

#ifdef I_dot1dStpPortDesignatedCost
      case I_dot1dStpPortDesignatedCost:
	dp = &data->dot1dStpPortDesignatedCost;
	break;
#endif				       /* I_dot1dStpPortDesignatedCost */

#ifdef I_dot1dStpPortDesignatedBridge
      case I_dot1dStpPortDesignatedBridge:
	dp = MakeOctetString(data->dot1dStpPortDesignatedBridge->octet_ptr, data->dot1dStpPortDesignatedBridge->length);
	break;
#endif				       /* I_dot1dStpPortDesignatedBridge */

#ifdef I_dot1dStpPortDesignatedPort
      case I_dot1dStpPortDesignatedPort:
	dp = MakeOctetString(data->dot1dStpPortDesignatedPort->octet_ptr, data->dot1dStpPortDesignatedPort->length);
	break;
#endif				       /* I_dot1dStpPortDesignatedPort */

#ifdef I_dot1dStpPortForwardTransitions
      case I_dot1dStpPortForwardTransitions:
	dp = &data->dot1dStpPortForwardTransitions;
	break;
#endif				       /* I_dot1dStpPortForwardTransitions */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the dot1dStpPortEntry data object.
 *---------------------------------------------------------------------*/
void
dot1dStpPortEntry_free(dot1dStpPortEntry_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after dot1dStpPortEntry set/undo
 *---------------------------------------------------------------------*/
static int
dot1dStpPortEntry_cleanup(doList_t *trash)
{
    dot1dStpPortEntry_free(trash->data);
#ifdef SR_SNMPv2
    dot1dStpPortEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
dot1dStpPortEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    /*VarBind        *vb = (VarBind *) NULL;*/
    int             found;
    int             carry = 0;
    dot1dStpPortEntry_t *dot1dStpPortEntry;
    long            dot1dStpPort;

    /*
     * Validate the object instance
     * 
     */
    if (instLength != 1) {
	return NO_CREATION_ERROR;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &dot1dStpPort, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    dot1dStpPortEntry = k_dot1dStpPortEntry_get(-1, contextInfo, object->nominator, EXACT, dot1dStpPort);

#ifndef dot1dStpPortEntry_READ_CREATE

    if (dot1dStpPortEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* dot1dStpPortEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == dot1dStpPortEntry_set) &&
	    (((dot1dStpPortEntry_t *) (dp->data)) != NULL) &&
	    (((dot1dStpPortEntry_t *) (dp->data))->dot1dStpPort == dot1dStpPort)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(dot1dStpPortEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(dot1dStpPortEntry_t));

	dp->setMethod = dot1dStpPortEntry_set;
	dp->cleanupMethod = dot1dStpPortEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_dot1dStpPort, ((dot1dStpPortEntry_t *) (dp->data))->valid);
	((dot1dStpPortEntry_t *) (dp->data))->dot1dStpPort = dot1dStpPort;

#ifdef dot1dStpPortEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (dot1dStpPortEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, dot1dStpPortEntry, sizeof(dot1dStpPortEntry_t));

	    SET_ALL_VALID(((dot1dStpPortEntry_t *) (dp->data))->valid);

	} else {


	    /* Fill in default values here */


	}
#endif				       /* dot1dStpPortEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_dot1dStpPortPriority
      case I_dot1dStpPortPriority:

	if (value->sl_value > 255)
	    return(WRONG_VALUE_ERROR);	

	SET_VALID(I_dot1dStpPortPriority, ((dot1dStpPortEntry_t *) (dp->data))->valid);

	((dot1dStpPortEntry_t *) (dp->data))->dot1dStpPortPriority = value->sl_value;
	break;
#endif				       /* I_dot1dStpPortPriority */

#ifdef I_dot1dStpPortEnable
      case I_dot1dStpPortEnable:

	if ((value->sl_value != D_dot1dStpPortEnable_enabled) &&
		(value->sl_value != D_dot1dStpPortEnable_disabled))
	    return(WRONG_VALUE_ERROR);

	SET_VALID(I_dot1dStpPortEnable, ((dot1dStpPortEntry_t *) (dp->data))->valid);

	((dot1dStpPortEntry_t *) (dp->data))->dot1dStpPortEnable = value->sl_value;
	break;
#endif				       /* I_dot1dStpPortEnable */

#ifdef I_dot1dStpPortPathCost
      case I_dot1dStpPortPathCost:

	if (value->sl_value < 1 || value->sl_value > 65535)
	    return(WRONG_VALUE_ERROR);	

	SET_VALID(I_dot1dStpPortPathCost, ((dot1dStpPortEntry_t *) (dp->data))->valid);

	((dot1dStpPortEntry_t *) (dp->data))->dot1dStpPortPathCost = value->sl_value;
	break;
#endif				       /* I_dot1dStpPortPathCost */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in dot1dStpPortEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
dot1dStpPortEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_dot1dStpPortEntry_set((dot1dStpPortEntry_t *) (doCur->data),
				    contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the dot1dTp family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
dot1dTp_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             arg;
    void           *dp;
    dot1dTp_t      *data=NULL;


    arg = snmp_scalar_instance(incoming, object, searchType);

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_dot1dTp_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_dot1dTpLearnedEntryDiscards
      case I_dot1dTpLearnedEntryDiscards:
	dp = &data->dot1dTpLearnedEntryDiscards;
	break;
#endif				       /* I_dot1dTpLearnedEntryDiscards */

#ifdef I_dot1dTpAgingTime
      case I_dot1dTpAgingTime:
	dp = &data->dot1dTpAgingTime;
	break;
#endif				       /* I_dot1dTpAgingTime */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the dot1dTp data object.
 *---------------------------------------------------------------------*/
void
dot1dTp_free(dot1dTp_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after dot1dTp set/undo
 *---------------------------------------------------------------------*/
static int
dot1dTp_cleanup(doList_t *trash)
{
    dot1dTp_free(trash->data);
#ifdef SR_SNMPv2
    dot1dTp_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
dot1dTp_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    /*VarBind        *vb = (VarBind *) NULL;*/
    int             found;
    /*int             carry = 0;
    dot1dTp_t      *dot1dTp;*/

    /*
     * Validate the object instance: 1) It must be of length 1  2) and the
     * instance must be 0.
     */
    if (instLength != 1 || incoming->oid_ptr[incoming->length - 1] != 0) {
	return (NO_CREATION_ERROR);
    }
    found = 0;

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(dot1dTp_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(dot1dTp_t));

	dp->setMethod = dot1dTp_set;
	dp->cleanupMethod = dot1dTp_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

    }
    switch (object->nominator) {

#ifdef I_dot1dTpAgingTime
      case I_dot1dTpAgingTime:

	if (value->sl_value < 10 || value->sl_value > 1000000)
	    return(WRONG_VALUE_ERROR);	

	SET_VALID(I_dot1dTpAgingTime, ((dot1dTp_t *) (dp->data))->valid);

	((dot1dTp_t *) (dp->data))->dot1dTpAgingTime = value->sl_value;
	break;
#endif				       /* I_dot1dTpAgingTime */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in dot1dTp_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
dot1dTp_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_dot1dTp_set((dot1dTp_t *) (doCur->data),
			  contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the dot1dTpFdbEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
dot1dTpFdbEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    dot1dTpFdbEntry_t *data=NULL;
    unsigned long   buffer[MAXBUFSIZE];
    OID             inst;
    int             carry;
    int             i;
    OctetString    *dot1dTpFdbAddress;
    int             dot1dTpFdbAddress_offset;
    int             index;
    int             final_index;

    dot1dTpFdbAddress_offset = object->oid.length;
    final_index = dot1dTpFdbAddress_offset + 6;

    if (searchType == EXACT) {
	if (instLength != final_index) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToFixedOctetString(incoming, dot1dTpFdbAddress_offset, &dot1dTpFdbAddress, searchType, &carry, 6)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_dot1dTpFdbEntry_get(serialNum, contextInfo, arg, searchType, dot1dTpFdbAddress)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	for (i = 0; i < data->dot1dTpFdbAddress->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->dot1dTpFdbAddress->octet_ptr[i];
	}

	inst.length = index;
    }

    if (dot1dTpFdbAddress != NULL) {
	FreeOctetString(dot1dTpFdbAddress);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_dot1dTpFdbAddress
      case I_dot1dTpFdbAddress:
	dp = MakeOctetString(data->dot1dTpFdbAddress->octet_ptr, data->dot1dTpFdbAddress->length);
	break;
#endif				       /* I_dot1dTpFdbAddress */

#ifdef I_dot1dTpFdbPort
      case I_dot1dTpFdbPort:
	dp = &data->dot1dTpFdbPort;
	break;
#endif				       /* I_dot1dTpFdbPort */

#ifdef I_dot1dTpFdbStatus
      case I_dot1dTpFdbStatus:
	dp = &data->dot1dTpFdbStatus;
	break;
#endif				       /* I_dot1dTpFdbStatus */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the dot1dTpPortEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
dot1dTpPortEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    dot1dTpPortEntry_t *data=NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            dot1dTpPort;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &dot1dTpPort, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_dot1dTpPortEntry_get(serialNum, contextInfo, arg, searchType, dot1dTpPort)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->dot1dTpPort;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_dot1dTpPort
      case I_dot1dTpPort:
	dp = &data->dot1dTpPort;
	break;
#endif				       /* I_dot1dTpPort */

#ifdef I_dot1dTpPortMaxInfo
      case I_dot1dTpPortMaxInfo:
	dp = &data->dot1dTpPortMaxInfo;
	break;
#endif				       /* I_dot1dTpPortMaxInfo */

#ifdef I_dot1dTpPortInFrames
      case I_dot1dTpPortInFrames:
	dp = &data->dot1dTpPortInFrames;
	break;
#endif				       /* I_dot1dTpPortInFrames */

#ifdef I_dot1dTpPortOutFrames
      case I_dot1dTpPortOutFrames:
	dp = &data->dot1dTpPortOutFrames;
	break;
#endif				       /* I_dot1dTpPortOutFrames */

#ifdef I_dot1dTpPortInDiscards
      case I_dot1dTpPortInDiscards:
	dp = &data->dot1dTpPortInDiscards;
	break;
#endif				       /* I_dot1dTpPortInDiscards */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the dot1dStaticEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
dot1dStaticEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    dot1dStaticEntry_t *data=NULL;
    unsigned long   buffer[MAXBUFSIZE];
    OID             inst;
    int             carry;
    int             i;
    OctetString    *dot1dStaticAddress;
    int             dot1dStaticAddress_offset;
    long            dot1dStaticReceivePort;
    int             dot1dStaticReceivePort_offset;
    int             index;
    int             final_index;

    dot1dStaticAddress_offset = object->oid.length;
    dot1dStaticReceivePort_offset = dot1dStaticAddress_offset + 6;
    final_index = dot1dStaticReceivePort_offset + 1;

    if (searchType == EXACT) {
	if (instLength != final_index) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, dot1dStaticReceivePort_offset, &dot1dStaticReceivePort, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToFixedOctetString(incoming, dot1dStaticAddress_offset, &dot1dStaticAddress, searchType, &carry, 6)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_dot1dStaticEntry_get(serialNum, contextInfo, arg, searchType, dot1dStaticAddress, dot1dStaticReceivePort)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	for (i = 0; i < data->dot1dStaticAddress->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->dot1dStaticAddress->octet_ptr[i];
	}

	inst.oid_ptr[index++] = (unsigned long) data->dot1dStaticReceivePort;
	inst.length = index;
    }

    if (dot1dStaticAddress != NULL) {
	FreeOctetString(dot1dStaticAddress);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_dot1dStaticAddress
      case I_dot1dStaticAddress:
	dp = MakeOctetString(data->dot1dStaticAddress->octet_ptr, data->dot1dStaticAddress->length);
	break;
#endif				       /* I_dot1dStaticAddress */

#ifdef I_dot1dStaticReceivePort
      case I_dot1dStaticReceivePort:
	dp = &data->dot1dStaticReceivePort;
	break;
#endif				       /* I_dot1dStaticReceivePort */

#ifdef I_dot1dStaticAllowedToGoTo
      case I_dot1dStaticAllowedToGoTo:
	dp = MakeOctetString(data->dot1dStaticAllowedToGoTo->octet_ptr, data->dot1dStaticAllowedToGoTo->length);
	break;
#endif				       /* I_dot1dStaticAllowedToGoTo */

#ifdef I_dot1dStaticStatus
      case I_dot1dStaticStatus:
	dp = &data->dot1dStaticStatus;
	break;
#endif				       /* I_dot1dStaticStatus */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the dot1dStaticEntry data object.
 *---------------------------------------------------------------------*/
void
dot1dStaticEntry_free(dot1dStaticEntry_t *data)
{
    if (data != NULL) {
	if (data->dot1dStaticAddress != NULL) {
	    FreeOctetString(data->dot1dStaticAddress);
	}
	if (data->dot1dStaticAllowedToGoTo != NULL) {
	    FreeOctetString(data->dot1dStaticAllowedToGoTo);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after dot1dStaticEntry set/undo
 *---------------------------------------------------------------------*/
static int
dot1dStaticEntry_cleanup(doList_t *trash)
{
    dot1dStaticEntry_free(trash->data);
#ifdef SR_SNMPv2
    dot1dStaticEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
dot1dStaticEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    /*VarBind        *vb = (VarBind *) NULL;*/
    int             found;
    int             carry = 0;
    dot1dStaticEntry_t *dot1dStaticEntry;
    OctetString    *dot1dStaticAddress;
    int             dot1dStaticAddress_offset;
    long            dot1dStaticReceivePort;
    int             dot1dStaticReceivePort_offset;
    int             final_index;

    /*
     * Validate the object instance
     * 
     */
    dot1dStaticAddress_offset = object->oid.length;
    dot1dStaticReceivePort_offset = dot1dStaticAddress_offset + 6;
    final_index = dot1dStaticReceivePort_offset + 1;

    if (instLength != final_index) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToFixedOctetString(incoming, dot1dStaticAddress_offset, &dot1dStaticAddress, EXACT, &carry, 6)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, dot1dStaticReceivePort_offset, &dot1dStaticReceivePort, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    dot1dStaticEntry = k_dot1dStaticEntry_get(-1, contextInfo, object->nominator, EXACT, dot1dStaticAddress, dot1dStaticReceivePort);

#ifndef dot1dStaticEntry_READ_CREATE

    if (dot1dStaticEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* dot1dStaticEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == dot1dStaticEntry_set) &&
	    (((dot1dStaticEntry_t *) (dp->data)) != NULL) &&
	    (((dot1dStaticEntry_t *) (dp->data))->dot1dStaticAddress == dot1dStaticAddress) &&
	    (((dot1dStaticEntry_t *) (dp->data))->dot1dStaticReceivePort == dot1dStaticReceivePort)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(dot1dStaticEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(dot1dStaticEntry_t));

	dp->setMethod = dot1dStaticEntry_set;
	dp->cleanupMethod = dot1dStaticEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_dot1dStaticAddress, ((dot1dStaticEntry_t *) (dp->data))->valid);
	((dot1dStaticEntry_t *) (dp->data))->dot1dStaticAddress = dot1dStaticAddress;

	SET_VALID(I_dot1dStaticReceivePort, ((dot1dStaticEntry_t *) (dp->data))->valid);
	((dot1dStaticEntry_t *) (dp->data))->dot1dStaticReceivePort = dot1dStaticReceivePort;

#ifdef dot1dStaticEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (dot1dStaticEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, dot1dStaticEntry, sizeof(dot1dStaticEntry_t));

	    SET_ALL_VALID(((dot1dStaticEntry_t *) (dp->data))->valid);

	    ((dot1dStaticEntry_t *) (dp->data))->dot1dStaticAddress =
		CloneOctetString(dot1dStaticEntry->dot1dStaticAddress);

	    ((dot1dStaticEntry_t *) (dp->data))->dot1dStaticAllowedToGoTo =
		CloneOctetString(dot1dStaticEntry->dot1dStaticAllowedToGoTo);

	} else {


	    /* Fill in default values here */


	}
#endif				       /* dot1dStaticEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_dot1dStaticAddress
      case I_dot1dStaticAddress:

	SET_VALID(I_dot1dStaticAddress, ((dot1dStaticEntry_t *) (dp->data))->valid);

	if (((dot1dStaticEntry_t *) (dp->data))->dot1dStaticAddress != NULL) {
	    FreeOctetString(((dot1dStaticEntry_t *) (dp->data))->dot1dStaticAddress);
	}
	((dot1dStaticEntry_t *) (dp->data))->dot1dStaticAddress =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_dot1dStaticAddress */

#ifdef I_dot1dStaticReceivePort
      case I_dot1dStaticReceivePort:

	SET_VALID(I_dot1dStaticReceivePort, ((dot1dStaticEntry_t *) (dp->data))->valid);

	((dot1dStaticEntry_t *) (dp->data))->dot1dStaticReceivePort = value->sl_value;
	break;
#endif				       /* I_dot1dStaticReceivePort */

#ifdef I_dot1dStaticAllowedToGoTo
      case I_dot1dStaticAllowedToGoTo:

	SET_VALID(I_dot1dStaticAllowedToGoTo, ((dot1dStaticEntry_t *) (dp->data))->valid);

	if (((dot1dStaticEntry_t *) (dp->data))->dot1dStaticAllowedToGoTo != NULL) {
	    FreeOctetString(((dot1dStaticEntry_t *) (dp->data))->dot1dStaticAllowedToGoTo);
	}
	((dot1dStaticEntry_t *) (dp->data))->dot1dStaticAllowedToGoTo =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_dot1dStaticAllowedToGoTo */

#ifdef I_dot1dStaticStatus
      case I_dot1dStaticStatus:

	SET_VALID(I_dot1dStaticStatus, ((dot1dStaticEntry_t *) (dp->data))->valid);

	((dot1dStaticEntry_t *) (dp->data))->dot1dStaticStatus = value->sl_value;
	break;
#endif				       /* I_dot1dStaticStatus */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in dot1dStaticEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
dot1dStaticEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_dot1dStaticEntry_set((dot1dStaticEntry_t *) (doCur->data),
				   contextInfo, doCur->state));
}

#endif				       /* SETS */




dot1dBase_t    *
k_dot1dBase_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator)
{
    static dot1dBase_t dot1dBaseData;
    static OctetString dot1dBaseBridgeAddress;

    dot1dBaseData.dot1dBaseBridgeAddress = &dot1dBaseBridgeAddress;
    dot1dBaseData.dot1dBaseBridgeAddress->octet_ptr = dot1d_smallmacaddr();
    if (dot1dBaseData.dot1dBaseBridgeAddress->octet_ptr)
	dot1dBaseData.dot1dBaseBridgeAddress->length = IEEEBYTES;
    else
	dot1dBaseData.dot1dBaseBridgeAddress->length = 0;

    dot1dBaseData.dot1dBaseNumPorts = dot1d_brports();
    dot1dBaseData.dot1dBaseType = D_dot1dBaseType_srt;

    return (&dot1dBaseData);
}

dot1dBasePortEntry_t *
k_dot1dBasePortEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            dot1dBasePort)
{
    static dot1dBasePortEntry_t dot1dBasePortEntryData;
    register hwidbtype *idb;

    idb = br_dot1d(&dot1dBasePort, searchType); 
    if (idb == NULL)
	return(NULL);

    dot1dBasePortEntryData.dot1dBasePort = idb->firstsw->if_number;
    dot1dBasePortEntryData.dot1dBasePortIfIndex = idb->snmp_if_index;
    /* dot1dBasePortCircuit not implemented */
    dot1dBasePortEntryData.dot1dBasePortCircuit = &nullOID;
    dot1dBasePortEntryData.dot1dBasePortDelayExceededDiscards = 0;
    dot1dBasePortEntryData.dot1dBasePortMtuExceededDiscards = 
		idb->span_in_bigdrop + idb->span_out_bigdrop;

    return (&dot1dBasePortEntryData);
}

dot1dStp_t     *
k_dot1dStp_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator)
{
    static dot1dStp_t dot1dStpData;
    register spantype *span;
    static OctetString dot1dStpDesignatedRoot;

    span = br_dot1d_Span();;
    if (span == NULL)
	return(NULL);

    switch (span->protocol) {
    case SPAN_PROTO_IEEE:
	dot1dStpData.dot1dStpProtocolSpecification =
		D_dot1dStpProtocolSpecification_ieee8021d;
	break;
    case SPAN_PROTO_DEC:
	dot1dStpData.dot1dStpProtocolSpecification =
		D_dot1dStpProtocolSpecification_decLb100;
	break;
    default:
	dot1dStpData.dot1dStpProtocolSpecification =
		D_dot1dStpProtocolSpecification_unknown;
	break;
    }
    dot1dStpData.dot1dStpPriority = span->priority;

   /* Determines how many seconds since the last spanning tree topology change */ 
    dot1dStpData.dot1dStpTimeSinceTopologyChange = 
        (system_uptime_seconds() - span->topology_change_start_time);	 

    dot1dStpData.dot1dStpTopChanges = span->topology_change_count;

    dot1dStpData.dot1dStpDesignatedRoot = &dot1dStpDesignatedRoot;
    dot1dStpData.dot1dStpDesignatedRoot->octet_ptr = span->designated_root;
    dot1dStpData.dot1dStpDesignatedRoot->length = IDBYTES;

    dot1dStpData.dot1dStpRootCost = span->root_path_cost;
    dot1dStpData.dot1dStpRootPort = span->root_port_id & 0xFF;
    dot1dStpData.dot1dStpMaxAge = span->max_age * 100;
    dot1dStpData.dot1dStpHelloTime = span->hello_time * 100;
    dot1dStpData.dot1dStpHoldTime = span->hold_time * 100;
    dot1dStpData.dot1dStpForwardDelay = span->forward_delay * 100;
    dot1dStpData.dot1dStpBridgeMaxAge = span->bridge_max_age * 100;
    dot1dStpData.dot1dStpBridgeHelloTime = span->bridge_hello_time * 100;
    dot1dStpData.dot1dStpBridgeForwardDelay = span->bridge_forward_delay * 100;

    return (&dot1dStpData);
}

#ifdef SETS
int
k_dot1dStp_set(
    dot1dStp_t     *data,
    ContextInfo    *contextInfo,
    int             function)
{
    register spantype *span;

    span = br_dot1d_Span();;
    if (span == NULL)
	return(GEN_ERROR);


    if (VALID(I_dot1dStpPriority, data->valid)) {
	span->priority = data->dot1dStpPriority;
	span_bridge_priority(span, span->priority);
    }

    if (VALID(I_dot1dStpBridgeMaxAge, data->valid)) {
	span->bridge_max_age = data->dot1dStpBridgeMaxAge / 100;
	if (root_bridge(span))
	   span->max_age = data->dot1dStpBridgeMaxAge / 100;
    }

    if (VALID(I_dot1dStpBridgeHelloTime, data->valid)) {
	span->bridge_hello_time = data->dot1dStpBridgeHelloTime / 100;
	if (root_bridge(span))
	   span->hello_time = data->dot1dStpBridgeHelloTime / 100;
    }

    if (VALID(I_dot1dStpBridgeForwardDelay, data->valid)) {
	span->bridge_forward_delay = data->dot1dStpBridgeForwardDelay / 100;
	if (root_bridge(span))
	   span->forward_delay = data->dot1dStpBridgeForwardDelay / 100;
    }

    return (NO_ERROR);
}

#endif				       /* SETS */

dot1dStpPortEntry_t *
k_dot1dStpPortEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            dot1dStpPort)
{
    static dot1dStpPortEntry_t dot1dStpPortEntryData;
    register idbtype *port;
    static OctetString dot1dStpPortDesignatedRoot, dot1dStpPortDesignatedPort,
	dot1dStpPortDesignatedBridge;

    port = br_dot1d_Idb(&dot1dStpPort,searchType);
    if (port == NULL)
	return(NULL);

    dot1dStpPortEntryData.dot1dStpPort = port->port_id & 0xFF;
    dot1dStpPortEntryData.dot1dStpPortPriority = port->port_id >> 8;

    switch (port->port_state) {
    case PORT_DISABLED:
	dot1dStpPortEntryData.dot1dStpPortState = D_dot1dStpPortState_disabled;
	break;
    case PORT_BLOCKING:
	dot1dStpPortEntryData.dot1dStpPortState = D_dot1dStpPortState_blocking;
	break;
    case PORT_LISTENING:
	dot1dStpPortEntryData.dot1dStpPortState = D_dot1dStpPortState_listening;
	break;
    case PORT_LEARNING:
	dot1dStpPortEntryData.dot1dStpPortState = D_dot1dStpPortState_learning;
	break;
    case PORT_FORWARDING:
	dot1dStpPortEntryData.dot1dStpPortState = 
		D_dot1dStpPortState_forwarding;
	break;
    default:
    case PORT_BROKEN:
	dot1dStpPortEntryData.dot1dStpPortState = D_dot1dStpPortState_broken;
	break;
    }

    dot1dStpPortEntryData.dot1dStpPortEnable = 
	(port->port_state == PORT_DISABLED) ? D_dot1dStpPortEnable_disabled :
	D_dot1dStpPortEnable_enabled;

    dot1dStpPortEntryData.dot1dStpPortPathCost = port->path_cost;

    dot1dStpPortEntryData.dot1dStpPortDesignatedRoot = 
	&dot1dStpPortDesignatedRoot;
    dot1dStpPortEntryData.dot1dStpPortDesignatedRoot->octet_ptr = 
	port->designated_root;
    dot1dStpPortEntryData.dot1dStpPortDesignatedRoot->length = IDBYTES;

    dot1dStpPortEntryData.dot1dStpPortDesignatedCost = port->designated_cost; 

    dot1dStpPortEntryData.dot1dStpPortDesignatedBridge =
	&dot1dStpPortDesignatedBridge;
    dot1dStpPortEntryData.dot1dStpPortDesignatedBridge->octet_ptr =
	port->designated_bridge;
    dot1dStpPortEntryData.dot1dStpPortDesignatedBridge->length = IDBYTES;

    dot1dStpPortEntryData.dot1dStpPortDesignatedPort = 
	&dot1dStpPortDesignatedPort;
    dot1dStpPortEntryData.dot1dStpPortDesignatedPort->octet_ptr = 
	(uchar *) &port->designated_port;
    dot1dStpPortEntryData.dot1dStpPortDesignatedPort->length = 2;

    dot1dStpPortEntryData.dot1dStpPortForwardTransitions = 
	port->forward_transition_count;

    return (&dot1dStpPortEntryData);
}

#ifdef SETS
int
k_dot1dStpPortEntry_set(
    dot1dStpPortEntry_t *data,
    ContextInfo    *contextInfo,
    int             function)
{
    register idbtype *port;
    ushort new_port_id;

    port = br_dot1d_Idb(&data->dot1dStpPort, EXACT);
    if (port == NULL)
	return(GEN_ERROR);

    if (VALID(I_dot1dStpPortPriority, data->valid)) {
	if (port->span_ptr) {
	    new_port_id = (data->dot1dStpPort << 8) |
		(port->port_id & 0xFF);
	    if (port->span_ptr->running) {
		span_port_priority(port->span_ptr, port, new_port_id);
	    } else {
		port->port_id = new_port_id;
	    }	
	}
    }

    if (VALID(I_dot1dStpPortEnable, data->valid)) {
	if (data->dot1dStpPortEnable == D_dot1dStpPortEnable_enabled)
	    span_port_enable(port->span_ptr, port);
	else
	    span_port_disable(port->span_ptr, port);
    }

    if (VALID(I_dot1dStpPortPathCost, data->valid)) {
	port->path_cost_explicit = TRUE;
	port->path_cost = data->dot1dStpPortPathCost;
	if (port->span_ptr->running)
	    span_path_cost(port->span_ptr);
    }

    return (NO_ERROR);
}

#endif				       /* SETS */

dot1dTp_t      *
k_dot1dTp_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator)
{
    static dot1dTp_t dot1dTpData;
    register spantype *span;

    span = br_dot1d_Span();
    if (span == NULL)
	return(NULL);

    dot1dTpData.dot1dTpLearnedEntryDiscards = span->learned_entry_discards;
    dot1dTpData.dot1dTpAgingTime = span->bridge_aging_time;

    return (&dot1dTpData);
}

#ifdef SETS
int
k_dot1dTp_set(
    dot1dTp_t      *data,
    ContextInfo    *contextInfo,
    int             function)
{
    register spantype *span;

    span = br_dot1d_Span();
    if (span == NULL)
	return(GEN_ERROR);

    if (VALID(I_dot1dTpAgingTime, data->valid)) {
	span->bridge_aging_time = data->dot1dTpAgingTime;
    }

    return (NO_ERROR);
}

#endif				       /* SETS */

dot1dTpFdbEntry_t *
k_dot1dTpFdbEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    OctetString    *dot1dTpFdbAddress)
{
    static dot1dTpFdbEntry_t dot1dTpFdbEntryData;
    static OctetString dot1dTpFdbAddress2;
    register btetype *entry;
    short fdb_status;

    entry = br_dot1d_Stn(dot1dTpFdbAddress->octet_ptr, searchType);
    if (entry == NULL || entry->bte_mac_addr.sword == NULL)
	return(NULL);

    dot1dTpFdbEntryData.dot1dTpFdbAddress = &dot1dTpFdbAddress2;
    dot1dTpFdbEntryData.dot1dTpFdbAddress->octet_ptr = (uchar *) 
	entry->bte_mac_addr.sword;
    dot1dTpFdbEntryData.dot1dTpFdbAddress->length = 6; 

    if (entry->bte_interface)
	dot1dTpFdbEntryData.dot1dTpFdbPort =
	    entry->bte_interface->port_id & 0xFF;
    else
	dot1dTpFdbEntryData.dot1dTpFdbPort = 0;

    fdb_status = entry->bte_attributes & BTE_STATIC;
    if (!fdb_status && entry->bte_interface)
	fdb_status = BTE_IFSPECIFIED;
    switch (fdb_status) {
    case BTE_IFSPECIFIED:
	dot1dTpFdbEntryData.dot1dTpFdbStatus = D_dot1dTpFdbStatus_learned;
	break;
    case BTE_STATIC:
	dot1dTpFdbEntryData.dot1dTpFdbStatus = D_dot1dTpFdbStatus_mgmt;
	break;
    case BTE_LAT:
    default:
	dot1dTpFdbEntryData.dot1dTpFdbStatus = D_dot1dTpFdbStatus_other;
	break;
    }
    return (&dot1dTpFdbEntryData);
}

dot1dTpPortEntry_t *
k_dot1dTpPortEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            dot1dTpPort)
{
    static dot1dTpPortEntry_t dot1dTpPortEntryData;
    register idbtype *port;

    port = br_dot1d_Idb(&dot1dTpPort, searchType);
    if (port == NULL)
	return(NULL);
    dot1dTpPortEntryData.dot1dTpPort = port->port_id & 0xFF;
    dot1dTpPortEntryData.dot1dTpPortMaxInfo = port->hwptr->max_buffer_size -
	port->hwptr->encsize;
    dot1dTpPortEntryData.dot1dTpPortInFrames = 
	port->hwptr->counters.inputs_fast[ACCT_PROTO_SPAN] +
	port->hwptr->counters.inputs_fast[ACCT_PROTO_BRIDGE];
    dot1dTpPortEntryData.dot1dTpPortOutFrames = 
	port->hwptr->counters.outputs_fast[ACCT_PROTO_SPAN] +
	port->hwptr->counters.outputs_fast[ACCT_PROTO_BRIDGE];
    dot1dTpPortEntryData.dot1dTpPortInDiscards = 0;

    return (&dot1dTpPortEntryData);
}

dot1dStaticEntry_t *
k_dot1dStaticEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    OctetString    *dot1dStaticAddress,
    long            dot1dStaticReceivePort)
{
#ifdef NOT_YET			
	/* not implemented yet */
    static dot1dStaticEntry_t dot1dStaticEntryData;

    dot1dStaticEntryData.dot1dStaticAddress =;
    dot1dStaticEntryData.dot1dStaticReceivePort =;
    dot1dStaticEntryData.dot1dStaticAllowedToGoTo =;
    dot1dStaticEntryData.dot1dStaticStatus =;

    return (&dot1dStaticEntryData);
#else				       /* NOT_YET */
    return (NULL);
#endif				       /* NOT_YET */
}

#ifdef SETS
int
k_dot1dStaticEntry_set(
    dot1dStaticEntry_t *data,
    ContextInfo    *contextInfo,
    int             function)
{

    return (GEN_ERROR);
}

#endif				       /* SETS */


/*
 * Finds the numerically smallest bridging address.
 */
static uchar *dot1d_smallmacaddr (void)
{

    hwidbtype   *idb;
    uchar *smallest_mac;
    spantype    *span;
    int          i;

    smallest_mac = largest_tr_macaddr;

    FOR_ALL_HWIDBS(idb) {

        if ((cmpid(zero_macaddress, idb->hardware, IEEEBYTES) != 0) && 
            (cmpid(smallest_mac,    idb->hardware, IEEEBYTES) >= 0) ) {
           smallest_mac = idb->hardware;
        }
    }

    /*
     * Use the lowest-numbered spanning tree.
     */
    for (i = 1; i < SPAN_MAXINDEX; i++) {
        span = spanarray[i];
        if (span && span->running) {
            break;
        }
    }
    if ((span != NULL) && 
        (cmpid(smallest_mac, &span->bridge_id[2], IEEEBYTES) >= 0))
        smallest_mac = &span->bridge_id[2];

    return(smallest_mac);
}

/*
 * Finds the total number of bridging ports
 */
static int dot1d_brports (void)
{

    hwidbtype *idb;
    int      count = 0;
    spantype *span;
    int i;
    list_element *l_elt;
    srb_vector_table_t *srbV_p = reg_invoke_srb_get_vector_table();

    FOR_ALL_HWIDBS_IN_LIST(HWIDBLIST_TOKEN, l_elt, idb) {
        /* count the SRB ports */
        if (srbV_p && srbV_p->srb_sb_get_thisring(idb->firstsw) != 0)
            count++;
    }

    /*
     * Use the lowest-numbered spanning tree.
     */
    for (i = 1; i < SPAN_MAXINDEX; i++) {
        span = spanarray[i];
        if (span && span->running) {
            break;
        }
    }
    if (span != NULL)
        count += span->port_count;

    return(count);
}


/*
 * get the idb for the interface of interest.
 */
static hwidbtype * br_dot1d (long *port, int old_next)
{

    register hwidbtype *idb = NULL;
    boolean next;
    srb_vector_table_t *srbV_p = reg_invoke_srb_get_vector_table();

    next = (old_next == NEXT);

    FOR_ALL_HWIDBS(idb) {
        idbtype *swidb = idb->firstsw;
        if (((*port == swidb->if_number) ||
             (next && *port <= swidb->if_number)) && 
             (((idb->status & IDB_TR)  && 
               (srbV_p && (srbV_p->srb_sb_get_thisring(swidb) !=0))) || 
              (swidb->span_ptr != NULL)))
            break;
    }
    if (idb != NULL) {
        *port = idb->firstsw->if_number;
        return(idb);
    }
    return(NULL);
}

/*
 * Validation function to locate a transparent bridging interface stucture
 */
static idbtype * br_dot1d_Idb (long *baseport, int old_next)
{
    register hwidbtype *idb = NULL;
    boolean next;

    next = (old_next == NEXT);

    FOR_ALL_HWIDBS(idb) {
        if ((((*baseport == (idb->firstsw->port_id & 0xFF)) && !next) ||
	     ((*baseport <= (idb->firstsw->port_id & 0xFF)) && next)) &&
	    (idb->firstsw->span_ptr))
	    break;
    }

    if (idb != NULL  && idb->firstsw->span_ptr != NULL) {
        *baseport  = idb->firstsw->port_id & 0xFF;
        return(idb->firstsw);
    }

    return(NULL);
}


/*
 * Validation function to locate a spanning tree stucture
 *
 * Since the standard specifies a single spanning tree structure per bridge,
 * default to the lowest-numbered one.
 */

static spantype * br_dot1d_Span (void)
{
    register spantype *span;
    int i;

    /*
     * Use the lowest-numbered spanning tree.
     */
    for (i = 1; i < SPAN_MAXINDEX; i++) {
        span = spanarray[i];
        if (span && span->running) {
	    return(span);
        }
    }
    return (NULL);
}


static btetype * br_dot1d_Stn (char *addr, int old_next)
{
    register btetype *stn = NULL;
    btetype **table = (btetype **)NULL;
    uint i;
    boolean next;

    next = (old_next == NEXT);
    /*
     * Use the forwarding table associated with the lowest-numbered
     * spanning tree.
     */
    for (i = 1; i < SPAN_MAXINDEX; i++) {
	if (spanarray[i] && spanarray[i]->running) {
	    table = spanarray[i]->bridge_tbl;
	    if (table)
		break;
	}
    }

    if (table) {
	if (next) {
	    stn = bridge_get_next_stn(addr, table);
	} else {
	    stn = bridge_get_stn(addr, table);
	}
    }

    if (stn)
	ieee_copy((uchar *) &stn->bte_mac_addr.sword[0], &addr[0]);
    
    return(stn);
}


/*
 * tbmib subsystem header
 */

#define MAJVERSION_tbmib 1
#define MINVERSION_tbmib 0
#define EDITVERSION_tbmib 0

SUBSYS_HEADER(tbmib,
              MAJVERSION_tbmib,
              MINVERSION_tbmib,
              EDITVERSION_tbmib,
              init_tbmib,
              SUBSYS_CLASS_MANAGEMENT,
              "req: tbridge",
              NULL);
      
