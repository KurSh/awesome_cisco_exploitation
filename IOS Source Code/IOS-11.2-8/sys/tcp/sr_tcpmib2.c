/* $Id: sr_tcpmib2.c,v 3.6.12.4 1996/07/06 05:57:06 thille Exp $
 * $Source: /release/112/cvs/Xsys/tcp/sr_tcpmib2.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * March 1994, Jeffrey T. Johnson (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1994-1997 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_tcpmib2.c,v $
 * Revision 3.6.12.4  1996/07/06  05:57:06  thille
 * CSCdi62136:  seq: iphost and req: iphost duplicated and waste memory
 * Branch: California_branch
 * Put copies of the strings in common_strings.c/h and reference them
 * instead of having multiple copies of the literals.  Save 660 bytes.
 *
 * Revision 3.6.12.3  1996/07/01  18:46:39  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.6.12.2  1996/06/18  01:49:04  hampton
 * Split the monolithic traffic array into smaller per-protocol traffic
 * arrays.  [CSCdi59224]
 * Branch: California_branch
 *
 * Revision 3.6.12.1  1996/04/19  17:49:28  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.6  1996/02/14  22:02:32  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.5  1996/01/22  07:29:14  mdb
 * CSCdi47065:  misuse of NULL macro in IOS sources
 *
 * Revision 3.4  1996/01/18  15:53:35  anke
 * CSCdi46969:  Change empty req and/or seq strings in SUBSYS_HEADERs to
 *              NULL
 *              Five bytes saved is five bytes earned
 *
 * Revision 3.3  1995/12/14  08:28:20  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.2  1995/11/17  18:48:21  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  13:35:34  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.4  1995/07/12  23:45:35  hampton
 * Convert TCP to fully use the passive timers macros instead of
 * referencing the system clock directly.  [CSCdi37015]
 *
 * Revision 2.3  1995/06/28 09:31:54  smackie
 * Repair widespread subsystem header braindamage. (CSCdi23568)
 *
 *   o Fix subsystem entry points to be foo(subsystype *) not foo(void)
 *   o Repair nonsensical and redundant subsystem sequences
 *   o Use NULL where no property is required
 *
 * Revision 2.2  1995/06/17  06:26:27  ahh
 * CSCdi35734:  TCP: Long overdue code reorganization
 * Separate tcp.h into public and private header files.  Shuffle functions
 * around into more logical groupings.  Rename functions to meet naming
 * conventions (say goodbye to StudlyCaps).  Delete unneeded externs.
 * Trim off old log messages.
 *
 * Revision 2.1  1995/06/07  23:05:33  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1993 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include "../ui/common_strings.h"
#include "subsys.h"
#include "../snmp/snmp_api.h"
#include "sr_tcpmib2.h"
#include "sr_tcpmib2-mib.h"
#include "sr_old_ltcpmib.h"
#include "interface_private.h"
#include "packet.h"
#include "tcp.h"
#include "tcpinternal.h"


void
init_tcpmib2 (subsystype *subsys)
{
    load_mib(tcpmib2_OidList, tcpmib2_OidListNum);
    load_oid(tcpmib2_oid_table);
    init_old_ltcpmib();
}








/*---------------------------------------------------------------------
 * Retrieve data from the tcp family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
tcp_get (
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = -1;
    void           *dp;
    tcp_t          *data = NULL;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1 and the single
     * instance element be 0.
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    switch (searchType) {
      case EXACT:
	if (instLength == 1 && incoming->oid_ptr[incoming->length - 1] == 0) {
	    arg = object->nominator;
	}
	break;

      case NEXT:
	if (instLength <= 0) {
	    arg = object->nominator;
	}
	break;

    }

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_tcp_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_tcpRtoAlgorithm
      case I_tcpRtoAlgorithm:
	dp = &data->tcpRtoAlgorithm;
	break;
#endif				       /* I_tcpRtoAlgorithm */

#ifdef I_tcpRtoMin
      case I_tcpRtoMin:
	dp = &data->tcpRtoMin;
	break;
#endif				       /* I_tcpRtoMin */

#ifdef I_tcpRtoMax
      case I_tcpRtoMax:
	dp = &data->tcpRtoMax;
	break;
#endif				       /* I_tcpRtoMax */

#ifdef I_tcpMaxConn
      case I_tcpMaxConn:
	dp = &data->tcpMaxConn;
	break;
#endif				       /* I_tcpMaxConn */

#ifdef I_tcpActiveOpens
      case I_tcpActiveOpens:
	dp = &data->tcpActiveOpens;
	break;
#endif				       /* I_tcpActiveOpens */

#ifdef I_tcpPassiveOpens
      case I_tcpPassiveOpens:
	dp = &data->tcpPassiveOpens;
	break;
#endif				       /* I_tcpPassiveOpens */

#ifdef I_tcpAttemptFails
      case I_tcpAttemptFails:
	dp = &data->tcpAttemptFails;
	break;
#endif				       /* I_tcpAttemptFails */

#ifdef I_tcpEstabResets
      case I_tcpEstabResets:
	dp = &data->tcpEstabResets;
	break;
#endif				       /* I_tcpEstabResets */

#ifdef I_tcpCurrEstab
      case I_tcpCurrEstab:
	dp = &data->tcpCurrEstab;
	break;
#endif				       /* I_tcpCurrEstab */

#ifdef I_tcpInSegs
      case I_tcpInSegs:
	dp = &data->tcpInSegs;
	break;
#endif				       /* I_tcpInSegs */

#ifdef I_tcpOutSegs
      case I_tcpOutSegs:
	dp = &data->tcpOutSegs;
	break;
#endif				       /* I_tcpOutSegs */

#ifdef I_tcpRetransSegs
      case I_tcpRetransSegs:
	dp = &data->tcpRetransSegs;
	break;
#endif				       /* I_tcpRetransSegs */

#ifdef I_tcpInErrs
      case I_tcpInErrs:
	dp = &data->tcpInErrs;
	break;
#endif				       /* I_tcpInErrs */

#ifdef I_tcpOutRsts
      case I_tcpOutRsts:
	dp = &data->tcpOutRsts;
	break;
#endif				       /* I_tcpOutRsts */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the tcpConnEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
tcpConnEntry_get (
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    tcpConnEntry_t *data = NULL;
    unsigned long   buffer[10];
    OID             inst;
    int             carry;
    unsigned long   tcpConnLocalAddress;
    long            tcpConnLocalPort;
    unsigned long   tcpConnRemAddress;
    long            tcpConnRemPort;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 10
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 10) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 9 + object->oid.length, &tcpConnRemPort, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToIP(incoming, 5 + object->oid.length, &tcpConnRemAddress, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 4 + object->oid.length, &tcpConnLocalPort, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToIP(incoming, 0 + object->oid.length, &tcpConnLocalAddress, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_tcpConnEntry_get(serialNum, contextInfo, arg, searchType, tcpConnLocalAddress, tcpConnLocalPort, tcpConnRemAddress, tcpConnRemPort)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 10;
	inst.oid_ptr[0] = (data->tcpConnLocalAddress >> 24) & 0xff;
	inst.oid_ptr[1] = (data->tcpConnLocalAddress >> 16) & 0xff;
	inst.oid_ptr[2] = (data->tcpConnLocalAddress >> 8) & 0xff;
	inst.oid_ptr[3] = (data->tcpConnLocalAddress >> 0) & 0xff;
	inst.oid_ptr[4] = data->tcpConnLocalPort;
	inst.oid_ptr[5] = (data->tcpConnRemAddress >> 24) & 0xff;
	inst.oid_ptr[6] = (data->tcpConnRemAddress >> 16) & 0xff;
	inst.oid_ptr[7] = (data->tcpConnRemAddress >> 8) & 0xff;
	inst.oid_ptr[8] = (data->tcpConnRemAddress >> 0) & 0xff;
	inst.oid_ptr[9] = data->tcpConnRemPort;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_tcpConnState
      case I_tcpConnState:
	dp = &data->tcpConnState;
	break;
#endif				       /* I_tcpConnState */

#ifdef I_tcpConnLocalAddress
      case I_tcpConnLocalAddress:
	dp = MakeOctetString((unsigned char *) &data->tcpConnLocalAddress, 4L);
	break;
#endif				       /* I_tcpConnLocalAddress */

#ifdef I_tcpConnLocalPort
      case I_tcpConnLocalPort:
	dp = &data->tcpConnLocalPort;
	break;
#endif				       /* I_tcpConnLocalPort */

#ifdef I_tcpConnRemAddress
      case I_tcpConnRemAddress:
	dp = MakeOctetString((unsigned char *) &data->tcpConnRemAddress, 4L);
	break;
#endif				       /* I_tcpConnRemAddress */

#ifdef I_tcpConnRemPort
      case I_tcpConnRemPort:
	dp = &data->tcpConnRemPort;
	break;
#endif				       /* I_tcpConnRemPort */

#ifdef I_ciscoTcpConnInBytes
      case I_ciscoTcpConnInBytes:
	dp = &data->ciscoTcpConnInBytes;
	break;
#endif				       /* I_ciscoTcpConnInBytes */

#ifdef I_ciscoTcpConnOutBytes
      case I_ciscoTcpConnOutBytes:
	dp = &data->ciscoTcpConnOutBytes;
	break;
#endif				       /* I_ciscoTcpConnOutBytes */

#ifdef I_ciscoTcpConnInPkts
      case I_ciscoTcpConnInPkts:
	dp = &data->ciscoTcpConnInPkts;
	break;
#endif				       /* I_ciscoTcpConnInPkts */

#ifdef I_ciscoTcpConnOutPkts
      case I_ciscoTcpConnOutPkts:
	dp = &data->ciscoTcpConnOutPkts;
	break;
#endif				       /* I_ciscoTcpConnOutPkts */

#ifdef I_ciscoTcpConnElapsed
      case I_ciscoTcpConnElapsed:
	dp = &data->ciscoTcpConnElapsed;
	break;
#endif				       /* I_ciscoTcpConnElapsed */

#ifdef I_ciscoTcpConnSRTT
      case I_ciscoTcpConnSRTT:
	dp = &data->ciscoTcpConnSRTT;
	break;
#endif				       /* I_ciscoTcpConnSRTT */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the tcpConnEntry data object.
 *---------------------------------------------------------------------*/
void
tcpConnEntry_free(tcpConnEntry_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after tcpConnEntry set/undo
 *---------------------------------------------------------------------*/
static int
tcpConnEntry_cleanup(doList_t *trash)
{
    tcpConnEntry_free(trash->data);
#ifdef SR_SNMPv2
    tcpConnEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Undo a previous set of the tcpConnEntry family.
 *---------------------------------------------------------------------*/
#ifdef SR_SNMPv2
int
tcpConnEntry_undo(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return UNDO_FAILED_ERROR;
}

#endif	/* SR_SNMPv2 */

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
tcpConnEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    doList_t       *dp;
    int             found;
    int             carry = 0;
    tcpConnEntry_t *tcpConnEntry;
    unsigned long   tcpConnLocalAddress;
    long            tcpConnLocalPort;
    unsigned long   tcpConnRemAddress;
    long            tcpConnRemPort;

    /*
     * Validate the object instance
     * 
     */

    if ((InstToIP(incoming, 0 + object->oid.length, &tcpConnLocalAddress, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, 4 + object->oid.length, &tcpConnLocalPort, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToIP(incoming, 5 + object->oid.length, &tcpConnRemAddress, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, 9 + object->oid.length, &tcpConnRemPort, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    tcpConnEntry = k_tcpConnEntry_get(-1, contextInfo, object->nominator, EXACT, tcpConnLocalAddress, tcpConnLocalPort, tcpConnRemAddress, tcpConnRemPort);

    if (tcpConnEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == tcpConnEntry_set) &&
	    (((tcpConnEntry_t *) (dp->data)) != NULL) &&
	    (((tcpConnEntry_t *) (dp->data))->tcpConnLocalAddress == tcpConnLocalAddress) &&
	    (((tcpConnEntry_t *) (dp->data))->tcpConnLocalPort == tcpConnLocalPort) &&
	    (((tcpConnEntry_t *) (dp->data))->tcpConnRemAddress == tcpConnRemAddress) &&
	    (((tcpConnEntry_t *) (dp->data))->tcpConnRemPort == tcpConnRemPort)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(tcpConnEntry_t))) == NULL) {
	    DPRINTF((0, "snmpd: Cannot allocate memory\n"));
	    return (GEN_ERROR);
	}
	memset(dp->data, 0, sizeof(tcpConnEntry_t));

	dp->setMethod = tcpConnEntry_set;
	dp->cleanupMethod = tcpConnEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = tcpConnEntry_undo;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_tcpConnLocalAddress, ((tcpConnEntry_t *) (dp->data))->valid);
	((tcpConnEntry_t *) (dp->data))->tcpConnLocalAddress = tcpConnLocalAddress;

	SET_VALID(I_tcpConnLocalPort, ((tcpConnEntry_t *) (dp->data))->valid);
	((tcpConnEntry_t *) (dp->data))->tcpConnLocalPort = tcpConnLocalPort;

	SET_VALID(I_tcpConnRemAddress, ((tcpConnEntry_t *) (dp->data))->valid);
	((tcpConnEntry_t *) (dp->data))->tcpConnRemAddress = tcpConnRemAddress;

	SET_VALID(I_tcpConnRemPort, ((tcpConnEntry_t *) (dp->data))->valid);
	((tcpConnEntry_t *) (dp->data))->tcpConnRemPort = tcpConnRemPort;

    }
    switch (object->nominator) {

#ifdef I_tcpConnState
      case I_tcpConnState:

	if (value->sl_value != D_tcpConnState_deleteTCB)
	    return(WRONG_VALUE_ERROR);

	SET_VALID(I_tcpConnState, ((tcpConnEntry_t *) (dp->data))->valid);

	((tcpConnEntry_t *) (dp->data))->tcpConnState = value->sl_value;
	break;
#endif				       /* I_tcpConnState */

      default:
	DPRINTF((0, "snmpd: Internal error (invalid nominator in tcpConnEntry)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = DELETE;

    return(NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
tcpConnEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_tcpConnEntry_set((tcpConnEntry_t *) (doCur->data),
			       contextInfo, doCur->state));
}

#endif				       /* SETS */

static ulong
tcp_currently_established(void)
{
    ulong     count;
    int       idx;
    tcbtype  *tcb;

    count = 0;

    for (idx = 0; idx < TCBHASHSIZE; idx++) {
	for (tcb = tcbhashtable[idx]; tcb; tcb = tcb->next) {
	    if ((tcb->state == ESTAB) || (tcb->state == CLOSEWAIT)) {
		count++;
	    }
	}
    }

    return(count);
}


tcp_t          *
k_tcp_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator)
{
    static tcp_t    tcpData;

    tcpData.tcpRtoAlgorithm = D_tcpRtoAlgorithm_vanj;
    tcpData.tcpRtoMin = MINRTT;
    tcpData.tcpRtoMax = MAXRTT;
    tcpData.tcpMaxConn = -1;
    tcpData.tcpActiveOpens = tcp_traffic.actopen;
    tcpData.tcpPassiveOpens = tcp_traffic.pasopen;
    tcpData.tcpAttemptFails = tcp_traffic.attfail;
    tcpData.tcpEstabResets = tcp_traffic.estrest;
    tcpData.tcpCurrEstab = tcp_currently_established();
    tcpData.tcpInSegs = tcp_traffic.inputs;
    tcpData.tcpOutSegs = tcp_traffic.outputs;
    tcpData.tcpRetransSegs = tcp_traffic.retrans;
    tcpData.tcpInErrs = tcp_traffic.checksumerr;
    tcpData.tcpOutRsts = tcp_traffic.reset;

    return (&tcpData);
}

tcbtype *
find_tcp_connection(
    int             serialNum,
    int             searchType,
    unsigned long   tcpConnLocalAddress,
    long            tcpConnLocalPort,
    unsigned long   tcpConnRemAddress,
    long            tcpConnRemPort)
{
    int      idx;
    tcbtype *tcb;
    tcbtype *best;

    best = NULL;

    for (idx = 0; idx < TCBHASHSIZE; idx++) {
	for (tcb = tcbhashtable[idx]; tcb; tcb = tcb->next) {

	    /*
	     * reject this entry if its indices are lexigraphically less-than
	     * the input indices (and select it if they are equal)
	     */

	    if (tcb->localhost.ip_addr < tcpConnLocalAddress)
		continue;
	    if (tcb->localhost.ip_addr == tcpConnLocalAddress) {
		if (tcb->localport < tcpConnLocalPort)
		    continue;
		if (tcb->localport == tcpConnLocalPort) {
		    if (tcb->foreignhost.ip_addr < tcpConnRemAddress)
			continue;
		    if (tcb->foreignhost.ip_addr == tcpConnRemAddress) {
			if (tcb->foreignport < tcpConnRemPort)
			    continue;
			if (tcb->foreignport == tcpConnRemPort)
			    /* exact match :-) */
			    return (tcb);
		    }
		}
	    }

	    /*
	     * reject this entry if an EXACT search since it didn't match
	     */

	    if (searchType == EXACT)
		continue;

	    /*
	     * reject this entry if its indices are lexigraphically
	     * greater than the previously found best match
	     */
	    if (best) {
		if (tcb->localhost.ip_addr > best->localhost.ip_addr)
		    continue;
		if (tcb->localhost.ip_addr == best->localhost.ip_addr) {
		    if (tcb->localport > best->localport)
			continue;
		    if (tcb->localport == best->localport) {
			if (tcb->foreignhost.ip_addr > best->foreignhost.ip_addr)
			    continue;
			if (tcb->foreignhost.ip_addr == best->foreignhost.ip_addr) {
			    if (tcb->foreignport > best->foreignport)
				continue;
			}
		    }
		}
	    }

	    best = tcb;
	}
    }

    return(best);
}



tcpConnEntry_t *
k_tcpConnEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    unsigned long   tcpConnLocalAddress,
    long            tcpConnLocalPort,
    unsigned long   tcpConnRemAddress,
    long            tcpConnRemPort)
{
    static tcpConnEntry_t tcpConnEntryData;
    tcbtype *best;

    best = find_tcp_connection(serialNum,
			      searchType,
			      tcpConnLocalAddress,
			      tcpConnLocalPort,
			      tcpConnRemAddress,
			      tcpConnRemPort);
    if (best == NULL)
	return (NULL);

    tcpConnEntryData.tcpConnState = best->state + 1;
    tcpConnEntryData.tcpConnLocalAddress = best->localhost.ip_addr;
    tcpConnEntryData.tcpConnLocalPort = best->localport;
    tcpConnEntryData.tcpConnRemAddress = best->foreignhost.ip_addr;
    tcpConnEntryData.tcpConnRemPort = best->foreignport;
    tcpConnEntryData.ciscoTcpConnInBytes = best->bytesincount;
    tcpConnEntryData.ciscoTcpConnOutBytes = best->bytesoutcount;
    tcpConnEntryData.ciscoTcpConnInPkts = best->pakindata;
    tcpConnEntryData.ciscoTcpConnOutPkts = best->pakoutdata;
    /* must scale from milliseconds to hundredths of a second */
    tcpConnEntryData.ciscoTcpConnElapsed =
	ELAPSED_TIME(best->starttime) / (ONESEC / 100);
    tcpConnEntryData.ciscoTcpConnSRTT = best->srtt >> 3; /* srtt is scaled */

    return (&tcpConnEntryData);
}

int
k_tcpConnEntry_set(
    tcpConnEntry_t *data,
    ContextInfo    *contextInfo,
    int             function)
{

    tcbtype *tcb;

    /*
     * We are only called to delete a tcb. First thing to do is locate
     * the tcb. If we find it, use tcp_clear_conn() to clear the connection. 
     * If we don't find it, then it has already been closed but we'll
     * take credit for it and still return success
     */

    tcb = find_tcp_connection(-1,
			      EXACT,
			      data->tcpConnLocalAddress,
			      data->tcpConnLocalPort,
			      data->tcpConnRemAddress,
			      data->tcpConnRemPort);

    if (tcb) 
	tcp_clear_conn(tcb);

    return (NO_ERROR);

}




/*
 * tcpmib2 subsystem header
 */

#define MAJVERSION_tcpmib2 1
#define MINVERSION_tcpmib2 0
#define EDITVERSION_tcpmib2 0

SUBSYS_HEADER(tcpmib2,
              MAJVERSION_tcpmib2,
              MINVERSION_tcpmib2,
              EDITVERSION_tcpmib2,
              init_tcpmib2,
              SUBSYS_CLASS_MANAGEMENT,
              subsys_req_iphost,
              NULL);
      
