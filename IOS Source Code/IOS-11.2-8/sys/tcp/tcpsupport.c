/* $Id: tcpsupport.c,v 3.16.4.9 1996/08/07 09:02:57 snyder Exp $
 * $Source: /release/112/cvs/Xsys/tcp/tcpsupport.c,v $
 *------------------------------------------------------------------
 * tcpsupport.c -- TCP support routines
 *
 * November 1985, Kirk Lougheed
 *
 * Copyright (c) 1985-1997 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 * $Log: tcpsupport.c,v $
 * Revision 3.16.4.9  1996/08/07  09:02:57  snyder
 * CSCdi65343:  more things that should be declared const
 *              char * [] -> char *const []
 *              char *    -> const char []
 *              savings 17,496 data space, 1,852 image space
 * Branch: California_branch
 *
 * Revision 3.16.4.8  1996/07/06  05:57:11  thille
 * CSCdi62136:  seq: iphost and req: iphost duplicated and waste memory
 * Branch: California_branch
 * Put copies of the strings in common_strings.c/h and reference them
 * instead of having multiple copies of the literals.  Save 660 bytes.
 *
 * Revision 3.16.4.7  1996/06/18  01:49:21  hampton
 * Split the monolithic traffic array into smaller per-protocol traffic
 * arrays.  [CSCdi59224]
 * Branch: California_branch
 *
 * Revision 3.16.4.6  1996/04/27  06:29:39  syiu
 * Branch: California_branch
 * Commit Dial1_branch
 *
 * Revision 3.9.2.3  1996/04/26  00:18:55  syiu
 * Branch: Dial1_branch
 * Dial1_branch to IosSec_postmerge_960419
 *
 * Revision 3.9.2.2  1996/04/16  23:40:26  syiu
 * Branch: Dial1_branch
 * Sync Dial1_branch to V111_1_3
 *
 * Revision 3.9.2.1  1996/01/26  20:26:01  agh
 * Branch: Dial1_branch
 * Initial Checkin of MLPVT Code.
 *
 * Revision 3.16.4.5  1996/04/16  19:11:47  rchandra
 * CSCdi54830:  IP features commit
 * Branch: California_branch
 *
 * Revision 3.16.4.4  1996/04/15  21:23:59  bcole
 * CSCdi54649:  IP Host Modularity, IP Automatic Stub Routing feature
 * commit
 * Branch: California_branch
 *
 * Revision 3.16.4.3  1996/03/28  01:24:01  jenny
 * CSCdi50806:  TCP connection terminates if outgoing interface MTU is
 * decreased
 * Branch: California_branch
 * Added a new CASE registry which IP now uses to notify of transport
 * layer if interface MTU is smaller than packet size and dont fragment
 * bit is set in the packet.
 *
 * Revision 3.16.4.2  1996/03/28  00:16:19  jenny
 * CSCdi51402:  TCP Path-MTU Discovery needs to be dynamic
 * Branch: California_branch
 * Implemented TCP PMTU dynamic discovery and PMTU timers (RFC 1191).
 * Moved ip tcp parser command into a seperated parser chain in TCP for
 * modularity.
 *
 * Revision 3.16.4.1  1996/03/18  22:13:51  gstovall
 * Branch: California_branch
 * Elvis has left the building.  He headed out to California, and took the
 * port ready changes with him.
 *
 * Revision 3.10.2.3  1996/03/16  07:41:17  gstovall
 * Branch: DeadKingOnAThrone_branch
 * Make the king aware of V111_1_3.
 *
 * Revision 3.10.2.2  1996/03/07  10:53:13  mdb
 * Branch: DeadKingOnAThrone_branch
 * cisco and ANSI/POSIX libraries.
 *
 * Revision 3.10.2.1  1996/02/20  21:21:31  dstine
 * Branch: DeadKingOnAThrone_branch
 *           Sync from DeadKingOnAThrone_baseline_960122 to
 *                     DeadKingOnAThrone_baseline_960213
 *
 * Revision 3.16  1996/03/08  00:43:19  lol
 * CSCdi50738:  no timeouts in T+
 *         Implement T+ timeouts for a customer who just won't wait. This
 *         code becomes obsolete in California.
 *
 * Revision 3.15  1996/03/07  07:01:14  jenny
 * CSCdi50769:  TCP may lose a packet after PMTU-discovery
 *
 * Revision 3.14  1996/02/23  23:38:53  ahh
 * CSCdi47841:  Running some telnet/pad sessions over serial causes rout...
 * Allow tcp_uniqueport() to fail, and clean up some debug messages.
 *
 * Revision 3.13  1996/02/20  19:45:49  ahh
 * CSCdi49358:  TCP: malformed options cause heartburn
 * Sanity check the option lengths.
 *
 * Revision 3.12  1996/01/29  07:30:26  hampton
 * Remove unnecessary includes of parser definition files.  [CSCdi47717]
 *
 * Revision 3.11  1996/01/24  20:41:23  jenny
 * CSCdi47046:  TCP/IP need code clean up (part 3)
 * . removed ip/tuba.c, ip/tuba_default.c and ip/tuba.h
 * . removed all includes for ip/tuba.h.
 * . removed more TUBA related code.
 *
 * Revision 3.10  1996/01/22  07:29:25  mdb
 * CSCdi47065:  misuse of NULL macro in IOS sources
 *
 * Revision 3.9  1996/01/13  00:22:40  ahh
 * CSCdi46808:  Router doing DLSW peering reloads when exposed to traf...
 * Repacketization needs pak->dataptr set up, so make sure it's
 * initialized in the new packets generated by path MTU discovery.
 *
 * Revision 3.8  1995/12/28  18:29:24  jenny
 * CSCdi46011:  TCP/IP need to do code clean up.
 * This is the first patch of code changes for TCP/IP code cleanup.
 * . removed all references to TUBA_IP and TUBA_CLNS.
 * . renamed open_tuba_socket() to ip_open_socket().
 * . renamed tcp_tuba_open() to tcp_open().
 * . pass addrtype * instead of ipaddrtype for local and foreight addresses
 *   to tcp_open() for feature portability.
 *
 * Revision 3.7  1995/12/13  04:24:49  ahh
 * CSCdi44230:  Remove dead code
 * Bring out your dead... *clang* (RSRB/TCP fast-switching)
 *
 * Revision 3.6  1995/12/10  21:02:37  smackie
 * Next on a very special Geraldo. Unused global booleans and the files
 * that loved them. (CSCdi45340)
 *
 * Revision 3.5  1995/12/05  05:51:52  ahh
 * CSCdi45000:  TCP: timers displayed incorrectly in show tcp
 * Fix the format strings.
 *
 * Revision 3.4  1995/11/21  08:27:29  ahh
 * CSCdi42413:  XOT: cannot tune TCP keepalive behavior
 * Allow keepalive rate to be controlled for XOT connections.
 *
 * Revision 3.3  1995/11/17  18:49:19  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.2  1995/11/17  00:44:22  gstovall
 * Ladies and gentlemen, I introduce to you, the port ready commit.
 *
 * Revision 3.1  1995/11/09  13:36:10  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.13  1995/11/08  21:32:16  shaker
 * Merge Arkansas_branch into 11.1 mainline.
 *
 * Revision 2.12  1995/08/28  21:46:51  jenny
 * CSCdi39127:  TCP header compression debugs print negative numbers
 *
 * Revision 2.11  1995/08/18  02:58:27  ahh
 * CSCdi38935:  TCP: TCP Listener should use new process primitives
 * Use process and list primitives for connection queueing support.
 * Clean up some crufties, and delete some conditionally-compiled
 * debug code.
 *
 * Revision 2.10  1995/07/29  00:21:56  ahh
 * CSCdi37655:  TCP: Listener process should be started on demand
 * Start it on demand, and make it low priority.
 *
 * Revision 2.9  1995/07/27  07:30:55  hampton
 * Rename insque/remque to lw_insert/lw_remove. [CSCdi37745]
 *
 * Revision 2.8  1995/07/12 23:45:46  hampton
 * Convert TCP to fully use the passive timers macros instead of
 * referencing the system clock directly.  [CSCdi37015]
 *
 * Revision 2.7  1995/06/21 09:01:15  smackie
 * Rename malloc memory pool derivatives so that they're prefixed with
 * malloc_ for consistency. (CSCdi36222)
 *
 * Revision 2.6  1995/06/20  22:02:08  ahh
 * CSCdi31398:  Rlogin sending window size packet twice
 * Eliminate race conditions in rlogin's urgent-data processing.
 *
 * Revision 2.5  1995/06/17  06:26:46  ahh
 * CSCdi35734:  TCP: Long overdue code reorganization
 * Separate tcp.h into public and private header files.  Shuffle functions
 * around into more logical groupings.  Rename functions to meet naming
 * conventions (say goodbye to StudlyCaps).  Delete unneeded externs.
 * Trim off old log messages.
 *
 * Revision 2.4  1995/06/16  04:29:50  dkatz
 * CSCdi35882:  Time-of-day code needs cleanup
 *
 * Revision 2.3  1995/06/09  23:40:18  achopra
 * CSCdi04836:  Provide ip-on-break functionality on TS
 *
 * Revision 2.2  1995/06/08  20:37:38  ahh
 * CSCdi35523:  TCP: timers not working correctly
 * Make sure the tcp_timer process wakes up when its timeout changes.
 *
 * Revision 2.1  1995/06/07  23:06:16  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

#include "master.h"
#include "../ui/common_strings.h"
#include <string.h>
#include <ciscolib.h>
#include "interface_private.h"
#include "packet.h"
#include "logger.h"
#include "../tcp/msg_tcp.c"		/* Not a typo, see logger.h */
#include "../os/free.h"
#include "../ui/debug.h"
#include "../ip/ip.h"
#include "../ip/ip_registry.h"
#include "tcp.h"
#include "tcpinternal.h"
#include "tcp_debug.h"
#include "telnet.h"
#include "config.h"
#include "parser.h"
#include "name.h"
#include "../ip/ip_media.h"
#include "../ip/ipoptions.h"
#include "ttysrv.h"
#include "connect.h"
#include "../iprouting/route.h"
#include "../clns/clns_externs.h"
#include "tcpdriver.h"
#include "sys_registry.h"
#include "../util/md5.h"
#include "mgd_timers.h"
#include "../os/clock.h"
#include "../util/random.h"
#include "../ui/service.h"
#include "subsys.h"

#undef TCPTRACE

/*
 * Storage definitions
 */

tcbtype *tcbhashtable[TCBHASHSIZE];
tcbtype *tcbwildtable;
tcp_traffic_t tcp_traffic;

static pid_t tcp_timer_pid;	/* pid for tcp_timer process */
static pid_t tcp_proto_pid;	/* pid for tcp_protocol process */
static sys_timestamp NextTimeout;/* next time to run tcp_timer */
int timers_pending;		/* count of active timers */
ushort tcp_portseed;		/* seed value for creating local port no's */
boolean tcp_ready;
boolean tcptunnel_enable;

/*
 * tcp_closeconnection:
 * Close connection by discarding the incoming segment and then
 * deallocating the connection.
 *
 * Parameters:
 * tcb     Ptr to tcb of current connection
 * curpkt  Ptr to rec. for current packet
 * code
 * reason
 */

void tcp_closeconnection (tcbtype *tcb, curpkttype *curpkt,
			  int code, char *reason)
{
    tcp_deallocatetcb(tcb, code);

    if (curpkt->tcpptr->rst && curpkt->seglen) {
	tcb->curinputpak = curpkt->pakptr;
	tcb->curinputpak->length = curpkt->seglen;
	tcb->curinputpak->dataptr = (uchar *)curpkt->tcpptr +
	  curpkt->segdataoffset;
	tcp_wakeup_process(tcb);
    } else
	tcp_discardsegment(curpkt->pakptr, "closing connection");

    if (tcp_debug)
	buginf("\nTCP%t: connection closed - %s", tcb->ttynum, reason);
}

#ifdef TCPVERBOSE
static
void tcp_dump_retrans (tcbtype *tcb)
{
    elementtype *el;
    paktype *pak;
    iphdrtype *ip;
    tcptype *tcp;
    int tcpdatasize;

    buginf("\ntcb %08lx retrans q:", tcb);
    for (el = (elementtype *) tcb->q[RETRANSQUEUE].qhead; el; el = el->next) {
	/* Set up the pointers */
	pak = el->pakptr;
	ip = (iphdrtype *) ipheadstart(pak);
	tcp = tcp_get_hdr(pak, tcb);
	tcpdatasize = pak->length - IPHEADERBYTES(tcb->options) -
	    	      (tcp->dataoffset << 2);
	buginf("\n\tpak=%08lx src %i dst %i ihl %d tl %d prot %d"
	       "\n\t data %d sport %d dport %d seq %u ack %u win %d ret %d",
	       pak, ip->srcadr, ip->dstadr, ip->ihl, ip->tl, ip->prot,
	       tcpdatasize, tcp->sourceport, tcp->destinationport,
	       tcp->sequencenumber, tcp->acknowledgementnumber, tcp->window,
	       pak->us_retransno);
    }
}
#endif

/* PMTU support */
static const ushort tcp_mtu_table[] = {	/* MTU plateaus from RFC 1191 */
    65535,
    32000,
    17914,
    8166,
    4352,
    2002,
    1492,
    1006,
    508,
    296,
    68
};

#define NUM_MTUS (sizeof(tcp_mtu_table) / sizeof(tcp_mtu_table[0]))

/*
 * tcp_pmtu_newmss
 * 
 * Set tcb MSS and congestion window to the new size discovered by
 * TCP Pathmtu-Discovery.
 */
static void tcp_pmtu_newmss (tcbtype *tcb, unsigned short new_mss)
{
    if (new_mss > tcb->maxrcvwnd) {
	new_mss = tcb->maxrcvwnd;
    }

    if (tcp_debug) {
	buginf("\nTCP%t: Pathmtu-Discovery, MSS changes from %d to %d", 
		tcb->ttynum, tcb->maxsegmentsize, new_mss);
    }
    tcb->maxsegmentsize = tcb->sndcwnd = new_mss;
    return;
}

/*
 * tcp_start_pmtutimer
 *
 * Set next PMTUTIMEOUT timeout value. PMTUTIMEOUT timer should never 
 * be shorter than the estimated round-trip time. 
 */
static void tcp_start_pmtutimer (tcbtype *tcb, long time)
{
    long t;

    t = max(time, (tcb->krtt? tcb->krtt : tcb->rtto));
    tcp_starttimer(tcb, PMTUTIMEOUT, t);
}	

/*
 * tcp_pmtu_estimate
 * 
 * tcp_pmtu_estimate is used to purge stale PMTU information. When the 
 * PMTU age timer expires, either the next-higest value in the MTU plateau 
 * table, or the first-hop MTU, or peer MSS, which ever is the smallest, 
 * is tried as the new segment size for the connection.
 */ 
static void tcp_pmtu_estimate (tcbtype *tcb)
{
    ushort max_segsize = 0;
    idbtype *idb;
    ipaddrtype dummy;
    int overhead;
    ushort segsize = 0;
    int i;

    overhead = IPHEADERBYTES(tcb->options) + TCPHEADERBYTES +
	       tcp_optionbytes(tcb, FALSE);
    dummy = tcb->foreignhost.ip_addr;
    idb = reg_invoke_ip_first_hop(&dummy, dummy, IP_PATH_DEFFLAGS);
    if (idb)
	max_segsize = idb->ip_mtu - overhead;
    /*
     * If the maxsegmentsize is already the first hop interface MTU,
     * this is the max size we can send for now, set the PMTU age timer,
     * and try again later just in case the first hop interface is
     * changed.
     */	
    if (tcb->maxsegmentsize == max_segsize) {
	tcp_start_pmtutimer(tcb, len_pathmtu_timeout);
	return;
    }
    for (i = NUM_MTUS-1; i >= 0; i--) {
	segsize = tcp_mtu_table[i];
	segsize = segsize - overhead;
	/*
	 * Use the new segment size found if it is bigger than the 
	 * maxsegmentsize currently in use and it's not bigger 
	 * than the first hop MTU and the MSS offered by peer.
	 * Set LENPMTUSHORTTIMEOUT as timer value for PMTUTIMEOUT
	 * so that if the new estimate is good, we can quickly 
 	 * increase the maxsegmentsize to next higher estimate. 
	 */
	if ((segsize <= max_segsize) && (segsize <= tcb->peer_mss) && 
	    (segsize > tcb->maxsegmentsize)) {
	    tcp_pmtu_newmss(tcb, segsize);
	    tcp_start_pmtutimer(tcb, LENPMTUSHORTTIMEOUT);
	    return;
	}
	/*
	 * If new segment size is larger than MSS offered by peer,
	 * set maxsegmentsize to peer MSS, and stop the PMTUTIMEOUT
	 * timer. Clear TCB_PMTUAGER in tcb->flags since no more 
	 * Pathmtu-discovery is needed for this connection. 
	 */  
	if (segsize > tcb->peer_mss) {
	    tcp_pmtu_newmss(tcb, tcb->peer_mss);
    	    tcp_stoptimer(tcb, PMTUTIMEOUT);
    	    tcb->flags &= ~TCB_PMTUAGER;
	    return;
	} 
	/* If new segment size is larger than first hop MTU size,
	 * set maxsegmentsize to MTU size, and set PMTUTIMEOUT timer.
	 * Check first hop interface MTU again when timer expires.
	 */
	if (segsize > max_segsize) {
	    tcp_pmtu_newmss(tcb, max_segsize);
	    tcp_start_pmtutimer(tcb, len_pathmtu_timeout);
	    return;
	}
    }

    /*
     * Didn't find another suitable new segment size, turn off the 
     * PMTUTIMEOUT to stop further path MTU discovery.
     */
    tcp_stoptimer(tcb, PMTUTIMEOUT);
}

/*
 * tcp_splinter
 *	Break up large segments on the retransmission queue
 * into MSS-sized segments.
 */

static
void tcp_splinter (tcbtype *tcb)
{
    queuetype *queue;
    elementtype *el;
    ushort linktype;
    int hdrbytes, optbytes, overhead;
    boolean all_full_seg;

    queue = &tcb->q[RETRANSQUEUE];
    optbytes = tcp_optionbytes(tcb, FALSE);
    hdrbytes = IPHEADERBYTES(tcb->options); 
    overhead = hdrbytes + TCPHEADERBYTES + optbytes;
    linktype = LINK_IP;

    for (el = (elementtype *) queue->qhead; el; el = el->next) {
	int tcpdatasize;
	iphdrtype *ip_first;
	tcptype *tcp_first;

	ip_first = (iphdrtype *) ipheadstart(el->pakptr);
	tcp_first = tcp_get_hdr(el->pakptr, tcb);
	tcpdatasize = el->pakptr->length - hdrbytes -
	    (tcp_first->dataoffset << 2);

	if (tcpdatasize > tcb->maxsegmentsize) {
	    paktype **newpaks;	
	    int newsegs, i;
	    int firstfin;
	    uchar *data;

	    /*
	     * Calculate the number of new segments to create
	     * out of the old, big one.
	     */
	    all_full_seg = (tcpdatasize % tcb->maxsegmentsize) ? FALSE : TRUE;
	    newsegs = (tcpdatasize / tcb->maxsegmentsize) + (all_full_seg? 0:1);

	    newpaks = malloc((newsegs - 1) * sizeof(paktype *));
	    if (newpaks == NULL) {
		/*
		 * Wow, no memory to hold a few measly pointers.
		 * Clear the don't-fragment bit so that this
		 * packet can be delivered.  Sorry!
		 */
		ip_first->dontfragment = 0;
		return;
	    }


	    /*
	     * Get packet buffers for the MSS-sized segments
	     * and the last one.
	     */
	    for (i = 0; i < newsegs - 1; i++) {
		int newsize;

		/* Figure the size of the new segment. */
		if ((i < newsegs - 2) || all_full_seg)
		    newsize = tcb->maxsegmentsize;
		else
		    newsize = tcpdatasize % tcb->maxsegmentsize;

		newpaks[i] = getbuffer(newsize + overhead);
		if (newpaks[i] == NULL) {
		    int j;

		    /*
		     * Yoiks -- free what's been allocated
		     * so far.  Clear don't-fragment to force
		     * the complaining router to fragment
		     * this packet.
		     */
		    for (j = 0; j < i; j++)
			retbuffer(newpaks[j]);
		    ip_first->dontfragment = 0;
		    free(newpaks);
		    return;
		}
		newpaks[i]->length = newsize + overhead;
	    }

	    /* Recycle the first segment by shrinking it. */
	    el->pakptr->length = tcb->maxsegmentsize + overhead;
	    newsegs--;
	    tcpdatasize -= tcb->maxsegmentsize;
	    firstfin = tcp_first->fin;
	    tcp_first->fin = 0;	/* see below */
	    if (tcb->flags & TCB_MD5) {
		uchar *md5;

		/* Need to rewrite signature */
		md5 = tcp_findoption(tcp_first, MD5OPTION);
		if (md5) {
		    tcp_first->checksum = 0;
		    tcp_md5digest(&md5[2], ip_first->srcadr, ip_first->dstadr,
				  TCP_PROT, tcb->maxsegmentsize + TCPHEADERBYTES,
				  tcp_first, &tcp_first->data[optbytes],
				  tcb->md5_key, tcb->md5_keylen);
		}
	    }

	    /* Now create the rest. */
	    data = &tcp_first->data[tcb->maxsegmentsize + optbytes];
	    for (i = 0; i < newsegs; i++) {
		iphdrtype *ip;
		tcptype *tcp;
		int newsize;

		newsize = newpaks[i]->length - overhead;

		/* Initialize packet fields. */
		newpaks[i]->us_retransno = 0;
		COPY_TIMESTAMP(el->pakptr->us_sendtime, newpaks[i]->us_sendtime);
		newpaks[i]->linktype = linktype;

		ip = (iphdrtype *) ipheadstart(newpaks[i]);
		ip->ihl = 0;

		/* Initialize the tcp header. */
		tcp = (tcptype *) (newpaks[i]->network_start + hdrbytes);
		tcp->sourceport = tcb->localport;
		tcp->destinationport = tcb->foreignport;
		tcp->sequencenumber = tcp_first->sequencenumber +
		    (tcb->maxsegmentsize * (i + 1));
		tcp->acknowledgementnumber = tcp_first->acknowledgementnumber;
		tcp->window = tcp_first->window;
		tcp->urgentpointer = tcp_first->urgentpointer;
		tcp->dataoffset = (TCPHEADERBYTES + optbytes) >> 2;

		/*
		 * URG -- URG set if it was set in the original segment.
		 * ACK -- ACK always set.  Screw it.
		 * PSH -- PSH set if it was set in the original segment.
		 * RST -- RST set if it was set in the original segment.
		 * SYN -- if SYN was set in the bounced segment, then only
		 *	  the first, truncated segment should have it set.
		 * FIN -- if FIN was set in the bounced segment, then only
		 * 	  the last segment should have it set.
		 */
		tcp->urg = tcp_first->urg;
		tcp->ack = 1;
		tcp->psh = tcp_first->psh;
		tcp->rst = tcp_first->rst;
		tcp->syn = 0;
		if (firstfin && (i == newsegs - 1))
		    tcp->fin = 1;
		else
		    tcp->fin = 0;

		/* Copy the data. */
		bcopy(data, &tcp->data[optbytes], newsize);
		newpaks[i]->dataptr = &tcp->data[optbytes] + newsize;
		data += newsize;

		/*
		 * Recreate any options that should
		 * be in the new segment.
		 */
		if (tcb->flags & TCB_MD5) {
		    uchar md5[MD5_LEN];

		    tcp->checksum = 0;
		    tcp_startoptions(tcb, &tcp->data[0]);
		    tcp_md5digest(md5, ip->srcadr, ip->dstadr,
				  TCP_PROT, newsize + TCPHEADERBYTES,
				  tcp, &tcp->data[optbytes],
				  tcb->md5_key, tcb->md5_keylen);
		    tcp_writeoption(tcb, MD5OPTION, md5, sizeof(md5));
		    tcp_endoptions(tcb);
		}

		/* Insert it after the last packet. */
		pak_insqueue(queue, newpaks[i], el);

		tcpdatasize -= newsize;

		/* Make the pointer point to the packet just inserted. */
		el = el->next;
	    }
	    free(newpaks);
	}
    }
}

static
void tcp_pmtu_response (tcbtype *tcb, icmptype *icmp)
{
    ushort segsize;
    idbtype *idb;
    ipaddrtype dummy;
    int overhead;

    overhead = IPHEADERBYTES(tcb->options) + TCPHEADERBYTES +
	tcp_optionbytes(tcb, FALSE);

    /*
     * Use the provided MTU if the complaining router deigned
     * to give us one; otherwise, find the next smallest MTU
     * in the candidate list above and use it.
     */
    if (icmp->next_hop_mtu) {
	segsize = icmp->next_hop_mtu - overhead;
    } else {
	int i;

	/* Old-style messages, try the next smallest. */
	for (i = 0; i < NUM_MTUS; i++)
	    if (tcp_mtu_table[i] < tcb->maxsegmentsize)
		break;
	if (i < NUM_MTUS) {
	    segsize = tcp_mtu_table[i] - overhead;
	} else {
	    /*
	     * Fell off the bottom, so drop down to min(536, mss).
	     * In case this isn't good enough, turn off PMTU
	     * discovery, so at least fragmentation happens.
	     */
	    segsize = min(tcb->maxsegmentsize, TCP_DEFAULT_MSS);
	    dummy = tcb->foreignhost.ip_addr;
	    idb = reg_invoke_ip_first_hop(&dummy, dummy, IP_PATH_DEFFLAGS);
	    if (idb)
		segsize = min(segsize, idb->ip_mtu - overhead);
	    tcp_pmtu_off(tcb);
	}
    }
    if (segsize > tcb->maxrcvwnd)
	segsize = tcb->maxrcvwnd;
    if (tcp_debug)
	buginf("\nTCP%t: ICMP datagram too big received (%d), MSS changes"
	       " from %d to %d", tcb->ttynum, icmp->next_hop_mtu,
	       tcb->maxsegmentsize, segsize);
    tcb->maxsegmentsize = tcb->sndcwnd = segsize;
    tcp_splinter(tcb);
    /*
     * Restart PMTUTIMEOUT timer if pathmtu age-timer is not configured 
     * as "infinite".
     */ 
    tcp_stoptimer(tcb, PMTUTIMEOUT);
    if (len_pathmtu_timeout)
    	tcp_start_pmtutimer(tcb, len_pathmtu_timeout);
    tcb->flags |= TCB_PMTUAGER;
}

/*
 * tcp_pmtu_on
 * tcp_pmtu_off
 * 	Turn on and off path MTU discovery for a TCB.
 */

void tcp_pmtu_on (tcbtype *tcb)
{
    if (tcp_pathmtu) {
	tcb->flags |= TCB_PMTUDISC;
	tcb->param.dontfragment = TRUE;
    }
}

void tcp_pmtu_off (tcbtype *tcb)
{
    if (tcp_pathmtu) {
	tcb->flags &= ~TCB_PMTUDISC;
	tcb->param.dontfragment = ipdefaultparams.dontfragment;
    }
}

/*
 * tcp_unreachable
 * Given the IP and partial TCP header of a packet sent back via an ICMP
 * destination unreachable, find the appropriate TCB and mark it unreachable
 * if the connection has not yet been fully established.  Don't blow up
 * established connections -- network routing may be in flux.
 */

static void tcp_unreachable (void *ipopaque, ipaddrtype src, void *icmpopaque)
{
    icmptype *icmp;
    iphdrtype *ip;
    tcbtype *tcb;
    tcptype *tcp;
    addrtype addr;

    ip = ipopaque;
    icmp = icmpopaque;
    tcp = (tcptype *) ipdatastart_iph(ip);
    addr.type = ADDR_IP;
    addr.ip_addr = ip->dstadr;
    tcb = find_tcb(n2h(tcp->destinationport), n2h(tcp->sourceport),
		   &addr, FALSE, FALSE);
    if (!tcb)
	return;
    /*
     * Check the code to see if this is "datagram too big" message
     */
    if (icmp->code == ICMP_UNRFRAG && tcp_pathmtu) {
	tcp_pmtu_response(tcb, icmp);
    } else {
	if (tcp_debug)
	    buginf("\nTCP%t: ICMP destination unreachable received",
		   tcb->ttynum);
	if (tcb->state != ESTAB && tcb->state != CLOSEWAIT) {
	    /*
	     * Throw away TCBs that applications either don't know
	     * about or don't care anymore.
	     */
	    if ((tcb->flags & TCB_GENTCBS && tcb->state == SYNRCVD) ||
		tcb->flags & TCB_APP_CLOSED) {
		tcp_async_cleanup(tcb, UNREACHABLE);
	    } else {
		/*
		 * Application is expected to close the connection
		 * upon notification of the state change.
		 */
		 tcp_deallocatetcb(tcb, UNREACHABLE);	
	    }
	}
    }
}

/*
 * tcp_seqinrange:
 * Determines whether a sequence number lies within the specified range.
 *
 * Parameters:
 * low     Range in which s should lie
 * s       Sequence number to be checked
 * high    Range in which s should lie
 */

boolean tcp_seqinrange (ulong low, ulong s, ulong high)
{
    if (((low <= s) && (s <= high)) ||
	    ((high < low) && ((low <= s) || (s <= high))))
	return (TRUE);
    else
	return (FALSE);
}

/*
 * tcp_allocatetcb
 * Create a TCB and initialize its data structures.
 */

tcbtype *tcp_allocatetcb (void)
{
    tcbtype *tcb;
    int i;

    tcb = malloc_named(sizeof(tcbtype), "TCP CB");
    if (tcb == NULL)
	return(NULL);

    /* 
     * Initialize to "blank" template state.  Since malloc clears memory,
     * we don't need to initialize zero fields or NULL pointers.
     */
    tcb->localhost.type = tcb->foreignhost.type = ADDR_ILLEGAL;
    tcb->flags = TCB_ACTIVE_OPEN_FLAGS;
    tcb->state = CLOSED;
    tcb->events |= tcp_set_events[CLOSED];
    tcb->events &= tcp_clear_events[CLOSED];
    tcb->lsterr = OK;
    tcb->rcvwnd = tcb->maxrcvwnd = tcp_defrcvwnd;
    tcb->maxsegmentsize = MAXPACKETDATALENGTH;
    tcb->qinput_max = 0; 
    tcb->maxrtt = 0;
    tcb->minrtt = MAXRTT;
    tcb->srtt = TCP_INIRTT;
    tcb->rtto = TCP_INIRTO;
    tcb->ackholdtime = MINRTT/2;
    tcb->param.tos = ipdefaultparams.tos;
    tcb->param.ttl = ipdefaultparams.ttl;
    tcb->param.dontfragment = ipdefaultparams.dontfragment;
    tcb->tcpdefhdr1 = TCPDEFHDR1;
    tcb->tcpdefhdr2 = TCPDEFHDR2;
    GET_TIMESTAMP(tcb->starttime);
    if (nagle_enable)
	tcb->flags |= TCB_NAGLE;
    tcb->sndcwnd = tcb->sndssthresh = MAXTCPWINDOW;
    for (i = 0; i < NUMTCPQUEUES; i++)
	queue_init(&tcb->q[i], 0);
    tcb->maxaliveticks = MAXALIVETICKS;
    tcb->maxalivetries = MAXALIVETRIES;
    tcb->giveuptime = 0;
    tcb->timewait_time = LENTMEWAITTIMEOUT;
    tcb->tcb_synwait = tcp_synwait;
    list_create(&tcb->connq, 0, "TCB connection queue", 0);
    return(tcb);
}

/*
 * tcp_deallocatetcb:
 * Resets all fields of the TCB, returns all queued buffers.
 * Removes TCB from TCB queue, but does *NOT* release storage, since
 * another process may be blocking on that TCB's state flag.
 * A statuscode of -1 means no change in I/O status.
 */

void tcp_deallocatetcb (tcbtype *tcb, int statuscode)
{
    int i;

    if (tcb->state != CLOSED)
	tcp_changestate(tcb, CLOSED);
    if (statuscode != -1)
	tcb->lsterr = statuscode;
    tcp_removeackedsendsegments(tcb);
#ifdef DEBUG
    if (tcp_debug) {
	if (!QUEUEEMPTY(&tcb->q[SAVEQUEUE]))
	   buginf("\ntcp_deallocatetcb: packets on save queue");
	if (!QUEUEEMPTY(&tcb->q[RETRANSQUEUE]))
	    buginf("\ntcp_deallocatetcb: packets on retransmit queue");
	if (!QUEUEEMPTY(&tcb->q[SEGQUEUE]))
	    buginf("\ntcp_deallocatetcb: packets on segment queue");
    }
#endif
    while (!QUEUEEMPTY(&tcb->q[RETRANSQUEUE]))
	datagram_done(pak_dequeue(&tcb->q[RETRANSQUEUE]));
    for (i = (RETRANSQUEUE+1); i <= SAVEQUEUE; i++)	/* flush queues */
	tcp_flushqueue(tcb, i);
    for (i = RETRANSTIMEOUT; i <= KEEPALIVETIMEOUT; i++) /* stop timers */
	tcp_stoptimer(tcb, i);
    datagram_done(tcb->curinputpak); tcb->curinputpak = NULL;
    datagram_done(tcb->curoutputpak); tcb->curoutputpak = NULL;
    tcb->unreadbytes = 0;		/* nuked all pending input */
    tcb_unqueue(tcb);
    if (tcb->options) {
	free(tcb->options);
	tcb->options = NULL;
    }
    if (tcb->saved_curpkt) {
	/*
	 * This tcb is for a synchronized-listen connection that
	 * was aborted before the call to tcp_establish.
	 * Clean up the state we had left around.
	 */
	retbuffer(tcb->saved_curpkt->pakptr);
	free(tcb->saved_curpkt);
	tcb->saved_curpkt = NULL;
    }
    if (tcb->tty)		/* maybe do CARDROP on vty's */
	(void) modemcheck(tcb->tty);
    tcp_close_children(tcb);
    if (LIST_ELEMENT_QUEUED(&tcb->newconn_element))
	list_remove(&tcp_newconn_list, &tcb->newconn_element, NULL);
    if (LIST_ELEMENT_QUEUED(&tcb->connq.element))
	list_destroy(&tcb->connq);
}

/*
 * tcp_flushqueue:
 * Flush designated queue.
 *
 * Parameters:
 * tcb     Ptr to tcb of current connection
 * queue   Which queue to flush
 */

void tcp_flushqueue (tcbtype *tcb, int queue)
{
    paktype *pkt;

    while (!QUEUEEMPTY(&tcb->q[queue])) {
	pkt = dequeue(&tcb->q[queue]);
	retbuffer(pkt);
    }
}

/*
 * tcp_changestate
 * Change TCB state to specified state.
 */

const ushort tcp_set_events[] = {
    /* CLOSED */
    (TCPEV_IS_CLOSED | TCPEV_MAYBE_OPEN | TCPEV_NOT_LISTEN | TCPEV_NOT_ESTAB),
    /* LISTEN */
    (TCPEV_NOT_ESTAB),
    /* SYNSENT */
    (TCPEV_NOT_LISTEN | TCPEV_NOT_ESTAB),
    /* SYNRCVD */
    (TCPEV_NOT_LISTEN | TCPEV_NOT_ESTAB),
    /* ESTAB */
    (TCPEV_MAYBE_OPEN | TCPEV_NOT_LISTEN | TCPEV_MAYBE_CONNECTED),
    /* FINWAIT1 */
    (TCPEV_NOT_ESTAB | TCPEV_NOT_LISTEN | TCPEV_MAYBE_CONNECTED |
     TCPEV_FROM_ESTAB),
    /* FINWAIT2 */
    (TCPEV_NOT_ESTAB | TCPEV_NOT_LISTEN | TCPEV_MAYBE_CONNECTED |
     TCPEV_FROM_ESTAB),
    /* CLOSEWAIT */
    (TCPEV_NOT_ESTAB | TCPEV_NOT_LISTEN | TCPEV_MAYBE_CONNECTED |
     TCPEV_FROM_ESTAB),
    /* LASTACK */
    (TCPEV_NOT_ESTAB | TCPEV_NOT_LISTEN | TCPEV_MAYBE_CONNECTED |
     TCPEV_FROM_ESTAB),
    /* CLOSING */
    (TCPEV_NOT_ESTAB | TCPEV_NOT_LISTEN | TCPEV_MAYBE_CONNECTED | 
     TCPEV_FROM_ESTAB),
    /* TIMEWAIT */
    (TCPEV_MAYBE_OPEN | TCPEV_NOT_ESTAB | TCPEV_NOT_LISTEN |
     TCPEV_MAYBE_CONNECTED | TCPEV_FROM_ESTAB)
};

const ushort tcp_clear_events[] = {
    /* CLOSED */
    ~(TCPEV_MAYBE_CONNECTED | TCPEV_FROM_ESTAB),
    /* LISTEN */
    ~(TCPEV_IS_CLOSED | TCPEV_MAYBE_OPEN | TCPEV_NOT_LISTEN |
      TCPEV_MAYBE_CONNECTED | TCPEV_FROM_ESTAB),
    /* SYNSENT */
    ~(TCPEV_IS_CLOSED | TCPEV_MAYBE_OPEN | TCPEV_MAYBE_CONNECTED |
      TCPEV_FROM_ESTAB),
    /* SYNRCVD */
    ~(TCPEV_IS_CLOSED | TCPEV_MAYBE_OPEN | TCPEV_MAYBE_CONNECTED |
      TCPEV_FROM_ESTAB),
    /* ESTAB */
    ~(TCPEV_IS_CLOSED | TCPEV_NOT_ESTAB | TCPEV_FROM_ESTAB),
    /* FINWAIT1 */
    ~(TCPEV_IS_CLOSED | TCPEV_MAYBE_OPEN),
    /* FINWAIT2 */
    ~(TCPEV_IS_CLOSED | TCPEV_MAYBE_OPEN),
    /* CLOSEWAIT */
    ~(TCPEV_IS_CLOSED | TCPEV_MAYBE_OPEN),
    /* LASTACK */
    ~(TCPEV_IS_CLOSED | TCPEV_MAYBE_OPEN),
    /* CLOSING */
    ~(TCPEV_IS_CLOSED | TCPEV_MAYBE_OPEN),
    /* TIMEWAIT */
    ~(TCPEV_IS_CLOSED)
};

void tcp_changestate (tcbtype *tcb, int state)
{
    if (tcp_debug)
	buginf("\nTCP%t: state was %s -> %s [%d -> %s(%d)]",
	       tcb->ttynum, tcp_statestring(tcb->state),
	       tcp_statestring(state), tcb->localport,
	       address_string(&tcb->foreignhost), tcb->foreignport);
#ifdef DEBUG
    /* Print out what's going to get dumped from the retransmission queue */
    if (tcppkt_debug && state == CLOSED && tcb->state != CLOSED) {
	elementtype *el;
	paktype *pak;
	iphdrtype *ip;
	tcptype *tcp;

	for (el = (elementtype *) tcb->q[RETRANSQUEUE].qhead; el;
	     el = el->next) {
	    pak = el->pakptr;
	    ip = (iphdrtype *) ipheadstart(pak);
	    tcp = (tcptype *) ipdatastart(pak);
	    print_tcp(tcb, pak, tcp, 'X', ip->id);
	}
    }
#endif
    if ((state >= CLOSED) && (state <= TIMEWAIT)) {
	tcb->events |= tcp_set_events[state];
	tcb->events &= tcp_clear_events[state];
	if (tcb->activate)
	    tcb->activate(tcb, tcb->rxhandle);
    }
    if (tcb->state == CLOSED && state == SYNSENT)
	tcp_traffic.actopen++;
    else if (tcb->state == LISTEN && (state == SYNSENT || state == SYNRCVD))
	tcp_traffic.pasopen++;
    else if (((tcb->state == SYNSENT || tcb->state == SYNRCVD) &&
	    state == CLOSED) || (tcb->state == SYNRCVD && state == LISTEN))
	tcp_traffic.attfail++;
    else if (tcb->state == ESTAB && (state == CLOSEWAIT || state == CLOSED))
	tcp_traffic.estrest++;
    tcb->state = state;			/* change the state */
    tcb->wakeup++;			/* possibly activate someone */
    tcp_wakeup_process(tcb);
}

/*
 * tcp_pmtutimer_on
 * Turn on PMTUTIMEOUT timer for appropriate connections.
 *
 * User has configured TCP Pathmtu-Discovery timer. This could be 
 * configured after a previous timer turn off or a first time config.
 * For the ones that was doing TCP Pathmtu-Discovery before this config,
 * turn the timer back on now. For the connections that wasn't doing 
 * TCP Pathmtu-Discovery, the timer will be turned on after a ICMP 
 * Datagram Too Big message is received for that connection. 
 */
void tcp_pmtutimer_on ()
{
    tcbtype *tcb;
    int i;

    /* 
     * calculate the age timer value as unit of minutes.
     */
    len_pathmtu_timeout = tcp_pathmtu_ager * ONEMIN;
    for (i = 0; i < TCBHASHSIZE; i++) {
	for (tcb = tcbhashtable[i]; tcb; tcb = tcb->next) {
	    if (tcb->flags & TCB_PMTUAGER)
		tcp_start_pmtutimer(tcb, len_pathmtu_timeout);
	}
    }
}

/* 
 * tcp_pmtutimer_off
 * Turn off PMTUTIMEOUT for appropriate connections.
 *
 * User has configured to turn off TCP Pathmtu-Discovery timer. 
 * Turn off the timer for the connections that currently have this 
 * timer on.
 */
void tcp_pmtutimer_off ()
{
    tcbtype *tcb;
    int i;

    /*
     * Clear the timer value so that the timer won't be restarted 
     * after receiving the "ICMP Datagram Too Big" message.
     */
    len_pathmtu_timeout = 0L;
    for (i = 0; i < TCBHASHSIZE; i++) {
	for (tcb = tcbhashtable[i]; tcb; tcb = tcb->next) {
	    if (tcb->flags & TCB_PMTUAGER)
	    	tcp_stoptimer(tcb, PMTUTIMEOUT);
	}
    }
}

/*
 * tcp_starttimer:
 * (Re)start specified timer.
 *
 * Parameters:
 * tcb     Ptr to tcb of current connection
 * timer   Index of timer to start
 * len     Length of timeout interval
 */

void tcp_starttimer (tcbtype *tcb, int timer, ulong len)
{
    sys_timestamp time;
    long nextlen;
    leveltype status;

    status = raise_interrupt_level(NETS_DISABLE);

    TIMER_START(time, len);

    /*
     * A zero time is used to indicate an inactive timer, but
     * TIMER_START takes care of the case where the activation
     * time happens to compute to zero, so no need to fudge here.
     */

    /*
     * If we are starting the timer, increment active total.
     */
    if (!TIMER_RUNNING(tcb->timers[timer])) {
	timers_pending++;		/* system total */
	tcb->pending++;			/* connection total */
    }
    COPY_TIMESTAMP(time, tcb->timers[timer]); /* (re)set timer */
    tcb->timeron[timer]++;		/* count timer activations */

    /*
     * Compute activation time for tcp_timer()
     */
    nextlen = TIME_LEFT_SLEEPING(NextTimeout);
    if (nextlen <= 0) {
	GET_TIMESTAMP(NextTimeout);	/* timer has already expired */
	process_wakeup(tcp_timer_pid);
    } else
 	if ((long) len < nextlen) {	/* timer goes off sooner */
	    TIMER_START(NextTimeout, len);
	    process_wakeup(tcp_timer_pid);
	}
    reset_interrupt_level(status);
}

/*
 * tcp_stoptimer:
 * Stop specified timer.
 *
 * Parameters:
 * tcb     Ptr to tcb of current connection
 * timer   Timer to stop
 */

void tcp_stoptimer (tcbtype *tcb, int timer)
{
    /*
     * If a timer is active, turn it off and decrement active total
     */
    if (TIMER_RUNNING(tcb->timers[timer])) {
	leveltype status;

	status = raise_interrupt_level(NETS_DISABLE);
	TIMER_STOP(tcb->timers[timer]);
	if (timer == SNDWNDTIMEOUT)	/* if send window has just opened */
	    tcb->wakeup++;		/* then wakeup a process */
	else if (timer == RETRANSTIMEOUT)
	    TIMER_STOP(tcb->timers[GIVEUPTIMEOUT]);
	--timers_pending;		/* decrement system timer total */
	--tcb->pending;			/* decrement connection total */
	reset_interrupt_level(status);
   }
}

/*
 * tcp_timerrunning:
 * Check if a timer is active
 *
 * Parameters:
 * tcb     Ptr to tcb of current connection
 * timer   Timer to stop
 */

boolean tcp_timerrunning (tcbtype *tcb, int timer)
{
    boolean running;

    /*
     * If a timer is active, return TRUE, otherwise FALSE
     */
    running = TIMER_RUNNING(tcb->timers[timer]);

    return(running);
}

/*
 * tcp_nexttimeout:
 * Returns the time of the next timeout for the specified connection.
 * Returns zero if no active timers.
 */

static
sys_timestamp tcp_nexttimeout (tcbtype *tcb)
{
    sys_timestamp time;
    long next, ticks;
    int i;

    next = MAXINT;
    ticks = 0;
    for (i = 0; i < NUMTCPTIMEOUTS; i++) {
	COPY_TIMESTAMP(tcb->timers[i], time);
	if (TIMER_RUNNING(time)) {
	    ticks = TIME_LEFT_SLEEPING(time);
	    if (ticks < next)
		next = ticks;
	}
    }
    if (next < 0)			/* if time was past.... */
	next = 0;			/* say next wakeup is now */
    TIMER_START(time, next);		/* compute next wakeup time */
    return (time);
}

/*
 * tcp_timeout
 * Handles TCP timeout events.
 */

static
sys_timestamp tcp_timeout (tcbtype *tcb)
{
    sys_timestamp timeout;

    /*
     * Check ACK timeout
     */
    COPY_TIMESTAMP(tcb->timers[ACKTIMEOUT], timeout);
    if (TIMER_RUNNING_AND_AWAKE(timeout)) {
	tcb->timerexp[ACKTIMEOUT]++;
#ifdef DEBUG
	if (tcp_debug)
	   buginf("\nTCP%t: ACK timeout timer expired", tcb->ttynum);
#endif
	tcp_sendacksegment(tcb);
	tcp_stoptimer(tcb, ACKTIMEOUT);
    }

   /*
    * Check Retransmit timeout and send window timeout.  These are basically
    * handled identically, but with slightly different side effects, especially
    * when the ack is finally received.
    */
    COPY_TIMESTAMP(tcb->timers[RETRANSTIMEOUT], timeout);
    if (TIMER_RUNNING_AND_AWAKE(timeout)) {
	tcb->timerexp[RETRANSTIMEOUT]++;
	tcp_removeackedsendsegments(tcb);
	if (QUEUEEMPTY(&tcb->q[RETRANSQUEUE])) {
	    tcp_stoptimer(tcb, RETRANSTIMEOUT);
	    tcp_stoptimer(tcb, GIVEUPTIMEOUT);
	    tcb->flags &= ~TCB_TIMINGOUT;
	} else {
	    /*
	     * TCB may be freed after coming back from tcp_retransmit().
	     */
	    if (tcp_retransmit(tcb, TRUE) == FALSE ||
		tcb->state == CLOSED || tcb->state == TIMEWAIT)
		return(timer_no_time);		/* connection declared dead */
	}
    }
    COPY_TIMESTAMP(tcb->timers[SNDWNDTIMEOUT], timeout);
    if (TIMER_RUNNING_AND_AWAKE(timeout)) {
	tcb->timerexp[SNDWNDTIMEOUT]++;
	if (QUEUEEMPTY(&tcb->q[RETRANSQUEUE])) {
	    if (tcp_debug)
		buginf("\nTCP%t: Send window timeout with no packet",
		       tcb->ttynum);
	    tcp_starttimer(tcb, SNDWNDTIMEOUT, tcb->rtto);	    
	} else {
	    /*
	     * TCB may be freed after coming back from tcp_retransmit().
	     */
	    if (tcp_retransmit(tcb, TRUE) == FALSE ||
		tcb->state == CLOSED || tcb->state == TIMEWAIT)
		return(timer_no_time);		/* connection declared dead */
	}
    }
    COPY_TIMESTAMP(tcb->timers[GIVEUPTIMEOUT], timeout);
    if (TIMER_RUNNING_AND_AWAKE(timeout)) {
	tcb->timerexp[TMEWAITTIMEOUT]++;
	if (tcp_debug)
	   buginf("\nTCP%t: give up timer expired", tcb->ttynum);
	tcp_stoptimer(tcb, GIVEUPTIMEOUT);
	tcp_deallocatetcb(tcb, TIMEDOUT);
	return(timer_no_time);				/* Connection is dead */
    }
    /*
     * Check End Timeout.
     */
    COPY_TIMESTAMP(tcb->timers[TMEWAITTIMEOUT], timeout);
    if (TIMER_RUNNING_AND_AWAKE(timeout)) {
	tcb->timerexp[TMEWAITTIMEOUT]++;
#ifdef DEBUG
	if (tcp_debug)
	   buginf("\nTCP%t: timewait timeout timer expired", tcb->ttynum);
#endif
	tcp_async_cleanup(tcb, TIMEDOUT);
	return(timer_no_time);
    }

    /*
     * Keep Alive Timeout.  
     * If the keep alive timer has expired, send an ACK with the fields
     * (<SEQ=SND.UNA-1>,<ACK=RCV.NXT-1>,<CTL=ACK>) in an attempt to generate
     * an ACK in reply.  If this doesn't work after a few retries, declare the
     * connection to be timed out.  Note that this timer is reset for each
     * packet passed to SegmentArrives.
     *
     * RCV.NXT-1 lies about how many bytes we have received.  It causes
     * the foreign TCP to respond.  SND.UNA causes the transmitted byte to
     * be outside the window -- note that we don't necessarily have a byte
     * in the window to send.
     */
    COPY_TIMESTAMP(tcb->timers[KEEPALIVETIMEOUT], timeout);
    if (TIMER_RUNNING_AND_AWAKE(timeout)) {
	if (tcp_debug)
	   buginf("\nTCP%t: keepalive timeout (%d/%d)", tcb->ttynum,
		  tcb->timerexp[KEEPALIVETIMEOUT], tcb->maxalivetries);
	if (tcb->timerexp[KEEPALIVETIMEOUT]++ >= tcb->maxalivetries) {
	    tcp_deallocatetcb(tcb, TIMEDOUT);
	    return(timer_no_time);
	}
	tcp_sendcontrolsegment(tcb, tcb->localport, tcb->foreignport,
			       &tcb->foreignhost, tcb->snduna-1, TRUE, 
			       tcb->rcvnxt-1, FALSE, FALSE);
	/*
	 * Only restart the timer if really needed! (Normally, the timer
	 * won't go off unless it needs to be reset, but we can occasionally
	 * start the timer the first time because of the tcp connection
	 * being in certain uncommon states that we want to recover from.)
	 */
	if (tcb->flags & TCB_KEEPALIVE ||
	    (tcb->qsaved > 0 && (tcb->flags&TCB_PASSIVEOPEN) &&
	     tcb->qinput == 0 && !TIMER_RUNNING(tcb->timers[RETRANSTIMEOUT]))) {
	    tcp_starttimer(tcb, KEEPALIVETIMEOUT, tcb->maxaliveticks);
	} else
	    tcp_stoptimer(tcb, KEEPALIVETIMEOUT);
    }

    /*
     * Path MTU Timeout
     * If pathmtu timer has expired, try another higer segment size if
     * the connection is still in the sending states.
     */  
    COPY_TIMESTAMP(tcb->timers[PMTUTIMEOUT], timeout);
    if (TIMER_RUNNING_AND_AWAKE(timeout)) {
	tcb->timerexp[PMTUTIMEOUT]++;
	if (tcb->state == ESTAB || tcb->state == CLOSEWAIT)
	    tcp_pmtu_estimate(tcb);
    }

    /*
     * Determine and return our next timeout, if any
     */
    return(tcp_nexttimeout(tcb));
}

/*
 * tcp_timer
 * Process to handle time driven TCP events
 */

static process tcp_timer (void)
{
    tcbtype *tcb, *next;
    sys_timestamp time;
    long when, ticks;
    int i;
    leveltype status;

    process_watch_timer(&NextTimeout, ENABLE);
    while (TRUE) {
	process_wait_for_event();		/* idle until the timeout */
	ticks = TCP_TIMER_MAXTICKS;		/* force maximum run time */
	for (i = 0; i < TCBHASHSIZE; i++) {
	    tcb = tcbhashtable[i];
	    while (tcb != NULL) {		/* scan the list */
	        next = tcb->next;		/* get pointer to successor */
	        if (tcb->pending) {
		    time = tcp_timeout(tcb);	/* active, do timeouts */
	            if (TIMER_RUNNING(time)) {	/* if timeouts pending... */
			when = TIME_LEFT_SLEEPING(time); /* ... how far in future? */
			if (when < ticks)	/* if sooner than planned */
		 	    ticks = when;	/* change our plans */
		    }
	        }
		tcb = next;			/* look at next TCB */
	    }
	}
        if (ticks < TCP_TIMER_MINTICKS)	/* lower bound */
	    ticks = TCP_TIMER_MINTICKS;
	if (ticks > TCP_TIMER_MAXTICKS)	/* upper bound */
	    ticks = TCP_TIMER_MAXTICKS;
	status = raise_interrupt_level(NETS_DISABLE);
	TIMER_START(NextTimeout, ticks);	/* set new first timeout */
	reset_interrupt_level(status);
    }
}

/*
 * tcp_status
 * Display TCB statistics and status information.
 */

static char *const tcbflagnames[] = {
    "passive open",		/* 0x001 set if passive open was done */
    "active",			/* 0x002 set if connection is now active */
    "higher precedence",	/* 0x004 set if higher precedence allowed */
    "idle user",		/* 0x008 set if user has idled connection */
    "retransmission timeout",	/* 0x010 set if retrans timeout aborts */
    "sending urgent data",	/* 0x020 set if urgent data is being sent */
    "keepalive running",	/* 0x040 set if keep alive timer is running */
    "retransmitting",		/* 0x080 retransmitting, don't queue output */
    "alias",			/* 0x100 TCB local address is an IP alias */
    "timing out",		/* 0x200 connection is possibly timing out */
    "net output pending",	/* 0x400 output to network is pending */
    "wait for FIN",		/* 0x800 wait for FIN to get acked */
    "nagle",			/* 0x1000 set if doing nagle processing */
    "closed",			/* 0x2000 app has closed connection */
    "always push",		/* 0x4000 push all packets (tn3270ism) */
    "sync listen",		/* 0x8000 handshake for LISTEN->ESTAB */
    "",				/* 0x10000 full-sized segs (internal use) */
    "path mtu capable", 	/* 0x20000 path MTU discovery capable */
    "gen tcbs",			/* 0x40000 generate tcbs as passive listener */
    "md5",			/* 0x80000 generating MD5 digests */
    "urgent data removed",	/* 0x100000 "edit" urgent data (rlogin) */
    "path mtu discovery"	/* 0x200000 doing path MTU discovery */
};
#define NTCBFLAGNAMES (sizeof(tcbflagnames) / sizeof(tcbflagnames[0]))
   	
/* Timer to string conversion. Used for "show tcp" display */
static char *const timer2string[] = { 
    "Retrans", "TimeWait", "AckHold", "SendWnd", 
    "KeepAlive", "GiveUp", "PmtuAger" 
};

void tcp_status (tcbtype *tcb)
{
    long i;

    if (!validmem(tcb))		/* If something happened to our tcp get out */
	return;

    mem_lock(tcb);		/* Make sure nothing does happen to it */

    printf("\nConnection state is %s, I/O status: %d, unread input bytes: %ld",
	 	tcp_statestring(tcb->state), tcb->lsterr, tcp_unread(tcb));
    printf("\nLocal host: %s, Local port: %d",
	   address_string(&tcb->localhost), tcb->localport);
    printf("\nForeign host: %s, Foreign port: %d",
	   address_string(&tcb->foreignhost),tcb->foreignport);
    if (tcb->options) {
	printf("\n");
	print_ipoptions(tcb->options);
    }
    printf("\n\nEnqueued packets for retransmit: %ld, input: %ld, saved: %ld",
	   QUEUESIZE(&tcb->q[RETRANSQUEUE]), QUEUESIZE(&tcb->q[SEGQUEUE]),
	   QUEUESIZE(&tcb->q[SAVEQUEUE]));

    printf("\n\nEvent Timers (current time is %#Tn):");
    printf("\nTimer          Starts    Wakeups            Next");
    for (i = 0; i < NUMTCPTIMEOUTS; i++) {
	printf("\n%10s %-10u %-10u %-#15Ta", timer2string[i], 
		tcb->timeron[i], tcb->timerexp[i], tcb->timers[i]);
    }

#ifdef ZEROWINDOW
    i = ((tcb->flags & TCB_IDLEUSER) ? 0 : tcb->rcvwnd);
#else
    i = tcb->rcvwnd;
#endif
    printf("\n\niss: %-10u  snduna: %-10u  sndnxt: %-10u     sndwnd: %-6u",
		tcb->iss, tcb->snduna, tcb->sndnxt, tcb->sndwnd);
    printf("\nirs: %-10u  rcvnxt: %-10u  rcvwnd: %-10u  delrcvwnd: %-6u",
		tcb->irs, tcb->rcvnxt, i, tcb->delrcvwnd);

    printf("\n\nSRTT: %ld ms, RTTO: %ld ms, RTV: %ld ms, KRTT: %ld ms\nminRTT: %ld ms, maxRTT: %ld ms, ACK hold: %ld ms",
	(tcb->srtt >> 3), tcb->rtto, tcb->srtv, tcb->krtt, tcb->minrtt,
	tcb->maxrtt, tcb->ackholdtime);
    printbits("\nFlags: ", tcb->flags, tcbflagnames, NTCBFLAGNAMES, NULL);

    printf("\n\nDatagrams (max data segment is %d bytes):\n",
		tcb->maxsegmentsize);
    printf("Rcvd: %lu (out of order: %lu), with data: %lu, total data bytes: %lu",
		tcb->pakincount,tcb->pakinorder,tcb->pakindata,
		tcb->bytesincount);
    printf("\nSent: %lu (retransmit: %lu), with data: %lu, total data bytes: %lu",
		tcb->pakoutcount,tcb->pakoutretrans,tcb->pakoutdata,
		tcb->bytesoutcount);

    free(tcb);	/* un-mem_lock() */
}


/*
 * tcp_netstat_fmt
 * Format up IP address and port number like netstat does.
 */

static
char *tcp_netstat_fmt (char *s, char *addrstring, char *portstring,
		  int start, int end)
{
    int indx;
    int col = end - start;
    int i, cnt;

#define ADDRLENGTH	16
#define PORTLENGTH	10

    /*
     * I'd use sprintf here, but our _doprnt is deficient and unfixable.
     * Likewise for strncpy.  What do you think it does?
     */
    cnt = 0;
    for (i = 0; *addrstring && (i < ADDRLENGTH); i++, cnt++)
	*s++ = *addrstring++;
    *s++ = '.';
    for (i = 0; *portstring && (i < PORTLENGTH); i++, cnt++)
	*s++ = *portstring++;
	
    /* Pad out the rest of the string. */
    indx = min(cnt, col - 1);
    memset(s, ' ', col - indx - 1);
    s += col - indx - 1;
    *s = '\0';

    return(s);		/* return pointer to end of string */
}

/*
 * tcp_status_brief
 * Give a one-liner for a TCB.
 */

void tcp_status_brief (tcbtype *tcb)
{
    char lportnumbuf[10], fportnumbuf[10];
    char linebuf[80];
    char *bufp;

#define LA_COL	11	/* column where "Local Address" starts */
#define FA_COL  35	/* column where "Foreign Address" starts */
#define ST_COL  58	/* column where "(state)" starts */

    mem_lock(tcb);
    if (tcb->localport != 0)
        sprintf(lportnumbuf, "%d", tcb->localport);
    else {
        lportnumbuf[0] = '*';
        lportnumbuf[1] = '\0';
    }
    if (tcb->foreignport != 0)
        sprintf(fportnumbuf, "%d", tcb->foreignport);
    else {
        fportnumbuf[0] = '*';
        fportnumbuf[1] = '\0';
    }
    bufp = linebuf;
    bufp = tcp_netstat_fmt(bufp, (tcb->localhost.type != ADDR_ILLEGAL) ?
			   name_addr2string(&tcb->localhost) : "*",
			   lportnumbuf, LA_COL, FA_COL);
    bufp = tcp_netstat_fmt(bufp, (tcb->foreignhost.type != ADDR_ILLEGAL) ?
			   name_addr2string(&tcb->foreignhost) : "*",
			   fportnumbuf, FA_COL+1, ST_COL);
    printf("\n%08lx  %s %s", tcb, linebuf, tcp_statestring(tcb->state));
    free(tcb);	/* un-mem_lock() */
}

/*
 * tcp_statestring
 * Given a state code, return a pointer to a descriptive string.
 * For debugging purposes.
 */

char *tcp_statestring (int state)
{
    switch(state) {
    case CLOSED: return("CLOSED");
    case LISTEN: return("LISTEN");
    case SYNSENT: return("SYNSENT");
    case SYNRCVD: return("SYNRCVD");
    case ESTAB: return("ESTAB");
    case FINWAIT1: return("FINWAIT1");
    case FINWAIT2: return("FINWAIT2");
    case CLOSEWAIT: return("CLOSEWAIT");
    case LASTACK: return("LASTACK");
    case CLOSING: return("CLOSING");
    case TIMEWAIT: return("TIMEWAIT");
    default: return("????");
    }
}

/*
 * tcp_show_traffic
 * TCP statistics
 */

void tcp_show_traffic (void)
{
    printf("\n\nTCP statistics:");
    printf("\n  Rcvd: %lu total, %lu checksum errors, %lu no port",
 		tcp_traffic.inputs, tcp_traffic.checksumerr,
		tcp_traffic.noport);
    printf("\n  Sent: %lu total", tcp_traffic.outputs);
}

/*
 * find_tcb(fport, lport, fhost, synbit)
 * Find the TCB that matches this datagram.
 */

tcbtype *find_tcb (ushort fport, ushort lport, addrtype *fhost, int synbit,
		   boolean get_new_listener)
{
    tcbtype *tcb;
    tcbtype *wildtcb = NULL;
    int index;

    /*
     * First look for a TCB that already has a connection.
     */
    index = tcbhash(lport, fport, *fhost);
    for (tcb = tcbhashtable[index]; tcb; tcb = tcb->next) {
	/*
	 * Ignoring TIMEWAIT-state TCBs here is wrong, but is
	 * apparently required for X.25 Remote Switching, where
	 * kajillions of connections are continually created and
	 * closed.  Barf.
	 */
	if ((tcb->state != CLOSED) && (tcb->state != TIMEWAIT))
	    if ((fport == tcb->foreignport) && (lport == tcb->localport) &&
		ip_match_address(&tcb->foreignhost, fhost))
		return(tcb);
    }

    /*
     * Now look for a wild listener that matches this packet.
     * We match in this order:
     *     1) TCB local port matches destination port and TCB foreign
     *        host matches source IP address.
     *     2) TCB local port matches destination port
     *     3) whatever is left matches the TCB set up by tcp_protocols()
     */
    if (!synbit)
	return(NULL);		/* only syn packets can match a wild TCB */
    wildtcb = NULL;
    for (tcb = tcbwildtable; tcb; tcb = tcb->next) {
	if (tcb->localport == lport) {
	    if (tcb->foreignhost.type != ADDR_ILLEGAL) {
		if (ip_match_address(&tcb->foreignhost, fhost))
		    return(tcb);/* best match */
	    } else {
		wildtcb = tcb;	/* might be a better match, keep looking */
	    }
	} else if (tcb->localport == 0 && wildtcb == NULL)
	    wildtcb = tcb;	/* found very wild listen - keep searching */
    } 

    /*
     * If no match was found, and if it's OK to allocate a new TCB when
     * necessary, and there are still memory in the local pool, get a
     * new TCB now.
     */
    if (wildtcb == NULL && get_new_listener && 
	(tcp_listenQ_count < tcp_listenQ_max) && 
	!(mempool_is_empty(MEMPOOL_CLASS_LOCAL))) { 
	wildtcb = tcp_create_wild_listen(stdio, 0);
	if (wildtcb) {
	    /*
	     * Set pid for tcp_protocol process as the pid for the TCB.
	     * Set TCB_INT_WAIT_ESTAB so that tcp_protocol process will
	     * be notified of state change for this TCB before it's
	     * in ESTAB state.
	     */
	    wildtcb->pid = tcp_proto_pid;
	    wildtcb->internal_flags |= TCB_INT_WAIT_ESTAB; 
	    tcp_listenQ_count++;
	}
    }

    return(wildtcb);
}

/*
 * tcb_enqueue(tcb)
 * Insert a TCB in the appropriate spot in the TCB hash table.
 * TCBs with foreignport = 0 go in the wildcard bucket.
 */

void tcb_enqueue (tcbtype *tcb)
{
    int bucket;

    if (tcb->foreignport == 0) {	/* Wild tcb ? */
	tcb->next = tcbwildtable;
	tcbwildtable = tcb;
    } else {	
	bucket = tcbhash(tcb->localport, tcb->foreignport, tcb->foreignhost);
	tcb->next = tcbhashtable[bucket];
	tcbhashtable[bucket] = tcb;
    }
}

/*
 * tcb_unqueue(tcb)
 * remove the tcb from the tcb hash table.
 */

void tcb_unqueue (tcbtype *tcb)
{
    tcbtype *pred;

    if (tcb->foreignport == 0)
	pred = (tcbtype *)&tcbwildtable;
    else
	pred = (tcbtype *)&tcbhashtable[tcbhash(tcb->localport,
				 tcb->foreignport, tcb->foreignhost)];
    while (pred->next != NULL) {
	if (pred->next == tcb) {
	    pred->next = tcb->next;
	    tcb->next = NULL;
	    return;
	}
	pred = pred->next;
    }
}

/*
 * tcb_findport(port)
 * Find a TCB with local port indicated.  This is used by uniqueport
 * to insure uniqueness.
 */

tcbtype *tcb_findport (ushort port)
{
    int i;
    tcbtype *tcb;

    tcb = tcbwildtable;
    while (tcb) {
	if (tcb->localport == port)
	    return(tcb);
	tcb = tcb->next;
    }
    for (i = 0; i < TCBHASHSIZE; i++) {
	tcb = tcbhashtable[i];
	while (tcb) {
	    if (tcb->localport == port)
		return(tcb);
	    tcb = tcb->next;
	}
    }
    return((tcbtype *)NULL);
}

/*
 * print_tcp
 * print the contents of a tcp packet, and the state of connection.  This
 * is for debug ip-tcp-packet, and should look sort of like the X.25 debugging
 */

void print_tcp (tcbtype *tcb, paktype *pak, tcptype *tcp, char dir, ushort id)
{
    char buffer[200];
    char *p = buffer;
    addrtype s, d;
    ushort sp = 0, dp = 0;
    int tl = 0;
    int ol = 0;

    if (tcplineno && (!tcb || (tcplineno != tcb->ttynum)))
	return;

    if (dir == 'I') {
	ip_extract_addr(pak, &s, SOURCE);
	ip_extract_addr(pak, &d, DESTINATION);
	sp = tcp->sourceport;
	dp = tcp->destinationport;
	tl = pak->length - (tcp->dataoffset<<2);
	ol = (tcp->dataoffset << 2) - TCPHEADERBYTES;
    } else if (tcb) {
	address_copy(&s, &tcb->foreignhost);
	address_copy(&d, &tcb->localhost);
	sp = tcp->destinationport;
	dp = tcp->sourceport;
	tl = pak->length - 
	     (IPHEADERBYTES(tcb->options) + (tcp->dataoffset << 2));
	ol = (tcp->dataoffset << 2) - TCPHEADERBYTES;
    }
    
    if (tcp_filter_debug(sp, dp, &s, &d, dir))
	return;

    p += sprintf(p, "tcp%t: %c %s", tcb ? tcb->ttynum : 0, dir, 
		 tcb ? tcp_statestring(tcb->state): "NoTCB");
    sprintf(p, " %s:%d %s:%d seq %u\n       ", address_string(&s),
	    sp, address_string(&d), dp, tcp->sequencenumber);

    buginf("\n%s", buffer);
    p = buffer;
    
    if (tl > 0)
	p += sprintf(p, " DATA %d", tl);
    if (ol > 0)
	p += sprintf(p, " OPTS %d", ol);
    if (tcp->ack)
	p += sprintf(p, " ACK %u", tcp->acknowledgementnumber);
    if (tcp->urg)
	p += sprintf(p, " URG %d", tcp->urgentpointer);
    if (tcp->fin)
	p += sprintf(p, " FIN");
    if (tcp->syn)
	p += sprintf(p, " SYN");
    if (tcp->rst)
	p += sprintf(p, " RST");
    if (tcp->psh)
	p += sprintf(p, " PSH");
    p += sprintf(p, "  WIN %d", tcp->window);
    buginf("%s", buffer);
}

/*
 * tcperror2string
 * Given an error or state code, return pointer to an error string
 */

char *tcperror2string (int error)
{
    char *fmt, *str;

    str = string_getnext();

    switch (error) {
    case NO_MEMORY:
	fmt = "Insufficient memory; try again later"; break;
    case REJECTED:
	fmt = "Connection refused by remote host"; break;
    case FOREIGN_RESET:
	fmt = "Connection reset by remote host"; break;
    case LOCAL_RESET:
	fmt = "Connection reset by user"; break;
    case TIMEDOUT:
	fmt = "Connection timed out; remote host not responding"; break;
    case ABORTED:
	fmt = "Connection aborted";  break;
    case UNREACHABLE:
	fmt = "Destination unreachable; gateway or host down";  break;
    case OPTSTOOBIG:
	fmt = "Options (source route) too big and security is on"; break;
    case CARRIER_DROP:
	fmt = "Carrier dropped"; break;
    case INUSE:
	fmt = "Address already in use"; break;
    case NO_DATA:
	fmt = "No input data available"; break;
    case END_OF_FILE:
	fmt = "End of data transfer"; break;
    case URGENT_DATA:
	fmt = "Urgent data received"; break;
    case IDLE_TIMEDOUT:
	fmt = "Inactivity timeout"; break;
    default:
	fmt = "Internal software error: %d"; break;
    }
    sprintf(str, fmt, error);
    return(str);
}    

/*
 * clear_tcp_by_tcb
 * Clears a TCP connection that matches the TCB address.
 */
boolean
clear_tcp_by_tcb (tcbtype *tcb)
{
    tcbtype *tmp_tcb;
    int i;

    for (i = 0; i < TCBHASHSIZE; i++) {
	for (tmp_tcb = tcbhashtable[i]; tmp_tcb; tmp_tcb = tmp_tcb->next) {
	    if (tmp_tcb == tcb) {
		tcp_clear_conn(tcb);
		return(TRUE);
	    }
	}
    }
    return(FALSE);
}


/*
 * clear_tcp_by_port_addr
 * Clears a TCP connection matches the local address/port and 
 * remote address/port.
 */
boolean 
clear_tcp_by_port_addr (addrtype *lhost, ushort lport, 
			addrtype *fhost, ushort fport)
{
    tcbtype *tcb;
    int index;

    index = tcbhash(lport, fport, *fhost);
    for (tcb = tcbhashtable[index]; tcb; tcb = tcb->next) {
	 if ((fport == tcb->foreignport) && (lport == tcb->localport) &&
	    ip_match_address(&tcb->localhost, lhost) &&
	    ip_match_address(&tcb->foreignhost, fhost)) {
	    tcp_clear_conn(tcb);
	    return(TRUE);
	 }
    }
    return(FALSE);
}

/*
 * clear_tcp_by_line
 * Clears a TCP connection matches the tty number. 
 */
boolean
clear_tcp_by_line (int line)
{
    conntype *conn;
    tt_soc *tty;
    int j; 

    tty = MODEMS[line];
    if (tty == NULL)
	return(FALSE);
    conn = tty->conntop;
    if (conn && conn->tcb && (conn->v == &tcp_connvector)) {
	clear_tcp_by_tcb(conn->tcb);
	return(TRUE);
    }
    for (j = 0; (conn = queuepick(&tty->connhead, j)); j++) {
	if ((conn->tcb) && (conn->v == &tcp_connvector)) {
	    clear_tcp_by_tcb(conn->tcb);
	    return(TRUE);
	}
    }
    return(FALSE);
}

/*
 * tcp_filter_debug
 * Apply the filter rules from the "debug ip tcp packet ..." command,
 * returning TRUE if the segment with the given characteristics
 * should be suppressed (not printed).
 */

boolean tcp_filter_debug (ushort sport, ushort dport,
			  addrtype *saddr, addrtype *daddr, char dir)
{
    if (dir == 'I') {
	if (tcp_dbg_dir == TCP_DIR_OUT)
	    return(TRUE);
    } else {
	if (tcp_dbg_dir == TCP_DIR_IN)
	    return(TRUE);
    }

    if (tcp_dbg_port && !(sport == tcp_dbg_port || dport == tcp_dbg_port))
	return(TRUE);

    if (tcp_dbg_addr.type != ADDR_ILLEGAL &&
	!(ip_match_address(&tcp_dbg_addr, saddr) ||
	  ip_match_address(&tcp_dbg_addr, daddr)))
	return(TRUE);

    return(FALSE);
}

/*
 * Called when router goes down gracefully to close all TCP connections
 */

static void tcp_router_reload (void)
{
    int i;
    tcbtype *tcb;

    for (i = 0; i < TCBHASHSIZE; i++)
	for (tcb = tcbhashtable[i]; tcb; tcb = tcb->next) {
	    /*
	     * Keep the memory allocated so the processes that own
	     * these TCB's won't crash in case they get rescheduled
	     * and try to work with them.
	     */
	    tcb->internal_flags |= TCB_INT_NOFREE;
	    tcp_close_statechange(tcb);
	}
}

/*
 * tcp_md5on()
 * tcp_md5digest()
 */
void tcp_md5on (tcbtype *tcb, char *password, int passwordlen)
{
    if (password && passwordlen > 0) {
	tcb->md5_keylen = min(passwordlen, sizeof(tcb->md5_key));
	tcb->flags |= TCB_MD5;
	bcopy(password, tcb->md5_key, tcb->md5_keylen);
    } else {
	tcb->flags &= ~TCB_MD5;
	tcb->md5_keylen = 0;
    }
}

void tcp_md5digest (uchar digest[MD5_LEN],
		    ipaddrtype src, ipaddrtype dst,
		    ushort zero_proto, ushort tcplen,
		    tcptype *tcp, uchar *data, uchar *key, int keylen)
{
    MD5_CTX mdcontext;
    int datalen;

    MD5Init(&mdcontext);
#ifdef TCPVERBOSE_MD5
    if (tcp_debug)
	buginf("\ndigesting pseudo-header: src %08x dst %08x proto %04x "
	       "tcplen %04x", src, dst, zero_proto, tcplen);
#endif
    MD5Update(&mdcontext, (unsigned char *) &src, sizeof(src));
    MD5Update(&mdcontext, (unsigned char *) &dst, sizeof(dst));
    MD5Update(&mdcontext, (unsigned char *) &zero_proto, sizeof(zero_proto));
    MD5Update(&mdcontext, (unsigned char *) &tcplen, sizeof(tcplen));
#ifdef TCPVERBOSE_MD5
    if (tcp_debug) {
	uchar *d = (uchar *) tcp;
	buginf("\n\tand tcp header:\n\t%02x %02x %02x %02x "
	       "%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x "
	       "%02x %02x %02x %02x",
	       d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7],
	       d[8], d[9], d[10], d[11], d[12], d[13],
	       d[14], d[15], d[16], d[17], d[18], d[19]);
    }
#endif
    MD5Update(&mdcontext, (unsigned char *) tcp, TCPHEADERBYTES);
    datalen = tcplen - (tcp->dataoffset << 2);
    if (data && datalen > 0) {
#ifdef TCPVERBOSE_MD5
	if (tcp_debug) {
	    int i;

	    buginf("\n\tand %d more bytes at %x (tcp %x): ", datalen, data, tcp);
	    for (i = 0; i < datalen; i++) {
		buginf("%02x ", data[i]);
		if ((i + 1) % 16 == 0)
		    buginf("\n");
	    }
	    if (i % 16)
		buginf("\n");
	}
#endif
	MD5Update(&mdcontext, data, datalen);
    }
#ifdef TCPVERBOSE_MD5
    if (tcp_debug)
	buginf("\n\tand key '%s'", key);
#endif
    MD5Update(&mdcontext, key, keylen);
    MD5Final(digest, &mdcontext);
}

/*
 * tcp_md5_connectionless_write
 *
 * Write an MD5 signature into a TCP segment when we have no state
 * for the connection but we need to respond with a segment carrying
 * a signature, for example, connectionless resets.
 */

boolean
tcp_md5_connectionless_write (addrtype *remote_addr, addrtype *local_addr,
			      tcptype *oldtcp, tcptype *newtcp, int len,
			      ipoptiontype *ipopts)
{
    ushort port;
    char keybuf[TCP_MAXMD5KEYLEN];
    char *password;

    /*
     * Try to figure out which port is the well-known port on which
     * the password guesser is registered.
     */
    if (oldtcp->sourceport < IPPORT_RESERVED)
	port = oldtcp->sourceport;
    else if (oldtcp->destinationport < IPPORT_RESERVED)
	port = oldtcp->destinationport;
    else
	return(FALSE);

    /*
     * Ask the application for its password.
     */
    password = reg_invoke_tcp_guess_md5_key(port, local_addr, remote_addr,
					    oldtcp->destinationport,
					    oldtcp->sourceport, keybuf,
					    TCP_MAXMD5KEYLEN);
    if (password == NULL)
	return(FALSE);

    /*
     * Write the MD5 option into the header.
     */
    newtcp->data[0] = MD5OPTION;
    newtcp->data[1] = MD5OPT_BYTES;
    tcp_md5digest(&newtcp->data[2], local_addr->ip_addr, remote_addr->ip_addr,
		  TCP_PROT, len, newtcp, NULL, password, strlen(password));
    newtcp->data[MD5OPT_BYTES] = ENDOPTIONLIST;
    newtcp->data[MD5OPT_BYTES+1] = ENDOPTIONLIST;

    return(TRUE);
}

/*
 * Options-related subroutines
 */


/*
 * tcp_findoption
 *
 * Find an option and return a pointer to it or NULL.
 */

uchar *tcp_findoption (tcptype *tcp, uchar option)
{
    uchar *data;
    int len, optlen;

    data = tcp->data;
    len = (tcp->dataoffset << 2) - TCPHEADERBYTES;
    while (len) {
	if (option == data[0]) {
	    return(data);
	} else {
	    switch (data[0]) {
	    case ENDOPTIONLIST:
		return(NULL);
	    case NOPOPTION:
		len -= 1;
		data += 1;
		break;
	    default:
		/* Sanity check the length. */
		optlen = data[1];
		if (optlen < MINTCPOPTIONLENGTH ||
		    optlen > MAXTCPOPTIONBYTES || optlen > len)
		    return(NULL);
		len -= optlen;
		data += optlen;
		break;
	    }
	}
    }

    return(NULL);
}

/*
 * tcp_optionbytes
 *
 * Return the amount of space needed for options for a particular segment.
 * Assumes our option-writing scheme of padding every option, as done
 * below in tcp_writeoption().
 */

int tcp_optionbytes (tcbtype *tcb, boolean syn)
{
    int optbytes;

    optbytes = 0;

    if (syn)
	optbytes += (MSSOPT_BYTES + 3) & ~3;
    if (tcb->flags & TCB_MD5)
	optbytes += (MD5OPT_BYTES + 3) & ~3;

    return(optbytes);
}

/*
 * tcp_startoptions
 * Initialize the context information, giving a pointer to the start
 * of the area to be filled with options.
 */

void tcp_startoptions (tcbtype *tcb, uchar *data)
{
    tcb->optstart = data;
    tcb->optbytes = 0;
}

/*
 * tcp_padoption
 * Pad to the next long word boundary with padbyte.  padbyte
 * should be either NOPOPTION or ENDOPTIONLIST.
 */

static
void tcp_padoption (tcbtype *tcb, uchar padbyte)
{
    int pad, i;

    /* Pad out to the next long word if needed. */
    if (tcb->optbytes % sizeof(ulong)) {
	pad = sizeof(ulong) - (tcb->optbytes % sizeof(ulong));
	for (i = 0; i < pad; i++) {
	    *tcb->optstart++ = padbyte;
	    tcb->optbytes++;
	}
    }
}

/*
 * tcp_writeoption
 * Write the option and its associated data into the option area
 * set up by tcp_startoptions().  Won't handle the only length-less
 * option (NOPOPTION), but could if I felt like it.
 * Note: each option starts on a long-word boundary.  If this
 * changes, tcp_optionbytes() above will need to change as well.
 */

void tcp_writeoption (tcbtype *tcb, uchar option, uchar *data, int len)
{
    /* Pad out last option with NOPs. */
    tcp_padoption(tcb, NOPOPTION);

    /* Write the option. */
    *tcb->optstart++ = option;
    *tcb->optstart++ = len + 2;
    bcopy(data, tcb->optstart, len);

    /* Update the state. */
    tcb->optstart += len;
    tcb->optbytes += 2 + len;
}

/*
 * tcp_endoptions
 * Finish writing option data, and pad out the end of the header
 * with ENDOPTIONLIST bytes.
 */

void tcp_endoptions (tcbtype *tcb)
{
    /* Pad out very last option with ENDs. */
    tcp_padoption(tcb, ENDOPTIONLIST);
}

/*
 * tcp_changercvwnd - adjust rcvwnd and complain if outside of range.
 * If the window changes from closed to open, send an ACK right now.
 */

void tcp_changercvwnd (tcbtype *tcb, int change)
{
    long rw;

    if (tcb->addwnd && change > (signed) tcb->addwnd) {
	change -= tcb->addwnd;
	tcb->addwnd = 0;
    }
    rw = tcb->rcvwnd;
    if ((rw + change) > (signed) tcb->maxrcvwnd) {
	if (tcp_debug)
	    buginf("\nTCP%t: bad arg to changercvwnd: %d to window %d, max %d",
		   tcb->ttynum, change, rw, tcb->maxrcvwnd);
	tcb->rcvwnd = tcb->maxrcvwnd;
    } else if (rw + change < 0) {
	if (tcp_debug)
	    buginf("\nTCP%t: bad arg to changercvwnd: %d to window %d",
		   tcb->ttynum, change, rw);
	tcb->rcvwnd = 0;
    } else
	tcb->rcvwnd += change;
    if (tcb->state >= CLOSEWAIT)
	return;			/* Don't send ACKs (window updates) if the */
    				/* connection is closed. (these will be only */
				/* be window updates anyway!) */
    if (tcb->rcvwnd == change)
	tcp_sendacksegment(tcb);/* rcvwnd went from 0 to change */
}

/*
 * tcp_openwindow
 * Open up the tcp window by moving any space we have not yet advertised
 * (delrcvwnd) to the real tcp window, and advertising the new window.
 */

void tcp_openwindow (tcbtype *tcb)
{
    ulong oldwnd = tcb->rcvwnd;

    if (tcb->state >= CLOSEWAIT)
	return;			/* Don't send ACKs (window updates) if the */
    				/* connection is closed. (these will be only */
				/* be window updates anyway!) */
    tcp_changercvwnd(tcb, tcb->delrcvwnd);
    tcb->delrcvwnd = 0;
    if (oldwnd)			/* tcp_changercvwnd handles old 0 window case*/
	tcp_sendacksegment(tcb);/* window changed, tell other host */
}

/*
 * tcp_addwindow
 * temporarily add some space to the receive window.  This way we can
 * offer a couple bytes of window for urgent data if we see likely typein.
 */
void tcp_addwindow (tcbtype *tcb, int change)
{
    tcb->addwnd += change;
    tcb->rcvwnd += change;
}

/*
 * tcp_selectiss
 * Selects an initial sequence number for a new connection.
 */

ulong tcp_selectiss (void)
{
    /*
     * RFC-793 wants the Initial Sequence Number to be tied to a
     * 32-bit clock whose low-order bit increments every 4ms or so.
     * The rationale is that this produces an ISN that cycles about
     * every 4.55 hours, and since this is much much greater than the
     * Maximum Segment Lifetime (2 minutes), ISN's will be unique
     * between connection instantiations.  Hrmm, well, returning a
     * 32-bit micro-second value gives us a counter that cycles every
     * 1.19 hours, which is good enough.  Besides, it's harder to
     * spoof.
     */
    return(clock_get_microsecs());
}

/*
 * tcp_retrans_sanity_check
 *
 * Sanity-check a TCB's retransmission queue.
 * Problems checked:
 *	- duplicate queue elements pointing to the same packet
 */

void tcp_retrans_sanity_check (tcbtype *tcb, paktype *pak)
{
    elementtype *el, *last, *next;

    last = NULL;
    for (el = (elementtype *) tcb->q[RETRANSQUEUE].qhead; el; el = next) {
	next = el->next;	/* el might be freed below */
	if (el->pakptr == pak && el->next != NULL) {
	    tcptype *tcp;
	    addrtype laddr, faddr;
	    paktype *prev_pak;

	    /*
	     * Found a queue element that points to the same packet
	     * just got enqueued.
	     * The following debug messages will show:
	     * . call traceback,
	     * . info for the packet with duplicated element pointers,
	     * . info for the packet queued in front of the "bad packet".
	     * . info for this TCB.
	     */
	    buginf("\n\nTCP%t: extra packet reference for pak 0x%x found: ", 
		     tcb->ttynum, pak);
	    errmsg(&msgsym(BADQUEUE, TCP), pak);
	    tcp = tcp_get_hdr(pak, tcb); 
	    ip_extract_addr(pak, &laddr, SOURCE);
	    ip_extract_addr(pak, &faddr, DESTINATION);
	    buginf("\n    pak: %s:%d, %s:%d, seq %u length %d", 
		     address_string(&laddr), tcp->sourceport, 
		     address_string(&faddr), tcp->destinationport, 
		     tcp->sequencenumber, 
		     (pak->dataptr)? 
			(pak->dataptr - pak_center(pak)):pak->length);
	    if (last) {
		tcp = tcp_get_hdr(last->pakptr, tcb);
		ip_extract_addr(last->pakptr, &laddr, SOURCE);
		ip_extract_addr(last->pakptr, &faddr, DESTINATION);
		prev_pak = last->pakptr;
		buginf("\n    prev pak: %s:%d, %s:%d, seq %u length %d", 
		     address_string(&laddr), tcp->sourceport, 
		     address_string(&faddr), tcp->destinationport, 
		     tcp->sequencenumber,
		     (prev_pak->dataptr)?
			(prev_pak->dataptr - pak_center(prev_pak)):prev_pak->length);
	    }
	    buginf("\n    TCB: %s:%d, %s:%d, sendnext %u, state %d",  
		    address_string(&tcb->localhost), tcb->localport,
		    address_string(&tcb->foreignhost), tcb->foreignport,
		    tcb->sndnxt, tcb->state);

	    /*
	     * Silently remove the first elment pointer for the packet.
	     */
	    element_dequeue(&tcb->q[RETRANSQUEUE], el);
	} else 
	    last = el;
    }
}

/*
 * tcp_wakeup_process
 * General-purpose TCB process waker-upper.
 */

void tcp_wakeup_process (tcbtype *tcb)
{
    if (tcb->pid) {
        if (tcb->internal_flags & (TCB_INT_MSG_NOTIFY | TCB_INT_WAIT_ESTAB)) {
	    /*
	     * The tcb may be freed if the state is already CLOSED
	     * when the msg is processed for the new connection.
	     * Increase the refcnt for the tcb so that it won't
	     * be freed until the last message for the tcb is
	     * processed by the tcp_protocol process.
	     */
	    if (tcb->internal_flags & TCB_INT_WAIT_ESTAB) {
		tcb->msg_refcnt++;
	    }
            process_send_message(tcb->pid, TCP_PASSTCB_MSG, tcb, 0);
	} else {
            process_wakeup(tcb->pid);
	}
    }
}

/*
 * tcp_pak_toobig
 * Search the tcb hash table and find connections using the interface
 * as first-hop-interface. Change MSS for the connections and split
 * up the old packets in retransmission queue to new maxsegmentsize.
 */
static void tcp_pak_toobig (idbtype *idb)
{
    tcbtype *tcb;
    ipaddrtype tmp_ip;
    idbtype *tmp_idb;
    ulong new_mtu;
    int overhead;
    int new_segsize;
    int i;

    new_mtu = idb->ip_mtu;
    for (i = 0; i < TCBHASHSIZE; i++) {
	for (tcb = tcbhashtable[i]; tcb; tcb = tcb->next) {
	    tmp_ip = tcb->foreignhost.ip_addr;
	    tmp_idb = reg_invoke_ip_first_hop(&tmp_ip, tmp_ip, 
					      IP_PATH_DEFFLAGS); 
	    if (tmp_idb == idb) {
		/*
		 * Found a TCP connection that uses the interface which
		 * had the MTU decrease. Adjust the MSS for the connection
		 * and split packets in retransmission queue.
		 */
		overhead = IPHEADERBYTES(tcb->options) + TCPHEADERBYTES +
			   tcp_optionbytes(tcb, FALSE);
		new_segsize = new_mtu - overhead;
		if (tcp_debug) {
		    buginf("\nTCP%t: Packet-too-big message received on"
			   " interface %s (MTU %d)", tcb->ttynum, 
			   idb->namestring, new_mtu);
		    buginf("\nTCP%t: MSS changes from %d to %d", tcb->ttynum, 
			   tcb->maxsegmentsize, new_segsize);
		}
		tcb->maxsegmentsize = tcb->sndcwnd = new_segsize;
		tcp_splinter(tcb);
		/*
		 * Start PMTUTIMEOUT timer if PMTU-discovery and pathmtu
		 * age-timer are configured on. 
		 */
		if (tcp_pmtu_on) {
		    tcp_stoptimer(tcb, PMTUTIMEOUT);
		    if (len_pathmtu_timeout)
		    	tcp_start_pmtutimer(tcb, len_pathmtu_timeout);
		    tcb->flags |= TCB_PMTUAGER;
		}
	    }
	}
    }
}

#ifdef TCPTRACE
/*
 * TCP tracing
 */

#define NUMRECS	100

struct tcp_trace_rec {
    int count;			/* record count */
    sys_timestamp time;		/* time trace record taken */
    tcptype tcp;		/* TCP header */
    ipaddrtype srcadr;		/* source IP address */
    ipaddrtype dstadr;		/* destination IP address */
    ushort id;			/* IP id */
    ulong segsize;		/* segment size */
    ulong rcvnxt;		/* TCB state */
    ulong rcvwnd;
    ulong sndwnd;
    ulong sndnxt;
    ulong sndmax;
    ulong snduna;
    ulong userdata[4];
};

static struct tcp_trace_rec tcp_trace_recs[NUMRECS];
static struct tcp_trace_rec *tcp_trace_rec = tcp_trace_recs;
static struct tcp_trace_rec *first_tcp_trace_rec = tcp_trace_recs;
static int wrapping = 0;
static int count = 0;
boolean tcp_tracing = FALSE;

void init_tcptrace (void)
{
    leveltype status;

    status = raise_interrupt_level(NETS_DISABLE);

    first_tcp_trace_rec = tcp_trace_rec = tcp_trace_recs;
    wrapping = 0;
    count = 0;

    reset_interrupt_level(status);
}

static struct tcp_trace_rec *alloc_tcp_trace_rec (void)
{
    struct tcp_trace_rec *rec;
    leveltype status;

    status = raise_interrupt_level(NETS_DISABLE);

    rec = tcp_trace_rec;
    tcp_trace_rec++;
    if (wrapping) {
	first_tcp_trace_rec++;
	if (first_tcp_trace_rec == &tcp_trace_recs[NUMRECS]) {
	    /* wrapping around */
	    first_tcp_trace_rec = tcp_trace_recs;
	}
    }
    if (tcp_trace_rec == &tcp_trace_recs[NUMRECS]) {
	/* wrapping around */
	tcp_trace_rec = tcp_trace_recs;
	wrapping = 1;
    }

    reset_interrupt_level(status);

    return(rec);
}

static void dump_tcp_trace_rec (struct tcp_trace_rec *rec)
{
    char buffer[200];
    char *p = buffer;

    printf("\n%d (%TA) -- %i:%d %i:%d seq %u (id %u)\n ",
	   rec->count, rec->time, rec->srcadr, rec->tcp.sourceport,
	   rec->dstadr, rec->tcp.destinationport,
	   rec->tcp.sequencenumber, rec->id);
    p = buffer;
    p += sprintf(p, " DATA %d", rec->segsize);
    if (rec->tcp.ack)
	p += sprintf(p, " ACK %u", rec->tcp.acknowledgementnumber);
    if (rec->tcp.urg)
	p += sprintf(p, " URG %d", rec->tcp.urgentpointer);
    if (rec->tcp.fin)
	p += sprintf(p, " FIN");
    if (rec->tcp.syn)
	p += sprintf(p, " SYN");
    if (rec->tcp.rst)
	p += sprintf(p, " RST");
    if (rec->tcp.psh)
	p += sprintf(p, " PSH");
    p += sprintf(p, "  WIN %d / sndwnd %u sndnxt %u",
		 rec->tcp.window, rec->sndwnd, rec->sndnxt);
    printf("%s", buffer);
    printf("\n  sndmax %u snduna %u rcvnxt %u rcvwnd %u", rec->sndmax,
	   rec->snduna, rec->rcvnxt, rec->rcvwnd);
    printf("\n  user %d %d %d %d", rec->userdata[0], rec->userdata[1],
	   rec->userdata[2], rec->userdata[3]);
}

void show_tcptrace(void)
{
    struct tcp_trace_rec *recs_copy;
    struct tcp_trace_rec *rec, *first_copy, *next_copy;
    leveltype status;

    printf("\nTCP tracing is %s.", tcp_tracing ? "on" : "off");

    if (count == 0)
	return;

    recs_copy = malloc(sizeof(struct tcp_trace_rec) * NUMRECS);
    if (recs_copy == NULL)
	return;

    status = raise_interrupt_level(NETS_DISABLE);
    bcopy(tcp_trace_recs, recs_copy, sizeof(struct tcp_trace_rec) * NUMRECS);
    first_copy = &recs_copy[first_tcp_trace_rec - tcp_trace_recs];
    next_copy = &recs_copy[tcp_trace_rec - tcp_trace_recs];
    reset_interrupt_level(status);

    if (first_copy < next_copy) {
	for (rec = first_copy; rec < next_copy; rec++) {
	    if (automore_quit())
		break;
	    dump_tcp_trace_rec(rec);
	}
    } else {
	for (rec = first_copy; rec < &recs_copy[NUMRECS]; rec++) {
	    if (automore_quit())
		break;
	    dump_tcp_trace_rec(rec);
	}
	for (rec = recs_copy; rec < next_copy; rec++) {
	    if (automore_quit())
		break;
	    dump_tcp_trace_rec(rec);
	}
    }

    free(recs_copy);
}

void make_tcptrace (tcbtype *tcb, tcptype *tcp, ulong segsize,
		    iphdrtype *iphead, ulong udata0, ulong udata1,
		    ulong udata2, ulong udata3)
{
    struct tcp_trace_rec *rec;

    rec = alloc_tcp_trace_rec();
    if (rec == NULL)
	return;

    rec->count = count++;
    GET_TIMESTAMP(rec->time);
    rec->tcp = *tcp;
    rec->srcadr = iphead->srcadr;
    rec->dstadr = iphead->dstadr;
    rec->id = iphead->id;
    rec->segsize = segsize;
    rec->rcvwnd = tcb->rcvwnd;
    rec->rcvnxt = tcb->rcvnxt;
    rec->sndwnd = tcb->sndwnd;
    rec->sndnxt = tcb->sndnxt;
    rec->sndmax = tcb->sndmax;
    rec->snduna = tcb->snduna;
    rec->userdata[0] = udata0;
    rec->userdata[1] = udata1;
    rec->userdata[2] = udata2;
    rec->userdata[3] = udata3;
}
#endif /* TCPTRACE */

/*
 * tcp_init
 * Initialize the TCP protocol handling.
 */

static void tcp_init (subsystype *dummy)
{
    int i;

    tcp_debug_init();
    telnet_init();

    memset(&tcp_traffic, 0, sizeof(tcp_traffic));
    for (i = 0; i < TCBHASHSIZE; i++)
	tcbhashtable[i] = NULL;
    tcbwildtable = NULL;
    GET_TIMESTAMP(NextTimeout);		/* next timer wakeup */
    tcp_portseed = random_gen();	/* seed for local port no.'s */
    tcp_chunksize = 0;
    tcp_defrcvwnd = TCP_DEFRCVWND;
    /* time driven actions */  
    tcp_timer_pid = process_create(tcp_timer, "TCP Timer", NORMAL_STACK,
				   PRIO_NORMAL);
    /* TCP servers */
    tcp_proto_pid = process_create(tcp_protocols, "TCP Protocols", 
				   LARGE_STACK, PRIO_LOW);
    tcp_listener_pid = 0;
    mgd_timer_init_parent(&tcptest_delay_timer, NULL);

    tcp_finwaittm = DEF_FINWAITTM;
    tcp_queuemax = DEF_QUEUEMAX_USER;
    tcp_synwait = DEF_SYNWAIT;
    tcp_pathmtu = DEF_PATHMTU;

    /*
     * Initialize tcp vty registries
     */
    reg_add_tcp_listen(ECHO_PORT, tcp_listen_echo_port,"tcp_listen_echo_port");
    reg_add_tcp_listen(DISCARD_PORT, tcp_listen_discard_port,
		   "tcp_listen_discard_port");
    reg_add_tcp_listen(CHARGEN_PORT, tcp_listen_chargen_port,
		   "tcp_listen_chargen_port");
    reg_add_tcp_listen(DAYTIME_PORT, tcp_listen_daytime_port,
		   "tcp_listen_daytime_port");
    reg_add_tcp_listen(FINGER_PORT, tcp_listen_finger_port,
		   "tcp_listen_finger_port");
    reg_add_default_tcp_listen(tcp_listen_default, "tcp_listen_default");
    reg_add_tcp_access_check(ECHO_PORT, tcp_access_check_small, 
			 "tcp_access_check_small");
    reg_add_tcp_access_check(DISCARD_PORT, tcp_access_check_small, 
			 "tcp_access_check_small");
    reg_add_tcp_access_check(CHARGEN_PORT, tcp_access_check_small, 
			 "tcp_access_check_small");
    reg_add_tcp_access_check(DAYTIME_PORT, tcp_access_check_small, 
			 "tcp_access_check_small");
    reg_add_tcp_access_check(FINGER_PORT, tcp_access_check_finger, 
			 "tcp_access_check_finger");
    reg_add_default_tcp_access_check(tcp_access_check_default,
				 "tcp_access_check_default");
    reg_add_ip_pak_toobig(TCP_PROT, tcp_pak_toobig, "tcp_pak_toobig");
    reg_add_ip_enqueue(TCP_PROT, tcp_inputsegment, "tcp_inputsegment");
    reg_add_ip_show_traffic(tcp_show_traffic, "tcp_show_traffic");
    reg_add_will_reload(tcp_router_reload, "tcp_router_reload");
    reg_add_ip_icmp_rcvquench(TCP_PROT, tcp_quench, "tcp_quench");
    reg_add_ip_icmp_rcvunreach(TCP_PROT, tcp_unreachable, "tcp_unreachable");

    tcptunnel_enable = DEF_TUNNEL_ENABLE;

    /*
     * Initialize TCP parser support
     */
    tcp_parser_init();

#ifdef TCPTRACE
    init_tcptrace();
#endif

    list_create(&tcp_newconn_list, 0, "TCP newconn", 0);

    tcp_ready = TRUE;
    tcpservers_max = TCP_DEFAULT_MAX_SMALL_SERVERS;
    tcpservers_current = 0;
    tvt_init();			/* init telnet protocol */
}

/*
 * tcp_get_hdr
 *
 * Return pointer to beginning of TCP transport header.
 */
tcptype *tcp_get_hdr (paktype *packet, tcbtype *tcb)
{
    iphdrtype *ip;

    /*
     * The IP header length may already have been computed if this
     * packet has already been through the IP output processing code.
     *
     * If so, the IP option length might have been increased (due to
     * extended IPSO) or decreased (due to ip security strip).  So
     * rely upon the IP header not the TCB to find the start of the
     * TCP header.
     */

    ip = iphdrtype_start(packet);

    if (ip->ihl) {
        if (!ip_secopt_bytes && (ip->ihl != 5) && tcp_debug)
            buginf("\nTCP: tcp_get_hdr: ihl %d", ip->ihl);
        return(TcpPkt(packet));
    }
    /*
     * Outgoing packet where source and destination addresses are
     * known via the TCB.
     */
    if (tcb)
	return((tcptype *) (packet->network_start +
			    IPHEADERBYTES(tcb->options))); 

    /*
     * Incoming packet where source and destination addresses are
     * obtained from packet.
     */
    return((tcptype *) ipdatastart(packet));
}    

/*
 * TCP subsystem header
 */

#define TCP_MAJVERSION 1
#define TCP_MINVERSION 0
#define TCP_EDITVERSION  1

SUBSYS_HEADER(tcp, TCP_MAJVERSION, TCP_MINVERSION, TCP_EDITVERSION,
	      tcp_init, SUBSYS_CLASS_PROTOCOL,
	      subsys_seq_iphost,
	      subsys_req_iphost);
