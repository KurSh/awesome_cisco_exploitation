/* $Id: sr_frmib.c,v 3.7.10.11 1996/09/11 16:49:44 liqin Exp $
 * $Source: /release/112/cvs/Xsys/wan/sr_frmib.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * February 1994, Chifei W. Cheng (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1995-1997 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_frmib.c,v $
 * Revision 3.7.10.11  1996/09/11  16:49:44  liqin
 * CSCdi68280:  replace malloc with malloc_named in frame relay code
 * Branch: California_branch
 *
 * Revision 3.7.10.10  1996/08/24  01:19:02  chifei
 * CSCdi66539:  Add invalid status to frCircuitState MIB
 * Branch: California_branch
 * Used "invalid" state for frCircuitState variable when the circuit's
 * status is "deleted" (which used to be presented as "inactive").
 *
 * Revision 3.7.10.9  1996/07/10  07:38:02  chifei
 * CSCdi60658:  Clear counters clears frame relay MIB objects
 * Branch: California_branch
 *
 * Revision 3.7.10.8  1996/07/03  20:44:29  thille
 * CSCdi61860: Implement Jeffs glass of slim-fast for snmp
 * Branch: California_branch
 * Take hunk of common code from many mib files, make it a procedure in
 * snmp_util.c and call it from the mibs.  Save 1640 bytes.
 *
 * Revision 3.7.10.7  1996/07/01  18:46:48  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.7.10.6  1996/05/21  10:09:59  thille
 * CSCdi51599:  multiple /interface/ literals bloat code.
 * Branch: California_branch
 * Save another 392 bytes by doing away with duplicate literals.
 *
 * Revision 3.7.10.5  1996/05/21  06:43:46  mordock
 * Branch: California_branch
 * Improve snmp modularity via creating services to register interfaces
 * and chassis cards.
 * Add syslog mib.
 *
 * Revision 3.7.10.4  1996/04/30  23:18:08  sdurham
 * CSCdi46300:  Interface missing from MIB
 * Branch: California_branch
 *          add atm and aal5 layers to the ifmib
 *
 * Revision 3.7.10.3  1996/04/25  23:24:34  ronnie
 * CSCdi55766:  Hey!  This ATM and Frame Relay is no different than in 11.1
 * Feature commit for ATM and Frame Relay into 11.2
 * Branch: California_branch
 *
 * Revision 3.7.10.2  1996/04/19  17:52:57  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.7.10.1  1996/03/18  22:48:56  gstovall
 * Branch: California_branch
 * Elvis has left the building.  He headed out to California, and took the
 * port ready changes with him.
 *
 * Revision 3.6.2.2  1996/03/16  07:56:28  gstovall
 * Branch: DeadKingOnAThrone_branch
 * Make the king aware of V111_1_3.
 *
 * Revision 3.6.2.1  1996/03/13  02:12:46  dstine
 * Branch: DeadKingOnAThrone_branch
 *         - commit IDB cleanups
 *
 * Revision 3.7  1996/02/23  21:11:54  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.6  1996/01/18  15:55:50  anke
 * CSCdi46969:  Change empty req and/or seq strings in SUBSYS_HEADERs to
 *              NULL
 *              Five bytes saved is five bytes earned
 *
 * Revision 3.5  1995/12/14  08:29:02  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.4  1995/11/18  00:22:54  jjohnson
 * CSCdi43548:  need mechanism to enable multiple traps for a subsystem
 *
 * Revision 3.3  1995/11/17  18:05:05  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.2  1995/11/17  00:50:49  gstovall
 * Ladies and gentlemen, I introduce to you, the port ready commit.
 *
 * Revision 3.1  1995/11/09  13:51:26  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.5  1995/11/08  21:36:59  shaker
 * Merge Arkansas_branch into 11.1 mainline.
 *
 * Revision 2.4  1995/08/01  16:59:42  ccpoe
 * CSCdi37323:  Frame relay not counting FECN/BECN/DE incoming when fast
 * switching. Since we don't set FECN/BECN bit unless the packet is
 * frame-relay switched, counting incoming FECN/BECN/DE suffices the
 * requirement.
 *
 * Revision 2.3  1995/07/17  07:35:33  bchan
 * CSCdi34760:  Ifindex usage incorrect
 *
 * Revision 2.2  1995/06/28  09:33:03  smackie
 * Repair widespread subsystem header braindamage. (CSCdi23568)
 *
 *   o Fix subsystem entry points to be foo(subsystype *) not foo(void)
 *   o Repair nonsensical and redundant subsystem sequences
 *   o Use NULL where no property is required
 *
 * Revision 2.1  1995/06/07  23:20:13  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1993 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include "../ui/common_strings.h"
#include "subsys.h"
#include "../snmp/snmp_api.h"
#include "sr_frmib.h"
#include "sr_frmib-mib.h"
#include "sys_registry.h"
#include "../h/interface_private.h"
#include "../h/config.h"
#include "frame_relay.h"
#include "fr_lmi.h"
#include "fr_switch.h"
#include "fr_registry.h"
#include "../snmp/snmp_registry.regh"
#include "../parser/parser_defs_snmp.h"
#include "snmp_interface.h"
#include "../snmp/ifmib_registry.h"
#include "../if/static_map.h"

static frame_relay_globals_t frame_relay_globalsData;
    
static const char *frame_relay_trap_oid = "frame_relay.0.1";

static void frDLCIStatusChange_trap(fr_pvc_info_type *fr_pvc);
static void fr_trap_cfg_nvwrt(parseinfo *csb);
static void fr_trap_cfg_set(boolean enable, uint subsys, uint traps);
static ifmib_err_t fr_subif_cntr32fn(
	  ifmib_cntr_t	ifCntr,
	  const	subiabtype *subiab,
          ulong		*retval,
	  int serialNum );

static boolean fr_admin_change(
	  enum SNMP_ADMIN_STATE	newStatus,
	  boolean		testPhase,
	  const	subiabtype      *subiab);

static frmib_pvc_stats_type stats_all_zeros;

static void fr_add_subif( idbtype *idb);
static void frmib_save_stats(fr_pvc_info_type *);


void
init_frmib (subsystype *subsys)
{
    /*
     * default value of frTrapState is to disable traps
     */
    frame_relay_globalsData.frTrapState = D_frTrapState_disabled;

    /*
     * load the frame relay mib
     */
    load_mib(frmib_OidList, frmib_OidListNum);
    load_oid(frmib_oid_table);

    /*
     * register the frame relay trap
     */
    register_snmp_trap(TRAP_FRAMERELAY, frame_relay_trap_oid);
    reg_add_Trap_cfg_set(fr_trap_cfg_set, "fr_trap_cfg_set");
    reg_add_Trap_cfg_nvwrt(fr_trap_cfg_nvwrt, "fr_trap_cfg_nvwrt");

    /*
     * register to process the clear counters command
     */
    reg_add_fr_mib_save_stats(frmib_save_stats, "frmib_save_stats");
    memset(&stats_all_zeros, 0, sizeof(frmib_pvc_stats_type));

    /*
     * register to process the frDLCIStatusChange service
     */
    reg_add_frDLCIStatusChange(frDLCIStatusChange_trap,
			       "frDLCIStatusChange_trap");
    /*
     * register to process counters for frame relay subinterfaces for
     * ifmib.
     */
    reg_add_ifmib_cntr32(D_ifType_frameRelay,fr_subif_cntr32fn,"fr_subif_cntr32fn");
    reg_add_ifmib_admin_change(D_ifType_frameRelay,fr_admin_change,"fr_admin_change");
    reg_add_ifmib_add_subif(ET_FRAME_RELAY,fr_add_subif,"fr_add_subif");
}




/*---------------------------------------------------------------------
 * Retrieve data from the frDlcmiEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *
frDlcmiEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    frDlcmiEntry_t *data;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            frDlcmiIfIndex;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &frDlcmiIfIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    data = NULL;	/* in order to compile */
    if (arg != -1) 
	if ((data = k_frDlcmiEntry_get(serialNum, contextInfo, arg, searchType, frDlcmiIfIndex)) != NULL) {
	    /*
	     * Build instance information
	     */
	    inst.oid_ptr = buffer;
	    inst.length = 1;
	    inst.oid_ptr[0] = data->frDlcmiIfIndex;
        }
	else
	    arg = -1;

    /*
     * Build the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_frDlcmiIfIndex
      case I_frDlcmiIfIndex:
	dp = &data->frDlcmiIfIndex;
	break;
#endif				       /* I_frDlcmiIfIndex */

#ifdef I_frDlcmiState
      case I_frDlcmiState:
	dp = &data->frDlcmiState;
	break;
#endif				       /* I_frDlcmiState */

#ifdef I_frDlcmiAddress
      case I_frDlcmiAddress:
	dp = &data->frDlcmiAddress;
	break;
#endif				       /* I_frDlcmiAddress */

#ifdef I_frDlcmiAddressLen
      case I_frDlcmiAddressLen:
	dp = &data->frDlcmiAddressLen;
	break;
#endif				       /* I_frDlcmiAddressLen */

#ifdef I_frDlcmiPollingInterval
      case I_frDlcmiPollingInterval:
	dp = &data->frDlcmiPollingInterval;
	break;
#endif				       /* I_frDlcmiPollingInterval */

#ifdef I_frDlcmiFullEnquiryInterval
      case I_frDlcmiFullEnquiryInterval:
	dp = &data->frDlcmiFullEnquiryInterval;
	break;
#endif				       /* I_frDlcmiFullEnquiryInterval */

#ifdef I_frDlcmiErrorThreshold
      case I_frDlcmiErrorThreshold:
	dp = &data->frDlcmiErrorThreshold;
	break;
#endif				       /* I_frDlcmiErrorThreshold */

#ifdef I_frDlcmiMonitoredEvents
      case I_frDlcmiMonitoredEvents:
	dp = &data->frDlcmiMonitoredEvents;
	break;
#endif				       /* I_frDlcmiMonitoredEvents */

#ifdef I_frDlcmiMaxSupportedVCs
      case I_frDlcmiMaxSupportedVCs:
	dp = &data->frDlcmiMaxSupportedVCs;
	break;
#endif				       /* I_frDlcmiMaxSupportedVCs */

#ifdef I_frDlcmiMulticast
      case I_frDlcmiMulticast:
	dp = &data->frDlcmiMulticast;
	break;
#endif				       /* I_frDlcmiMulticast */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the frDlcmiEntry data object.
 *---------------------------------------------------------------------*/
void
frDlcmiEntry_free(frDlcmiEntry_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after frDlcmiEntry set/undo
 *---------------------------------------------------------------------*/
static int
frDlcmiEntry_cleanup(doList_t *trash)
{
    frDlcmiEntry_free(trash->data);
#ifdef SR_SNMPv2
    frDlcmiEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Undo a previous set of the frDlcmiEntry family.
 *---------------------------------------------------------------------*/
#ifdef SR_SNMPv2
int
frDlcmiEntry_undo(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return UNDO_FAILED_ERROR;
}

#endif	/* SR_SNMPv2 */

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
frDlcmiEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    doList_t       *dp;
    int             found;
    int             carry;
    frDlcmiEntry_t *frDlcmiEntry;
    long            frDlcmiIfIndex;

    carry = 0;
    /*
     * Validate the object instance
     * 
     */
    if ((InstToInt(incoming, 0 + object->oid.length, &frDlcmiIfIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    frDlcmiEntry = k_frDlcmiEntry_get(-1, contextInfo, object->nominator, EXACT, frDlcmiIfIndex);

#ifndef frDlcmiEntry_READ_CREATE

    if (frDlcmiEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* frDlcmiEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == frDlcmiEntry_set) &&
	    (((frDlcmiEntry_t *) (dp->data)) != NULL) &&
	    (((frDlcmiEntry_t *) (dp->data))->frDlcmiIfIndex == frDlcmiIfIndex)) {
	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc_named(sizeof(frDlcmiEntry_t), "FR MIB:
DLCI Entry")) == NULL) {
	    DPRINTF((0, "snmpd: Cannot allocate memory\n"));
	    return (GEN_ERROR);
	}
	memset(dp->data, 0, sizeof(frDlcmiEntry_t));

	dp->setMethod = frDlcmiEntry_set;
	dp->cleanupMethod = frDlcmiEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = frDlcmiEntry_undo;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;
	SET_VALID(I_frDlcmiIfIndex, ((frDlcmiEntry_t *) (dp->data))->valid);
	((frDlcmiEntry_t *) (dp->data))->frDlcmiIfIndex = frDlcmiIfIndex;

#ifdef frDlcmiEntry_READ_CREATE
	/*
	 * Try to fill in reasonable default values for this new entry.
	 */
	if (frDlcmiEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, frDlcmiEntry, sizeof(frDlcmiEntry_t));
	    SET_ALL_VALID(((frDlcmiEntry_t *) (dp->data))->valid);
	} else {

	    /* Fill in default values here  */

	}
#endif				       /* frDlcmiEntry_READ_CREATE */
    }

    switch (object->nominator) {

#ifdef I_frDlcmiState
      case I_frDlcmiState:
	switch (value->sl_value) {
	case D_frDlcmiState_noLmiConfigured:
	case D_frDlcmiState_lmiRev1:	/* = Cisco LMI */
	case D_frDlcmiState_ansiT1_617_D:
	/* not supporting D_frDlcmiState_ansiT1_617_B */
	case D_frDlcmiState_ccitt_933A:	/* in draft but we support it */
	    break;
	default:
	    return(WRONG_VALUE_ERROR);
	}
	SET_VALID(I_frDlcmiState, ((frDlcmiEntry_t *) (dp->data))->valid);
	((frDlcmiEntry_t *) (dp->data))->frDlcmiState = value->sl_value;
	break;
#endif				       /* I_frDlcmiState */

#ifdef I_frDlcmiAddress
      case I_frDlcmiAddress:
	switch (value->sl_value) {
	case D_frDlcmiAddress_q922November90:
	case D_frDlcmiAddress_q922:
	    break;
	default:
	    return(WRONG_VALUE_ERROR);
	}
	break;
#endif				       /* I_frDlcmiAddress */

#ifdef I_frDlcmiAddressLen
      case I_frDlcmiAddressLen:
        if (value->sl_value != D_frDlcmiAddressLen_two_octets)	/* support only 2-byte */
	    return(WRONG_VALUE_ERROR);
	break;		/* one value; no need to change any */
#endif				       /* I_frDlcmiAddressLen */

#ifdef I_frDlcmiPollingInterval
      case I_frDlcmiPollingInterval:
        if (value->sl_value < 5 || value->sl_value > 30)
	    return(WRONG_VALUE_ERROR);
	SET_VALID(I_frDlcmiPollingInterval, ((frDlcmiEntry_t *) (dp->data))->valid);
	((frDlcmiEntry_t *) (dp->data))->frDlcmiPollingInterval = value->sl_value;
	break;
#endif				       /* I_frDlcmiPollingInterval */

#ifdef I_frDlcmiFullEnquiryInterval
      case I_frDlcmiFullEnquiryInterval:
        if (value->sl_value < 1 || value->sl_value > 255)
	    return(WRONG_VALUE_ERROR);
	SET_VALID(I_frDlcmiFullEnquiryInterval, ((frDlcmiEntry_t *) (dp->data))->valid);
	((frDlcmiEntry_t *) (dp->data))->frDlcmiFullEnquiryInterval = value->sl_value;
	break;
#endif				       /* I_frDlcmiFullEnquiryInterval */

#ifdef I_frDlcmiErrorThreshold
      case I_frDlcmiErrorThreshold:
        if (value->sl_value < 1 || value->sl_value > 10)
	    return(WRONG_VALUE_ERROR);
	SET_VALID(I_frDlcmiErrorThreshold, ((frDlcmiEntry_t *) (dp->data))->valid);
	((frDlcmiEntry_t *) (dp->data))->frDlcmiErrorThreshold = value->sl_value;
	break;
#endif				       /* I_frDlcmiErrorThreshold */

#ifdef I_frDlcmiMonitoredEvents
      case I_frDlcmiMonitoredEvents:
        if (value->sl_value < 1 || value->sl_value > 10)
	    return(WRONG_VALUE_ERROR);
	SET_VALID(I_frDlcmiMonitoredEvents, ((frDlcmiEntry_t *) (dp->data))->valid);
	((frDlcmiEntry_t *) (dp->data))->frDlcmiMonitoredEvents = value->sl_value;
	break;
#endif				       /* I_frDlcmiMonitoredEvents */

#ifdef I_frDlcmiMaxSupportedVCs
      case I_frDlcmiMaxSupportedVCs:
	return(NOT_WRITABLE_ERROR);	/* should be writable in the future */
#endif				       /* I_frDlcmiMaxSupportedVCs */

#ifdef I_frDlcmiMulticast
      case I_frDlcmiMulticast:
        if (value->sl_value != D_frDlcmiMulticast_nonBroadcast &&
	    value->sl_value != D_frDlcmiMulticast_broadcast)
	    return(WRONG_VALUE_ERROR);
	SET_VALID(I_frDlcmiMulticast, ((frDlcmiEntry_t *) (dp->data))->valid);
	((frDlcmiEntry_t *) (dp->data))->frDlcmiMulticast = value->sl_value;
	break;
#endif				       /* I_frDlcmiMulticast */

      default:
	DPRINTF((0, "snmpd: Internal error (invalid nominator in frDlcmiEntry)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
frDlcmiEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_frDlcmiEntry_set((frDlcmiEntry_t *) (doCur->data),
			       contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the frCircuitEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
frCircuitEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength;
    int             arg;
    void           *dp;
    frCircuitEntry_t *data;
    unsigned long   buffer[2];
    OID             inst;
    int             carry;
    long            frCircuitIfIndex;
    long            frCircuitDlci;

    instLength = incoming->length - object->oid.length;
    arg = object->nominator;
    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 2
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 2) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 1 + object->oid.length, &frCircuitDlci, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &frCircuitIfIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    data = NULL;	/* in order to compile */
    if (arg != -1) 
	if ((data = k_frCircuitEntry_get(serialNum, contextInfo, arg, searchType, frCircuitIfIndex, frCircuitDlci)) != NULL) {
	    /*
	     * Build instance information
	     */
	    inst.oid_ptr = buffer;
	    inst.length = 2;
	    inst.oid_ptr[0] = data->frCircuitIfIndex;
	    inst.oid_ptr[1] = data->frCircuitDlci;
        }
	else
	    arg = -1;

    /*
     * Build the the variable binding for the variable that will be returned.
     */
    switch (arg) {

#ifdef I_frCircuitIfIndex
      case I_frCircuitIfIndex:
	dp = &data->frCircuitIfIndex;
	break;
#endif				       /* I_frCircuitIfIndex */

#ifdef I_frCircuitDlci
      case I_frCircuitDlci:
	dp = &data->frCircuitDlci;
	break;
#endif				       /* I_frCircuitDlci */

#ifdef I_frCircuitState
      case I_frCircuitState:
	dp = &data->frCircuitState;
	break;
#endif				       /* I_frCircuitState */

#ifdef I_frCircuitReceivedFECNs
      case I_frCircuitReceivedFECNs:
	dp = &data->frCircuitReceivedFECNs;
	break;
#endif				       /* I_frCircuitReceivedFECNs */

#ifdef I_frCircuitReceivedBECNs
      case I_frCircuitReceivedBECNs:
	dp = &data->frCircuitReceivedBECNs;
	break;
#endif				       /* I_frCircuitReceivedBECNs */

#ifdef I_frCircuitSentFrames
      case I_frCircuitSentFrames:
	dp = &data->frCircuitSentFrames;
	break;
#endif				       /* I_frCircuitSentFrames */

#ifdef I_frCircuitSentOctets
      case I_frCircuitSentOctets:
	dp = &data->frCircuitSentOctets;
	break;
#endif				       /* I_frCircuitSentOctets */

#ifdef I_frCircuitReceivedFrames
      case I_frCircuitReceivedFrames:
	dp = &data->frCircuitReceivedFrames;
	break;
#endif				       /* I_frCircuitReceivedFrames */

#ifdef I_frCircuitReceivedOctets
      case I_frCircuitReceivedOctets:
	dp = &data->frCircuitReceivedOctets;
	break;
#endif				       /* I_frCircuitReceivedOctets */

#ifdef I_frCircuitCreationTime
      case I_frCircuitCreationTime:
	dp = &data->frCircuitCreationTime;
	break;
#endif				       /* I_frCircuitCreationTime */

#ifdef I_frCircuitLastTimeChange
      case I_frCircuitLastTimeChange:
	dp = &data->frCircuitLastTimeChange;
	break;
#endif				       /* I_frCircuitLastTimeChange */

#ifdef I_frCircuitCommittedBurst
      case I_frCircuitCommittedBurst:
	dp = &data->frCircuitCommittedBurst;
	break;
#endif				       /* I_frCircuitCommittedBurst */

#ifdef I_frCircuitExcessBurst
      case I_frCircuitExcessBurst:
	dp = &data->frCircuitExcessBurst;
	break;
#endif				       /* I_frCircuitExcessBurst */

#ifdef I_frCircuitThroughput
      case I_frCircuitThroughput:
	dp = &data->frCircuitThroughput;
	break;
#endif				       /* I_frCircuitThroughput */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

#ifdef	FR_WRITE_NOT_IMPLEMENTED

/*----------------------------------------------------------------------
 * Free the frCircuitEntry data object.
 *---------------------------------------------------------------------*/
void
frCircuitEntry_free(frCircuitEntry_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after frCircuitEntry set/undo
 *---------------------------------------------------------------------*/
static int
frCircuitEntry_cleanup(doList_t *trash)
{
    frCircuitEntry_free(trash->data);
#ifdef SR_SNMPv2
    frCircuitEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Undo a previous set of the frCircuitEntry family.
 *---------------------------------------------------------------------*/
#ifdef SR_SNMPv2
int
frCircuitEntry_undo(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return UNDO_FAILED_ERROR;
}

#endif	/* SR_SNMPv2 */

#endif	/* FR_WRITE_NOT_IMPLEMENTED */

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
frCircuitEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return(NOT_WRITABLE_ERROR);

#ifdef	FR_WRITE_NOT_IMPLEMENTED

    doList_t       *dp;
    int             found;
    int             carry;
    frCircuitEntry_t *frCircuitEntry;
    long            frCircuitIfIndex;
    long            frCircuitDlci;

    carry = 0;
    /*
     * Validate the object instance
     * 
     */

    if ((InstToInt(incoming, 0 + object->oid.length, &frCircuitIfIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, 1 + object->oid.length, &frCircuitDlci, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    frCircuitEntry = k_frCircuitEntry_get(-1, contextInfo, object->nominator, EXACT, frCircuitIfIndex, frCircuitDlci);

#ifndef frCircuitEntry_READ_CREATE

    if (frCircuitEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* frCircuitEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == frCircuitEntry_set) &&
	    (((frCircuitEntry_t *) (dp->data)) != NULL) &&
	    (((frCircuitEntry_t *) (dp->data))->frCircuitIfIndex == frCircuitIfIndex) &&
	    (((frCircuitEntry_t *) (dp->data))->frCircuitDlci == frCircuitDlci)) {
	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc_named(sizeof(frCircuitEntry_t), "FR
MIB: Circuit Entry")) == NULL) {
	    DPRINTF((0, "snmpd: Cannot allocate memory\n"));
	    return (GEN_ERROR);
	}
	memset(dp->data, 0, sizeof(frCircuitEntry_t));

	dp->setMethod = frCircuitEntry_set;
	dp->cleanupMethod = frCircuitEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = frCircuitEntry_undo;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

        SET_VALID(I_frCircuitIfIndex, ((frCircuitEntry_t *) (dp->data))->valid);
        ((frCircuitEntry_t *) (dp->data))->frCircuitIfIndex = frCircuitIfIndex;

	SET_VALID(I_frCircuitDlci, ((frCircuitEntry_t *) (dp->data))->valid);
	((frCircuitEntry_t *) (dp->data))->frCircuitDlci = frCircuitDlci;

#ifdef frCircuitEntry_READ_CREATE	/* not supporting creation -cc */

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */
	if (frCircuitEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, frCircuitEntry, sizeof(frCircuitEntry_t));
	    SET_ALL_VALID(((frCircuitEntry_t *) (dp->data))->valid);
	} else {

	    /* Fill in default values here */

	}
#endif				       /* frCircuitEntry_READ_CREATE */
    }

    switch (object->nominator) {

#ifdef I_frCircuitState
      case I_frCircuitState:
	SET_VALID(I_frCircuitState, ((frCircuitEntry_t *) (dp->data))->valid);
	((frCircuitEntry_t *) (dp->data))->frCircuitState = value->sl_value;
	break;
#endif				       /* I_frCircuitState */

#ifdef I_frCircuitCommittedBurst
      case I_frCircuitCommittedBurst:
	SET_VALID(I_frCircuitCommittedBurst, ((frCircuitEntry_t *) (dp->data))->valid);
	((frCircuitEntry_t *) (dp->data))->frCircuitCommittedBurst = value->sl_value;
	break;
#endif				       /* I_frCircuitCommittedBurst */

#ifdef I_frCircuitExcessBurst
      case I_frCircuitExcessBurst:
	SET_VALID(I_frCircuitExcessBurst, ((frCircuitEntry_t *) (dp->data))->valid);
	((frCircuitEntry_t *) (dp->data))->frCircuitExcessBurst = value->sl_value;
	break;
#endif				       /* I_frCircuitExcessBurst */

#ifdef I_frCircuitThroughput
      case I_frCircuitThroughput:
	SET_VALID(I_frCircuitThroughput, ((frCircuitEntry_t *) (dp->data))->valid);
	((frCircuitEntry_t *) (dp->data))->frCircuitThroughput = value->sl_value;
	break;
#endif				       /* I_frCircuitThroughput */

      default:
	DPRINTF((0, "snmpd: Internal error (invalid nominator in frCircuitEntry)\n"));
	return (GEN_ERROR);
    }				       /* switch */
    dp->state = ADD_MODIFY;
    return (NO_ERROR);

#endif	/* FR_WRITE_NOT_IMPLEMENTED */
}

#ifdef	FR_WRITE_NOT_IMPLEMENTED

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
frCircuitEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_frCircuitEntry_set((frCircuitEntry_t *) (doCur->data),
				 contextInfo, doCur->state));
}

#endif	/* FR_WRITE_NOT_IMPLEMENTED */

#endif				       /* SETS */


#ifdef NOT_IMPLEMENTED_TOO_EXPENSIVE

/*---------------------------------------------------------------------
 * Retrieve data from the frErrEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
frErrEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    frErrEntry_t   *data;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    int             i;
    long            frErrIfIndex;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &frErrIfIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_frErrEntry_get(serialNum, contextInfo, arg, searchType, frErrIfIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->frErrIfIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_frErrIfIndex
      case I_frErrIfIndex:
	dp = &data->frErrIfIndex;
	break;
#endif				       /* I_frErrIfIndex */

#ifdef I_frErrType
      case I_frErrType:
	dp = &data->frErrType;
	break;
#endif				       /* I_frErrType */

#ifdef I_frErrData
      case I_frErrData:
	dp = MakeOctetString(data->frErrData->octet_ptr, data->frErrData->length);
	break;
#endif				       /* I_frErrData */

#ifdef I_frErrTime
      case I_frErrTime:
	dp = &data->frErrTime;
	break;
#endif				       /* I_frErrTime */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#endif				       /* NOT_IMPLEMENTED_TOO_EXPENSIVE */



/*---------------------------------------------------------------------
 * Retrieve data from the frame_relay_globals family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *
frame_relay_globals_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             arg;
    void           *dp;
    frame_relay_globals_t *data = NULL;


    arg = snmp_scalar_instance(incoming, object, searchType);

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_frame_relay_globals_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_frTrapState
      case I_frTrapState:
	dp = &data->frTrapState;
	break;
#endif				       /* I_frTrapState */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the frame_relay_globals data object.
 *---------------------------------------------------------------------*/
void
frame_relay_globals_free(frame_relay_globals_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after frame_relay_globals set/undo
 *---------------------------------------------------------------------*/
static int
frame_relay_globals_cleanup(doList_t *trash)
{
    frame_relay_globals_free(trash->data);
#ifdef SR_SNMPv2
    frame_relay_globals_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Undo a previous set of the frame_relay_globals family.
 *---------------------------------------------------------------------*/
#ifdef SR_SNMPv2
int
frame_relay_globals_undo(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return UNDO_FAILED_ERROR;
}

#endif	/* SR_SNMPv2 */

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
frame_relay_globals_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength;
    doList_t       *dp;
    int             found;
/*    VarBind        *vb = (VarBind *) NULL;
 *    int             carry = 0;
 *    frame_relay_globals_t *frame_relay_globals; 
					-cc unused, to be removed later */

    instLength = incoming->length - object->oid.length;
    /*
     * Validate the object instance: 1) It must be of length 1  2) and the
     * instance must be 0.
     */
    if (instLength != 1 || incoming->oid_ptr[incoming->length - 1] != 0) {
	return (NO_CREATION_ERROR);
    }
    found = 0;

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc_named(sizeof(frame_relay_globals_t),
				     "FR MIB: FR Globals")) == NULL) {
	    DPRINTF((0, "snmpd: Cannot allocate memory\n"));
	    return (GEN_ERROR);
	}
	memset(dp->data, 0, sizeof(frame_relay_globals_t));

	dp->setMethod = frame_relay_globals_set;
	dp->cleanupMethod = frame_relay_globals_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = frame_relay_globals_undo;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

    }
    switch (object->nominator) {

#ifdef I_frTrapState
      case I_frTrapState:
	if (value->sl_value != D_frTrapState_enabled && value->sl_value != D_frTrapState_disabled)
	    return (WRONG_VALUE_ERROR);
	SET_VALID(I_frTrapState, ((frame_relay_globals_t *) (dp->data))->valid);
	((frame_relay_globals_t *) (dp->data))->frTrapState = value->sl_value;
	break;
#endif				       /* I_frTrapState */

      default:
	DPRINTF((0, "snmpd: Internal error (invalid nominator in frame_relay_globals)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
frame_relay_globals_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_frame_relay_globals_set((frame_relay_globals_t *) (doCur->data),
				      contextInfo, doCur->state));
}

#endif				       /* SETS */


static boolean snmp_fr_idb_tester (hwidbtype* idb, long* index2)
{
   return is_frame_relay(idb);
}
/*
 * k_frDlcmiEntry_get()
 */
frDlcmiEntry_t *
k_frDlcmiEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            frDlcmiIfIndex)
{
    static frDlcmiEntry_t frDlcmiEntryData, *frData;
    hwidbtype      *idb;
    fr_idb_struct_type *fr_idb;

    idb = ifmib_hwidb_get(serialNum, searchType, frDlcmiIfIndex,
			  snmp_fr_idb_tester, NULL);
    /*
     * Return an idb structure only if vector set for FR.
     */

    if (idb == NULL || (fr_idb = idb->frame_relay_stuff) == NULL)
	return (NULL);
    frData = &frDlcmiEntryData;
    frData->frDlcmiIfIndex = idb->snmp_if_index;

    if (!idb->nokeepalive)		/* LMI enabled */
	switch (lmi_idb->fr_lmi_type) {
	  case FR_CISCO_LMI:
	    frData->frDlcmiState = D_frDlcmiState_lmiRev1;
	    break;
	  case FR_ANSI_D:
	    frData->frDlcmiState = D_frDlcmiState_ansiT1_617_D;
	    break;
	  case FR_CCITT_LMI:
	    frData->frDlcmiState = D_frDlcmiState_ccitt_933A;
	    break;
	  default:		/* safety */
	    frData->frDlcmiState = D_frDlcmiState_unknownLmi;
	    break;
	}
    else				/* LMI disabled */
	frData->frDlcmiState = D_frDlcmiState_noLmiConfigured;

    switch (fr_idb->fr_dlci_bits) {
      case Q921_DLCI:
	frData->frDlcmiAddress = D_frDlcmiAddress_q921;
	break;
      case Q922MAR90_DLCI:
	frData->frDlcmiAddress = D_frDlcmiAddress_q922March90;
	break;
      case Q922NOV90_DLCI:
	frData->frDlcmiAddress = D_frDlcmiAddress_q922November90;
	break;
      default:
	frData->frDlcmiAddress = D_frDlcmiAddress_q922;
	break;
    }

    frData->frDlcmiAddressLen = D_frDlcmiAddressLen_two_octets;
    frData->frDlcmiPollingInterval = idb->keep_period;
    frData->frDlcmiFullEnquiryInterval = lmi_idb->fr_lmi_n391dte;
    frData->frDlcmiErrorThreshold = lmi_idb->fr_lmi_n392dte;
    frData->frDlcmiMonitoredEvents = lmi_idb->fr_lmi_n393dte;
    frData->frDlcmiMaxSupportedVCs = MAX_DLCI - MIN_DLCI + 1;

    switch (fr_idb->fr_multicast_status) {
      case FR_MULTICAST_NOTSET:
	frData->frDlcmiMulticast = D_frDlcmiMulticast_nonBroadcast;
	break;
      case FR_MULTICAST_STATIC:
      case FR_MULTICAST_DYNAMIC:
	frData->frDlcmiMulticast = D_frDlcmiMulticast_broadcast;
	break;
    }

    return (frData);
}

/*
 * k_frDlcmiEntry_set()
 */
int
k_frDlcmiEntry_set(
    frDlcmiEntry_t *data,
    ContextInfo    *contextInfo,
    int             function)
{
    hwidbtype      *idb;
    fr_idb_struct_type *fr_idb;

    idb = NULL;
    FOR_ALL_HWIDBS(idb) {
	if ((data->frDlcmiIfIndex == idb->snmp_if_index) && is_frame_relay(idb))
	    break;
    }
    if (idb == NULL || (fr_idb = idb->frame_relay_stuff) == NULL)
	return (GEN_ERROR);

#ifdef I_frDlcmiState
    if (VALID(I_frDlcmiState, data->valid))
	switch (data->frDlcmiState) {
	  case D_frDlcmiState_noLmiConfigured:
	    idb->nokeepalive = TRUE;
	    fr_lmi_set(idb, fr_idb, FR_CISCO_LMI, TRUE, FALSE);
	    break;
	  case D_frDlcmiState_lmiRev1:
	    idb->nokeepalive = FALSE;
	    fr_lmi_set(idb, fr_idb, FR_CISCO_LMI, TRUE, TRUE);
	    break;
	  case D_frDlcmiState_ansiT1_617_D:
	    idb->nokeepalive = FALSE;
	    fr_lmi_set(idb, fr_idb, FR_ANSI_D, TRUE, TRUE);
	    break;
	  case D_frDlcmiState_ccitt_933A:
	    idb->nokeepalive = FALSE;
	    fr_lmi_set(idb, fr_idb, FR_CCITT_LMI, TRUE, TRUE);
	    break;
	}
#endif

#ifdef I_frDlcmiAddress
    if (VALID(I_frDlcmiAddress, data->valid))
	fr_idb->fr_dlci_bits = FRAME_RELAY_DEFAULT_DLCI_BITS;
				/* support 10-bit DLCI only for now */
#endif

#ifdef I_frDlcmiPollingInterval
    if (VALID(I_frDlcmiPollingInterval, data->valid))
	idb->keep_period = data->frDlcmiPollingInterval;
#endif

#ifdef I_frDlcmiFullEnquiryInterval
    if (VALID(I_frDlcmiFullEnquiryInterval, data->valid))
	lmi_idb->fr_lmi_n391dte = data->frDlcmiFullEnquiryInterval;
#endif

#ifdef I_frDlcmiErrorThreshold
    if (VALID(I_frDlcmiErrorThreshold, data->valid))
	lmi_idb->fr_lmi_n392dte = data->frDlcmiErrorThreshold;
#endif

#ifdef I_frDlcmiMonitoredEvents
    if (VALID(I_frDlcmiMonitoredEvents, data->valid))
	lmi_idb->fr_lmi_n393dte = data->frDlcmiMonitoredEvents;
#endif

#ifdef I_frDlcmiMulticast
    if (VALID(I_frDlcmiMulticast, data->valid))
	switch (data->frDlcmiMulticast) {
	case D_frDlcmiMulticast_nonBroadcast:
	    fr_idb->fr_multicast_status = FR_MULTICAST_NOTSET;
	    break;
	case D_frDlcmiMulticast_broadcast:
	    if (fr_idb->fr_multicast_status != FR_MULTICAST_DYNAMIC)
                fr_idb->fr_multicast_status = FR_MULTICAST_STATIC;
            break;
	default:
	    return(GEN_ERROR);	/* safety; test routine should have blocked it */
	}
#endif

    return (NO_ERROR);
}

/* This is called by snmp_hwidb_get to get next with the dlci as the index2.
 * *index2 is returned with the dlci value if found else it is set to zero.
 * It is necessary to set to zero because this value will pass back later
 * on for the next idb. 
 */

static boolean snmp_fr_dlci_idb_tester (hwidbtype* idb, long* index2)
{
   fr_idb_struct_type *fr_idb;
   if (is_frame_relay(idb) && (fr_idb = idb->frame_relay_stuff) != NULL){
      long pvcindex = *index2;
      while (pvcindex < MAXDLCI_VALUES && fr_idb->fr_dlci_tab[pvcindex] == NULL)
           pvcindex++;
      if (fr_idb->fr_dlci_tab[pvcindex] != NULL){
          *index2 = pvcindex;
          return TRUE;
      }
   }
   return FALSE;
}

/*
 * fr_find_nli
 *	-- search the nli list for the one associated with this dlci
 */
static fr_svc_nli_type *fr_find_nli (
	fr_idb_struct_type *fr_idb,
	ushort dlci)
{
    fr_svc_nli_type *nli;

    for (nli = fr_idb->nli_flink; nli; nli = nli->flink) {
	if (nli->dlci == dlci)
	    return (nli);
	if (nli == fr_idb->nli_blink)
	    break;
    }
    return (NULL);
}

/*
 * k_frCircuitEntry_get()
 *	-- return NULL means no-such error
 */
frCircuitEntry_t *
k_frCircuitEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            frCircuitIfIndex,
    long            frCircuitDlci)
{
    static frCircuitEntry_t frCircuitEntryData;
    hwidbtype *idb;
    fr_idb_struct_type *fr_idb;
    fr_pvc_info_type *fr_pvc;
    long pvcindex;
    frmib_pvc_stats_type *save;
    fr_pvc_stats_type *stats;
    fr_params_type *fr_params = NULL;
    mapclass_type *fr_mapclass;
    fr_svc_nli_type *nli;
    struct fr_svc_params *svc_params = NULL;

#define FR_NO_VALUE 0	/* no matching internal value; not configured */

    fr_idb = NULL;
    fr_pvc = NULL;
    pvcindex = frCircuitDlci;

    idb = ifmib_2indices_get(serialNum, searchType,frCircuitIfIndex,
			     snmp_fr_dlci_idb_tester, &pvcindex);
    /*
     * Normal path here is to check only whether idb is NULL or not.
     * Extra safety checks are added to ensure we get good idb and pvcindex,
     * just in case that an invalid hwidb or pvcindex is returned.
     *
     */
    if (is_frame_relay(idb) == FALSE || (idb->status & IDB_DELETED) ||
	!(fr_idb = idb->frame_relay_stuff) ||
	(pvcindex > MAXDLCI_VALUES) || (pvcindex < MIN_DLCI) ||
	!(fr_pvc = fr_idb->fr_dlci_tab[pvcindex]))
	return (NULL);

    frCircuitEntryData.frCircuitIfIndex = idb->snmp_if_index;
    frCircuitEntryData.frCircuitDlci = pvcindex;

    frCircuitEntryData.frCircuitState = 
	IS_PVC_ACTIVE_BIT_SET(fr_pvc->pvc_status)?
	D_frCircuitState_active : (IS_DLCI_DELETED(fr_pvc->pvc_status)?
			D_frCircuitState_invalid : D_frCircuitState_inactive);
    stats = &fr_pvc->pvc_stats;
    save = (frmib_pvc_stats_type *)fr_pvc->stats_save;
    if (!save)
	save = &stats_all_zeros;
    frCircuitEntryData.frCircuitReceivedFECNs =
	fr_pvc_input_fecn_pkts(stats) + save->in_fecn_sav;
    frCircuitEntryData.frCircuitReceivedBECNs =
	fr_pvc_input_becn_pkts(stats) + save->in_becn_sav;
    frCircuitEntryData.frCircuitSentFrames =
	fr_pvc_output_pkts(stats) + save->out_pkts_sav;
    frCircuitEntryData.frCircuitSentOctets =
	fr_pvc_output_bytes(stats) + save->out_bytes_sav;
    frCircuitEntryData.frCircuitReceivedFrames =
	fr_pvc_input_pkts(stats) + save->in_pkts_sav;
    frCircuitEntryData.frCircuitReceivedOctets =
	fr_pvc_input_bytes(stats) + save->in_bytes_sav;
    frCircuitEntryData.frCircuitCreationTime =
	SNMP_ABSOLUTE_TIME(fr_pvc->pvc_create_time);
    frCircuitEntryData.frCircuitLastTimeChange =
	SNMP_ABSOLUTE_TIME(fr_pvc->pvc_change_time);

    frCircuitEntryData.frCircuitCommittedBurst = FR_NO_VALUE;
    frCircuitEntryData.frCircuitExcessBurst = FR_NO_VALUE;
    frCircuitEntryData.frCircuitThroughput = FR_NO_VALUE;
    fr_params = NULL;
    if (fr_pvc->pvc_type == SVC_DYNAMIC) {	/* svc */
	svc_params = NULL;
	if ((nli = fr_find_nli(fr_idb, pvcindex))) {
	    svc_params = (nli->in_params) ? nli->in_params : nli->map_params;
		/* get the negotiated params if it exists */
	}
	if (svc_params) {
	    frCircuitEntryData.frCircuitCommittedBurst = 
		fr_svc_get_exponential((svc_params->out_cbs << 3),
				svc_params->out_cbs_mag);
	    frCircuitEntryData.frCircuitExcessBurst =
		fr_svc_get_exponential((svc_params->out_ebs << 3),
				svc_params->inc_ebs_mag);
	    frCircuitEntryData.frCircuitThroughput =
		fr_svc_get_exponential(svc_params->out_cir_mult,
				svc_params->out_cir_mag);
	}
    } else {	/* pvc */
	if (fr_pvc->pvc_class)
	    fr_params = fr_pvc->pvc_class->params;
	if (!fr_params) {
	    reg_invoke_fr_find_mapclass(fr_pvc, &fr_mapclass);
	    if (fr_mapclass)
		fr_params = fr_mapclass->params;
	}
	if (fr_params) {
	    frCircuitEntryData.frCircuitCommittedBurst = 
		fr_params->vcq_params->fr_peak_rate;
	    frCircuitEntryData.frCircuitExcessBurst =
		idb->firstsw->visible_bandwidth * 1000;	/* = line speed */
	    frCircuitEntryData.frCircuitThroughput =
		fr_params->vcq_params->fr_ave_rate;
	}
    }

    return (&frCircuitEntryData);
}

int
k_frCircuitEntry_set(
    frCircuitEntry_t *data,
    ContextInfo    *contextInfo,
    int             function)
{
    hwidbtype      *idb;
    fr_idb_struct_type *fr_idb;
    fr_pvc_info_type *fr_pvc;

    idb = NULL;
    fr_idb = NULL;
    fr_pvc = NULL;
    if (!data)
	return (GEN_ERROR);	/* safety */
    FOR_ALL_HWIDBS(idb) {
        if ((data->frCircuitIfIndex == idb->snmp_if_index) && is_frame_relay(idb))
            break;
    }
    if (!idb || !(fr_idb = idb->frame_relay_stuff)
	     || !(fr_pvc = fr_idb->fr_dlci_tab[data->frCircuitDlci]))
        return (GEN_ERROR);

/* -cc not supported as in current 9.21/10 versions, but may be modified soon..

#ifdef I_frCircuitState
    if (VALID(I_frCircuitState, data->valid))
        fr_pvc->pvc_status = data->frCircuitState;
#endif

#ifdef I_frCircuitCommittedBurst
    if (VALID(I_frCircuitCommittedBurst, data->valid))
	;
#endif
#ifdef I_frCircuitExcessBurst
    if (VALID(I_frCircuitExcessBurst, data->valid))
	;
#endif
#ifdef I_frCircuitThroughput
    if (VALID(I_frCircuitThroughput, data->valid))
	;
#endif
 -cc */

    return (NO_ERROR);
}


#ifdef NOT_IMPLEMENTED_TOO_EXPENSIVE

frErrEntry_t   *
k_frErrEntry_get(serialNum, contextInfo, nominator, searchType, frErrIfIndex)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
    int             searchType;
    long            frErrIfIndex;
{
    static frErrEntry_t frErrEntryData;

#ifdef NOT_YET
    frErrEntryData.frErrIfIndex =;
    frErrEntryData.frErrType =;
    frErrEntryData.frErrData =;
    frErrEntryData.frErrTime =;

    return (&frErrEntryData);
#else				       /* NOT_YET */
    return (NULL);
#endif				       /* NOT_YET */
}

#endif	/* NOT_IMPLEMENTED_TOO_EXPENSIVE */



frame_relay_globals_t *
k_frame_relay_globals_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator)
{
    return (&frame_relay_globalsData);
}

int
k_frame_relay_globals_set(
    frame_relay_globals_t *data,
    ContextInfo    *contextInfo,
    int             function)
{
#ifdef I_frTrapState
    if (VALID(I_frTrapState, data->valid))
	frame_relay_globalsData.frTrapState = data->frTrapState;
#endif
    return(NO_ERROR);
}

/*
 * fr_trap_cfg_nvwrt -- set the frTrapState through config cmd
 */
static void
fr_trap_cfg_nvwrt (parseinfo *csb)
{
    if (frame_relay_globalsData.frTrapState == D_frTrapState_enabled)
	nv_write(TRUE, "%s traps frame-relay", csb->nv_command);
}

/*
 * fr_trap_cfg_set -- set the frTrapState through config cmd
 */
static void
fr_trap_cfg_set (boolean enable, uint subsys, uint traps)
{
    if ((subsys & (1 << TRAP_FRAMERELAY)))
	frame_relay_globalsData.frTrapState = enable ?
	    D_frTrapState_enabled : D_frTrapState_disabled;
}


/*
         frDLCIStatusChange TRAP-TYPE
             ENTERPRISE frame-relay
             VARIABLES  { frCircuitIfIndex, frCircuitDlci, frCircuitState }
             DESCRIPTION
                "This trap indicates that the indicated Virtual
                Circuit  has changed state.  It has either been
                created or invalidated, or has toggled  between
                the active and inactive states."
             ::= 1
*/
#define TRAP_VARBIND_COUNT 3
#define FR_TRAP_NUMBER 1

static const OID frame_relayOID = {LNframe_relay, (ulong *)IDframe_relay};
static const OID frame_relayVBs[TRAP_VARBIND_COUNT] = {
    {LNfrCircuitIfIndex, (ulong *)IDfrCircuitIfIndex},
    {LNfrCircuitDlci, (ulong *)IDfrCircuitDlci},
    {LNfrCircuitState, (ulong *)IDfrCircuitState}};

void
frDLCIStatusChange_trap (fr_pvc_info_type *fr_pvc)
{
    int		vbIndex;
    OID	       *vbList[TRAP_VARBIND_COUNT+1];
    OID		instanceOID;
    ulong	instance[2];

    /*
     * don't do anything if frame relay traps are disabled
     */
    if (frame_relay_globalsData.frTrapState == D_frTrapState_disabled)
	return;

    /*
     * All the trap varbind objects have an instance described by
     * INDEX { frCircuitIfIndex, frCircuitDlci }
     */
    instance[0] = fr_pvc->idb->hwptr->snmp_if_index;
    instance[1] = fr_pvc->this_dlci;
    instanceOID.oid_ptr = instance;
    instanceOID.length = 2;

    /*
     * create the varbind list
     */
    for (vbIndex = 0; vbIndex < TRAP_VARBIND_COUNT; vbIndex++) {
	vbList[vbIndex] = CatOID((OID *) &frame_relayVBs[vbIndex],
					    &instanceOID);
    }
    vbList[vbIndex] = NULL;

    /*
     * tell snmp to do something
     */
    snmp_trap(ENTERPRISE_TRAP, FR_TRAP_NUMBER, vbList,
	      (OID *)&frame_relayOID, (char *)frame_relay_trap_oid);

    /*
     * free data allocated by the CatOID service
     */
    for (vbIndex = 0; vbIndex < TRAP_VARBIND_COUNT; vbIndex++) {
	FreeOID(vbList[vbIndex]);
    }
}



static ifmib_err_t fr_subif_cntr32fn (
	  ifmib_cntr_t	ifCntr,
	  const	subiabtype *subiab,
          ulong		*retval,
	  int     serialNum)
/* 
 * get the specified ifEntry or ifXEntry counter 
 * INPUTS:
 *	ifCntr == enum of specific counter requested
 *	if_ptr == r/o pointer to IDB for this interface
 *      serialNum == passed in from getrequest for caching
 * OUTPUTS:
 *	*retval == the returned counter value
 * RETURNS:
 *	return status
 *
 *  this routine needed to support subinterfaces in ifmib
 */

{
    fr_idb_struct_type *fr_idb = NULL;
    fr_pvc_info_type *fr_pvc = NULL;
    uint  thispvc;
    boolean pvc_found = FALSE;
    const snmpifptrtype *if_ptr;

    if_ptr = &subiab->master_ptr;
    *retval = 0;
   if ((if_ptr) && (if_ptr->ifptr.swidb) && (if_ptr->ifptr.swidb->hwptr))
       fr_idb = if_ptr->ifptr.swidb->hwptr->frame_relay_stuff;
    if (!fr_idb)
	return(IF_CNTR_NOT_AVAIL);

    for (thispvc = 0; thispvc < MAXDLCI; thispvc++) {
	fr_pvc = fr_idb->fr_dlci_tab[thispvc];
        if (fr_pvc && (if_ptr->ifptr.swidb ==  fr_pvc->idb)) {
	    pvc_found = TRUE;
	    switch (ifCntr) {
	    case IN_OCTETS_CNTR:
		*retval += fr_pvc->pvc_stats.num_bytes_rcv + fr_pvc->pvc_stats.num_fast_bytes_rcv;
		break;

	    case OUT_OCTETS_CNTR:
		*retval += fr_pvc->pvc_stats.num_bytes_send + fr_pvc->pvc_stats.num_fast_bytes_send;
		break;

  /*
   * these are separated because they should be supported for a
   * conformant agent, but aren't available in the router yet
   */
	    case IN_ERRORS_CNTR:
	    case IN_UNK_PROTOS_CNTR:
	    case OUT_ERRORS_CNTR:
  
	    case IN_UCAST_CNTR:
	    case IN_DISCARDS_CNTR:
	    case OUT_UCAST_CNTR:
	    case OUT_DISCARDS_CNTR:
	    case IN_BCAST_CNTR:			/* ifXTable */
	    case IN_MCAST_CNTR:
	    case OUT_BCAST_CNTR:
	    case OUT_MCAST_CNTR:
	    default:
		return(IF_CNTR_NOT_AVAIL);
		
	    }
	}
    }
    if (pvc_found)
	return (IF_NO_ERR);
    else 
	return(IF_CNTR_NOT_AVAIL);
}


static boolean fr_admin_change (
	  enum SNMP_ADMIN_STATE	newStatus,
	  boolean		testPhase,
	  const	subiabtype      *subiab)

/*
 * support function for changing ifAdminStatus - correct api wrapper
 * around fr_set_subif_state() routine.
 *
 * LOG-IF-MIB ifAdminStatus change callback function.
 * INPUTS:
 *     newStatus == requested new value of ifAdminStatus
 *		     this must be different than the current value
 *     testPhase == TRUE if this the value is being checked
 *                   in the test phase of PDU processing
 *		     FALSE if the change should take effect now
 *     if_ptr == r/o pointer to IDB for this interface
 * RETURNS:
 *   TRUE if the change is allowed by LOG-IF-MIB
 *       if testPhase == TRUE:
 *          upon exit, ifAdminStatus has not changed.       
 *       if testPhase == FALSE:
 *	    upon exit, the new value of ifAdminStatus is in effect
 *  FALSE if LOG-IF-MIB is rejecting the requested change
 *       upon exit, ifAdminStatus has not changed.
 */ 

{

    uchar newstate;

   /*
    * convert to subif state enum
    */
    switch ( newStatus) {
    case D_ifAdminStatus_down:
	newstate = SUBIF_STATE_ADMINDOWN;
	break;

    case D_ifAdminStatus_up:
	newstate = SUBIF_STATE_UP;
	break;
    default:
	return FALSE;

    }

    if (!testPhase)
	fr_set_subif_state(subiab->master_ptr.ifptr.swidb, FR_FORCE_STATE,
			   newstate);

    return TRUE;
}

static void fr_add_subif (idbtype *idb)
{
    snmpifptrtype if_ptr;
    ulong state;
    snmpidbtype *snmpidb = NULL;    
    subiabtype  *subiab;
    boolean result;

    if((idb == NULL) || (idb->subif_state & SUBIF_STATE_DELETED)) {
	return;
    }

    if (idb->snmp_if_index) 
	snmpidb =  ifmib_snmpidb_get(NULL,0,EXACT,idb->snmp_if_index,NULL,NULL);

    if (snmpidb != NULL)
	return;

    subiab = malloc(sizeof(subiabtype));
    if (!subiab)
	return;

    subiab->master_ptr.ifptr.swidb = idb;
    subiab->master_type = SNMP_IF_SWIDB;
    if_ptr.ifptr.subiab = subiab;

    subiab->data_ptr = NULL;
    subiab->cleaner = NULL;

    state = reg_invoke_ifmib_get_adminstatus(D_ifType_frameRelay, subiab);
    
    subiab->snmp_if_index = 0; 	/*uint  ifIndex */
    subiab->if_descrstring = idb->namestring;
    subiab->if_name = idb->short_namestring;
    subiab->ifPhysAddr = 0;
    subiab->ifPhysAddrLen = NULL; 
    subiab->ifType = D_ifType_frameRelay;
    subiab->maxmtu = (ushort *)(&idb->sub_mtu)+1;
    result = reg_invoke_ifmib_register_subif(&if_ptr, SNMP_IF_SUBIAB, state);
    if (!result) {
	free(subiab);
	return;
    }

    /* 
     * now add the link to the ifmib stack table
     */
    reg_invoke_ifmib_create_stacklink(idb->snmp_if_index,idb->hwptr->snmp_if_index);

}

/*
 * frmib_save_stats() - save pvc statistics at clear counters command
 */
static void frmib_save_stats (fr_pvc_info_type *pvc)
{
    frmib_pvc_stats_type *save;
    fr_pvc_stats_type *stats;

    save = (frmib_pvc_stats_type *)pvc->stats_save;
    if (!save) {
	(ulong)save = pvc->stats_save =
		(ulong)malloc_named(sizeof(frmib_pvc_stats_type), "FR
MIB: PVC Stats");
	memset(save, 0, sizeof(frmib_pvc_stats_type));
    }
    if (save) {
	stats = &pvc->pvc_stats;
	save->in_pkts_sav += fr_pvc_input_pkts(stats);
	save->out_pkts_sav += fr_pvc_output_pkts(stats);
	save->in_bytes_sav += fr_pvc_input_bytes(stats);
	save->out_bytes_sav += fr_pvc_output_bytes(stats);
	save->in_fecn_sav += fr_pvc_input_fecn_pkts(stats);
	save->in_becn_sav += fr_pvc_input_becn_pkts(stats);
    }
}

/*
 * frmib subsystem header
 */

#define MAJVERSION_frmib 1
#define MINVERSION_frmib 0
#define EDITVERSION_frmib 0

SUBSYS_HEADER(frmib,
              MAJVERSION_frmib,
              MINVERSION_frmib,
              EDITVERSION_frmib,
              init_frmib,
              SUBSYS_CLASS_MANAGEMENT,
              "req: frame_relay",
              NULL);
      
