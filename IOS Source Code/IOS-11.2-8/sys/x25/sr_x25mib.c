/* $Id: sr_x25mib.c,v 3.7.10.7 1996/07/03 20:44:44 thille Exp $
 * $Source: /release/112/cvs/Xsys/x25/sr_x25mib.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * April 1994, Nicholas Thille (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1994-1997 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_x25mib.c,v $
 * Revision 3.7.10.7  1996/07/03  20:44:44  thille
 * CSCdi61860: Implement Jeffs glass of slim-fast for snmp
 * Branch: California_branch
 * Take hunk of common code from many mib files, make it a procedure in
 * snmp_util.c and call it from the mibs.  Save 1640 bytes.
 *
 * Revision 3.7.10.6  1996/07/01  18:46:58  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.7.10.5  1996/05/21  10:10:39  thille
 * CSCdi51599:  multiple /interface/ literals bloat code.
 * Branch: California_branch
 * Save another 392 bytes by doing away with duplicate literals.
 *
 * Revision 3.7.10.4  1996/05/21  06:44:31  mordock
 * Branch: California_branch
 * Improve snmp modularity via creating services to register interfaces
 * and chassis cards.
 * Add syslog mib.
 *
 * Revision 3.7.10.3  1996/04/30  23:18:37  sdurham
 * CSCdi46300:  Interface missing from MIB
 * Branch: California_branch
 *          add atm and aal5 layers to the ifmib
 *
 * Revision 3.7.10.2  1996/04/19  17:54:05  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.7.10.1  1996/03/18  22:49:50  gstovall
 * Branch: California_branch
 * Elvis has left the building.  He headed out to California, and took the
 * port ready changes with him.
 *
 * Revision 3.5.2.3  1996/03/16  07:57:22  gstovall
 * Branch: DeadKingOnAThrone_branch
 * Make the king aware of V111_1_3.
 *
 * Revision 3.5.2.2  1996/03/13  02:13:16  dstine
 * Branch: DeadKingOnAThrone_branch
 *         - commit IDB cleanups
 *
 * Revision 3.5.2.1  1996/02/20  21:55:32  dstine
 * Branch: DeadKingOnAThrone_branch
 *           Sync from DeadKingOnAThrone_baseline_960122 to
 *                     DeadKingOnAThrone_baseline_960213
 *
 * Revision 3.7  1996/02/26  19:43:29  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.6  1996/02/01  06:12:59  hampton
 * Migrate files out of the parser directory.  [CSCdi47717]
 *   Step 2: Change all files which reference the moved parser files to
 *   point to their new locations.
 *
 * Revision 3.5  1996/01/18  15:57:09  anke
 * CSCdi46969:  Change empty req and/or seq strings in SUBSYS_HEADERs to
 *              NULL
 *              Five bytes saved is five bytes earned
 *
 * Revision 3.4  1995/12/14  08:29:30  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.3  1995/11/17  18:06:56  hampton
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.2  1995/11/17  00:51:46  gstovall
 * Ladies and gentlemen, I introduce to you, the port ready commit.
 *
 * Revision 3.1  1995/11/09  13:53:09  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.4  1995/11/08  21:37:19  shaker
 * Merge Arkansas_branch into 11.1 mainline.
 *
 * Revision 2.3  1995/07/17  07:35:16  bchan
 * CSCdi34760:  Ifindex usage incorrect
 *
 * Revision 2.2  1995/06/28  09:33:21  smackie
 * Repair widespread subsystem header braindamage. (CSCdi23568)
 *
 *   o Fix subsystem entry points to be foo(subsystype *) not foo(void)
 *   o Repair nonsensical and redundant subsystem sequences
 *   o Use NULL where no property is required
 *
 * Revision 2.1  1995/06/07  23:21:39  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1993 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include "../ui/common_strings.h"
#include "subsys.h"
#include "../snmp/snmp_api.h"
#include "sr_x25mib.h"
#include "sr_x25mib-mib.h"
#include "snmp_interface.h"
#include "../snmp/snmp_trap_fe.h"

#include "interface_private.h"
#include "lapb.h"
#include "x25.h"
#include "x25_switch.h"
#include "x25_address.h"
#include "x25_registry.h"
#include "parser_defs_x25.h"
#include "registry.h"
#include "../snmp/snmp_registry.regh"
#include "../parser/parser_defs_snmp.h"
#include "../snmp/ifmib_registry.h"

static const ulong nullOIDstr[] = { 0, 0, 0 };
static OID         x25nullOID = { (sizeof(nullOIDstr) / sizeof(long)),
				      (ulong *)&nullOIDstr };

static       OID   x25ProtocolVersionSupported;
static const OID   x25enterprise = {LNx25, (ulong *)IDx25};

static const char restart_trap_oid[] = "x25.0.1";
static const char reset_trap_oid[] = "x25.0.2";

/*
 * looking ahead...
 */
static void generate_x25Restart_trap(hwidbtype *idb);
static void generate_x25Reset_trap(lcitype *lci);

static ifmib_err_t x25_subif_cntr32fn(
	  ifmib_cntr_t	ifCntr,
	  const	subiabtype *subiab,
          ulong		*retval,
	  int serialNum );

static void x25_add_subif(idbtype *idb);

void init_x25mib (subsystype *subsys)
{
    load_mib(x25mib_OidList, x25mib_OidListNum);
    load_oid(x25mib_oid_table);
    register_snmp_trap(TRAP_X25, restart_trap_oid);
    register_snmp_trap(TRAP_X25, reset_trap_oid);

    reg_add_x25Restart_event(generate_x25Restart_trap,
			     "generate_x25Restart_trap");
    reg_add_x25Reset_event(generate_x25Reset_trap,
			   "generate_x25Reset_trap");

    /*
     * register to process counters for x25subinterfaces for ifmib.
     */

    reg_add_ifmib_cntr32(D_ifType_ddnX25,x25_subif_cntr32fn,"x25_subif_cntr32fn");
    reg_add_ifmib_cntr32(D_ifType_rfc877x25,x25_subif_cntr32fn,"x25_subif_cntr32fn");

    reg_add_ifmib_add_subif(ET_X25,x25_add_subif,"x25_add_subif");

    x25ProtocolVersionSupported.oid_ptr = (ulong *)&IDx25protocolCcittV1984;
    x25ProtocolVersionSupported.length = LNx25protocolCcittV1984;
}








/*---------------------------------------------------------------------
 * Retrieve data from the x25 family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *x25_get (OID         *incoming, 
                  ObjectInfo  *object, 
		  int          searchType, 
		  ContextInfo *contextInfo, 
		  int          serialNum)
{
    int             arg;
    void           *dp;
    x25_t          *data = NULL;


    arg = snmp_scalar_instance(incoming, object, searchType);

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_x25_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_x25ClearedCircuitEntriesRequested
      case I_x25ClearedCircuitEntriesRequested:
	dp = &data->x25ClearedCircuitEntriesRequested;
	break;
#endif				       /* I_x25ClearedCircuitEntriesRequested */

#ifdef I_x25ClearedCircuitEntriesGranted
      case I_x25ClearedCircuitEntriesGranted:
	dp = &data->x25ClearedCircuitEntriesGranted;
	break;
#endif				       /* I_x25ClearedCircuitEntriesGranted */

      default:
	return(NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the x25 data object.
 *---------------------------------------------------------------------*/
void x25_free (x25_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after x25 set/undo
 *---------------------------------------------------------------------*/
static int x25_cleanup (doList_t *trash)
{
    x25_free(trash->data);
#ifdef SR_SNMPv2
    x25_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Undo a previous set of the x25 family.
 *---------------------------------------------------------------------*/
#ifdef SR_SNMPv2
int x25_undo (doList_t    *doHead,
	      doList_t    *doCur,
	      ContextInfo *contextInfo)
{
    return UNDO_FAILED_ERROR;
}

#endif	/* SR_SNMPv2 */

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int x25_test (OID          *incoming,
	      ObjectInfo   *object,
	      ObjectSyntax *value,
	      doList_t     *doHead,
	      doList_t     *doCur,
	      ContextInfo  *contextInfo)
{
    int             instLength;
    doList_t       *dp;
    VarBind        *vb;
    int             found;
    int             carry;


    instLength = incoming->length - object->oid.length;
    vb =  NULL;
    carry = 0;

    /*
     * Validate the object instance: 1) It must be of length 1  2) and the
     * instance must be 0.
     */
    if (instLength != 1 || incoming->oid_ptr[incoming->length - 1] != 0) {
	return (NO_CREATION_ERROR);
    }
    found = 0;

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(x25_t))) == NULL) {
	    DPRINTF((0, "snmpd: Cannot allocate memory\n"));
	    return (GEN_ERROR);
	}
	memset(dp->data, 0, sizeof(x25_t));

	dp->setMethod = x25_set;
	dp->cleanupMethod = x25_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = x25_undo;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

    }
    switch (object->nominator) {

#ifdef I_x25ClearedCircuitEntriesRequested
      case I_x25ClearedCircuitEntriesRequested:

	SET_VALID(I_x25ClearedCircuitEntriesRequested, ((x25_t *) (dp->data))->valid);

	((x25_t *) (dp->data))->x25ClearedCircuitEntriesRequested = value->sl_value;
	break;
#endif				       /* I_x25ClearedCircuitEntriesRequested */

      default:
	DPRINTF((0, "snmpd: Internal error (invalid nominator in x25)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int x25_set (doList_t    *doHead,
	     doList_t    *doCur,
	     ContextInfo *contextInfo)
{
    return (k_x25_set((x25_t *) (doCur->data),
		      contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the x25AdmnEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *x25AdmnEntry_get (OID         *incoming,
			   ObjectInfo  *object,
			   int          searchType,
			   ContextInfo *contextInfo,
			   int          serialNum)
{
    int             instLength;
    int             arg;
    void           *dp;
    x25AdmnEntry_t *data;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            x25AdmnIndex;

    instLength = incoming->length - object->oid.length;
    arg = object->nominator;
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return(NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &x25AdmnIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_x25AdmnEntry_get(serialNum, contextInfo, arg, searchType, x25AdmnIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->x25AdmnIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_x25AdmnIndex
      case I_x25AdmnIndex:
	dp = &data->x25AdmnIndex;
	break;
#endif				       /* I_x25AdmnIndex */

#ifdef I_x25AdmnInterfaceMode
      case I_x25AdmnInterfaceMode:
	dp = &data->x25AdmnInterfaceMode;
	break;
#endif				       /* I_x25AdmnInterfaceMode */

#ifdef I_x25AdmnMaxActiveCircuits
      case I_x25AdmnMaxActiveCircuits:
	dp = &data->x25AdmnMaxActiveCircuits;
	break;
#endif				       /* I_x25AdmnMaxActiveCircuits */

#ifdef I_x25AdmnPacketSequencing
      case I_x25AdmnPacketSequencing:
	dp = &data->x25AdmnPacketSequencing;
	break;
#endif				       /* I_x25AdmnPacketSequencing */

#ifdef I_x25AdmnRestartTimer
      case I_x25AdmnRestartTimer:
	dp = &data->x25AdmnRestartTimer;
	break;
#endif				       /* I_x25AdmnRestartTimer */

#ifdef I_x25AdmnCallTimer
      case I_x25AdmnCallTimer:
	dp = &data->x25AdmnCallTimer;
	break;
#endif				       /* I_x25AdmnCallTimer */

#ifdef I_x25AdmnResetTimer
      case I_x25AdmnResetTimer:
	dp = &data->x25AdmnResetTimer;
	break;
#endif				       /* I_x25AdmnResetTimer */

#ifdef I_x25AdmnClearTimer
      case I_x25AdmnClearTimer:
	dp = &data->x25AdmnClearTimer;
	break;
#endif				       /* I_x25AdmnClearTimer */

#ifdef I_x25AdmnWindowTimer
      case I_x25AdmnWindowTimer:
	dp = &data->x25AdmnWindowTimer;
	break;
#endif				       /* I_x25AdmnWindowTimer */

#ifdef I_x25AdmnDataRxmtTimer
      case I_x25AdmnDataRxmtTimer:
	dp = &data->x25AdmnDataRxmtTimer;
	break;
#endif				       /* I_x25AdmnDataRxmtTimer */

#ifdef I_x25AdmnInterruptTimer
      case I_x25AdmnInterruptTimer:
	dp = &data->x25AdmnInterruptTimer;
	break;
#endif				       /* I_x25AdmnInterruptTimer */

#ifdef I_x25AdmnRejectTimer
      case I_x25AdmnRejectTimer:
	dp = &data->x25AdmnRejectTimer;
	break;
#endif				       /* I_x25AdmnRejectTimer */

#ifdef I_x25AdmnRegistrationRequestTimer
      case I_x25AdmnRegistrationRequestTimer:
	dp = &data->x25AdmnRegistrationRequestTimer;
	break;
#endif				       /* I_x25AdmnRegistrationRequestTimer */

#ifdef I_x25AdmnMinimumRecallTimer
      case I_x25AdmnMinimumRecallTimer:
	dp = &data->x25AdmnMinimumRecallTimer;
	break;
#endif				       /* I_x25AdmnMinimumRecallTimer */

#ifdef I_x25AdmnRestartCount
      case I_x25AdmnRestartCount:
	dp = &data->x25AdmnRestartCount;
	break;
#endif				       /* I_x25AdmnRestartCount */

#ifdef I_x25AdmnResetCount
      case I_x25AdmnResetCount:
	dp = &data->x25AdmnResetCount;
	break;
#endif				       /* I_x25AdmnResetCount */

#ifdef I_x25AdmnClearCount
      case I_x25AdmnClearCount:
	dp = &data->x25AdmnClearCount;
	break;
#endif				       /* I_x25AdmnClearCount */

#ifdef I_x25AdmnDataRxmtCount
      case I_x25AdmnDataRxmtCount:
	dp = &data->x25AdmnDataRxmtCount;
	break;
#endif				       /* I_x25AdmnDataRxmtCount */

#ifdef I_x25AdmnRejectCount
      case I_x25AdmnRejectCount:
	dp = &data->x25AdmnRejectCount;
	break;
#endif				       /* I_x25AdmnRejectCount */

#ifdef I_x25AdmnRegistrationRequestCount
      case I_x25AdmnRegistrationRequestCount:
	dp = &data->x25AdmnRegistrationRequestCount;
	break;
#endif				       /* I_x25AdmnRegistrationRequestCount */

#ifdef I_x25AdmnNumberPVCs
      case I_x25AdmnNumberPVCs:
	dp = &data->x25AdmnNumberPVCs;
	break;
#endif				       /* I_x25AdmnNumberPVCs */

#ifdef I_x25AdmnDefCallParamId
      case I_x25AdmnDefCallParamId:
	dp = MakeOID(data->x25AdmnDefCallParamId->oid_ptr, data->x25AdmnDefCallParamId->length);
	break;
#endif				       /* I_x25AdmnDefCallParamId */

#ifdef I_x25AdmnLocalAddress
      case I_x25AdmnLocalAddress:
	dp = MakeOctetString(data->x25AdmnLocalAddress->octet_ptr, data->x25AdmnLocalAddress->length);
	break;
#endif				       /* I_x25AdmnLocalAddress */

#ifdef I_x25AdmnProtocolVersionSupported
      case I_x25AdmnProtocolVersionSupported:
	dp = MakeOID(data->x25AdmnProtocolVersionSupported->oid_ptr, data->x25AdmnProtocolVersionSupported->length);
	break;
#endif				       /* I_x25AdmnProtocolVersionSupported */

      default:
	return(NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the x25AdmnEntry data object.
 *---------------------------------------------------------------------*/
void x25AdmnEntry_free (x25AdmnEntry_t *data)
{
    if (data != NULL) {
	if (data->x25AdmnDefCallParamId != NULL) {
	    FreeOID(data->x25AdmnDefCallParamId);
	}
	if (data->x25AdmnLocalAddress != NULL) {
	    FreeOctetString(data->x25AdmnLocalAddress);
	}
	if (data->x25AdmnProtocolVersionSupported != NULL) {
	    FreeOID(data->x25AdmnProtocolVersionSupported);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after x25AdmnEntry set/undo
 *---------------------------------------------------------------------*/
static int x25AdmnEntry_cleanup (doList_t *trash)
{
    x25AdmnEntry_free(trash->data);
#ifdef SR_SNMPv2
    x25AdmnEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Undo a previous set of the x25AdmnEntry family.
 *---------------------------------------------------------------------*/
#ifdef SR_SNMPv2
int x25AdmnEntry_undo (doList_t    *doHead,
		       doList_t    *doCur,
		       ContextInfo *contextInfo)
{
    return UNDO_FAILED_ERROR;
}

#endif	/* SR_SNMPv2 */

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int x25AdmnEntry_test (OID          *incoming,
		       ObjectInfo   *object,
		       ObjectSyntax *value,
		       doList_t     *doHead,
		       doList_t     *doCur,
		       ContextInfo  *contextInfo)
{
    int             instLength;
    doList_t       *dp;
    VarBind        *vb;
    int             found;
    int             carry;
    x25AdmnEntry_t *x25AdmnEntry;
    long            x25AdmnIndex;

    instLength = incoming->length - object->oid.length;
    vb =  NULL;
    carry = 0;

    /*
     * Validate the object instance
     * 
     */

    if ((InstToInt(incoming, 0 + object->oid.length, &x25AdmnIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    x25AdmnEntry = k_x25AdmnEntry_get(-1, contextInfo, object->nominator, EXACT, x25AdmnIndex);

#ifndef x25AdmnEntry_READ_CREATE

    if (x25AdmnEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* x25AdmnEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == x25AdmnEntry_set) &&
	    (((x25AdmnEntry_t *) (dp->data)) != NULL) &&
	  (((x25AdmnEntry_t *) (dp->data))->x25AdmnIndex == x25AdmnIndex)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(x25AdmnEntry_t))) == NULL) {
	    DPRINTF((0, "snmpd: Cannot allocate memory\n"));
	    return (GEN_ERROR);
	}
	memset(dp->data, 0, sizeof(x25AdmnEntry_t));

	dp->setMethod = x25AdmnEntry_set;
	dp->cleanupMethod = x25AdmnEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = x25AdmnEntry_undo;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_x25AdmnIndex, ((x25AdmnEntry_t *) (dp->data))->valid);
	((x25AdmnEntry_t *) (dp->data))->x25AdmnIndex = x25AdmnIndex;

#ifdef x25AdmnEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (x25AdmnEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, x25AdmnEntry, sizeof(x25AdmnEntry_t));

	    SET_ALL_VALID(((x25AdmnEntry_t *) (dp->data))->valid);

	    ((x25AdmnEntry_t *) (dp->data))->x25AdmnDefCallParamId =
		CloneOID(value->oid_value);


	    ((x25AdmnEntry_t *) (dp->data))->x25AdmnLocalAddress =
		CloneOctetString(value->os_value);


	    ((x25AdmnEntry_t *) (dp->data))->x25AdmnProtocolVersionSupported =
		CloneOID(value->oid_value);


	} else {


	    /* Fill in default values here */


	}
#endif				       /* x25AdmnEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_x25AdmnInterfaceMode
      case I_x25AdmnInterfaceMode:

	SET_VALID(I_x25AdmnInterfaceMode, ((x25AdmnEntry_t *) (dp->data))->valid);

	((x25AdmnEntry_t *) (dp->data))->x25AdmnInterfaceMode = value->sl_value;
	break;
#endif				       /* I_x25AdmnInterfaceMode */

#ifdef I_x25AdmnMaxActiveCircuits
      case I_x25AdmnMaxActiveCircuits:

	SET_VALID(I_x25AdmnMaxActiveCircuits, ((x25AdmnEntry_t *) (dp->data))->valid);

	((x25AdmnEntry_t *) (dp->data))->x25AdmnMaxActiveCircuits = value->sl_value;
	break;
#endif				       /* I_x25AdmnMaxActiveCircuits */

#ifdef I_x25AdmnPacketSequencing
      case I_x25AdmnPacketSequencing:

	SET_VALID(I_x25AdmnPacketSequencing, ((x25AdmnEntry_t *) (dp->data))->valid);

	((x25AdmnEntry_t *) (dp->data))->x25AdmnPacketSequencing = value->sl_value;
	break;
#endif				       /* I_x25AdmnPacketSequencing */

#ifdef I_x25AdmnRestartTimer
      case I_x25AdmnRestartTimer:

	SET_VALID(I_x25AdmnRestartTimer, ((x25AdmnEntry_t *) (dp->data))->valid);

	((x25AdmnEntry_t *) (dp->data))->x25AdmnRestartTimer = value->sl_value;
	break;
#endif				       /* I_x25AdmnRestartTimer */

#ifdef I_x25AdmnCallTimer
      case I_x25AdmnCallTimer:

	SET_VALID(I_x25AdmnCallTimer, ((x25AdmnEntry_t *) (dp->data))->valid);

	((x25AdmnEntry_t *) (dp->data))->x25AdmnCallTimer = value->sl_value;
	break;
#endif				       /* I_x25AdmnCallTimer */

#ifdef I_x25AdmnResetTimer
      case I_x25AdmnResetTimer:

	SET_VALID(I_x25AdmnResetTimer, ((x25AdmnEntry_t *) (dp->data))->valid);

	((x25AdmnEntry_t *) (dp->data))->x25AdmnResetTimer = value->sl_value;
	break;
#endif				       /* I_x25AdmnResetTimer */

#ifdef I_x25AdmnClearTimer
      case I_x25AdmnClearTimer:

	SET_VALID(I_x25AdmnClearTimer, ((x25AdmnEntry_t *) (dp->data))->valid);

	((x25AdmnEntry_t *) (dp->data))->x25AdmnClearTimer = value->sl_value;
	break;
#endif				       /* I_x25AdmnClearTimer */

#ifdef I_x25AdmnWindowTimer
      case I_x25AdmnWindowTimer:

	SET_VALID(I_x25AdmnWindowTimer, ((x25AdmnEntry_t *) (dp->data))->valid);

	((x25AdmnEntry_t *) (dp->data))->x25AdmnWindowTimer = value->sl_value;
	break;
#endif				       /* I_x25AdmnWindowTimer */

#ifdef I_x25AdmnDataRxmtTimer
      case I_x25AdmnDataRxmtTimer:

	SET_VALID(I_x25AdmnDataRxmtTimer, ((x25AdmnEntry_t *) (dp->data))->valid);

	((x25AdmnEntry_t *) (dp->data))->x25AdmnDataRxmtTimer = value->sl_value;
	break;
#endif				       /* I_x25AdmnDataRxmtTimer */

#ifdef I_x25AdmnInterruptTimer
      case I_x25AdmnInterruptTimer:

	SET_VALID(I_x25AdmnInterruptTimer, ((x25AdmnEntry_t *) (dp->data))->valid);

	((x25AdmnEntry_t *) (dp->data))->x25AdmnInterruptTimer = value->sl_value;
	break;
#endif				       /* I_x25AdmnInterruptTimer */

#ifdef I_x25AdmnRejectTimer
      case I_x25AdmnRejectTimer:

	SET_VALID(I_x25AdmnRejectTimer, ((x25AdmnEntry_t *) (dp->data))->valid);

	((x25AdmnEntry_t *) (dp->data))->x25AdmnRejectTimer = value->sl_value;
	break;
#endif				       /* I_x25AdmnRejectTimer */

#ifdef I_x25AdmnRegistrationRequestTimer
      case I_x25AdmnRegistrationRequestTimer:

	SET_VALID(I_x25AdmnRegistrationRequestTimer, ((x25AdmnEntry_t *) (dp->data))->valid);

	((x25AdmnEntry_t *) (dp->data))->x25AdmnRegistrationRequestTimer = value->sl_value;
	break;
#endif				       /* I_x25AdmnRegistrationRequestTimer */

#ifdef I_x25AdmnMinimumRecallTimer
      case I_x25AdmnMinimumRecallTimer:

	SET_VALID(I_x25AdmnMinimumRecallTimer, ((x25AdmnEntry_t *) (dp->data))->valid);

	((x25AdmnEntry_t *) (dp->data))->x25AdmnMinimumRecallTimer = value->sl_value;
	break;
#endif				       /* I_x25AdmnMinimumRecallTimer */

#ifdef I_x25AdmnRestartCount
      case I_x25AdmnRestartCount:

	SET_VALID(I_x25AdmnRestartCount, ((x25AdmnEntry_t *) (dp->data))->valid);

	((x25AdmnEntry_t *) (dp->data))->x25AdmnRestartCount = value->sl_value;
	break;
#endif				       /* I_x25AdmnRestartCount */

#ifdef I_x25AdmnResetCount
      case I_x25AdmnResetCount:

	SET_VALID(I_x25AdmnResetCount, ((x25AdmnEntry_t *) (dp->data))->valid);

	((x25AdmnEntry_t *) (dp->data))->x25AdmnResetCount = value->sl_value;
	break;
#endif				       /* I_x25AdmnResetCount */

#ifdef I_x25AdmnClearCount
      case I_x25AdmnClearCount:

	SET_VALID(I_x25AdmnClearCount, ((x25AdmnEntry_t *) (dp->data))->valid);

	((x25AdmnEntry_t *) (dp->data))->x25AdmnClearCount = value->sl_value;
	break;
#endif				       /* I_x25AdmnClearCount */

#ifdef I_x25AdmnDataRxmtCount
      case I_x25AdmnDataRxmtCount:

	SET_VALID(I_x25AdmnDataRxmtCount, ((x25AdmnEntry_t *) (dp->data))->valid);

	((x25AdmnEntry_t *) (dp->data))->x25AdmnDataRxmtCount = value->sl_value;
	break;
#endif				       /* I_x25AdmnDataRxmtCount */

#ifdef I_x25AdmnRejectCount
      case I_x25AdmnRejectCount:

	SET_VALID(I_x25AdmnRejectCount, ((x25AdmnEntry_t *) (dp->data))->valid);

	((x25AdmnEntry_t *) (dp->data))->x25AdmnRejectCount = value->sl_value;
	break;
#endif				       /* I_x25AdmnRejectCount */

#ifdef I_x25AdmnRegistrationRequestCount
      case I_x25AdmnRegistrationRequestCount:

	SET_VALID(I_x25AdmnRegistrationRequestCount, ((x25AdmnEntry_t *) (dp->data))->valid);

	((x25AdmnEntry_t *) (dp->data))->x25AdmnRegistrationRequestCount = value->sl_value;
	break;
#endif				       /* I_x25AdmnRegistrationRequestCount */

#ifdef I_x25AdmnNumberPVCs
      case I_x25AdmnNumberPVCs:

	SET_VALID(I_x25AdmnNumberPVCs, ((x25AdmnEntry_t *) (dp->data))->valid);

	((x25AdmnEntry_t *) (dp->data))->x25AdmnNumberPVCs = value->sl_value;
	break;
#endif				       /* I_x25AdmnNumberPVCs */

#ifdef I_x25AdmnDefCallParamId
      case I_x25AdmnDefCallParamId:

	SET_VALID(I_x25AdmnDefCallParamId, ((x25AdmnEntry_t *) (dp->data))->valid);

	if (((x25AdmnEntry_t *) (dp->data))->x25AdmnDefCallParamId != NULL) {
	    FreeOID(((x25AdmnEntry_t *) (dp->data))->x25AdmnDefCallParamId);
	}
	((x25AdmnEntry_t *) (dp->data))->x25AdmnDefCallParamId =
	    MakeOID(value->oid_value->oid_ptr, value->oid_value->length);

	break;
#endif				       /* I_x25AdmnDefCallParamId */

#ifdef I_x25AdmnLocalAddress
      case I_x25AdmnLocalAddress:

	SET_VALID(I_x25AdmnLocalAddress, ((x25AdmnEntry_t *) (dp->data))->valid);

	if (((x25AdmnEntry_t *) (dp->data))->x25AdmnLocalAddress != NULL) {
	    FreeOctetString(((x25AdmnEntry_t *) (dp->data))->x25AdmnLocalAddress);
	}
	((x25AdmnEntry_t *) (dp->data))->x25AdmnLocalAddress =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_x25AdmnLocalAddress */

#ifdef I_x25AdmnProtocolVersionSupported
      case I_x25AdmnProtocolVersionSupported:

	SET_VALID(I_x25AdmnProtocolVersionSupported, ((x25AdmnEntry_t *) (dp->data))->valid);

	if (((x25AdmnEntry_t *) (dp->data))->x25AdmnProtocolVersionSupported != NULL) {
	    FreeOID(((x25AdmnEntry_t *) (dp->data))->x25AdmnProtocolVersionSupported);
	}
	((x25AdmnEntry_t *) (dp->data))->x25AdmnProtocolVersionSupported =
	    MakeOID(value->oid_value->oid_ptr, value->oid_value->length);

	break;
#endif				       /* I_x25AdmnProtocolVersionSupported */

      default:
	DPRINTF((0, "snmpd: Internal error (invalid nominator in x25AdmnEntry)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int x25AdmnEntry_set (doList_t    *doHead,
		      doList_t    *doCur,
		      ContextInfo *contextInfo)
{
    return (k_x25AdmnEntry_set((x25AdmnEntry_t *) (doCur->data),
			       contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the x25OperEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *x25OperEntry_get (OID         *incoming,
			   ObjectInfo  *object,
			   int          searchType,
			   ContextInfo *contextInfo,
			   int          serialNum)
{
    int             instLength;
    int             arg;
    void           *dp;
    x25OperEntry_t *data;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            x25OperIndex;

    instLength = incoming->length - object->oid.length;
    arg = object->nominator;
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return(NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &x25OperIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_x25OperEntry_get(serialNum, contextInfo, arg, searchType, x25OperIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->x25OperIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_x25OperIndex
      case I_x25OperIndex:
	dp = &data->x25OperIndex;
	break;
#endif				       /* I_x25OperIndex */

#ifdef I_x25OperInterfaceMode
      case I_x25OperInterfaceMode:
	dp = &data->x25OperInterfaceMode;
	break;
#endif				       /* I_x25OperInterfaceMode */

#ifdef I_x25OperMaxActiveCircuits
      case I_x25OperMaxActiveCircuits:
	dp = &data->x25OperMaxActiveCircuits;
	break;
#endif				       /* I_x25OperMaxActiveCircuits */

#ifdef I_x25OperPacketSequencing
      case I_x25OperPacketSequencing:
	dp = &data->x25OperPacketSequencing;
	break;
#endif				       /* I_x25OperPacketSequencing */

#ifdef I_x25OperRestartTimer
      case I_x25OperRestartTimer:
	dp = &data->x25OperRestartTimer;
	break;
#endif				       /* I_x25OperRestartTimer */

#ifdef I_x25OperCallTimer
      case I_x25OperCallTimer:
	dp = &data->x25OperCallTimer;
	break;
#endif				       /* I_x25OperCallTimer */

#ifdef I_x25OperResetTimer
      case I_x25OperResetTimer:
	dp = &data->x25OperResetTimer;
	break;
#endif				       /* I_x25OperResetTimer */

#ifdef I_x25OperClearTimer
      case I_x25OperClearTimer:
	dp = &data->x25OperClearTimer;
	break;
#endif				       /* I_x25OperClearTimer */

#ifdef I_x25OperWindowTimer
      case I_x25OperWindowTimer:
	dp = &data->x25OperWindowTimer;
	break;
#endif				       /* I_x25OperWindowTimer */

#ifdef I_x25OperDataRxmtTimer
      case I_x25OperDataRxmtTimer:
	dp = &data->x25OperDataRxmtTimer;
	break;
#endif				       /* I_x25OperDataRxmtTimer */

#ifdef I_x25OperInterruptTimer
      case I_x25OperInterruptTimer:
	dp = &data->x25OperInterruptTimer;
	break;
#endif				       /* I_x25OperInterruptTimer */

#ifdef I_x25OperRejectTimer
      case I_x25OperRejectTimer:
	dp = &data->x25OperRejectTimer;
	break;
#endif				       /* I_x25OperRejectTimer */

#ifdef I_x25OperRegistrationRequestTimer
      case I_x25OperRegistrationRequestTimer:
	dp = &data->x25OperRegistrationRequestTimer;
	break;
#endif				       /* I_x25OperRegistrationRequestTimer */

#ifdef I_x25OperMinimumRecallTimer
      case I_x25OperMinimumRecallTimer:
	dp = &data->x25OperMinimumRecallTimer;
	break;
#endif				       /* I_x25OperMinimumRecallTimer */

#ifdef I_x25OperRestartCount
      case I_x25OperRestartCount:
	dp = &data->x25OperRestartCount;
	break;
#endif				       /* I_x25OperRestartCount */

#ifdef I_x25OperResetCount
      case I_x25OperResetCount:
	dp = &data->x25OperResetCount;
	break;
#endif				       /* I_x25OperResetCount */

#ifdef I_x25OperClearCount
      case I_x25OperClearCount:
	dp = &data->x25OperClearCount;
	break;
#endif				       /* I_x25OperClearCount */

#ifdef I_x25OperDataRxmtCount
      case I_x25OperDataRxmtCount:
	dp = &data->x25OperDataRxmtCount;
	break;
#endif				       /* I_x25OperDataRxmtCount */

#ifdef I_x25OperRejectCount
      case I_x25OperRejectCount:
	dp = &data->x25OperRejectCount;
	break;
#endif				       /* I_x25OperRejectCount */

#ifdef I_x25OperRegistrationRequestCount
      case I_x25OperRegistrationRequestCount:
	dp = &data->x25OperRegistrationRequestCount;
	break;
#endif				       /* I_x25OperRegistrationRequestCount */

#ifdef I_x25OperNumberPVCs
      case I_x25OperNumberPVCs:
	dp = &data->x25OperNumberPVCs;
	break;
#endif				       /* I_x25OperNumberPVCs */

#ifdef I_x25OperDefCallParamId
      case I_x25OperDefCallParamId:
	dp = MakeOID(data->x25OperDefCallParamId->oid_ptr, data->x25OperDefCallParamId->length);
	break;
#endif				       /* I_x25OperDefCallParamId */

#ifdef I_x25OperLocalAddress
      case I_x25OperLocalAddress:
	dp = MakeOctetString(data->x25OperLocalAddress->octet_ptr, data->x25OperLocalAddress->length);
	break;
#endif				       /* I_x25OperLocalAddress */

#ifdef I_x25OperDataLinkId
      case I_x25OperDataLinkId:
	dp = MakeOID(data->x25OperDataLinkId->oid_ptr, data->x25OperDataLinkId->length);
	break;
#endif				       /* I_x25OperDataLinkId */

#ifdef I_x25OperProtocolVersionSupported
      case I_x25OperProtocolVersionSupported:
	dp = MakeOID(data->x25OperProtocolVersionSupported->oid_ptr, data->x25OperProtocolVersionSupported->length);
	break;
#endif				       /* I_x25OperProtocolVersionSupported */

      default:
	return(NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the x25StatEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *x25StatEntry_get (OID         *incoming,
			   ObjectInfo  *object,
			   int          searchType,
			   ContextInfo *contextInfo,
			   int          serialNum)
{
    int             instLength;
    int             arg;
    void           *dp;
    x25StatEntry_t *data;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            x25StatIndex;

    instLength = incoming->length - object->oid.length;
    arg = object->nominator;
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return(NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &x25StatIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_x25StatEntry_get(serialNum, contextInfo, arg, searchType, x25StatIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->x25StatIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_x25StatIndex
      case I_x25StatIndex:
	dp = &data->x25StatIndex;
	break;
#endif				       /* I_x25StatIndex */

#ifdef I_x25StatInCalls
      case I_x25StatInCalls:
	dp = &data->x25StatInCalls;
	break;
#endif				       /* I_x25StatInCalls */

#ifdef I_x25StatInCallRefusals
      case I_x25StatInCallRefusals:
	dp = &data->x25StatInCallRefusals;
	break;
#endif				       /* I_x25StatInCallRefusals */

#ifdef I_x25StatInProviderInitiatedClears
      case I_x25StatInProviderInitiatedClears:
	dp = &data->x25StatInProviderInitiatedClears;
	break;
#endif				       /* I_x25StatInProviderInitiatedClears */

#ifdef I_x25StatInRemotelyInitiatedResets
      case I_x25StatInRemotelyInitiatedResets:
	dp = &data->x25StatInRemotelyInitiatedResets;
	break;
#endif				       /* I_x25StatInRemotelyInitiatedResets */

#ifdef I_x25StatInProviderInitiatedResets
      case I_x25StatInProviderInitiatedResets:
	dp = &data->x25StatInProviderInitiatedResets;
	break;
#endif				       /* I_x25StatInProviderInitiatedResets */

#ifdef I_x25StatInRestarts
      case I_x25StatInRestarts:
	dp = &data->x25StatInRestarts;
	break;
#endif				       /* I_x25StatInRestarts */

#ifdef I_x25StatInDataPackets
      case I_x25StatInDataPackets:
	dp = &data->x25StatInDataPackets;
	break;
#endif				       /* I_x25StatInDataPackets */

#ifdef I_x25StatInAccusedOfProtocolErrors
      case I_x25StatInAccusedOfProtocolErrors:
	dp = &data->x25StatInAccusedOfProtocolErrors;
	break;
#endif				       /* I_x25StatInAccusedOfProtocolErrors */

#ifdef I_x25StatInInterrupts
      case I_x25StatInInterrupts:
	dp = &data->x25StatInInterrupts;
	break;
#endif				       /* I_x25StatInInterrupts */

#ifdef I_x25StatOutCallAttempts
      case I_x25StatOutCallAttempts:
	dp = &data->x25StatOutCallAttempts;
	break;
#endif				       /* I_x25StatOutCallAttempts */

#ifdef I_x25StatOutCallFailures
      case I_x25StatOutCallFailures:
	dp = &data->x25StatOutCallFailures;
	break;
#endif				       /* I_x25StatOutCallFailures */

#ifdef I_x25StatOutInterrupts
      case I_x25StatOutInterrupts:
	dp = &data->x25StatOutInterrupts;
	break;
#endif				       /* I_x25StatOutInterrupts */

#ifdef I_x25StatOutDataPackets
      case I_x25StatOutDataPackets:
	dp = &data->x25StatOutDataPackets;
	break;
#endif				       /* I_x25StatOutDataPackets */

#ifdef I_x25StatOutgoingCircuits
      case I_x25StatOutgoingCircuits:
	dp = &data->x25StatOutgoingCircuits;
	break;
#endif				       /* I_x25StatOutgoingCircuits */

#ifdef I_x25StatIncomingCircuits
      case I_x25StatIncomingCircuits:
	dp = &data->x25StatIncomingCircuits;
	break;
#endif				       /* I_x25StatIncomingCircuits */

#ifdef I_x25StatTwowayCircuits
      case I_x25StatTwowayCircuits:
	dp = &data->x25StatTwowayCircuits;
	break;
#endif				       /* I_x25StatTwowayCircuits */

#ifdef I_x25StatRestartTimeouts
      case I_x25StatRestartTimeouts:
	dp = &data->x25StatRestartTimeouts;
	break;
#endif				       /* I_x25StatRestartTimeouts */

#ifdef I_x25StatCallTimeouts
      case I_x25StatCallTimeouts:
	dp = &data->x25StatCallTimeouts;
	break;
#endif				       /* I_x25StatCallTimeouts */

#ifdef I_x25StatResetTimeouts
      case I_x25StatResetTimeouts:
	dp = &data->x25StatResetTimeouts;
	break;
#endif				       /* I_x25StatResetTimeouts */

#ifdef I_x25StatClearTimeouts
      case I_x25StatClearTimeouts:
	dp = &data->x25StatClearTimeouts;
	break;
#endif				       /* I_x25StatClearTimeouts */

#ifdef I_x25StatDataRxmtTimeouts
      case I_x25StatDataRxmtTimeouts:
	dp = &data->x25StatDataRxmtTimeouts;
	break;
#endif				       /* I_x25StatDataRxmtTimeouts */

#ifdef I_x25StatInterruptTimeouts
      case I_x25StatInterruptTimeouts:
	dp = &data->x25StatInterruptTimeouts;
	break;
#endif				       /* I_x25StatInterruptTimeouts */

#ifdef I_x25StatRetryCountExceededs
      case I_x25StatRetryCountExceededs:
	dp = &data->x25StatRetryCountExceededs;
	break;
#endif				       /* I_x25StatRetryCountExceededs */

#ifdef I_x25StatClearCountExceededs
      case I_x25StatClearCountExceededs:
	dp = &data->x25StatClearCountExceededs;
	break;
#endif				       /* I_x25StatClearCountExceededs */

      default:
	return(NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the x25ChannelEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *x25ChannelEntry_get (OID         *incoming,
			      ObjectInfo  *object,
			      int          searchType,
			      ContextInfo *contextInfo,
			      int          serialNum)
{
    int             instLength;
    int             arg;
    void           *dp;
    x25ChannelEntry_t *data;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            x25ChannelIndex;

    instLength = incoming->length - object->oid.length;
    arg = object->nominator;
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return(NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &x25ChannelIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_x25ChannelEntry_get(serialNum, contextInfo, arg, searchType, x25ChannelIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->x25ChannelIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_x25ChannelIndex
      case I_x25ChannelIndex:
	dp = &data->x25ChannelIndex;
	break;
#endif				       /* I_x25ChannelIndex */

#ifdef I_x25ChannelLIC
      case I_x25ChannelLIC:
	dp = &data->x25ChannelLIC;
	break;
#endif				       /* I_x25ChannelLIC */

#ifdef I_x25ChannelHIC
      case I_x25ChannelHIC:
	dp = &data->x25ChannelHIC;
	break;
#endif				       /* I_x25ChannelHIC */

#ifdef I_x25ChannelLTC
      case I_x25ChannelLTC:
	dp = &data->x25ChannelLTC;
	break;
#endif				       /* I_x25ChannelLTC */

#ifdef I_x25ChannelHTC
      case I_x25ChannelHTC:
	dp = &data->x25ChannelHTC;
	break;
#endif				       /* I_x25ChannelHTC */

#ifdef I_x25ChannelLOC
      case I_x25ChannelLOC:
	dp = &data->x25ChannelLOC;
	break;
#endif				       /* I_x25ChannelLOC */

#ifdef I_x25ChannelHOC
      case I_x25ChannelHOC:
	dp = &data->x25ChannelHOC;
	break;
#endif				       /* I_x25ChannelHOC */

      default:
	return(NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the x25ChannelEntry data object.
 *---------------------------------------------------------------------*/
void x25ChannelEntry_free (x25ChannelEntry_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after x25ChannelEntry set/undo
 *---------------------------------------------------------------------*/
static int x25ChannelEntry_cleanup (doList_t *trash)
{
    x25ChannelEntry_free(trash->data);
#ifdef SR_SNMPv2
    x25ChannelEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Undo a previous set of the x25ChannelEntry family.
 *---------------------------------------------------------------------*/
#ifdef SR_SNMPv2
int x25ChannelEntry_undo (doList_t    *doHead,
			  doList_t    *doCur,
			  ContextInfo *contextInfo)
{
    return UNDO_FAILED_ERROR;
}

#endif	/* SR_SNMPv2 */

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int x25ChannelEntry_test (OID          *incoming,
			  ObjectInfo   *object,
			  ObjectSyntax *value,
			  doList_t     *doHead,
			  doList_t     *doCur,
			  ContextInfo  *contextInfo)
{
    int             instLength;
    doList_t       *dp;
    VarBind        *vb;
    int             found;
    int             carry;
    x25ChannelEntry_t *x25ChannelEntry;
    long            x25ChannelIndex;

    instLength = incoming->length - object->oid.length;
    vb = NULL;
    carry = 0;

    /*
     * Validate the object instance
     * 
     */

    if ((InstToInt(incoming, 0 + object->oid.length, &x25ChannelIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    x25ChannelEntry = k_x25ChannelEntry_get(-1, contextInfo, object->nominator, EXACT, x25ChannelIndex);

#ifndef x25ChannelEntry_READ_CREATE

    if (x25ChannelEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* x25ChannelEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == x25ChannelEntry_set) &&
	    (((x25ChannelEntry_t *) (dp->data)) != NULL) &&
	    (((x25ChannelEntry_t *) (dp->data))->x25ChannelIndex == x25ChannelIndex)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(x25ChannelEntry_t))) == NULL) {
	    DPRINTF((0, "snmpd: Cannot allocate memory\n"));
	    return (GEN_ERROR);
	}
	memset(dp->data, 0, sizeof(x25ChannelEntry_t));

	dp->setMethod = x25ChannelEntry_set;
	dp->cleanupMethod = x25ChannelEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = x25ChannelEntry_undo;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_x25ChannelIndex, ((x25ChannelEntry_t *) (dp->data))->valid);
	((x25ChannelEntry_t *) (dp->data))->x25ChannelIndex = x25ChannelIndex;

#ifdef x25ChannelEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (x25ChannelEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, x25ChannelEntry, sizeof(x25ChannelEntry_t));

	    SET_ALL_VALID(((x25ChannelEntry_t *) (dp->data))->valid);

	} else {


	    /* Fill in default values here */


	}
#endif				       /* x25ChannelEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_x25ChannelLIC
      case I_x25ChannelLIC:

	SET_VALID(I_x25ChannelLIC, ((x25ChannelEntry_t *) (dp->data))->valid);

	((x25ChannelEntry_t *) (dp->data))->x25ChannelLIC = value->sl_value;
	break;
#endif				       /* I_x25ChannelLIC */

#ifdef I_x25ChannelHIC
      case I_x25ChannelHIC:

	SET_VALID(I_x25ChannelHIC, ((x25ChannelEntry_t *) (dp->data))->valid);

	((x25ChannelEntry_t *) (dp->data))->x25ChannelHIC = value->sl_value;
	break;
#endif				       /* I_x25ChannelHIC */

#ifdef I_x25ChannelLTC
      case I_x25ChannelLTC:

	SET_VALID(I_x25ChannelLTC, ((x25ChannelEntry_t *) (dp->data))->valid);

	((x25ChannelEntry_t *) (dp->data))->x25ChannelLTC = value->sl_value;
	break;
#endif				       /* I_x25ChannelLTC */

#ifdef I_x25ChannelHTC
      case I_x25ChannelHTC:

	SET_VALID(I_x25ChannelHTC, ((x25ChannelEntry_t *) (dp->data))->valid);

	((x25ChannelEntry_t *) (dp->data))->x25ChannelHTC = value->sl_value;
	break;
#endif				       /* I_x25ChannelHTC */

#ifdef I_x25ChannelLOC
      case I_x25ChannelLOC:

	SET_VALID(I_x25ChannelLOC, ((x25ChannelEntry_t *) (dp->data))->valid);

	((x25ChannelEntry_t *) (dp->data))->x25ChannelLOC = value->sl_value;
	break;
#endif				       /* I_x25ChannelLOC */

#ifdef I_x25ChannelHOC
      case I_x25ChannelHOC:

	SET_VALID(I_x25ChannelHOC, ((x25ChannelEntry_t *) (dp->data))->valid);

	((x25ChannelEntry_t *) (dp->data))->x25ChannelHOC = value->sl_value;
	break;
#endif				       /* I_x25ChannelHOC */

      default:
	DPRINTF((0, "snmpd: Internal error (invalid nominator in x25ChannelEntry)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int x25ChannelEntry_set (doList_t    *doHead,
			 doList_t    *doCur,
			 ContextInfo *contextInfo)
{
    return (k_x25ChannelEntry_set((x25ChannelEntry_t *) (doCur->data),
				  contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the x25CircuitEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *x25CircuitEntry_get (OID         *incoming,
			      ObjectInfo  *object,
			      int          searchType,
			      ContextInfo *contextInfo,
			      int          serialNum)
{
    int             instLength;
    int             arg;
    void           *dp;
    x25CircuitEntry_t *data;
    unsigned long   buffer[2];
    OID             inst;
    int             carry;
    long            x25CircuitIndex;
    long            x25CircuitChannel;

    instLength = incoming->length - object->oid.length;
    arg = object->nominator;
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 2
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 2) {
	    return (NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 1 + object->oid.length, &x25CircuitChannel, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &x25CircuitIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_x25CircuitEntry_get(serialNum, contextInfo, arg, searchType, x25CircuitIndex, x25CircuitChannel)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 2;
	inst.oid_ptr[0] = data->x25CircuitIndex;
	inst.oid_ptr[1] = data->x25CircuitChannel;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_x25CircuitIndex
      case I_x25CircuitIndex:
	dp = &data->x25CircuitIndex;
	break;
#endif				       /* I_x25CircuitIndex */

#ifdef I_x25CircuitChannel
      case I_x25CircuitChannel:
	dp = &data->x25CircuitChannel;
	break;
#endif				       /* I_x25CircuitChannel */

#ifdef I_x25CircuitStatus
      case I_x25CircuitStatus:
	dp = &data->x25CircuitStatus;
	break;
#endif				       /* I_x25CircuitStatus */

#ifdef I_x25CircuitEstablishTime
      case I_x25CircuitEstablishTime:
	dp = &data->x25CircuitEstablishTime;
	break;
#endif				       /* I_x25CircuitEstablishTime */

#ifdef I_x25CircuitDirection
      case I_x25CircuitDirection:
	dp = &data->x25CircuitDirection;
	break;
#endif				       /* I_x25CircuitDirection */

#ifdef I_x25CircuitInOctets
      case I_x25CircuitInOctets:
	dp = &data->x25CircuitInOctets;
	break;
#endif				       /* I_x25CircuitInOctets */

#ifdef I_x25CircuitInPdus
      case I_x25CircuitInPdus:
	dp = &data->x25CircuitInPdus;
	break;
#endif				       /* I_x25CircuitInPdus */

#ifdef I_x25CircuitInRemotelyInitiatedResets
      case I_x25CircuitInRemotelyInitiatedResets:
	dp = &data->x25CircuitInRemotelyInitiatedResets;
	break;
#endif				       /* I_x25CircuitInRemotelyInitiatedReset
				        * s */

#ifdef I_x25CircuitInProviderInitiatedResets
      case I_x25CircuitInProviderInitiatedResets:
	dp = &data->x25CircuitInProviderInitiatedResets;
	break;
#endif				       /* I_x25CircuitInProviderInitiatedReset
				        * s */

#ifdef I_x25CircuitInInterrupts
      case I_x25CircuitInInterrupts:
	dp = &data->x25CircuitInInterrupts;
	break;
#endif				       /* I_x25CircuitInInterrupts */

#ifdef I_x25CircuitOutOctets
      case I_x25CircuitOutOctets:
	dp = &data->x25CircuitOutOctets;
	break;
#endif				       /* I_x25CircuitOutOctets */

#ifdef I_x25CircuitOutPdus
      case I_x25CircuitOutPdus:
	dp = &data->x25CircuitOutPdus;
	break;
#endif				       /* I_x25CircuitOutPdus */

#ifdef I_x25CircuitOutInterrupts
      case I_x25CircuitOutInterrupts:
	dp = &data->x25CircuitOutInterrupts;
	break;
#endif				       /* I_x25CircuitOutInterrupts */

#ifdef I_x25CircuitDataRetransmissionTimeouts
      case I_x25CircuitDataRetransmissionTimeouts:
	dp = &data->x25CircuitDataRetransmissionTimeouts;
	break;
#endif				       /* I_x25CircuitDataRetransmissionTimeou
				        * ts */

#ifdef I_x25CircuitResetTimeouts
      case I_x25CircuitResetTimeouts:
	dp = &data->x25CircuitResetTimeouts;
	break;
#endif				       /* I_x25CircuitResetTimeouts */

#ifdef I_x25CircuitInterruptTimeouts
      case I_x25CircuitInterruptTimeouts:
	dp = &data->x25CircuitInterruptTimeouts;
	break;
#endif				       /* I_x25CircuitInterruptTimeouts */

#ifdef I_x25CircuitCallParamId
      case I_x25CircuitCallParamId:
	dp = MakeOID(data->x25CircuitCallParamId->oid_ptr, data->x25CircuitCallParamId->length);
	break;
#endif				       /* I_x25CircuitCallParamId */

#ifdef I_x25CircuitCalledDteAddress
      case I_x25CircuitCalledDteAddress:
	dp = MakeOctetString(data->x25CircuitCalledDteAddress->octet_ptr, data->x25CircuitCalledDteAddress->length);
	break;
#endif				       /* I_x25CircuitCalledDteAddress */

#ifdef I_x25CircuitCallingDteAddress
      case I_x25CircuitCallingDteAddress:
	dp = MakeOctetString(data->x25CircuitCallingDteAddress->octet_ptr, data->x25CircuitCallingDteAddress->length);
	break;
#endif				       /* I_x25CircuitCallingDteAddress */

#ifdef I_x25CircuitOriginallyCalledAddress
      case I_x25CircuitOriginallyCalledAddress:
	dp = MakeOctetString(data->x25CircuitOriginallyCalledAddress->octet_ptr, data->x25CircuitOriginallyCalledAddress->length);
	break;
#endif				       /* I_x25CircuitOriginallyCalledAddress */

#ifdef I_x25CircuitDescr
      case I_x25CircuitDescr:
	dp = MakeOctetString(data->x25CircuitDescr->octet_ptr, data->x25CircuitDescr->length);
	break;
#endif				       /* I_x25CircuitDescr */

      default:
	return (NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the x25CircuitEntry data object.
 *---------------------------------------------------------------------*/
void x25CircuitEntry_free (x25CircuitEntry_t *data)
{
    if (data != NULL) {
	if (data->x25CircuitCallParamId != NULL) {
	    FreeOID(data->x25CircuitCallParamId);
	}
	if (data->x25CircuitCalledDteAddress != NULL) {
	    FreeOctetString(data->x25CircuitCalledDteAddress);
	}
	if (data->x25CircuitCallingDteAddress != NULL) {
	    FreeOctetString(data->x25CircuitCallingDteAddress);
	}
	if (data->x25CircuitOriginallyCalledAddress != NULL) {
	    FreeOctetString(data->x25CircuitOriginallyCalledAddress);
	}
	if (data->x25CircuitDescr != NULL) {
	    FreeOctetString(data->x25CircuitDescr);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after x25CircuitEntry set/undo
 *---------------------------------------------------------------------*/
static int x25CircuitEntry_cleanup (doList_t *trash)
{
    x25CircuitEntry_free(trash->data);
#ifdef SR_SNMPv2
    x25CircuitEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Undo a previous set of the x25CircuitEntry family.
 *---------------------------------------------------------------------*/
#ifdef SR_SNMPv2
int x25CircuitEntry_undo (doList_t    *doHead,
			  doList_t    *doCur,
			  ContextInfo *contextInfo)
{
    return UNDO_FAILED_ERROR;
}

#endif	/* SR_SNMPv2 */

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int x25CircuitEntry_test (OID          *incoming,
			  ObjectInfo   *object,
			  ObjectSyntax *value,
			  doList_t     *doHead,
			  doList_t     *doCur,
			  ContextInfo  *contextInfo)
{
    int             instLength;
    doList_t       *dp;
    VarBind        *vb;
    int             found;
    int             carry;
    x25CircuitEntry_t *x25CircuitEntry;
    long            x25CircuitIndex;
    long            x25CircuitChannel;

    instLength = incoming->length - object->oid.length;
    vb = NULL;
    carry = 0;

    /*
     * Validate the object instance
     * 
     */

    if ((InstToInt(incoming, 0 + object->oid.length, &x25CircuitIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, 1 + object->oid.length, &x25CircuitChannel, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    x25CircuitEntry = k_x25CircuitEntry_get(-1, contextInfo, object->nominator, EXACT, x25CircuitIndex, x25CircuitChannel);

#ifndef x25CircuitEntry_READ_CREATE

    if (x25CircuitEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* x25CircuitEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == x25CircuitEntry_set) &&
	    (((x25CircuitEntry_t *) (dp->data)) != NULL) &&
	    (((x25CircuitEntry_t *) (dp->data))->x25CircuitIndex == x25CircuitIndex) &&
	    (((x25CircuitEntry_t *) (dp->data))->x25CircuitChannel == x25CircuitChannel)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(x25CircuitEntry_t))) == NULL) {
	    DPRINTF((0, "snmpd: Cannot allocate memory\n"));
	    return (GEN_ERROR);
	}
	memset(dp->data, 0, sizeof(x25CircuitEntry_t));

	dp->setMethod = x25CircuitEntry_set;
	dp->cleanupMethod = x25CircuitEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = x25CircuitEntry_undo;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_x25CircuitIndex, ((x25CircuitEntry_t *) (dp->data))->valid);
	((x25CircuitEntry_t *) (dp->data))->x25CircuitIndex = x25CircuitIndex;

	SET_VALID(I_x25CircuitChannel, ((x25CircuitEntry_t *) (dp->data))->valid);
	((x25CircuitEntry_t *) (dp->data))->x25CircuitChannel = x25CircuitChannel;

#ifdef x25CircuitEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (x25CircuitEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, x25CircuitEntry, sizeof(x25CircuitEntry_t));

	    SET_ALL_VALID(((x25CircuitEntry_t *) (dp->data))->valid);

	    ((x25CircuitEntry_t *) (dp->data))->x25CircuitCallParamId =
		CloneOID(value->oid_value);


	    ((x25CircuitEntry_t *) (dp->data))->x25CircuitCalledDteAddress =
		CloneOctetString(value->os_value);


	    ((x25CircuitEntry_t *) (dp->data))->x25CircuitCallingDteAddress =
		CloneOctetString(value->os_value);


	    ((x25CircuitEntry_t *) (dp->data))->x25CircuitOriginallyCalledAddress =
		CloneOctetString(value->os_value);


	    ((x25CircuitEntry_t *) (dp->data))->x25CircuitDescr =
		CloneOctetString(value->os_value);


	} else {


	    /* Fill in default values here */


	}
#endif				       /* x25CircuitEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_x25CircuitStatus
      case I_x25CircuitStatus:

	SET_VALID(I_x25CircuitStatus, ((x25CircuitEntry_t *) (dp->data))->valid);

	((x25CircuitEntry_t *) (dp->data))->x25CircuitStatus = value->sl_value;
	break;
#endif				       /* I_x25CircuitStatus */

#ifdef I_x25CircuitDirection
      case I_x25CircuitDirection:

	SET_VALID(I_x25CircuitDirection, ((x25CircuitEntry_t *) (dp->data))->valid);

	((x25CircuitEntry_t *) (dp->data))->x25CircuitDirection = value->sl_value;
	break;
#endif				       /* I_x25CircuitDirection */

#ifdef I_x25CircuitCallParamId
      case I_x25CircuitCallParamId:

	SET_VALID(I_x25CircuitCallParamId, ((x25CircuitEntry_t *) (dp->data))->valid);

	if (((x25CircuitEntry_t *) (dp->data))->x25CircuitCallParamId != NULL) {
	    FreeOID(((x25CircuitEntry_t *) (dp->data))->x25CircuitCallParamId);
	}
	((x25CircuitEntry_t *) (dp->data))->x25CircuitCallParamId =
	    MakeOID(value->oid_value->oid_ptr, value->oid_value->length);

	break;
#endif				       /* I_x25CircuitCallParamId */

#ifdef I_x25CircuitCalledDteAddress
      case I_x25CircuitCalledDteAddress:

	SET_VALID(I_x25CircuitCalledDteAddress, ((x25CircuitEntry_t *) (dp->data))->valid);

	if (((x25CircuitEntry_t *) (dp->data))->x25CircuitCalledDteAddress != NULL) {
	    FreeOctetString(((x25CircuitEntry_t *) (dp->data))->x25CircuitCalledDteAddress);
	}
	((x25CircuitEntry_t *) (dp->data))->x25CircuitCalledDteAddress =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_x25CircuitCalledDteAddress */

#ifdef I_x25CircuitCallingDteAddress
      case I_x25CircuitCallingDteAddress:

	SET_VALID(I_x25CircuitCallingDteAddress, ((x25CircuitEntry_t *) (dp->data))->valid);

	if (((x25CircuitEntry_t *) (dp->data))->x25CircuitCallingDteAddress != NULL) {
	    FreeOctetString(((x25CircuitEntry_t *) (dp->data))->x25CircuitCallingDteAddress);
	}
	((x25CircuitEntry_t *) (dp->data))->x25CircuitCallingDteAddress =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_x25CircuitCallingDteAddress */

#ifdef I_x25CircuitOriginallyCalledAddress
      case I_x25CircuitOriginallyCalledAddress:

	SET_VALID(I_x25CircuitOriginallyCalledAddress, ((x25CircuitEntry_t *) (dp->data))->valid);

	if (((x25CircuitEntry_t *) (dp->data))->x25CircuitOriginallyCalledAddress != NULL) {
	    FreeOctetString(((x25CircuitEntry_t *) (dp->data))->x25CircuitOriginallyCalledAddress);
	}
	((x25CircuitEntry_t *) (dp->data))->x25CircuitOriginallyCalledAddress =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_x25CircuitOriginallyCalledAddress */

#ifdef I_x25CircuitDescr
      case I_x25CircuitDescr:

	SET_VALID(I_x25CircuitDescr, ((x25CircuitEntry_t *) (dp->data))->valid);

	if (((x25CircuitEntry_t *) (dp->data))->x25CircuitDescr != NULL) {
	    FreeOctetString(((x25CircuitEntry_t *) (dp->data))->x25CircuitDescr);
	}
	((x25CircuitEntry_t *) (dp->data))->x25CircuitDescr =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_x25CircuitDescr */

      default:
	DPRINTF((0, "snmpd: Internal error (invalid nominator in x25CircuitEntry)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int x25CircuitEntry_set (doList_t    *doHead,
			 doList_t    *doCur,
			 ContextInfo *contextInfo)
{
    return (k_x25CircuitEntry_set((x25CircuitEntry_t *) (doCur->data),
				  contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the x25ClearedCircuitEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *x25ClearedCircuitEntry_get (OID         *incoming,
				     ObjectInfo  *object,
				     int          searchType,
				     ContextInfo *contextInfo,
				     int          serialNum)
{
    int             instLength;
    int             arg;
    void           *dp;
    x25ClearedCircuitEntry_t *data;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            x25ClearedCircuitIndex;

    instLength = incoming->length - object->oid.length;
    arg = object->nominator;
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return (NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &x25ClearedCircuitIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_x25ClearedCircuitEntry_get(serialNum, contextInfo, arg, searchType, x25ClearedCircuitIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->x25ClearedCircuitIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_x25ClearedCircuitIndex
      case I_x25ClearedCircuitIndex:
	dp = &data->x25ClearedCircuitIndex;
	break;
#endif				       /* I_x25ClearedCircuitIndex */

#ifdef I_x25ClearedCircuitPleIndex
      case I_x25ClearedCircuitPleIndex:
	dp = &data->x25ClearedCircuitPleIndex;
	break;
#endif				       /* I_x25ClearedCircuitPleIndex */

#ifdef I_x25ClearedCircuitTimeEstablished
      case I_x25ClearedCircuitTimeEstablished:
	dp = &data->x25ClearedCircuitTimeEstablished;
	break;
#endif				       /* I_x25ClearedCircuitTimeEstablished */

#ifdef I_x25ClearedCircuitTimeCleared
      case I_x25ClearedCircuitTimeCleared:
	dp = &data->x25ClearedCircuitTimeCleared;
	break;
#endif				       /* I_x25ClearedCircuitTimeCleared */

#ifdef I_x25ClearedCircuitChannel
      case I_x25ClearedCircuitChannel:
	dp = &data->x25ClearedCircuitChannel;
	break;
#endif				       /* I_x25ClearedCircuitChannel */

#ifdef I_x25ClearedCircuitClearingCause
      case I_x25ClearedCircuitClearingCause:
	dp = &data->x25ClearedCircuitClearingCause;
	break;
#endif				       /* I_x25ClearedCircuitClearingCause */

#ifdef I_x25ClearedCircuitDiagnosticCode
      case I_x25ClearedCircuitDiagnosticCode:
	dp = &data->x25ClearedCircuitDiagnosticCode;
	break;
#endif				       /* I_x25ClearedCircuitDiagnosticCode */

#ifdef I_x25ClearedCircuitInPdus
      case I_x25ClearedCircuitInPdus:
	dp = &data->x25ClearedCircuitInPdus;
	break;
#endif				       /* I_x25ClearedCircuitInPdus */

#ifdef I_x25ClearedCircuitOutPdus
      case I_x25ClearedCircuitOutPdus:
	dp = &data->x25ClearedCircuitOutPdus;
	break;
#endif				       /* I_x25ClearedCircuitOutPdus */

#ifdef I_x25ClearedCircuitCalledAddress
      case I_x25ClearedCircuitCalledAddress:
	dp = MakeOctetString(data->x25ClearedCircuitCalledAddress->octet_ptr, data->x25ClearedCircuitCalledAddress->length);
	break;
#endif				       /* I_x25ClearedCircuitCalledAddress */

#ifdef I_x25ClearedCircuitCallingAddress
      case I_x25ClearedCircuitCallingAddress:
	dp = MakeOctetString(data->x25ClearedCircuitCallingAddress->octet_ptr, data->x25ClearedCircuitCallingAddress->length);
	break;
#endif				       /* I_x25ClearedCircuitCallingAddress */

#ifdef I_x25ClearedCircuitClearFacilities
      case I_x25ClearedCircuitClearFacilities:
	dp = MakeOctetString(data->x25ClearedCircuitClearFacilities->octet_ptr, data->x25ClearedCircuitClearFacilities->length);
	break;
#endif				       /* I_x25ClearedCircuitClearFacilities */

      default:
	return (NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the x25CallParmEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind *x25CallParmEntry_get (OID         *incoming,
			       ObjectInfo  *object,
			       int          searchType,
			       ContextInfo *contextInfo,
			       int          serialNum)
{
    int             instLength;
    int             arg;
    void           *dp;
    x25CallParmEntry_t *data;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            x25CallParmIndex;

    instLength = incoming->length - object->oid.length;
    arg = object->nominator;
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return (NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &x25CallParmIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_x25CallParmEntry_get(serialNum, contextInfo, arg, searchType, x25CallParmIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->x25CallParmIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_x25CallParmIndex
      case I_x25CallParmIndex:
	dp = &data->x25CallParmIndex;
	break;
#endif				       /* I_x25CallParmIndex */

#ifdef I_x25CallParmStatus
      case I_x25CallParmStatus:
	dp = &data->x25CallParmStatus;
	break;
#endif				       /* I_x25CallParmStatus */

#ifdef I_x25CallParmRefCount
      case I_x25CallParmRefCount:
	dp = &data->x25CallParmRefCount;
	break;
#endif				       /* I_x25CallParmRefCount */

#ifdef I_x25CallParmInPacketSize
      case I_x25CallParmInPacketSize:
	dp = &data->x25CallParmInPacketSize;
	break;
#endif				       /* I_x25CallParmInPacketSize */

#ifdef I_x25CallParmOutPacketSize
      case I_x25CallParmOutPacketSize:
	dp = &data->x25CallParmOutPacketSize;
	break;
#endif				       /* I_x25CallParmOutPacketSize */

#ifdef I_x25CallParmInWindowSize
      case I_x25CallParmInWindowSize:
	dp = &data->x25CallParmInWindowSize;
	break;
#endif				       /* I_x25CallParmInWindowSize */

#ifdef I_x25CallParmOutWindowSize
      case I_x25CallParmOutWindowSize:
	dp = &data->x25CallParmOutWindowSize;
	break;
#endif				       /* I_x25CallParmOutWindowSize */

#ifdef I_x25CallParmAcceptReverseCharging
      case I_x25CallParmAcceptReverseCharging:
	dp = &data->x25CallParmAcceptReverseCharging;
	break;
#endif				       /* I_x25CallParmAcceptReverseCharging */

#ifdef I_x25CallParmProposeReverseCharging
      case I_x25CallParmProposeReverseCharging:
	dp = &data->x25CallParmProposeReverseCharging;
	break;
#endif				       /* I_x25CallParmProposeReverseCharging */

#ifdef I_x25CallParmFastSelect
      case I_x25CallParmFastSelect:
	dp = &data->x25CallParmFastSelect;
	break;
#endif				       /* I_x25CallParmFastSelect */

#ifdef I_x25CallParmInThruPutClasSize
      case I_x25CallParmInThruPutClasSize:
	dp = &data->x25CallParmInThruPutClasSize;
	break;
#endif				       /* I_x25CallParmInThruPutClasSize */

#ifdef I_x25CallParmOutThruPutClasSize
      case I_x25CallParmOutThruPutClasSize:
	dp = &data->x25CallParmOutThruPutClasSize;
	break;
#endif				       /* I_x25CallParmOutThruPutClasSize */

#ifdef I_x25CallParmCug
      case I_x25CallParmCug:
	dp = MakeOctetString(data->x25CallParmCug->octet_ptr, data->x25CallParmCug->length);
	break;
#endif				       /* I_x25CallParmCug */

#ifdef I_x25CallParmCugoa
      case I_x25CallParmCugoa:
	dp = MakeOctetString(data->x25CallParmCugoa->octet_ptr, data->x25CallParmCugoa->length);
	break;
#endif				       /* I_x25CallParmCugoa */

#ifdef I_x25CallParmBcug
      case I_x25CallParmBcug:
	dp = MakeOctetString(data->x25CallParmBcug->octet_ptr, data->x25CallParmBcug->length);
	break;
#endif				       /* I_x25CallParmBcug */

#ifdef I_x25CallParmNui
      case I_x25CallParmNui:
	dp = MakeOctetString(data->x25CallParmNui->octet_ptr, data->x25CallParmNui->length);
	break;
#endif				       /* I_x25CallParmNui */

#ifdef I_x25CallParmChargingInfo
      case I_x25CallParmChargingInfo:
	dp = &data->x25CallParmChargingInfo;
	break;
#endif				       /* I_x25CallParmChargingInfo */

#ifdef I_x25CallParmRpoa
      case I_x25CallParmRpoa:
	dp = MakeOctetString(data->x25CallParmRpoa->octet_ptr, data->x25CallParmRpoa->length);
	break;
#endif				       /* I_x25CallParmRpoa */

#ifdef I_x25CallParmTrnstDly
      case I_x25CallParmTrnstDly:
	dp = &data->x25CallParmTrnstDly;
	break;
#endif				       /* I_x25CallParmTrnstDly */

#ifdef I_x25CallParmCallingExt
      case I_x25CallParmCallingExt:
	dp = MakeOctetString(data->x25CallParmCallingExt->octet_ptr, data->x25CallParmCallingExt->length);
	break;
#endif				       /* I_x25CallParmCallingExt */

#ifdef I_x25CallParmCalledExt
      case I_x25CallParmCalledExt:
	dp = MakeOctetString(data->x25CallParmCalledExt->octet_ptr, data->x25CallParmCalledExt->length);
	break;
#endif				       /* I_x25CallParmCalledExt */

#ifdef I_x25CallParmInMinThuPutCls
      case I_x25CallParmInMinThuPutCls:
	dp = &data->x25CallParmInMinThuPutCls;
	break;
#endif				       /* I_x25CallParmInMinThuPutCls */

#ifdef I_x25CallParmOutMinThuPutCls
      case I_x25CallParmOutMinThuPutCls:
	dp = &data->x25CallParmOutMinThuPutCls;
	break;
#endif				       /* I_x25CallParmOutMinThuPutCls */

#ifdef I_x25CallParmEndTrnsDly
      case I_x25CallParmEndTrnsDly:
	dp = MakeOctetString(data->x25CallParmEndTrnsDly->octet_ptr, data->x25CallParmEndTrnsDly->length);
	break;
#endif				       /* I_x25CallParmEndTrnsDly */

#ifdef I_x25CallParmPriority
      case I_x25CallParmPriority:
	dp = MakeOctetString(data->x25CallParmPriority->octet_ptr, data->x25CallParmPriority->length);
	break;
#endif				       /* I_x25CallParmPriority */

#ifdef I_x25CallParmProtection
      case I_x25CallParmProtection:
	dp = MakeOctetString(data->x25CallParmProtection->octet_ptr, data->x25CallParmProtection->length);
	break;
#endif				       /* I_x25CallParmProtection */

#ifdef I_x25CallParmExptData
      case I_x25CallParmExptData:
	dp = &data->x25CallParmExptData;
	break;
#endif				       /* I_x25CallParmExptData */

#ifdef I_x25CallParmUserData
      case I_x25CallParmUserData:
	dp = MakeOctetString(data->x25CallParmUserData->octet_ptr, data->x25CallParmUserData->length);
	break;
#endif				       /* I_x25CallParmUserData */

#ifdef I_x25CallParmCallingNetworkFacilities
      case I_x25CallParmCallingNetworkFacilities:
	dp = MakeOctetString(data->x25CallParmCallingNetworkFacilities->octet_ptr, data->x25CallParmCallingNetworkFacilities->length);
	break;
#endif				       /* I_x25CallParmCallingNetworkFacilitie
				        * s */

#ifdef I_x25CallParmCalledNetworkFacilities
      case I_x25CallParmCalledNetworkFacilities:
	dp = MakeOctetString(data->x25CallParmCalledNetworkFacilities->octet_ptr, data->x25CallParmCalledNetworkFacilities->length);
	break;
#endif				       /* I_x25CallParmCalledNetworkFacilities
				        *  */

      default:
	return (NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the x25CallParmEntry data object.
 *---------------------------------------------------------------------*/
void x25CallParmEntry_free (x25CallParmEntry_t *data)
{
    if (data != NULL) {
	if (data->x25CallParmCug != NULL) {
	    FreeOctetString(data->x25CallParmCug);
	}
	if (data->x25CallParmCugoa != NULL) {
	    FreeOctetString(data->x25CallParmCugoa);
	}
	if (data->x25CallParmBcug != NULL) {
	    FreeOctetString(data->x25CallParmBcug);
	}
	if (data->x25CallParmNui != NULL) {
	    FreeOctetString(data->x25CallParmNui);
	}
	if (data->x25CallParmRpoa != NULL) {
	    FreeOctetString(data->x25CallParmRpoa);
	}
	if (data->x25CallParmCallingExt != NULL) {
	    FreeOctetString(data->x25CallParmCallingExt);
	}
	if (data->x25CallParmCalledExt != NULL) {
	    FreeOctetString(data->x25CallParmCalledExt);
	}
	if (data->x25CallParmEndTrnsDly != NULL) {
	    FreeOctetString(data->x25CallParmEndTrnsDly);
	}
	if (data->x25CallParmPriority != NULL) {
	    FreeOctetString(data->x25CallParmPriority);
	}
	if (data->x25CallParmProtection != NULL) {
	    FreeOctetString(data->x25CallParmProtection);
	}
	if (data->x25CallParmUserData != NULL) {
	    FreeOctetString(data->x25CallParmUserData);
	}
	if (data->x25CallParmCallingNetworkFacilities != NULL) {
	    FreeOctetString(data->x25CallParmCallingNetworkFacilities);
	}
	if (data->x25CallParmCalledNetworkFacilities != NULL) {
	    FreeOctetString(data->x25CallParmCalledNetworkFacilities);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after x25CallParmEntry set/undo
 *---------------------------------------------------------------------*/
static int x25CallParmEntry_cleanup (doList_t *trash)
{
    x25CallParmEntry_free(trash->data);
#ifdef SR_SNMPv2
    x25CallParmEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*----------------------------------------------------------------------
 * Undo a previous set of the x25CallParmEntry family.
 *---------------------------------------------------------------------*/
#ifdef SR_SNMPv2
int x25CallParmEntry_undo (doList_t    *doHead,
			   doList_t    *doCur,
			   ContextInfo *contextInfo)
{
    return UNDO_FAILED_ERROR;
}

#endif	/* SR_SNMPv2 */

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int x25CallParmEntry_test (OID          *incoming,
			   ObjectInfo   *object,
			   ObjectSyntax *value,
			   doList_t     *doHead,
			   doList_t     *doCur,
			   ContextInfo  *contextInfo)
{
    int                 instLength;
    doList_t           *dp;
    VarBind            *vb;
    int                 found;
    int                 carry;
    x25CallParmEntry_t *x25CallParmEntry;
    long                x25CallParmIndex;

    instLength = incoming->length - object->oid.length;
    vb =  NULL;
    carry = 0;

    /*
     * Validate the object instance
     * 
     */

    if ((InstToInt(incoming, 0 + object->oid.length, &x25CallParmIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    x25CallParmEntry = k_x25CallParmEntry_get(-1, contextInfo, object->nominator, EXACT, x25CallParmIndex);

#ifndef x25CallParmEntry_READ_CREATE

    if (x25CallParmEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* x25CallParmEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == x25CallParmEntry_set) &&
	    (((x25CallParmEntry_t *) (dp->data)) != NULL) &&
	    (((x25CallParmEntry_t *) (dp->data))->x25CallParmIndex == x25CallParmIndex)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(x25CallParmEntry_t))) == NULL) {
	    DPRINTF((0, "snmpd: Cannot allocate memory\n"));
	    return (GEN_ERROR);
	}
	memset(dp->data, 0, sizeof(x25CallParmEntry_t));

	dp->setMethod = x25CallParmEntry_set;
	dp->cleanupMethod = x25CallParmEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = x25CallParmEntry_undo;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_x25CallParmIndex, ((x25CallParmEntry_t *) (dp->data))->valid);
	((x25CallParmEntry_t *) (dp->data))->x25CallParmIndex = x25CallParmIndex;

#ifdef x25CallParmEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (x25CallParmEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, x25CallParmEntry, sizeof(x25CallParmEntry_t));

	    SET_ALL_VALID(((x25CallParmEntry_t *) (dp->data))->valid);

	    ((x25CallParmEntry_t *) (dp->data))->x25CallParmCug =
		CloneOctetString(value->os_value);


	    ((x25CallParmEntry_t *) (dp->data))->x25CallParmCugoa =
		CloneOctetString(value->os_value);


	    ((x25CallParmEntry_t *) (dp->data))->x25CallParmBcug =
		CloneOctetString(value->os_value);


	    ((x25CallParmEntry_t *) (dp->data))->x25CallParmNui =
		CloneOctetString(value->os_value);


	    ((x25CallParmEntry_t *) (dp->data))->x25CallParmRpoa =
		CloneOctetString(value->os_value);


	    ((x25CallParmEntry_t *) (dp->data))->x25CallParmCallingExt =
		CloneOctetString(value->os_value);


	    ((x25CallParmEntry_t *) (dp->data))->x25CallParmCalledExt =
		CloneOctetString(value->os_value);


	    ((x25CallParmEntry_t *) (dp->data))->x25CallParmEndTrnsDly =
		CloneOctetString(value->os_value);


	    ((x25CallParmEntry_t *) (dp->data))->x25CallParmPriority =
		CloneOctetString(value->os_value);


	    ((x25CallParmEntry_t *) (dp->data))->x25CallParmProtection =
		CloneOctetString(value->os_value);


	    ((x25CallParmEntry_t *) (dp->data))->x25CallParmUserData =
		CloneOctetString(value->os_value);


	    ((x25CallParmEntry_t *) (dp->data))->x25CallParmCallingNetworkFacilities =
		CloneOctetString(value->os_value);


	    ((x25CallParmEntry_t *) (dp->data))->x25CallParmCalledNetworkFacilities =
		CloneOctetString(value->os_value);


	} else {


	    /* Fill in default values here */


	}
#endif				       /* x25CallParmEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_x25CallParmStatus
      case I_x25CallParmStatus:

	SET_VALID(I_x25CallParmStatus, ((x25CallParmEntry_t *) (dp->data))->valid);

	((x25CallParmEntry_t *) (dp->data))->x25CallParmStatus = value->sl_value;
	break;
#endif				       /* I_x25CallParmStatus */

#ifdef I_x25CallParmInPacketSize
      case I_x25CallParmInPacketSize:

	SET_VALID(I_x25CallParmInPacketSize, ((x25CallParmEntry_t *) (dp->data))->valid);

	((x25CallParmEntry_t *) (dp->data))->x25CallParmInPacketSize = value->sl_value;
	break;
#endif				       /* I_x25CallParmInPacketSize */

#ifdef I_x25CallParmOutPacketSize
      case I_x25CallParmOutPacketSize:

	SET_VALID(I_x25CallParmOutPacketSize, ((x25CallParmEntry_t *) (dp->data))->valid);

	((x25CallParmEntry_t *) (dp->data))->x25CallParmOutPacketSize = value->sl_value;
	break;
#endif				       /* I_x25CallParmOutPacketSize */

#ifdef I_x25CallParmInWindowSize
      case I_x25CallParmInWindowSize:

	SET_VALID(I_x25CallParmInWindowSize, ((x25CallParmEntry_t *) (dp->data))->valid);

	((x25CallParmEntry_t *) (dp->data))->x25CallParmInWindowSize = value->sl_value;
	break;
#endif				       /* I_x25CallParmInWindowSize */

#ifdef I_x25CallParmOutWindowSize
      case I_x25CallParmOutWindowSize:

	SET_VALID(I_x25CallParmOutWindowSize, ((x25CallParmEntry_t *) (dp->data))->valid);

	((x25CallParmEntry_t *) (dp->data))->x25CallParmOutWindowSize = value->sl_value;
	break;
#endif				       /* I_x25CallParmOutWindowSize */

#ifdef I_x25CallParmAcceptReverseCharging
      case I_x25CallParmAcceptReverseCharging:

	SET_VALID(I_x25CallParmAcceptReverseCharging, ((x25CallParmEntry_t *) (dp->data))->valid);

	((x25CallParmEntry_t *) (dp->data))->x25CallParmAcceptReverseCharging = value->sl_value;
	break;
#endif				       /* I_x25CallParmAcceptReverseCharging */

#ifdef I_x25CallParmProposeReverseCharging
      case I_x25CallParmProposeReverseCharging:

	SET_VALID(I_x25CallParmProposeReverseCharging, ((x25CallParmEntry_t *) (dp->data))->valid);

	((x25CallParmEntry_t *) (dp->data))->x25CallParmProposeReverseCharging = value->sl_value;
	break;
#endif				       /* I_x25CallParmProposeReverseCharging */

#ifdef I_x25CallParmFastSelect
      case I_x25CallParmFastSelect:

	SET_VALID(I_x25CallParmFastSelect, ((x25CallParmEntry_t *) (dp->data))->valid);

	((x25CallParmEntry_t *) (dp->data))->x25CallParmFastSelect = value->sl_value;
	break;
#endif				       /* I_x25CallParmFastSelect */

#ifdef I_x25CallParmInThruPutClasSize
      case I_x25CallParmInThruPutClasSize:

	SET_VALID(I_x25CallParmInThruPutClasSize, ((x25CallParmEntry_t *) (dp->data))->valid);

	((x25CallParmEntry_t *) (dp->data))->x25CallParmInThruPutClasSize = value->sl_value;
	break;
#endif				       /* I_x25CallParmInThruPutClasSize */

#ifdef I_x25CallParmOutThruPutClasSize
      case I_x25CallParmOutThruPutClasSize:

	SET_VALID(I_x25CallParmOutThruPutClasSize, ((x25CallParmEntry_t *) (dp->data))->valid);

	((x25CallParmEntry_t *) (dp->data))->x25CallParmOutThruPutClasSize = value->sl_value;
	break;
#endif				       /* I_x25CallParmOutThruPutClasSize */

#ifdef I_x25CallParmCug
      case I_x25CallParmCug:

	SET_VALID(I_x25CallParmCug, ((x25CallParmEntry_t *) (dp->data))->valid);

	if (((x25CallParmEntry_t *) (dp->data))->x25CallParmCug != NULL) {
	    FreeOctetString(((x25CallParmEntry_t *) (dp->data))->x25CallParmCug);
	}
	((x25CallParmEntry_t *) (dp->data))->x25CallParmCug =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_x25CallParmCug */

#ifdef I_x25CallParmCugoa
      case I_x25CallParmCugoa:

	SET_VALID(I_x25CallParmCugoa, ((x25CallParmEntry_t *) (dp->data))->valid);

	if (((x25CallParmEntry_t *) (dp->data))->x25CallParmCugoa != NULL) {
	    FreeOctetString(((x25CallParmEntry_t *) (dp->data))->x25CallParmCugoa);
	}
	((x25CallParmEntry_t *) (dp->data))->x25CallParmCugoa =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_x25CallParmCugoa */

#ifdef I_x25CallParmBcug
      case I_x25CallParmBcug:

	SET_VALID(I_x25CallParmBcug, ((x25CallParmEntry_t *) (dp->data))->valid);

	if (((x25CallParmEntry_t *) (dp->data))->x25CallParmBcug != NULL) {
	    FreeOctetString(((x25CallParmEntry_t *) (dp->data))->x25CallParmBcug);
	}
	((x25CallParmEntry_t *) (dp->data))->x25CallParmBcug =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_x25CallParmBcug */

#ifdef I_x25CallParmNui
      case I_x25CallParmNui:

	SET_VALID(I_x25CallParmNui, ((x25CallParmEntry_t *) (dp->data))->valid);

	if (((x25CallParmEntry_t *) (dp->data))->x25CallParmNui != NULL) {
	    FreeOctetString(((x25CallParmEntry_t *) (dp->data))->x25CallParmNui);
	}
	((x25CallParmEntry_t *) (dp->data))->x25CallParmNui =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_x25CallParmNui */

#ifdef I_x25CallParmChargingInfo
      case I_x25CallParmChargingInfo:

	SET_VALID(I_x25CallParmChargingInfo, ((x25CallParmEntry_t *) (dp->data))->valid);

	((x25CallParmEntry_t *) (dp->data))->x25CallParmChargingInfo = value->sl_value;
	break;
#endif				       /* I_x25CallParmChargingInfo */

#ifdef I_x25CallParmRpoa
      case I_x25CallParmRpoa:

	SET_VALID(I_x25CallParmRpoa, ((x25CallParmEntry_t *) (dp->data))->valid);

	if (((x25CallParmEntry_t *) (dp->data))->x25CallParmRpoa != NULL) {
	    FreeOctetString(((x25CallParmEntry_t *) (dp->data))->x25CallParmRpoa);
	}
	((x25CallParmEntry_t *) (dp->data))->x25CallParmRpoa =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_x25CallParmRpoa */

#ifdef I_x25CallParmTrnstDly
      case I_x25CallParmTrnstDly:

	SET_VALID(I_x25CallParmTrnstDly, ((x25CallParmEntry_t *) (dp->data))->valid);

	((x25CallParmEntry_t *) (dp->data))->x25CallParmTrnstDly = value->sl_value;
	break;
#endif				       /* I_x25CallParmTrnstDly */

#ifdef I_x25CallParmCallingExt
      case I_x25CallParmCallingExt:

	SET_VALID(I_x25CallParmCallingExt, ((x25CallParmEntry_t *) (dp->data))->valid);

	if (((x25CallParmEntry_t *) (dp->data))->x25CallParmCallingExt != NULL) {
	    FreeOctetString(((x25CallParmEntry_t *) (dp->data))->x25CallParmCallingExt);
	}
	((x25CallParmEntry_t *) (dp->data))->x25CallParmCallingExt =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_x25CallParmCallingExt */

#ifdef I_x25CallParmCalledExt
      case I_x25CallParmCalledExt:

	SET_VALID(I_x25CallParmCalledExt, ((x25CallParmEntry_t *) (dp->data))->valid);

	if (((x25CallParmEntry_t *) (dp->data))->x25CallParmCalledExt != NULL) {
	    FreeOctetString(((x25CallParmEntry_t *) (dp->data))->x25CallParmCalledExt);
	}
	((x25CallParmEntry_t *) (dp->data))->x25CallParmCalledExt =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_x25CallParmCalledExt */

#ifdef I_x25CallParmInMinThuPutCls
      case I_x25CallParmInMinThuPutCls:

	SET_VALID(I_x25CallParmInMinThuPutCls, ((x25CallParmEntry_t *) (dp->data))->valid);

	((x25CallParmEntry_t *) (dp->data))->x25CallParmInMinThuPutCls = value->sl_value;
	break;
#endif				       /* I_x25CallParmInMinThuPutCls */

#ifdef I_x25CallParmOutMinThuPutCls
      case I_x25CallParmOutMinThuPutCls:

	SET_VALID(I_x25CallParmOutMinThuPutCls, ((x25CallParmEntry_t *) (dp->data))->valid);

	((x25CallParmEntry_t *) (dp->data))->x25CallParmOutMinThuPutCls = value->sl_value;
	break;
#endif				       /* I_x25CallParmOutMinThuPutCls */

#ifdef I_x25CallParmEndTrnsDly
      case I_x25CallParmEndTrnsDly:

	SET_VALID(I_x25CallParmEndTrnsDly, ((x25CallParmEntry_t *) (dp->data))->valid);

	if (((x25CallParmEntry_t *) (dp->data))->x25CallParmEndTrnsDly != NULL) {
	    FreeOctetString(((x25CallParmEntry_t *) (dp->data))->x25CallParmEndTrnsDly);
	}
	((x25CallParmEntry_t *) (dp->data))->x25CallParmEndTrnsDly =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_x25CallParmEndTrnsDly */

#ifdef I_x25CallParmPriority
      case I_x25CallParmPriority:

	SET_VALID(I_x25CallParmPriority, ((x25CallParmEntry_t *) (dp->data))->valid);

	if (((x25CallParmEntry_t *) (dp->data))->x25CallParmPriority != NULL) {
	    FreeOctetString(((x25CallParmEntry_t *) (dp->data))->x25CallParmPriority);
	}
	((x25CallParmEntry_t *) (dp->data))->x25CallParmPriority =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_x25CallParmPriority */

#ifdef I_x25CallParmProtection
      case I_x25CallParmProtection:

	SET_VALID(I_x25CallParmProtection, ((x25CallParmEntry_t *) (dp->data))->valid);

	if (((x25CallParmEntry_t *) (dp->data))->x25CallParmProtection != NULL) {
	    FreeOctetString(((x25CallParmEntry_t *) (dp->data))->x25CallParmProtection);
	}
	((x25CallParmEntry_t *) (dp->data))->x25CallParmProtection =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_x25CallParmProtection */

#ifdef I_x25CallParmExptData
      case I_x25CallParmExptData:

	SET_VALID(I_x25CallParmExptData, ((x25CallParmEntry_t *) (dp->data))->valid);

	((x25CallParmEntry_t *) (dp->data))->x25CallParmExptData = value->sl_value;
	break;
#endif				       /* I_x25CallParmExptData */

#ifdef I_x25CallParmUserData
      case I_x25CallParmUserData:

	SET_VALID(I_x25CallParmUserData, ((x25CallParmEntry_t *) (dp->data))->valid);

	if (((x25CallParmEntry_t *) (dp->data))->x25CallParmUserData != NULL) {
	    FreeOctetString(((x25CallParmEntry_t *) (dp->data))->x25CallParmUserData);
	}
	((x25CallParmEntry_t *) (dp->data))->x25CallParmUserData =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_x25CallParmUserData */

#ifdef I_x25CallParmCallingNetworkFacilities
      case I_x25CallParmCallingNetworkFacilities:

	SET_VALID(I_x25CallParmCallingNetworkFacilities, ((x25CallParmEntry_t *) (dp->data))->valid);

	if (((x25CallParmEntry_t *) (dp->data))->x25CallParmCallingNetworkFacilities != NULL) {
	    FreeOctetString(((x25CallParmEntry_t *) (dp->data))->x25CallParmCallingNetworkFacilities);
	}
	((x25CallParmEntry_t *) (dp->data))->x25CallParmCallingNetworkFacilities =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_x25CallParmCallingNetworkFacilitie
				        * s */

#ifdef I_x25CallParmCalledNetworkFacilities
      case I_x25CallParmCalledNetworkFacilities:

	SET_VALID(I_x25CallParmCalledNetworkFacilities, ((x25CallParmEntry_t *) (dp->data))->valid);

	if (((x25CallParmEntry_t *) (dp->data))->x25CallParmCalledNetworkFacilities != NULL) {
	    FreeOctetString(((x25CallParmEntry_t *) (dp->data))->x25CallParmCalledNetworkFacilities);
	}
	((x25CallParmEntry_t *) (dp->data))->x25CallParmCalledNetworkFacilities =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_x25CallParmCalledNetworkFacilities
				        *  */

      default:
	DPRINTF((0, "snmpd: Internal error (invalid nominator in x25CallParmEntry)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int x25CallParmEntry_set (doList_t    *doHead,
			  doList_t    *doCur,
			  ContextInfo *contextInfo)
{
    return (k_x25CallParmEntry_set((x25CallParmEntry_t *) (doCur->data),
				   contextInfo, doCur->state));
}

#endif				       /* SETS */



/*
 **********************************************************************
 *
 * KERNEL CODE begins here.  Above is all generated by SNMP Research
 * compiler.  Below code does the real work in getting the router
 * information.  
 *
 * First come the utility helper routines.
 *
 **********************************************************************
 */

static boolean snmp_x25_idb_tester (hwidbtype *idb, long* index2)
{
    return(is_x25(idb));
}

static int compute_max_active_vcs (hwidbtype *hwidb)
{
    int max_vcs;

    max_vcs = 0;

    /* compute the number of possible SVCs */
    if (hwidb->x25_admin_lic && hwidb->x25_admin_hic &&
	hwidb->x25_admin_hic >= hwidb->x25_admin_lic)
	max_vcs += hwidb->x25_admin_hic - hwidb->x25_admin_lic + 1;
    if (hwidb->x25_admin_ltc && hwidb->x25_admin_htc &&
	hwidb->x25_admin_htc >= hwidb->x25_admin_ltc)
	max_vcs += hwidb->x25_admin_htc - hwidb->x25_admin_ltc + 1;
    if (hwidb->x25_admin_loc && hwidb->x25_admin_hoc &&
	hwidb->x25_admin_hoc >= hwidb->x25_admin_loc)
	max_vcs += hwidb->x25_admin_hoc - hwidb->x25_admin_loc + 1;

    /* add the potential PVCs */
    if (hwidb->x25_admin_lic && hwidb->x25_admin_hic &&
	hwidb->x25_admin_hic >= hwidb->x25_admin_lic)
	max_vcs += hwidb->x25_admin_lic - 1;
    else if (hwidb->x25_admin_ltc && hwidb->x25_admin_htc &&
	     hwidb->x25_admin_htc >= hwidb->x25_admin_ltc)
	max_vcs += hwidb->x25_admin_ltc - 1;
    else if (hwidb->x25_admin_loc && hwidb->x25_admin_hoc &&
	     hwidb->x25_admin_hoc >= hwidb->x25_admin_loc)
	max_vcs += hwidb->x25_admin_loc - 1;
    else
	max_vcs = 4095;

    return(max_vcs);
}

static int compute_num_pvcs (hwidbtype *hwidb)
{
    lcitype *lci;
    int lci_num;
    int num_pvcs;

    num_pvcs = 0;
    lci_num = 0;

    while ((lci = x25_lci_lookup_next(hwidb, lci_num, NULL))) {
	if (IS_LCI_PVC(hwidb, lci->lci_lci)) {
	    num_pvcs++;
	    lci_num = lci->lci_lci;
	} else {
	    break;
	}
    }
    return(num_pvcs);
}


/*
 * Below are the kernel routines called by the SNMP research code.
 */

x25_t *k_x25_get (int          serialNum,
		  ContextInfo *contextInfo,
		  int          nominator)
{
#ifdef NOT_YET
    static x25_t    x25Data;

    x25Data.x25ClearedCircuitEntriesRequested =;
    x25Data.x25ClearedCircuitEntriesGranted =;

    return (&x25Data);
#else				       /* NOT_YET */
    return (NULL);
#endif				       /* NOT_YET */
}

int k_x25_set (x25_t       *data,
	       ContextInfo *contextInfo,
	       int          function)
{
    return (GEN_ERROR);
}

x25AdmnEntry_t *k_x25AdmnEntry_get (int          serialNum,
				    ContextInfo *contextInfo,
				    int          nominator,
				    int          searchType,
				    long         x25AdmnIndex)
{
    static x25AdmnEntry_t x25AdmnEntryData;
    static OctetString x25AdmnLocalAddress;

    hwidbtype *hwidb;

    hwidb = ifmib_hwidb_get(serialNum, searchType, x25AdmnIndex,
			    snmp_x25_idb_tester, NULL);
    if (hwidb == NULL)
	return (NULL);

    x25AdmnEntryData.x25AdmnIndex = hwidb->snmp_if_index;

    if (IS_DTE(hwidb, x25_dce))
	x25AdmnEntryData.x25AdmnInterfaceMode = D_x25AdmnInterfaceMode_dte;
    else if (IS_DCE(hwidb, x25_dce))
	x25AdmnEntryData.x25AdmnInterfaceMode = D_x25AdmnInterfaceMode_dce;
    else
	x25AdmnEntryData.x25AdmnInterfaceMode = D_x25AdmnInterfaceMode_dxe;

    x25AdmnEntryData.x25AdmnMaxActiveCircuits = compute_max_active_vcs(hwidb);

    if (hwidb->x25_admin_modulo == X25_MOD8)
	x25AdmnEntryData.x25AdmnPacketSequencing =
	    D_x25AdmnPacketSequencing_modulo8;
    else
	x25AdmnEntryData.x25AdmnPacketSequencing =
	    D_x25AdmnPacketSequencing_modulo128;

    x25AdmnEntryData.x25AdmnRestartTimer = hwidb->x25_t0;
    x25AdmnEntryData.x25AdmnCallTimer = hwidb->x25_t1;
    x25AdmnEntryData.x25AdmnResetTimer = hwidb->x25_t2;
    x25AdmnEntryData.x25AdmnClearTimer = hwidb->x25_t3;
    x25AdmnEntryData.x25AdmnWindowTimer = MAX_POSITIVE_32;
    x25AdmnEntryData.x25AdmnDataRxmtTimer = MAX_POSITIVE_32;
    x25AdmnEntryData.x25AdmnInterruptTimer = MAX_POSITIVE_32;
    x25AdmnEntryData.x25AdmnRejectTimer = MAX_POSITIVE_32;
    x25AdmnEntryData.x25AdmnRegistrationRequestTimer = MAX_POSITIVE_32;
    x25AdmnEntryData.x25AdmnMinimumRecallTimer = (hwidb->x25_holdtime *
						  MSEC_PER_MIN);
    /*
     *  from the 1988 Table D-2/X.25, a DTE has no retransmit limit,
     *  while Table D-1/X.25 shows a DCE retransmits once
     */
    x25AdmnEntryData.x25AdmnRestartCount = IS_DTE(hwidb, x25_dce) ?
	MAX_POSITIVE_16 : 1; 
    x25AdmnEntryData.x25AdmnResetCount = 1;
    x25AdmnEntryData.x25AdmnClearCount = 1;
    x25AdmnEntryData.x25AdmnDataRxmtCount = 0;
    x25AdmnEntryData.x25AdmnRejectCount = 0;
    x25AdmnEntryData.x25AdmnRegistrationRequestCount = 0;
    x25AdmnEntryData.x25AdmnNumberPVCs = compute_num_pvcs(hwidb);
    x25AdmnEntryData.x25AdmnDefCallParamId = &x25nullOID;

    x25AdmnEntryData.x25AdmnLocalAddress = &x25AdmnLocalAddress;
    x25AdmnEntryData.x25AdmnLocalAddress->octet_ptr =
	hwidb->x25_address->x121_addr;
    x25AdmnEntryData.x25AdmnLocalAddress->length =
	hwidb->x25_address->length;

    x25AdmnEntryData.x25AdmnProtocolVersionSupported = 
	&x25ProtocolVersionSupported;

    return (&x25AdmnEntryData);
}

int k_x25AdmnEntry_set (x25AdmnEntry_t *data,
			ContextInfo    *contextInfo,
			int             function)
{
    return (GEN_ERROR);
}

x25OperEntry_t *k_x25OperEntry_get (int          serialNum,
		    ContextInfo *contextInfo,
				    int          nominator,
				    int          searchType,
				    long         x25OperIndex)
{
    static x25OperEntry_t x25OperEntryData;
    static OctetString x25OperLocalAddress;

    hwidbtype *hwidb;

    hwidb = ifmib_hwidb_get(serialNum, searchType, x25OperIndex,
			    snmp_x25_idb_tester, NULL);
    if (hwidb == NULL)
	return (NULL);

    x25OperEntryData.x25OperIndex = hwidb->snmp_if_index;

    if (IS_DTE(hwidb, x25_dce)) 
	x25OperEntryData.x25OperInterfaceMode = D_x25OperInterfaceMode_dte;
    else if (IS_DCE(hwidb, x25_dce)) 
	x25OperEntryData.x25OperInterfaceMode = D_x25OperInterfaceMode_dce;
    else 
	x25OperEntryData.x25OperInterfaceMode = D_x25OperInterfaceMode_dxe;

    x25OperEntryData.x25OperMaxActiveCircuits = compute_max_active_vcs(hwidb);

    if (hwidb->x25_modulo == X25_MOD8) 
	x25OperEntryData.x25OperPacketSequencing =
	    D_x25OperPacketSequencing_modulo8;
    else
	x25OperEntryData.x25OperPacketSequencing =
	    D_x25OperPacketSequencing_modulo128;

    x25OperEntryData.x25OperRestartTimer = hwidb->x25_t0;
    x25OperEntryData.x25OperCallTimer = hwidb->x25_t1;
    x25OperEntryData.x25OperResetTimer = hwidb->x25_t2;
    x25OperEntryData.x25OperClearTimer = hwidb->x25_t3;
    x25OperEntryData.x25OperWindowTimer = MAX_POSITIVE_32;
    x25OperEntryData.x25OperDataRxmtTimer = MAX_POSITIVE_32;
    x25OperEntryData.x25OperInterruptTimer = MAX_POSITIVE_32;
    x25OperEntryData.x25OperRejectTimer = MAX_POSITIVE_32;
    x25OperEntryData.x25OperRegistrationRequestTimer = MAX_POSITIVE_32;
    x25OperEntryData.x25OperMinimumRecallTimer = (hwidb->x25_holdtime
						  * MSEC_PER_MIN);
    x25OperEntryData.x25OperRestartCount = IS_DTE(hwidb, x25_dce) ?
	MAX_POSITIVE_32 : 1; 
    x25OperEntryData.x25OperResetCount = 1;
    x25OperEntryData.x25OperClearCount = 1;
    x25OperEntryData.x25OperDataRxmtCount = 0;
    x25OperEntryData.x25OperRejectCount = 0;
    x25OperEntryData.x25OperRegistrationRequestCount = 0;
    x25OperEntryData.x25OperNumberPVCs = compute_num_pvcs(hwidb);
    x25OperEntryData.x25OperDefCallParamId = &x25nullOID;

    x25OperEntryData.x25OperLocalAddress = &x25OperLocalAddress;
    x25OperEntryData.x25OperLocalAddress->octet_ptr =
	hwidb->x25_address->x121_addr;
    x25OperEntryData.x25OperLocalAddress->length =
	hwidb->x25_address->length;

    x25OperEntryData.x25OperDataLinkId = &x25nullOID;
    x25OperEntryData.x25OperProtocolVersionSupported = 
	&x25ProtocolVersionSupported;

    return (&x25OperEntryData);
}

x25StatEntry_t *k_x25StatEntry_get (int          serialNum,
				    ContextInfo *contextInfo,
				    int          nominator,
				    int          searchType,
				    long         x25StatIndex)
{
    static x25StatEntry_t x25StatEntryData;

    hwidbtype *hwidb;
    lcitype *lci;
    int lci_num;

    hwidb = ifmib_hwidb_get(serialNum, searchType, x25StatIndex,
			    snmp_x25_idb_tester, NULL);
    if (hwidb == NULL)
	return (NULL);

    x25StatEntryData.x25StatIndex = hwidb->snmp_if_index;
    x25StatEntryData.x25StatInCalls = hwidb->x25_callsrcvd;
    x25StatEntryData.x25StatInCallRefusals = hwidb->x25_callsrcvdfailed;
    x25StatEntryData.x25StatInProviderInitiatedClears =
	hwidb->x25_provider_clears; 
    x25StatEntryData.x25StatInRemotelyInitiatedResets = hwidb->x25_dte_resets;
    x25StatEntryData.x25StatInProviderInitiatedResets = hwidb->x25_dce_resets;
    x25StatEntryData.x25StatInRestarts = hwidb->x25_unexp_restarts_rx;
    x25StatEntryData.x25StatInDataPackets = hwidb->x25_data_rx;
    x25StatEntryData.x25StatInAccusedOfProtocolErrors =
	hwidb->x25_errors_accused; 
    x25StatEntryData.x25StatInInterrupts = hwidb->x25_interrupt_rx;
    x25StatEntryData.x25StatOutCallAttempts = hwidb->x25_callssent;
    x25StatEntryData.x25StatOutCallFailures = hwidb->x25_callssentfailed;
    x25StatEntryData.x25StatOutInterrupts = hwidb->x25_interrupt_tx;
    x25StatEntryData.x25StatOutDataPackets = hwidb->x25_data_tx;
    x25StatEntryData.x25StatOutgoingCircuits = 0;
    if (hwidb->x25_upstate && hwidb->x25_loc &&
	hwidb->x25_hoc >= hwidb->x25_loc) {
	lci_num = hwidb->x25_loc - 1;
	while ((lci = x25_lci_lookup_next(hwidb, lci_num, NULL))) {
	    if (lci->lci_lci > hwidb->x25_hoc)
		break;
	    x25StatEntryData.x25StatOutgoingCircuits++;
	    lci_num = lci->lci_lci;
	}
    }
    x25StatEntryData.x25StatIncomingCircuits = 0;
    if (hwidb->x25_upstate && hwidb->x25_lic &&
	hwidb->x25_hic >= hwidb->x25_lic) {
	lci_num = hwidb->x25_lic - 1;
	while ((lci = x25_lci_lookup_next(hwidb, lci_num, NULL))) {
	    if (lci->lci_lci > hwidb->x25_hic)
		break;
	    x25StatEntryData.x25StatIncomingCircuits++;
	    lci_num = lci->lci_lci;
	}
    }
    x25StatEntryData.x25StatTwowayCircuits = 0;
    if (hwidb->x25_upstate && hwidb->x25_ltc &&
	hwidb->x25_htc >= hwidb->x25_ltc) {
	lci_num = hwidb->x25_ltc - 1;
	while ((lci = x25_lci_lookup_next(hwidb, lci_num, NULL))) {
	    if (lci->lci_lci > hwidb->x25_htc)
		break;
	    x25StatEntryData.x25StatTwowayCircuits++;
	    lci_num = lci->lci_lci;
	}
    }
    x25StatEntryData.x25StatRestartTimeouts = hwidb->x25_t0_count;
    x25StatEntryData.x25StatCallTimeouts = hwidb->x25_t1_count;
    x25StatEntryData.x25StatResetTimeouts = hwidb->x25_t2_count;
    x25StatEntryData.x25StatClearTimeouts = hwidb->x25_t3_count;
    x25StatEntryData.x25StatDataRxmtTimeouts = 0;
    x25StatEntryData.x25StatInterruptTimeouts = 0;
    x25StatEntryData.x25StatRetryCountExceededs = hwidb->x25_retries_exhausted;
    x25StatEntryData.x25StatClearCountExceededs = hwidb->x25_clears_exhausted;

    return (&x25StatEntryData);
}

x25ChannelEntry_t *k_x25ChannelEntry_get (int          serialNum,
					  ContextInfo *contextInfo,
					  int          nominator,
					  int          searchType,
					  long         x25ChannelIndex)
{
    static x25ChannelEntry_t x25ChannelEntryData;

    hwidbtype *hwidb;

    hwidb = ifmib_hwidb_get(serialNum, searchType, x25ChannelIndex,
			    snmp_x25_idb_tester, NULL);
    if (hwidb == NULL)
	return (NULL);

    x25ChannelEntryData.x25ChannelIndex = hwidb->snmp_if_index;
    x25ChannelEntryData.x25ChannelLIC = hwidb->x25_admin_lic;
    x25ChannelEntryData.x25ChannelHIC = hwidb->x25_admin_hic;
    x25ChannelEntryData.x25ChannelLTC = hwidb->x25_admin_ltc;
    x25ChannelEntryData.x25ChannelHTC = hwidb->x25_admin_htc;
    x25ChannelEntryData.x25ChannelLOC = hwidb->x25_admin_loc;
    x25ChannelEntryData.x25ChannelHOC = hwidb->x25_admin_hoc;

    return (&x25ChannelEntryData);
}

int k_x25ChannelEntry_set(x25ChannelEntry_t *data,
			  ContextInfo       *contextInfo,
			  int                function)
{
    return (GEN_ERROR);
}
/* return TRUE if there is vc is  configured */
static boolean snmp_lci_idb_tester (hwidbtype *idb, long* vc)
{
   lcitype          *lci;
   if (is_x25(idb)){
       if ((lci = x25_lci_lookup_next(idb, *vc == 0? 0: *vc - 1, 0)) != NULL){
           *vc = lci->lci_lci;
           return TRUE; 
       }
   }
   return FALSE;      /* cant find one */
}



x25CircuitEntry_t *k_x25CircuitEntry_get (int          serialNum,
					  ContextInfo *contextInfo,
					  int          nominator,
					  int          searchType,
					  long         x25CircuitIndex,
					  long         x25CircuitChannel)
{
    static x25CircuitEntry_t   x25CircuitEntryData;
    static OctetString         x25CircuitCalledDteAddress;
    static OctetString         x25CircuitCallingDteAddress;
    static OctetString         x25CircuitOriginallyCalledAddress;
    static OctetString         x25CircuitDescr;

    hwidbtype        *hwidb;
    lcitype          *lci = NULL;


    hwidb = 
	ifmib_2indices_get(serialNum, searchType, x25CircuitIndex,
			   snmp_lci_idb_tester, &x25CircuitChannel);
    if (hwidb)
	lci = x25_lci_lookup (hwidb, x25CircuitChannel, NULL);

    /* Next or not, we ought to have an LCI now.  If we don't, then bail */
    if (lci == NULL)
	return(NULL);

    x25CircuitEntryData.x25CircuitIndex = hwidb->snmp_if_index;
    x25CircuitEntryData.x25CircuitChannel = lci->lci_lci;
    /*
     *  VCs in state P1 don't have an lci, so shouldn't get here
     */
    if (IS_LCI_PVC(hwidb, lci->lci_lci)) {
	if (lci->lci_state == X25_D2 || lci->lci_state == X25_D3)
	    x25CircuitEntryData.x25CircuitStatus = 
		D_x25CircuitStatus_pvcResetting;
	else
	    x25CircuitEntryData.x25CircuitStatus = D_x25CircuitStatus_pvc;
    } else {
	switch (lci->lci_state) {
   	    case X25_X1:
	    case X25_P1:
	        x25CircuitEntryData.x25CircuitStatus =
		    D_x25CircuitStatus_closed;
	        break;
            case X25_P2:
            case X25_P3:
            case X25_P5:
                x25CircuitEntryData.x25CircuitStatus =
		    D_x25CircuitStatus_calling;
                break;
            case X25_P4:
            case X25_D1:
            case X25_D2:
            case X25_D3:
                x25CircuitEntryData.x25CircuitStatus =
		    D_x25CircuitStatus_open;
                break;
            case X25_P6:
            case X25_P7:
                x25CircuitEntryData.x25CircuitStatus = 
		    D_x25CircuitStatus_clearing;
                break;
            default:
                x25CircuitEntryData.x25CircuitStatus = 
		    D_x25CircuitStatus_other;
                break;
        }
    }
    x25CircuitEntryData.x25CircuitEstablishTime =
	SNMP_ABSOLUTE_TIME(lci->lci_starttime);
    
    if (IS_LCI_PVC(hwidb, lci->lci_lci))
	x25CircuitEntryData.x25CircuitDirection = D_x25CircuitDirection_pvc;
    else if (lci->lci_outgoing)
	x25CircuitEntryData.x25CircuitDirection = 
	    D_x25CircuitDirection_outgoing;
    else
	x25CircuitEntryData.x25CircuitDirection =
	    D_x25CircuitDirection_incoming;
    x25CircuitEntryData.x25CircuitInOctets = lci->lci_bytesrcvd;
    x25CircuitEntryData.x25CircuitInPdus = lci->lci_packetsrcvd;
    x25CircuitEntryData.x25CircuitInRemotelyInitiatedResets =
	lci->lci_dte_resets; 
    x25CircuitEntryData.x25CircuitInProviderInitiatedResets = 
	lci->lci_dce_resets;
    x25CircuitEntryData.x25CircuitInInterrupts = lci->lci_intsrcvd;
    x25CircuitEntryData.x25CircuitOutOctets = lci->lci_bytessent;
    x25CircuitEntryData.x25CircuitOutPdus = lci->lci_packetssent;
    x25CircuitEntryData.x25CircuitOutInterrupts = lci->lci_intssent;
    x25CircuitEntryData.x25CircuitDataRetransmissionTimeouts = 0;
    x25CircuitEntryData.x25CircuitResetTimeouts = lci->lci_t2_count;
    x25CircuitEntryData.x25CircuitInterruptTimeouts = 0;
    x25CircuitEntryData.x25CircuitCallParamId = &x25nullOID;

    x25CircuitEntryData.x25CircuitCalledDteAddress =
	&x25CircuitCalledDteAddress;
    x25CircuitEntryData.x25CircuitCalledDteAddress->octet_ptr =
	lci->lci_dst_addr.x121_addr;
    x25CircuitEntryData.x25CircuitCalledDteAddress->length =
	lci->lci_dst_addr.length;

    x25CircuitEntryData.x25CircuitCallingDteAddress =
	&x25CircuitCallingDteAddress;
    x25CircuitEntryData.x25CircuitCallingDteAddress->octet_ptr =
	lci->lci_src_addr.x121_addr;
    x25CircuitEntryData.x25CircuitCallingDteAddress->length =
	lci->lci_src_addr.length;

    x25CircuitEntryData.x25CircuitOriginallyCalledAddress = 
	&x25CircuitOriginallyCalledAddress;
    x25CircuitEntryData.x25CircuitOriginallyCalledAddress->octet_ptr =
	lci->lci_orig_dst_addr.x121_addr; 
    x25CircuitEntryData.x25CircuitOriginallyCalledAddress->length =
	lci->lci_orig_dst_addr.length;

    x25CircuitEntryData.x25CircuitDescr = &x25CircuitDescr;

    switch (lci->lci_linktype) {
    case LINK_X25SERVICE:
	switch ((int)lci->lci_rtp->data) {
	case X25_FUNC_CHARGEN:
	    x25CircuitEntryData.x25CircuitDescr->octet_ptr =
		"Character generation function VC";
	    break;
	case X25_FUNC_DISCARD:
	    x25CircuitEntryData.x25CircuitDescr->octet_ptr =
		"Discard function VC";
	    break;
	case X25_FUNC_HELP:
	    x25CircuitEntryData.x25CircuitDescr->octet_ptr =
		"Help function VC";
	    break;
	case X25_FUNC_ECHO:
	    x25CircuitEntryData.x25CircuitDescr->octet_ptr =
		"Echo function VC";
	    break;
	default:
	    x25CircuitEntryData.x25CircuitDescr->octet_ptr =
		"UNKNOWN function VC";
	    break;
	}
	break;
    case LINK_X25:
	if (lci->lci_map && (lci->lci_map->map_linktype == LINK_CMNS))
	    x25CircuitEntryData.x25CircuitDescr->octet_ptr =
		"OSI CMNS routed VC";
	else if (lci->lci_swtype == X25_ROUTE_IF)
	    x25CircuitEntryData.x25CircuitDescr->octet_ptr =
		"Locally routed VC";
	else if (lci->lci_swtype == X25_ROUTE_IPADDR)
	    x25CircuitEntryData.x25CircuitDescr->octet_ptr =
		"Remotely routed VC";
	else
	    x25CircuitEntryData.x25CircuitDescr->octet_ptr =
		"UNKNOWN type of routed VC";
	break;
    case LINK_PAD:
	x25CircuitEntryData.x25CircuitDescr->octet_ptr = "PAD VC";
	break;
    case LINK_CLNS:
	x25CircuitEntryData.x25CircuitDescr->octet_ptr =
	    "OSI CLNS encapsulation VC";
	break;
    case LINK_IP:
	x25CircuitEntryData.x25CircuitDescr->octet_ptr =
	    "IP encapsulation VC";
	break;
    case LINK_COMPRESSED_TCP:
	x25CircuitEntryData.x25CircuitDescr->octet_ptr =
	    "TCP header compression encapsulation VC";
	break;
    case LINK_PUP:
	x25CircuitEntryData.x25CircuitDescr->octet_ptr =
	    "PUP encapsulation VC";
	break;
    case LINK_DECNET:
    case LINK_DECNET_ROUTER_L1:
    case LINK_DECNET_ROUTER_L2:
    case LINK_DECNET_PRIME_ROUTER:
    case LINK_DECNET_NODE:
	x25CircuitEntryData.x25CircuitDescr->octet_ptr =
	    "DECnet encapsulation VC";
	break;
    case LINK_XNS:
	x25CircuitEntryData.x25CircuitDescr->octet_ptr =
	    "XNS encapsulation VC";
	break;
    case LINK_APPLETALK:
	x25CircuitEntryData.x25CircuitDescr->octet_ptr =
	    "AppleTalk encapsulation VC";
	break;
    case LINK_NOVELL:
	x25CircuitEntryData.x25CircuitDescr->octet_ptr =
	    "Novell IPX encapsulation VC";
	break;
    case LINK_APOLLO:
	x25CircuitEntryData.x25CircuitDescr->octet_ptr =
	    "Apollo Domain encapsulation VC";
	break;
    case LINK_BRIDGE:
	x25CircuitEntryData.x25CircuitDescr->octet_ptr =
	    "Bridging encapsulation VC";
	break;
    case LINK_QLLC:
	x25CircuitEntryData.x25CircuitDescr->octet_ptr =
	    "QLLC encapsulation VC";
	break;
    default:
	x25CircuitEntryData.x25CircuitDescr->octet_ptr = 
	    "UNKNOWN encapsulation VC"; 
	break;
    }
    x25CircuitEntryData.x25CircuitDescr->length =
	strlen(x25CircuitEntryData.x25CircuitDescr->octet_ptr); 

    return (&x25CircuitEntryData);
}

int k_x25CircuitEntry_set (x25CircuitEntry_t *data,
			   ContextInfo       *contextInfo,
			   int                function)
{
    return (GEN_ERROR);
}

x25ClearedCircuitEntry_t *k_x25ClearedCircuitEntry_get (
    int          serialNum,
    ContextInfo *contextInfo,
    int          nominator,
    int          searchType,
    long         x25ClearedCircuitIndex)
{
#ifdef NOT_YET
    static x25ClearedCircuitEntry_t  x25ClearedCircuitEntryData;
    hwidbtype              *hwidb;

    hwidb = ifmib_hwidb_get(serialNum, searchType,
			    x25ClearedCircuitIndex,
			    snmp_x25_idb_tester, NULL);
    if (hwidb == NULL)
	return (NULL);

    x25ClearedCircuitEntryData.x25ClearedCircuitIndex = hwidb->snmp_if_index;
    x25ClearedCircuitEntryData.x25ClearedCircuitPleIndex =;
    x25ClearedCircuitEntryData.x25ClearedCircuitTimeEstablished =;
    x25ClearedCircuitEntryData.x25ClearedCircuitTimeCleared =;
    x25ClearedCircuitEntryData.x25ClearedCircuitChannel =;
    x25ClearedCircuitEntryData.x25ClearedCircuitClearingCause =;
    x25ClearedCircuitEntryData.x25ClearedCircuitDiagnosticCode =;
    x25ClearedCircuitEntryData.x25ClearedCircuitInPdus =;
    x25ClearedCircuitEntryData.x25ClearedCircuitOutPdus =;
    x25ClearedCircuitEntryData.x25ClearedCircuitCalledAddress =;
    x25ClearedCircuitEntryData.x25ClearedCircuitCallingAddress =;
    x25ClearedCircuitEntryData.x25ClearedCircuitClearFacilities =;

    return (&x25ClearedCircuitEntryData);
#else				       /* NOT_YET */
    return (NULL);
#endif				       /* NOT_YET */
}

x25CallParmEntry_t *k_x25CallParmEntry_get (int          serialNum,
					    ContextInfo *contextInfo,
					    int          nominator,
					    int          searchType,
					    long         x25CallParmIndex)
{
#ifdef NOT_YET
    static x25CallParmEntry_t   x25CallParmEntryData;
    hwidbtype                  *hwidb;

    hwidb = ifmib_hwidb_get(serialNum, searchType, x25CallParmIndex,
			    snmp_x25_idb_tester, NULL);
    if (hwidb == NULL)
	return (NULL);

    x25CallParmEntryData.x25CallParmIndex = hwidb->snmp_if_index;
    x25CallParmEntryData.x25CallParmStatus =;
    x25CallParmEntryData.x25CallParmRefCount =;
    x25CallParmEntryData.x25CallParmInPacketSize =;
    x25CallParmEntryData.x25CallParmOutPacketSize =;
    x25CallParmEntryData.x25CallParmInWindowSize =;
    x25CallParmEntryData.x25CallParmOutWindowSize =;
    x25CallParmEntryData.x25CallParmAcceptReverseCharging =;
    x25CallParmEntryData.x25CallParmProposeReverseCharging =;
    x25CallParmEntryData.x25CallParmFastSelect =;
    x25CallParmEntryData.x25CallParmInThruPutClasSize =;
    x25CallParmEntryData.x25CallParmOutThruPutClasSize =;
    x25CallParmEntryData.x25CallParmCug =;
    x25CallParmEntryData.x25CallParmCugoa =;
    x25CallParmEntryData.x25CallParmBcug =;
    x25CallParmEntryData.x25CallParmNui =;
    x25CallParmEntryData.x25CallParmChargingInfo =;
    x25CallParmEntryData.x25CallParmRpoa =;
    x25CallParmEntryData.x25CallParmTrnstDly =;
    x25CallParmEntryData.x25CallParmCallingExt =;
    x25CallParmEntryData.x25CallParmCalledExt =;
    x25CallParmEntryData.x25CallParmInMinThuPutCls =;
    x25CallParmEntryData.x25CallParmOutMinThuPutCls =;
    x25CallParmEntryData.x25CallParmEndTrnsDly =;
    x25CallParmEntryData.x25CallParmPriority =;
    x25CallParmEntryData.x25CallParmProtection =;
    x25CallParmEntryData.x25CallParmExptData =;
    x25CallParmEntryData.x25CallParmUserData =;
    x25CallParmEntryData.x25CallParmCallingNetworkFacilities =;
    x25CallParmEntryData.x25CallParmCalledNetworkFacilities =;

    return (&x25CallParmEntryData);
#else				       /* NOT_YET */
    return (NULL);
#endif				       /* NOT_YET */
}

int k_x25CallParmEntry_set (x25CallParmEntry_t *data,
			    ContextInfo        *contextInfo,
			    int                 function)
{
    return (GEN_ERROR);
}

/*
          x25Restart      TRAP-TYPE
                  ENTERPRISE  x25
                  VARIABLES { x25OperIndex }
                  DESCRIPTION
                          "This trap means the X.25 PLE sent or
                          received a restart packet.  The restart that
                          brings up the link should not send a
                          x25Restart trap so the interface should send
                          a linkUp trap.  Sending this trap means the
                          agent does not send a linkDown and linkUp
                          trap."
                  ::= 1
*/

#define RESTART_VBCOUNT 1
#define RESTART_TRAPNUM 1

static const OID restartVarBinds[RESTART_VBCOUNT] = {
    {LNx25OperIndex, (ulong *)IDx25OperIndex}
};

static void generate_x25Restart_trap (hwidbtype *idb)
{
    OID         instanceOID;
    ulong       instance[1];

    /*
     * All the trap varbind objects have an instance described by
     * INDEX { x25OperIndex }
     */
    instance[0] = idb->snmp_if_index;
    instanceOID.oid_ptr = instance;
    instanceOID.length = 1;

    /*
     * generate the trap
     */
    SnmpSendTrap_Generic(restartVarBinds,
			 &x25enterprise,
			 restart_trap_oid,
			 &instanceOID,
			 RESTART_VBCOUNT,
			 ENTERPRISE_TRAP,
			 RESTART_TRAPNUM);
}

/*
          x25Reset        TRAP-TYPE
                  ENTERPRISE  x25
                  VARIABLES { x25CircuitIndex,
                          x25CircuitChannel }
                  DESCRIPTION
                          "If the PLE sends or receives a reset, the
                          agent should send an x25Reset trap."
                  ::= 2
*/

#define RESET_VBCOUNT 2
#define RESET_TRAPNUM 2

static const OID resetVarBinds[RESET_VBCOUNT] = {
    {LNx25CircuitIndex, (ulong *)IDx25CircuitIndex},
    {LNx25CircuitChannel, (ulong *)IDx25CircuitChannel}
};

static void generate_x25Reset_trap (lcitype *lci)
{
    OID         instanceOID;
    ulong       instance[2];

    /*
     * All the trap varbind objects have an instance described by
     * INDEX { x25CircuitIndex, x25CircuitChannel }
     */
    instance[0] = lci->lci_idb->hwptr->snmp_if_index;
    instance[1] = lci->lci_lci;
    instanceOID.oid_ptr = instance;
    instanceOID.length = 2;

    /*
     * generate the trap
     */
    SnmpSendTrap_Generic(resetVarBinds,
			 &x25enterprise,
			 reset_trap_oid,
			 &instanceOID,
			 RESET_VBCOUNT,
			 ENTERPRISE_TRAP,
			 RESET_TRAPNUM);
}



static ifmib_err_t x25_subif_cntr32fn (
	  ifmib_cntr_t	ifCntr,
	  const	subiabtype *subiab,
          ulong		*retval,
	  int     serialNum)
/* 
 * get the specified ifEntry or ifXEntry counter 
 * INPUTS:
 *	ifCntr == enum of specific counter requested
 *	if_ptr == r/o pointer to IDB for this interface
 *      serialNum == passed in from getrequest for caching
 * OUTPUTS:
 *	*retval == the returned counter value
 * RETURNS:
 *	return status
 *
 *  this routine needed to support subinterfaces in ifmib
 */

{
    hwidbtype  *hwidb;
    lcitype *lci;
    int lci_num;
    boolean  lci_found;
    const snmpifptrtype *if_ptr;

    hwidb = NULL;
    lci_num = 0;
    lci_found  = FALSE;
    *retval = 0;
    if_ptr = &subiab->master_ptr;

   if ((if_ptr) && (if_ptr->ifptr.swidb) && (if_ptr->ifptr.swidb->hwptr))
       hwidb = if_ptr->ifptr.swidb->hwptr;
    else
	return(IF_CNTR_NOT_AVAIL);


    while ((lci = x25_lci_lookup_next(hwidb, lci_num, NULL))) {
	lci_found = TRUE;
	lci_num = lci->lci_lci;
	switch (ifCntr) {
	case IN_OCTETS_CNTR:
	    *retval += lci->lci_bytesrcvd;
	    break;
	    
	case OUT_OCTETS_CNTR:
	    *retval += lci->lci_bytessent;
	    break;
	    /*
	     * these are separated because they should be supported for a
	     * conformant agent, but aren't available in the router yet
	     */
	case IN_ERRORS_CNTR:
	case IN_UNK_PROTOS_CNTR:
	case OUT_ERRORS_CNTR:
	    
	case IN_UCAST_CNTR:
	case IN_DISCARDS_CNTR:
	case OUT_UCAST_CNTR:
	case OUT_DISCARDS_CNTR:
	case IN_BCAST_CNTR:			/* ifXTable */
	case IN_MCAST_CNTR:
	case OUT_BCAST_CNTR:
	case OUT_MCAST_CNTR:
	default:
	    return(IF_CNTR_NOT_AVAIL);
	    
	}
    }
    if (lci_found)
	return (IF_NO_ERR);
    else 
	return(IF_CNTR_NOT_AVAIL);
}

static void x25_add_subif(idbtype *idb)
{
    snmpifptrtype if_ptr;
    ulong state;
    snmpidbtype *snmpidb = NULL;    
    subiabtype  *subiab;
    uint type;
    boolean result;

    if(idb->subif_state & SUBIF_STATE_DELETED)
	return;

    if (idb && idb->snmp_if_index) 
	snmpidb =  ifmib_snmpidb_get(NULL,0,EXACT,idb->snmp_if_index,NULL,NULL);

    if (snmpidb != NULL)
	return;

    subiab = malloc(sizeof(subiabtype));
    if (!subiab)
	return;

    subiab->master_ptr.ifptr.swidb = idb;
    subiab->master_type = SNMP_IF_SWIDB;
    if_ptr.ifptr.subiab = subiab;

    subiab->data_ptr = NULL;
    subiab->cleaner = NULL;

    if (ISDDN(idb->hwptr))
	type =  D_ifType_ddnX25;
    else 
	type = D_ifType_rfc877x25;
    state = reg_invoke_ifmib_get_adminstatus(type, subiab);
    
    subiab->snmp_if_index = 0; 	/*uint  ifIndex */
    subiab->if_descrstring = idb->namestring;
    subiab->if_name = idb->short_namestring;
    subiab->ifPhysAddr = 0;
    subiab->ifPhysAddrLen = NULL;
    subiab->ifType = type;
    subiab->maxmtu = NULL;          /* not applicable */
    result = reg_invoke_ifmib_register_subif(&if_ptr, SNMP_IF_SUBIAB, state);
    if (!result) {
	free(subiab);
	return;
    }
    /* 
     * now add the link to the ifmib stack table
     */
    reg_invoke_ifmib_create_stacklink(idb->snmp_if_index,idb->hwptr->snmp_if_index);
}

/*
 * x25mib subsystem header
 */

#define MAJVERSION_x25mib 1
#define MINVERSION_x25mib 0
#define EDITVERSION_x25mib 0

SUBSYS_HEADER(x25mib,
              MAJVERSION_x25mib,
              MINVERSION_x25mib,
              EDITVERSION_x25mib,
              init_x25mib,
              SUBSYS_CLASS_MANAGEMENT,
              "req: x25",
              NULL);
      
