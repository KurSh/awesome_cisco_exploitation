/* $Id: sr_newfddimib.c,v 3.6.12.4 1996/07/03 20:44:56 thille Exp $
 * $Source: /release/112/cvs/Xsys/xdi/sr_newfddimib.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * RFC 1512 FDDI SMT 7.3 MIB Support
 * June 1994, Chifei W. Cheng (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1995-1997 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_newfddimib.c,v $
 * Revision 3.6.12.4  1996/07/03  20:44:56  thille
 * CSCdi61860: Implement Jeffs glass of slim-fast for snmp
 * Branch: California_branch
 * Take hunk of common code from many mib files, make it a procedure in
 * snmp_util.c and call it from the mibs.  Save 1640 bytes.
 *
 * Revision 3.6.12.3  1996/07/01  18:47:03  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.6.12.2  1996/04/19  17:54:28  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.6.12.1  1996/03/18  22:51:45  gstovall
 * Branch: California_branch
 * Elvis has left the building.  He headed out to California, and took the
 * port ready changes with him.
 *
 * Revision 3.5.2.2  1996/03/16  07:58:17  gstovall
 * Branch: DeadKingOnAThrone_branch
 * Make the king aware of V111_1_3.
 *
 * Revision 3.5.2.1  1996/03/07  11:20:47  mdb
 * Branch: DeadKingOnAThrone_branch
 * cisco and ANSI/POSIX libraries.
 *
 * Revision 3.6  1996/02/15  17:30:13  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.5  1996/01/22  07:52:19  mdb
 * CSCdi47065:  misuse of NULL macro in IOS sources
 *
 * Revision 3.4  1996/01/18  15:57:48  anke
 * CSCdi46969:  Change empty req and/or seq strings in SUBSYS_HEADERs to
 *              NULL
 *              Five bytes saved is five bytes earned
 *
 * Revision 3.3  1995/12/14  08:29:53  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.2  1995/11/17  19:19:58  gstovall
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  13:56:34  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.3  1995/07/17  07:35:47  bchan
 * CSCdi34760:  Ifindex usage incorrect
 *
 * Revision 2.2  1995/06/28  09:33:33  smackie
 * Repair widespread subsystem header braindamage. (CSCdi23568)
 *
 *   o Fix subsystem entry points to be foo(subsystype *) not foo(void)
 *   o Repair nonsensical and redundant subsystem sequences
 *   o Use NULL where no property is required
 *
 * Revision 2.1  1995/06/07  23:26:14  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include <string.h>
#include <ciscolib.h>
#include "subsys.h"
#include "interface_private.h"
#include "../if/fddi.h"
#include "sr_newfddimib.h"
#include "sr_newfddimib-mib.h"
					/* the following are XLNT originated */
#include "../xdi/xdihdrsif.h"		/* include platform specific .h's */
#include "../xdi/smtmsg.h"		/* smttypes.h is included in if/if_xdi.h */
#include "../xdi/mibglbl.h"
#include "../xdi/mibproto.h"
#include "../xdi/fddihdr.h"

#include "../if/if_fddi.h"
#include "../hes/if_mci.h"		/* just because of mciregtype */
#include "../hes/if_fci.h"		/* because of hes_xdi.h */
#include "../hes/hes_fddi_public.h"	/* because of hes_xdi.h */

/* some global vars private to this file for fddimibPATHConfigTable: */
static FDDIAvailablePaths	searchPath;
static uchar	startIndex, currentIndex;
static ushort	startType, currentType;
static long	resourceCt;
static int	totalResource;



/*
 *  Utilities to convert timers in internal format to FddiTimeNano 
 *  which is integer of (0..2147483647) nano seconds.
 *  Most timers are in ANSI TimerTwosComplement format which is 
 *  2's complement of the time value in unit of 80 ns.
 *  1 milisec (ms) = 1000 microsec (us) = 1000000 nanosec (ns)
 */
				/* below is ((2's comp. of time)*80) */
#define snmpFddi_2sCompToTimeNano(time) (((-(time)) << 4) * 5)
				/* below is (2's comp. of (time/80)) */
#define snmpFddi_nsTo2sComp(time) (-(((time) / 5) >> 4)) 
				/* below turns us to ns -- times 1000 */
#define snmpFddi_us2ns(time) (((time) << 3) * 125)
				/* below turns ns to us -- devided by 1000 */
#define snmpFddi_ns2us(time) (((time) / 125) >> 3)
				/* below turns 80ns base to ms,
				 * (time*80) / 1000000, i.e. (time/5^5)/2^2) */
#define snmpFddi_80ns2ms(time) (((time) / 3125) >> 2)
				/* below turns ms to 80ns, reverse of above */
#define snmpFddi_ms2ns80(time) (((time) << 2) * 3125)



void
init_newfddimib (subsystype *subsys)
{
    load_mib(newfddimib_OidList, newfddimib_OidListNum);
    load_oid(newfddimib_oid_table);
    totalResource = MAX_MAC_COUNT + MAX_PORT_COUNT;
}








/*---------------------------------------------------------------------
 * Retrieve data from the fddimibSMT family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
fddimibSMT_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             arg;
    void           *dp;
    fddimibSMT_t   *data = NULL;


    arg = snmp_scalar_instance(incoming, object, searchType);

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_fddimibSMT_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_fddimibSMTNumber
      case I_fddimibSMTNumber:
	dp = &data->fddimibSMTNumber;
	break;
#endif				       /* I_fddimibSMTNumber */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the fddimibSMTEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
fddimibSMTEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength;
    int             arg;
    void           *dp;
    fddimibSMTEntry_t *data;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            fddimibSMTIndex;

    instLength = incoming->length - object->oid.length;
    arg = object->nominator;
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &fddimibSMTIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_fddimibSMTEntry_get(serialNum, contextInfo, arg, searchType, fddimibSMTIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->fddimibSMTIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_fddimibSMTIndex
      case I_fddimibSMTIndex:
	dp = &data->fddimibSMTIndex;
	break;
#endif				       /* I_fddimibSMTIndex */

#ifdef I_fddimibSMTStationId
      case I_fddimibSMTStationId:
	dp = MakeOctetString(data->fddimibSMTStationId->octet_ptr, data->fddimibSMTStationId->length);
	break;
#endif				       /* I_fddimibSMTStationId */

#ifdef I_fddimibSMTOpVersionId
      case I_fddimibSMTOpVersionId:
	dp = &data->fddimibSMTOpVersionId;
	break;
#endif				       /* I_fddimibSMTOpVersionId */

#ifdef I_fddimibSMTHiVersionId
      case I_fddimibSMTHiVersionId:
	dp = &data->fddimibSMTHiVersionId;
	break;
#endif				       /* I_fddimibSMTHiVersionId */

#ifdef I_fddimibSMTLoVersionId
      case I_fddimibSMTLoVersionId:
	dp = &data->fddimibSMTLoVersionId;
	break;
#endif				       /* I_fddimibSMTLoVersionId */

#ifdef I_fddimibSMTUserData
      case I_fddimibSMTUserData:
	dp = MakeOctetString(data->fddimibSMTUserData->octet_ptr, data->fddimibSMTUserData->length);
	break;
#endif				       /* I_fddimibSMTUserData */

#ifdef I_fddimibSMTMIBVersionId
      case I_fddimibSMTMIBVersionId:
	dp = &data->fddimibSMTMIBVersionId;
	break;
#endif				       /* I_fddimibSMTMIBVersionId */

#ifdef I_fddimibSMTMACCts
      case I_fddimibSMTMACCts:
	dp = &data->fddimibSMTMACCts;
	break;
#endif				       /* I_fddimibSMTMACCts */

#ifdef I_fddimibSMTNonMasterCts
      case I_fddimibSMTNonMasterCts:
	dp = &data->fddimibSMTNonMasterCts;
	break;
#endif				       /* I_fddimibSMTNonMasterCts */

#ifdef I_fddimibSMTMasterCts
      case I_fddimibSMTMasterCts:
	dp = &data->fddimibSMTMasterCts;
	break;
#endif				       /* I_fddimibSMTMasterCts */

#ifdef I_fddimibSMTAvailablePaths
      case I_fddimibSMTAvailablePaths:
	dp = &data->fddimibSMTAvailablePaths;
	break;
#endif				       /* I_fddimibSMTAvailablePaths */

#ifdef I_fddimibSMTConfigCapabilities
      case I_fddimibSMTConfigCapabilities:
	dp = &data->fddimibSMTConfigCapabilities;
	break;
#endif				       /* I_fddimibSMTConfigCapabilities */

#ifdef I_fddimibSMTConfigPolicy
      case I_fddimibSMTConfigPolicy:
	dp = &data->fddimibSMTConfigPolicy;
	break;
#endif				       /* I_fddimibSMTConfigPolicy */

#ifdef I_fddimibSMTConnectionPolicy
      case I_fddimibSMTConnectionPolicy:
	dp = &data->fddimibSMTConnectionPolicy;
	break;
#endif				       /* I_fddimibSMTConnectionPolicy */

#ifdef I_fddimibSMTTNotify
      case I_fddimibSMTTNotify:
	dp = &data->fddimibSMTTNotify;
	break;
#endif				       /* I_fddimibSMTTNotify */

#ifdef I_fddimibSMTStatRptPolicy
      case I_fddimibSMTStatRptPolicy:
	dp = &data->fddimibSMTStatRptPolicy;
	break;
#endif				       /* I_fddimibSMTStatRptPolicy */

#ifdef I_fddimibSMTTraceMaxExpiration
      case I_fddimibSMTTraceMaxExpiration:
	dp = &data->fddimibSMTTraceMaxExpiration;
	break;
#endif				       /* I_fddimibSMTTraceMaxExpiration */

#ifdef I_fddimibSMTBypassPresent
      case I_fddimibSMTBypassPresent:
	dp = &data->fddimibSMTBypassPresent;
	break;
#endif				       /* I_fddimibSMTBypassPresent */

#ifdef I_fddimibSMTECMState
      case I_fddimibSMTECMState:
	dp = &data->fddimibSMTECMState;
	break;
#endif				       /* I_fddimibSMTECMState */

#ifdef I_fddimibSMTCFState
      case I_fddimibSMTCFState:
	dp = &data->fddimibSMTCFState;
	break;
#endif				       /* I_fddimibSMTCFState */

#ifdef I_fddimibSMTRemoteDisconnectFlag
      case I_fddimibSMTRemoteDisconnectFlag:
	dp = &data->fddimibSMTRemoteDisconnectFlag;
	break;
#endif				       /* I_fddimibSMTRemoteDisconnectFlag */

#ifdef I_fddimibSMTStationStatus
      case I_fddimibSMTStationStatus:
	dp = &data->fddimibSMTStationStatus;
	break;
#endif				       /* I_fddimibSMTStationStatus */

#ifdef I_fddimibSMTPeerWrapFlag
      case I_fddimibSMTPeerWrapFlag:
	dp = &data->fddimibSMTPeerWrapFlag;
	break;
#endif				       /* I_fddimibSMTPeerWrapFlag */

#ifdef I_fddimibSMTTimeStamp
      case I_fddimibSMTTimeStamp:
	dp = &data->fddimibSMTTimeStamp;
	break;
#endif				       /* I_fddimibSMTTimeStamp */

#ifdef I_fddimibSMTTransitionTimeStamp
      case I_fddimibSMTTransitionTimeStamp:
	dp = &data->fddimibSMTTransitionTimeStamp;
	break;
#endif				       /* I_fddimibSMTTransitionTimeStamp */

#ifdef I_fddimibSMTStationAction
      case I_fddimibSMTStationAction:
	dp = &data->fddimibSMTStationAction;
	break;
#endif				       /* I_fddimibSMTStationAction */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the fddimibSMTEntry data object.
 *---------------------------------------------------------------------*/
void
fddimibSMTEntry_free(
    fddimibSMTEntry_t *data)
{
    if (data != NULL) {
	if (data->fddimibSMTUserData != NULL) {
	    FreeOctetString(data->fddimibSMTUserData);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after fddimibSMTEntry set/undo
 *---------------------------------------------------------------------*/
static int
fddimibSMTEntry_cleanup(
    doList_t       *trash)
{
    fddimibSMTEntry_free(trash->data);
#ifdef SR_SNMPv2
    fddimibSMTEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
fddimibSMTEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength;
    doList_t       *dp;
    VarBind        *vb;
    int             found;
    int             carry;
    fddimibSMTEntry_t *fddimibSMTEntry;
    long            fddimibSMTIndex;

    instLength = incoming->length - object->oid.length;
    vb = (VarBind *) NULL;
    carry = 0;

    /*
     * Validate the object instance
     */
    if (instLength != 1) {
	return NO_CREATION_ERROR;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &fddimibSMTIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    fddimibSMTEntry = k_fddimibSMTEntry_get(-1, contextInfo, object->nominator, EXACT, fddimibSMTIndex);

#ifndef fddimibSMTEntry_READ_CREATE

    if (fddimibSMTEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* fddimibSMTEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == fddimibSMTEntry_set) &&
	    (((fddimibSMTEntry_t *) (dp->data)) != NULL) &&
	    (((fddimibSMTEntry_t *) (dp->data))->fddimibSMTIndex == fddimibSMTIndex)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(fddimibSMTEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(fddimibSMTEntry_t));

	dp->setMethod = fddimibSMTEntry_set;
	dp->cleanupMethod = fddimibSMTEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_fddimibSMTIndex, ((fddimibSMTEntry_t *) (dp->data))->valid);
	((fddimibSMTEntry_t *) (dp->data))->fddimibSMTIndex = fddimibSMTIndex;

#ifdef fddimibSMTEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (fddimibSMTEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, fddimibSMTEntry, sizeof(fddimibSMTEntry_t));

	    SET_ALL_VALID(((fddimibSMTEntry_t *) (dp->data))->valid);

	    ((fddimibSMTEntry_t *) (dp->data))->fddimibSMTUserData =
		CloneOctetString(fddimibSMTEntry->fddimibSMTUserData);

	} else {


	    /* Fill in default values here */


	}
#endif				       /* fddimibSMTEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_fddimibSMTUserData
      case I_fddimibSMTUserData:

	/* validate there's only one var value as ascii string of length 32 */
	if (value->os_value->length != SIZE_SMTUserDataType)
	    return (WRONG_LENGTH_ERROR);

	SET_VALID(I_fddimibSMTUserData, ((fddimibSMTEntry_t *) (dp->data))->valid);

	if (((fddimibSMTEntry_t *) (dp->data))->fddimibSMTUserData != NULL) {
	    FreeOctetString(((fddimibSMTEntry_t *) (dp->data))->fddimibSMTUserData);
	}
	((fddimibSMTEntry_t *) (dp->data))->fddimibSMTUserData =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_fddimibSMTUserData */

#ifdef I_fddimibSMTConfigPolicy
      case I_fddimibSMTConfigPolicy:

	if (value->sl_value < D_fddimibSMTCfgPlcy_LowBound  ||
	    value->sl_value > D_fddimibSMTCfgPlcy_HighBound)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_fddimibSMTConfigPolicy, ((fddimibSMTEntry_t *) (dp->data))->valid);

	((fddimibSMTEntry_t *) (dp->data))->fddimibSMTConfigPolicy = value->sl_value;
	break;
#endif				       /* I_fddimibSMTConfigPolicy */

#ifdef I_fddimibSMTConnectionPolicy
      case I_fddimibSMTConnectionPolicy:

	if (value->sl_value < D_fddimibSMTConnPlcy_LowBound  ||
	    value->sl_value > D_fddimibSMTConnPlcy_HighBound)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_fddimibSMTConnectionPolicy, ((fddimibSMTEntry_t *) (dp->data))->valid);

	((fddimibSMTEntry_t *) (dp->data))->fddimibSMTConnectionPolicy = value->sl_value;
	break;
#endif				       /* I_fddimibSMTConnectionPolicy */

#ifdef I_fddimibSMTTNotify
      case I_fddimibSMTTNotify:

	if (value->sl_value < D_fddimibSMTNotify_LowBound ||
	    value->sl_value > D_fddimibSMTNotify_HighBound)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_fddimibSMTTNotify, ((fddimibSMTEntry_t *) (dp->data))->valid);

	((fddimibSMTEntry_t *) (dp->data))->fddimibSMTTNotify = value->sl_value;
	break;
#endif				       /* I_fddimibSMTTNotify */

#ifdef I_fddimibSMTStatRptPolicy
      case I_fddimibSMTStatRptPolicy:
	if (!(value->sl_value == D_fddimibSMTStatRptPolicy_true ||
	    value->sl_value == D_fddimibSMTStatRptPolicy_false))
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_fddimibSMTStatRptPolicy, ((fddimibSMTEntry_t *) (dp->data))->valid);

	((fddimibSMTEntry_t *) (dp->data))->fddimibSMTStatRptPolicy = value->sl_value;
	break;
#endif				       /* I_fddimibSMTStatRptPolicy */

#ifdef I_fddimibSMTTraceMaxExpiration
      case I_fddimibSMTTraceMaxExpiration:
/*
 * fddimibSMTTraceMaxExpiration is of type FddiTimeMilli (integer 
 * 0..2147483647), but its internal value is 80 ns based. So it won't
 * work to take 2147483647 as the high limit check for the incoming
 * set value (in ms). Rather, 2147483647 should be the ceiling for 
 * internal value to avoid overflow and thus incorrect value stored.
 */
	if (value->sl_value < D_fddiTime_LowBound ||
	    value->sl_value > snmpFddi_80ns2ms(D_fddiTime_HighBound))
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_fddimibSMTTraceMaxExpiration, ((fddimibSMTEntry_t *) (dp->data))->valid);

	((fddimibSMTEntry_t *) (dp->data))->fddimibSMTTraceMaxExpiration = value->sl_value;
	break;
#endif				       /* I_fddimibSMTTraceMaxExpiration */

#ifdef I_fddimibSMTStationAction
      case I_fddimibSMTStationAction:

	if (value->sl_value <= D_fddimibSMTaction_LowBound ||	/* no 'other' */
	    value->sl_value > D_fddimibSMTaction_HighBound ||
	    value->sl_value == D_fddimibSMTStationAction_self_Test)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_fddimibSMTStationAction, ((fddimibSMTEntry_t *) (dp->data))->valid);

	((fddimibSMTEntry_t *) (dp->data))->fddimibSMTStationAction = value->sl_value;
	break;
#endif				       /* I_fddimibSMTStationAction */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in fddimibSMTEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
fddimibSMTEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_fddimibSMTEntry_set((fddimibSMTEntry_t *) (doCur->data),
				  contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the fddimibMAC family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
fddimibMAC_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             arg;
    void           *dp;
    fddimibMAC_t   *data = NULL;


    arg = snmp_scalar_instance(incoming, object, searchType);

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_fddimibMAC_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_fddimibMACNumber
      case I_fddimibMACNumber:
	dp = &data->fddimibMACNumber;
	break;
#endif				       /* I_fddimibMACNumber */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the fddimibMACEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
fddimibMACEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength;
    int             arg;
    void           *dp;
    fddimibMACEntry_t *data;
    unsigned long   buffer[2];
    OID             inst;
    int             carry;
    long            fddimibMACSMTIndex;
    long            fddimibMACIndex;

    instLength = incoming->length - object->oid.length;
    arg = object->nominator;
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 2
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 2) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 1 + object->oid.length, &fddimibMACIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &fddimibMACSMTIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_fddimibMACEntry_get(serialNum, contextInfo, arg, searchType, fddimibMACSMTIndex, fddimibMACIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 2;
	inst.oid_ptr[0] = data->fddimibMACSMTIndex;
	inst.oid_ptr[1] = data->fddimibMACIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_fddimibMACSMTIndex
      case I_fddimibMACSMTIndex:
	dp = &data->fddimibMACSMTIndex;
	break;
#endif				       /* I_fddimibMACSMTIndex */

#ifdef I_fddimibMACIndex
      case I_fddimibMACIndex:
	dp = &data->fddimibMACIndex;
	break;
#endif				       /* I_fddimibMACIndex */

#ifdef I_fddimibMACIfIndex
      case I_fddimibMACIfIndex:
	dp = &data->fddimibMACIfIndex;
	break;
#endif				       /* I_fddimibMACIfIndex */

#ifdef I_fddimibMACFrameStatusFunctions
      case I_fddimibMACFrameStatusFunctions:
	dp = &data->fddimibMACFrameStatusFunctions;
	break;
#endif				       /* I_fddimibMACFrameStatusFunctions */

#ifdef I_fddimibMACTMaxCapability
      case I_fddimibMACTMaxCapability:
	dp = &data->fddimibMACTMaxCapability;
	break;
#endif				       /* I_fddimibMACTMaxCapability */

#ifdef I_fddimibMACTVXCapability
      case I_fddimibMACTVXCapability:
	dp = &data->fddimibMACTVXCapability;
	break;
#endif				       /* I_fddimibMACTVXCapability */

#ifdef I_fddimibMACAvailablePaths
      case I_fddimibMACAvailablePaths:
	dp = &data->fddimibMACAvailablePaths;
	break;
#endif				       /* I_fddimibMACAvailablePaths */

#ifdef I_fddimibMACCurrentPath
      case I_fddimibMACCurrentPath:
	dp = &data->fddimibMACCurrentPath;
	break;
#endif				       /* I_fddimibMACCurrentPath */

#ifdef I_fddimibMACUpstreamNbr
      case I_fddimibMACUpstreamNbr:
	dp = MakeOctetString(data->fddimibMACUpstreamNbr->octet_ptr, data->fddimibMACUpstreamNbr->length);
	break;
#endif				       /* I_fddimibMACUpstreamNbr */

#ifdef I_fddimibMACDownstreamNbr
      case I_fddimibMACDownstreamNbr:
	dp = MakeOctetString(data->fddimibMACDownstreamNbr->octet_ptr, data->fddimibMACDownstreamNbr->length);
	break;
#endif				       /* I_fddimibMACDownstreamNbr */

#ifdef I_fddimibMACOldUpstreamNbr
      case I_fddimibMACOldUpstreamNbr:
	dp = MakeOctetString(data->fddimibMACOldUpstreamNbr->octet_ptr, data->fddimibMACOldUpstreamNbr->length);
	break;
#endif				       /* I_fddimibMACOldUpstreamNbr */

#ifdef I_fddimibMACOldDownstreamNbr
      case I_fddimibMACOldDownstreamNbr:
	dp = MakeOctetString(data->fddimibMACOldDownstreamNbr->octet_ptr, data->fddimibMACOldDownstreamNbr->length);
	break;
#endif				       /* I_fddimibMACOldDownstreamNbr */

#ifdef I_fddimibMACDupAddressTest
      case I_fddimibMACDupAddressTest:
	dp = &data->fddimibMACDupAddressTest;
	break;
#endif				       /* I_fddimibMACDupAddressTest */

#ifdef I_fddimibMACRequestedPaths
      case I_fddimibMACRequestedPaths:
	dp = &data->fddimibMACRequestedPaths;
	break;
#endif				       /* I_fddimibMACRequestedPaths */

#ifdef I_fddimibMACDownstreamPORTType
      case I_fddimibMACDownstreamPORTType:
	dp = &data->fddimibMACDownstreamPORTType;
	break;
#endif				       /* I_fddimibMACDownstreamPORTType */

#ifdef I_fddimibMACSMTAddress
      case I_fddimibMACSMTAddress:
	dp = MakeOctetString(data->fddimibMACSMTAddress->octet_ptr, data->fddimibMACSMTAddress->length);
	break;
#endif				       /* I_fddimibMACSMTAddress */

#ifdef I_fddimibMACTReq
      case I_fddimibMACTReq:
	dp = &data->fddimibMACTReq;
	break;
#endif				       /* I_fddimibMACTReq */

#ifdef I_fddimibMACTNeg
      case I_fddimibMACTNeg:
	dp = &data->fddimibMACTNeg;
	break;
#endif				       /* I_fddimibMACTNeg */

#ifdef I_fddimibMACTMax
      case I_fddimibMACTMax:
	dp = &data->fddimibMACTMax;
	break;
#endif				       /* I_fddimibMACTMax */

#ifdef I_fddimibMACTvxValue
      case I_fddimibMACTvxValue:
	dp = &data->fddimibMACTvxValue;
	break;
#endif				       /* I_fddimibMACTvxValue */

#ifdef I_fddimibMACFrameCts
      case I_fddimibMACFrameCts:
	dp = &data->fddimibMACFrameCts;
	break;
#endif				       /* I_fddimibMACFrameCts */

#ifdef I_fddimibMACCopiedCts
      case I_fddimibMACCopiedCts:
	dp = &data->fddimibMACCopiedCts;
	break;
#endif				       /* I_fddimibMACCopiedCts */

#ifdef I_fddimibMACTransmitCts
      case I_fddimibMACTransmitCts:
	dp = &data->fddimibMACTransmitCts;
	break;
#endif				       /* I_fddimibMACTransmitCts */

#ifdef I_fddimibMACErrorCts
      case I_fddimibMACErrorCts:
	dp = &data->fddimibMACErrorCts;
	break;
#endif				       /* I_fddimibMACErrorCts */

#ifdef I_fddimibMACLostCts
      case I_fddimibMACLostCts:
	dp = &data->fddimibMACLostCts;
	break;
#endif				       /* I_fddimibMACLostCts */

#ifdef I_fddimibMACFrameErrorThreshold
      case I_fddimibMACFrameErrorThreshold:
	dp = &data->fddimibMACFrameErrorThreshold;
	break;
#endif				       /* I_fddimibMACFrameErrorThreshold */

#ifdef I_fddimibMACFrameErrorRatio
      case I_fddimibMACFrameErrorRatio:
	dp = &data->fddimibMACFrameErrorRatio;
	break;
#endif				       /* I_fddimibMACFrameErrorRatio */

#ifdef I_fddimibMACRMTState
      case I_fddimibMACRMTState:
	dp = &data->fddimibMACRMTState;
	break;
#endif				       /* I_fddimibMACRMTState */

#ifdef I_fddimibMACDaFlag
      case I_fddimibMACDaFlag:
	dp = &data->fddimibMACDaFlag;
	break;
#endif				       /* I_fddimibMACDaFlag */

#ifdef I_fddimibMACUnaDaFlag
      case I_fddimibMACUnaDaFlag:
	dp = &data->fddimibMACUnaDaFlag;
	break;
#endif				       /* I_fddimibMACUnaDaFlag */

#ifdef I_fddimibMACFrameErrorFlag
      case I_fddimibMACFrameErrorFlag:
	dp = &data->fddimibMACFrameErrorFlag;
	break;
#endif				       /* I_fddimibMACFrameErrorFlag */

#ifdef I_fddimibMACMAUnitdataAvailable
      case I_fddimibMACMAUnitdataAvailable:
	dp = &data->fddimibMACMAUnitdataAvailable;
	break;
#endif				       /* I_fddimibMACMAUnitdataAvailable */

#ifdef I_fddimibMACHardwarePresent
      case I_fddimibMACHardwarePresent:
	dp = &data->fddimibMACHardwarePresent;
	break;
#endif				       /* I_fddimibMACHardwarePresent */

#ifdef I_fddimibMACMAUnitdataEnable
      case I_fddimibMACMAUnitdataEnable:
	dp = &data->fddimibMACMAUnitdataEnable;
	break;
#endif				       /* I_fddimibMACMAUnitdataEnable */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the fddimibMACEntry data object.
 *---------------------------------------------------------------------*/
void
fddimibMACEntry_free(
    fddimibMACEntry_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after fddimibMACEntry set/undo
 *---------------------------------------------------------------------*/
static int
fddimibMACEntry_cleanup(
    doList_t       *trash)
{
    fddimibMACEntry_free(trash->data);
#ifdef SR_SNMPv2
    fddimibMACEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
fddimibMACEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength;
    doList_t       *dp;
    VarBind        *vb;
    int             found;
    int             carry = 0;
    fddimibMACEntry_t *fddimibMACEntry;
    long            fddimibMACSMTIndex;
    long            fddimibMACIndex;

    instLength = incoming->length - object->oid.length;
    vb = (VarBind *) NULL;

    /*
     * Validate the object instance
     * 
     */
    if (instLength != 2) {
	return NO_CREATION_ERROR;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &fddimibMACSMTIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, 1 + object->oid.length, &fddimibMACIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    fddimibMACEntry = k_fddimibMACEntry_get(-1, contextInfo, object->nominator, EXACT, fddimibMACSMTIndex, fddimibMACIndex);

#ifndef fddimibMACEntry_READ_CREATE

    if (fddimibMACEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* fddimibMACEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == fddimibMACEntry_set) &&
	    (((fddimibMACEntry_t *) (dp->data)) != NULL) &&
	    (((fddimibMACEntry_t *) (dp->data))->fddimibMACSMTIndex == fddimibMACSMTIndex) &&
	    (((fddimibMACEntry_t *) (dp->data))->fddimibMACIndex == fddimibMACIndex)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(fddimibMACEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(fddimibMACEntry_t));

	dp->setMethod = fddimibMACEntry_set;
	dp->cleanupMethod = fddimibMACEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_fddimibMACSMTIndex, ((fddimibMACEntry_t *) (dp->data))->valid);
	((fddimibMACEntry_t *) (dp->data))->fddimibMACSMTIndex = fddimibMACSMTIndex;

	SET_VALID(I_fddimibMACIndex, ((fddimibMACEntry_t *) (dp->data))->valid);
	((fddimibMACEntry_t *) (dp->data))->fddimibMACIndex = fddimibMACIndex;

#ifdef fddimibMACEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (fddimibMACEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, fddimibMACEntry, sizeof(fddimibMACEntry_t));

	    SET_ALL_VALID(((fddimibMACEntry_t *) (dp->data))->valid);

	} else {


	    /* Fill in default values here */


	}
#endif				       /* fddimibMACEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_fddimibMACRequestedPaths
      case I_fddimibMACRequestedPaths:
	if (value->sl_value < D_fddimibMacReqPath_LowBound  ||
	    value->sl_value > D_fddimibMacReqPath_HighBound)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_fddimibMACRequestedPaths, ((fddimibMACEntry_t *) (dp->data))->valid);

	((fddimibMACEntry_t *) (dp->data))->fddimibMACRequestedPaths = value->sl_value;
	break;
#endif				       /* I_fddimibMACRequestedPaths */

#ifdef I_fddimibMACFrameErrorThreshold
      case I_fddimibMACFrameErrorThreshold:
	if (value->sl_value < D_fddimibMacErrThrshd_LowBound  ||
	    value->sl_value > D_fddimibMacErrThrshd_HighBound)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_fddimibMACFrameErrorThreshold, ((fddimibMACEntry_t *) (dp->data))->valid);

	((fddimibMACEntry_t *) (dp->data))->fddimibMACFrameErrorThreshold = value->sl_value;
	break;
#endif				       /* I_fddimibMACFrameErrorThreshold */

#ifdef I_fddimibMACMAUnitdataEnable
      case I_fddimibMACMAUnitdataEnable:
	if (!(value->sl_value == D_fddimibMACMAUnitdataEnable_true ||
	    value->sl_value == D_fddimibMACMAUnitdataEnable_false))
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_fddimibMACMAUnitdataEnable, ((fddimibMACEntry_t *) (dp->data))->valid);

	((fddimibMACEntry_t *) (dp->data))->fddimibMACMAUnitdataEnable = value->sl_value;
	break;
#endif				       /* I_fddimibMACMAUnitdataEnable */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in fddimibMACEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
fddimibMACEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_fddimibMACEntry_set((fddimibMACEntry_t *) (doCur->data),
				  contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the fddimibMACCountersEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
fddimibMACCountersEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength;
    int             arg;
    void           *dp;
    fddimibMACCountersEntry_t *data;
    unsigned long   buffer[2];
    OID             inst;
    int             carry;
    long            fddimibMACSMTIndex;
    long            fddimibMACIndex;

    instLength = incoming->length - object->oid.length;
    arg = object->nominator;
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 2
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 2) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 1 + object->oid.length, &fddimibMACIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &fddimibMACSMTIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_fddimibMACCountersEntry_get(serialNum, contextInfo, arg, searchType, fddimibMACSMTIndex, fddimibMACIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 2;
	inst.oid_ptr[0] = data->fddimibMACSMTIndex;
	inst.oid_ptr[1] = data->fddimibMACIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_fddimibMACTokenCts
      case I_fddimibMACTokenCts:
	dp = &data->fddimibMACTokenCts;
	break;
#endif				       /* I_fddimibMACTokenCts */

#ifdef I_fddimibMACTvxExpiredCts
      case I_fddimibMACTvxExpiredCts:
	dp = &data->fddimibMACTvxExpiredCts;
	break;
#endif				       /* I_fddimibMACTvxExpiredCts */

#ifdef I_fddimibMACNotCopiedCts
      case I_fddimibMACNotCopiedCts:
	dp = &data->fddimibMACNotCopiedCts;
	break;
#endif				       /* I_fddimibMACNotCopiedCts */

#ifdef I_fddimibMACLateCts
      case I_fddimibMACLateCts:
	dp = &data->fddimibMACLateCts;
	break;
#endif				       /* I_fddimibMACLateCts */

#ifdef I_fddimibMACRingOpCts
      case I_fddimibMACRingOpCts:
	dp = &data->fddimibMACRingOpCts;
	break;
#endif				       /* I_fddimibMACRingOpCts */

#ifdef I_fddimibMACNotCopiedRatio
      case I_fddimibMACNotCopiedRatio:
	dp = &data->fddimibMACNotCopiedRatio;
	break;
#endif				       /* I_fddimibMACNotCopiedRatio */

#ifdef I_fddimibMACNotCopiedFlag
      case I_fddimibMACNotCopiedFlag:
	dp = &data->fddimibMACNotCopiedFlag;
	break;
#endif				       /* I_fddimibMACNotCopiedFlag */

#ifdef I_fddimibMACNotCopiedThreshold
      case I_fddimibMACNotCopiedThreshold:
	dp = &data->fddimibMACNotCopiedThreshold;
	break;
#endif				       /* I_fddimibMACNotCopiedThreshold */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the fddimibMACCountersEntry data object.
 *---------------------------------------------------------------------*/
void
fddimibMACCountersEntry_free(
    fddimibMACCountersEntry_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after fddimibMACCountersEntry set/undo
 *---------------------------------------------------------------------*/
static int
fddimibMACCountersEntry_cleanup(
    doList_t       *trash)
{
    fddimibMACCountersEntry_free(trash->data);
#ifdef SR_SNMPv2
    fddimibMACCountersEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
fddimibMACCountersEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength;
    doList_t       *dp;
    VarBind        *vb;
    int             found;
    int             carry;
    fddimibMACCountersEntry_t *fddimibMACCountersEntry;
    long            fddimibMACSMTIndex;
    long            fddimibMACIndex;
    MACDataType	   *macPtr;

    instLength = incoming->length - object->oid.length;
    vb = (VarBind *) NULL;
    carry = 0;

    /*
     * Validate the object instance
     * 
     */
    if (instLength != 2) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &fddimibMACSMTIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, 1 + object->oid.length, &fddimibMACIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    fddimibMACCountersEntry = k_fddimibMACCountersEntry_get(-1, contextInfo, object->nominator, EXACT, fddimibMACSMTIndex, fddimibMACIndex);

#ifndef fddimibMACCountersEntry_READ_CREATE

    if (fddimibMACCountersEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* fddimibMACCountersEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == fddimibMACCountersEntry_set) &&
	    (((fddimibMACCountersEntry_t *) (dp->data)) != NULL) &&
	    (((fddimibMACCountersEntry_t *) (dp->data))->fddimibMACSMTIndex == fddimibMACSMTIndex) &&
	    (((fddimibMACCountersEntry_t *) (dp->data))->fddimibMACIndex == fddimibMACIndex)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(fddimibMACCountersEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(fddimibMACCountersEntry_t));

	dp->setMethod = fddimibMACCountersEntry_set;
	dp->cleanupMethod = fddimibMACCountersEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_fddimibMACSMTIndex, ((fddimibMACCountersEntry_t *) (dp->data))->valid);
	((fddimibMACCountersEntry_t *) (dp->data))->fddimibMACSMTIndex = fddimibMACSMTIndex;

	SET_VALID(I_fddimibMACIndex, ((fddimibMACCountersEntry_t *) (dp->data))->valid);
	((fddimibMACCountersEntry_t *) (dp->data))->fddimibMACIndex = fddimibMACIndex;

#ifdef fddimibMACCountersEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (fddimibMACCountersEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, fddimibMACCountersEntry, sizeof(fddimibMACCountersEntry_t));

	    SET_ALL_VALID(((fddimibMACCountersEntry_t *) (dp->data))->valid);

	} else {


	    /* Fill in default values here */


	}
#endif				       /* fddimibMACCountersEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_fddimibMACNotCopiedThreshold
      case I_fddimibMACNotCopiedThreshold:

	/* instances should have been validated */
	macPtr = &MIBDATA(fddimibMACSMTIndex - 1, mib->macBase[fddimibMACIndex - 1]);
	if (!((macPtr->baseData.xdi.packages & PKG_framenotcopiedmanagement) &&
	    (macPtr->baseData.xdi.packages & PKG_framenotcopied)))
	    return (NO_ACCESS_ERROR);
	if (value->sl_value < D_fddimibMacErrThrshd_LowBound ||
	    value->sl_value > D_fddimibMacErrThrshd_HighBound)
	    return (WRONG_VALUE_ERROR);
	SET_VALID(I_fddimibMACNotCopiedThreshold, ((fddimibMACCountersEntry_t *) (dp->data))->valid);

	((fddimibMACCountersEntry_t *) (dp->data))->fddimibMACNotCopiedThreshold = value->sl_value;
	break;
#endif				       /* I_fddimibMACNotCopiedThreshold */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in fddimibMACCountersEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
fddimibMACCountersEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_fddimibMACCountersEntry_set((fddimibMACCountersEntry_t *) (doCur->data),
					  contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the fddimibPATH family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
fddimibPATH_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             arg;
    void           *dp;
    fddimibPATH_t  *data = NULL;


    arg = snmp_scalar_instance(incoming, object, searchType);

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_fddimibPATH_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_fddimibPATHNumber
      case I_fddimibPATHNumber:
	dp = &data->fddimibPATHNumber;
	break;
#endif				       /* I_fddimibPATHNumber */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the fddimibPATHEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
fddimibPATHEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength;
    int             arg;
    void           *dp;
    fddimibPATHEntry_t *data;
    unsigned long   buffer[2];
    OID             inst;
    int             carry;
    long            fddimibPATHSMTIndex;
    long            fddimibPATHIndex;

    instLength = incoming->length - object->oid.length;
    arg = object->nominator;
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 2
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 2) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 1 + object->oid.length, &fddimibPATHIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &fddimibPATHSMTIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_fddimibPATHEntry_get(serialNum, contextInfo, arg, searchType, fddimibPATHSMTIndex, fddimibPATHIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 2;
	inst.oid_ptr[0] = data->fddimibPATHSMTIndex;
	inst.oid_ptr[1] = data->fddimibPATHIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_fddimibPATHSMTIndex
      case I_fddimibPATHSMTIndex:
	dp = &data->fddimibPATHSMTIndex;
	break;
#endif				       /* I_fddimibPATHSMTIndex */

#ifdef I_fddimibPATHIndex
      case I_fddimibPATHIndex:
	dp = &data->fddimibPATHIndex;
	break;
#endif				       /* I_fddimibPATHIndex */

#ifdef I_fddimibPATHTVXLowerBound
      case I_fddimibPATHTVXLowerBound:
	dp = &data->fddimibPATHTVXLowerBound;
	break;
#endif				       /* I_fddimibPATHTVXLowerBound */

#ifdef I_fddimibPATHTMaxLowerBound
      case I_fddimibPATHTMaxLowerBound:
	dp = &data->fddimibPATHTMaxLowerBound;
	break;
#endif				       /* I_fddimibPATHTMaxLowerBound */

#ifdef I_fddimibPATHMaxTReq
      case I_fddimibPATHMaxTReq:
	dp = &data->fddimibPATHMaxTReq;
	break;
#endif				       /* I_fddimibPATHMaxTReq */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the fddimibPATHEntry data object.
 *---------------------------------------------------------------------*/
void
fddimibPATHEntry_free(
    fddimibPATHEntry_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after fddimibPATHEntry set/undo
 *---------------------------------------------------------------------*/
static int
fddimibPATHEntry_cleanup(
    doList_t       *trash)
{
    fddimibPATHEntry_free(trash->data);
#ifdef SR_SNMPv2
    fddimibPATHEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
fddimibPATHEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength;
    doList_t       *dp;
    VarBind        *vb;
    int             found;
    int             carry;
    fddimibPATHEntry_t *fddimibPATHEntry;
    long            fddimibPATHSMTIndex;
    long            fddimibPATHIndex;
    MACDataType	*macPtr;
    PATHDataType *pathPtr;
    int		timevalue,		/* working varbind value */
		macCnt;			/* working counter of mac on a path */
    unsigned char paths;		/* bit flag for a MAC's requested paths */

    instLength = incoming->length - object->oid.length;
    vb = (VarBind *) NULL;
    carry = 0;

    /*
     * Validate the object instance
     * 
     */
    if (instLength != 2) {
	return NO_CREATION_ERROR;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &fddimibPATHSMTIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, 1 + object->oid.length, &fddimibPATHIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    fddimibPATHEntry = k_fddimibPATHEntry_get(-1, contextInfo, object->nominator, EXACT, fddimibPATHSMTIndex, fddimibPATHIndex);

#ifndef fddimibPATHEntry_READ_CREATE

    if (fddimibPATHEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* fddimibPATHEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == fddimibPATHEntry_set) &&
	    (((fddimibPATHEntry_t *) (dp->data)) != NULL) &&
	    (((fddimibPATHEntry_t *) (dp->data))->fddimibPATHSMTIndex == fddimibPATHSMTIndex) &&
	    (((fddimibPATHEntry_t *) (dp->data))->fddimibPATHIndex == fddimibPATHIndex)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(fddimibPATHEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(fddimibPATHEntry_t));

	dp->setMethod = fddimibPATHEntry_set;
	dp->cleanupMethod = fddimibPATHEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_fddimibPATHSMTIndex, ((fddimibPATHEntry_t *) (dp->data))->valid);
	((fddimibPATHEntry_t *) (dp->data))->fddimibPATHSMTIndex = fddimibPATHSMTIndex;

	SET_VALID(I_fddimibPATHIndex, ((fddimibPATHEntry_t *) (dp->data))->valid);
	((fddimibPATHEntry_t *) (dp->data))->fddimibPATHIndex = fddimibPATHIndex;

#ifdef fddimibPATHEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (fddimibPATHEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, fddimibPATHEntry, sizeof(fddimibPATHEntry_t));

	    SET_ALL_VALID(((fddimibPATHEntry_t *) (dp->data))->valid);

	} else {


	    /* Fill in default values here */


	}
#endif				       /* fddimibPATHEntry_READ_CREATE */
    }

    macPtr = &MIBDATA(fddimibPATHSMTIndex - 1, mib->macBase[0]);
    pathPtr = &MIBDATA(fddimibPATHSMTIndex - 1, mib->pathBase[fddimibPATHIndex]);
    if (!pathPtr->inUse)
	return (NO_CREATION_ERROR);		/* safety, inconsistency */
    timevalue = value->sl_value;

    switch (object->nominator) {

#ifdef I_fddimibPATHTVXLowerBound
      case I_fddimibPATHTVXLowerBound:

	/* value should satisfy the following:
	 *	0 < fddimibPATHTVXLowerBound < fddimibPATHMaxTReq
	 * and
	 *	fddimibPATHTVXLowerBound <= fddimibMACTVXCapability of each of
	 *				    the MACs currently on the path
	 */
	if (timevalue < D_fddiTime_LowBound ||
	    timevalue > (int)snmpFddi_us2ns(pathPtr->baseData.MaxT_Req))
	    return (WRONG_VALUE_ERROR);
	switch (pathPtr->baseData.Index) {
	case PI_primary:
	    paths = PP_primary_alt | PP_primary_pref;
	    break;
	case PI_secondary:
	    paths = PP_secondary_alt | PP_secondary_pref;
	    break;
	default:
	    paths = PP_local;
	}
	for (macCnt = 0; macCnt < MAX_MAC_COUNT; macCnt++, macPtr++)
	    if (macPtr->inUse && macPtr->baseData.HardwarePresent &&
		(macPtr->baseData.RequestedPaths.reqPaths & paths) &&
		!((paths & PP_local) && 
		  (macPtr->baseData.xdi.localPath == pathPtr->baseData.Index)) &&
		timevalue > (int)snmpFddi_2sCompToTimeNano(macPtr->hwData.TVXCapability))
		break;
	if (macCnt < MAX_MAC_COUNT)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_fddimibPATHTVXLowerBound, ((fddimibPATHEntry_t *) (dp->data))->valid);

	((fddimibPATHEntry_t *) (dp->data))->fddimibPATHTVXLowerBound = value->sl_value;
	break;
#endif				       /* I_fddimibPATHTVXLowerBound */

#ifdef I_fddimibPATHTMaxLowerBound
      case I_fddimibPATHTMaxLowerBound:

	/* value should satisfy the following:
	 *	10000000 ns (10 ms) <= fddimibPATHTMaxLowerBound
	 * and
	 *	fddimibPATHMaxTReq <= fddimibPATHTMaxLowerBound
	 * and
	 *	fddimibPATHTMaxLowerBound <= fddimibMACTMaxCapability of each of
	 *				    the MACs currently on the path
	 */
	if (timevalue < D_fddimibPathMaxLowBound_min ||
	    timevalue < (int)snmpFddi_us2ns(pathPtr->baseData.MaxT_Req))
	    return (WRONG_VALUE_ERROR);
	switch (pathPtr->baseData.Index) {
	case PI_primary:
	    paths = PP_primary_alt | PP_primary_pref;
	    break;
	case PI_secondary:
	    paths = PP_secondary_alt | PP_secondary_pref;
	    break;
	default:
	    paths = PP_local;
	}
	for (macCnt = 0; macCnt < MAX_MAC_COUNT; macCnt++, macPtr++)
	    if (macPtr->inUse && macPtr->baseData.HardwarePresent &&
		(macPtr->baseData.RequestedPaths.reqPaths & paths) &&
		!((paths & PP_local) && 
		  (macPtr->baseData.xdi.localPath == pathPtr->baseData.Index)) &&
		timevalue > (int)snmpFddi_2sCompToTimeNano(macPtr->hwData.T_MaxCapability))
		break;
	if (macCnt < MAX_MAC_COUNT)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_fddimibPATHTMaxLowerBound, ((fddimibPATHEntry_t *) (dp->data))->valid);

	((fddimibPATHEntry_t *) (dp->data))->fddimibPATHTMaxLowerBound = value->sl_value;
	break;
#endif				       /* I_fddimibPATHTMaxLowerBound */

#ifdef I_fddimibPATHMaxTReq
      case I_fddimibPATHMaxTReq:

	/* Value should satisfy:
	 *	fddimibPATHTVXLowerBound < fddimibPATHMaxTReq <=
	 *	fddimibPATHTMaxLowerBound <= fddimibMACTMaxCapability
	 */
	if (timevalue <= (int)snmpFddi_2sCompToTimeNano(pathPtr->baseData.TVXLowerBound) ||
	    timevalue > (int)snmpFddi_2sCompToTimeNano(pathPtr->baseData.T_MaxLowerBound))
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_fddimibPATHMaxTReq, ((fddimibPATHEntry_t *) (dp->data))->valid);

	((fddimibPATHEntry_t *) (dp->data))->fddimibPATHMaxTReq = value->sl_value;
	break;
#endif				       /* I_fddimibPATHMaxTReq */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in fddimibPATHEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
fddimibPATHEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_fddimibPATHEntry_set((fddimibPATHEntry_t *) (doCur->data),
				   contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the fddimibPATHConfigEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
fddimibPATHConfigEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength;
    int             arg;
    void           *dp;
    fddimibPATHConfigEntry_t *data;
    unsigned long   buffer[3];
    OID             inst;
    int             carry;
    long            fddimibPATHConfigSMTIndex;
    long            fddimibPATHConfigPATHIndex;
    long            fddimibPATHConfigTokenOrder;

    instLength = incoming->length - object->oid.length;
    arg = object->nominator;
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 3
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 3) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 2 + object->oid.length, &fddimibPATHConfigTokenOrder, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 1 + object->oid.length, &fddimibPATHConfigPATHIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &fddimibPATHConfigSMTIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_fddimibPATHConfigEntry_get(serialNum, contextInfo, arg, searchType, fddimibPATHConfigSMTIndex, fddimibPATHConfigPATHIndex, fddimibPATHConfigTokenOrder)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 3;
	inst.oid_ptr[0] = data->fddimibPATHConfigSMTIndex;
	inst.oid_ptr[1] = data->fddimibPATHConfigPATHIndex;
	inst.oid_ptr[2] = data->fddimibPATHConfigTokenOrder;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_fddimibPATHConfigSMTIndex
      case I_fddimibPATHConfigSMTIndex:
	dp = &data->fddimibPATHConfigSMTIndex;
	break;
#endif				       /* I_fddimibPATHConfigSMTIndex */

#ifdef I_fddimibPATHConfigPATHIndex
      case I_fddimibPATHConfigPATHIndex:
	dp = &data->fddimibPATHConfigPATHIndex;
	break;
#endif				       /* I_fddimibPATHConfigPATHIndex */

#ifdef I_fddimibPATHConfigTokenOrder
      case I_fddimibPATHConfigTokenOrder:
	dp = &data->fddimibPATHConfigTokenOrder;
	break;
#endif				       /* I_fddimibPATHConfigTokenOrder */

#ifdef I_fddimibPATHConfigResourceType
      case I_fddimibPATHConfigResourceType:
	dp = &data->fddimibPATHConfigResourceType;
	break;
#endif				       /* I_fddimibPATHConfigResourceType */

#ifdef I_fddimibPATHConfigResourceIndex
      case I_fddimibPATHConfigResourceIndex:
	dp = &data->fddimibPATHConfigResourceIndex;
	break;
#endif				       /* I_fddimibPATHConfigResourceIndex */

#ifdef I_fddimibPATHConfigCurrentPath
      case I_fddimibPATHConfigCurrentPath:
	dp = &data->fddimibPATHConfigCurrentPath;
	break;
#endif				       /* I_fddimibPATHConfigCurrentPath */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the fddimibPORT family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
fddimibPORT_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             arg;
    void           *dp;
    fddimibPORT_t  *data = NULL;


    arg = snmp_scalar_instance(incoming, object, searchType);

    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_fddimibPORT_get(serialNum, contextInfo, arg)) == NULL) {
	arg = -1;
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_fddimibPORTNumber
      case I_fddimibPORTNumber:
	dp = &data->fddimibPORTNumber;
	break;
#endif				       /* I_fddimibPORTNumber */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &ZeroOid, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the fddimibPORTEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
fddimibPORTEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength;
    int             arg;
    void           *dp;
    fddimibPORTEntry_t *data;
    unsigned long   buffer[2];
    OID             inst;
    int             carry;
    long            fddimibPORTSMTIndex;
    long            fddimibPORTIndex;

    instLength = incoming->length - object->oid.length;
    arg = object->nominator;
    dp = NULL;
    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 2
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 2) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 1 + object->oid.length, &fddimibPORTIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &fddimibPORTSMTIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_fddimibPORTEntry_get(serialNum, contextInfo, arg, searchType, fddimibPORTSMTIndex, fddimibPORTIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 2;
	inst.oid_ptr[0] = data->fddimibPORTSMTIndex;
	inst.oid_ptr[1] = data->fddimibPORTIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_fddimibPORTSMTIndex
      case I_fddimibPORTSMTIndex:
	dp = &data->fddimibPORTSMTIndex;
	break;
#endif				       /* I_fddimibPORTSMTIndex */

#ifdef I_fddimibPORTIndex
      case I_fddimibPORTIndex:
	dp = &data->fddimibPORTIndex;
	break;
#endif				       /* I_fddimibPORTIndex */

#ifdef I_fddimibPORTMyType
      case I_fddimibPORTMyType:
	dp = &data->fddimibPORTMyType;
	break;
#endif				       /* I_fddimibPORTMyType */

#ifdef I_fddimibPORTNeighborType
      case I_fddimibPORTNeighborType:
	dp = &data->fddimibPORTNeighborType;
	break;
#endif				       /* I_fddimibPORTNeighborType */

#ifdef I_fddimibPORTConnectionPolicies
      case I_fddimibPORTConnectionPolicies:
	dp = &data->fddimibPORTConnectionPolicies;
	break;
#endif				       /* I_fddimibPORTConnectionPolicies */

#ifdef I_fddimibPORTMACIndicated
      case I_fddimibPORTMACIndicated:
	dp = &data->fddimibPORTMACIndicated;
	break;
#endif				       /* I_fddimibPORTMACIndicated */

#ifdef I_fddimibPORTCurrentPath
      case I_fddimibPORTCurrentPath:
	dp = &data->fddimibPORTCurrentPath;
	break;
#endif				       /* I_fddimibPORTCurrentPath */

#ifdef I_fddimibPORTRequestedPaths
      case I_fddimibPORTRequestedPaths:
	dp = MakeOctetString(data->fddimibPORTRequestedPaths->octet_ptr, data->fddimibPORTRequestedPaths->length);
	break;
#endif				       /* I_fddimibPORTRequestedPaths */

#ifdef I_fddimibPORTMACPlacement
      case I_fddimibPORTMACPlacement:
	dp = &data->fddimibPORTMACPlacement;
	break;
#endif				       /* I_fddimibPORTMACPlacement */

#ifdef I_fddimibPORTAvailablePaths
      case I_fddimibPORTAvailablePaths:
	dp = &data->fddimibPORTAvailablePaths;
	break;
#endif				       /* I_fddimibPORTAvailablePaths */

#ifdef I_fddimibPORTPMDClass
      case I_fddimibPORTPMDClass:
	dp = &data->fddimibPORTPMDClass;
	break;
#endif				       /* I_fddimibPORTPMDClass */

#ifdef I_fddimibPORTConnectionCapabilities
      case I_fddimibPORTConnectionCapabilities:
	dp = &data->fddimibPORTConnectionCapabilities;
	break;
#endif				       /* I_fddimibPORTConnectionCapabilities */

#ifdef I_fddimibPORTBSFlag
      case I_fddimibPORTBSFlag:
	dp = &data->fddimibPORTBSFlag;
	break;
#endif				       /* I_fddimibPORTBSFlag */

#ifdef I_fddimibPORTLCTFailCts
      case I_fddimibPORTLCTFailCts:
	dp = &data->fddimibPORTLCTFailCts;
	break;
#endif				       /* I_fddimibPORTLCTFailCts */

#ifdef I_fddimibPORTLerEstimate
      case I_fddimibPORTLerEstimate:
	dp = &data->fddimibPORTLerEstimate;
	break;
#endif				       /* I_fddimibPORTLerEstimate */

#ifdef I_fddimibPORTLemRejectCts
      case I_fddimibPORTLemRejectCts:
	dp = &data->fddimibPORTLemRejectCts;
	break;
#endif				       /* I_fddimibPORTLemRejectCts */

#ifdef I_fddimibPORTLemCts
      case I_fddimibPORTLemCts:
	dp = &data->fddimibPORTLemCts;
	break;
#endif				       /* I_fddimibPORTLemCts */

#ifdef I_fddimibPORTLerCutoff
      case I_fddimibPORTLerCutoff:
	dp = &data->fddimibPORTLerCutoff;
	break;
#endif				       /* I_fddimibPORTLerCutoff */

#ifdef I_fddimibPORTLerAlarm
      case I_fddimibPORTLerAlarm:
	dp = &data->fddimibPORTLerAlarm;
	break;
#endif				       /* I_fddimibPORTLerAlarm */

#ifdef I_fddimibPORTConnectState
      case I_fddimibPORTConnectState:
	dp = &data->fddimibPORTConnectState;
	break;
#endif				       /* I_fddimibPORTConnectState */

#ifdef I_fddimibPORTPCMState
      case I_fddimibPORTPCMState:
	dp = &data->fddimibPORTPCMState;
	break;
#endif				       /* I_fddimibPORTPCMState */

#ifdef I_fddimibPORTPCWithhold
      case I_fddimibPORTPCWithhold:
	dp = &data->fddimibPORTPCWithhold;
	break;
#endif				       /* I_fddimibPORTPCWithhold */

#ifdef I_fddimibPORTLerFlag
      case I_fddimibPORTLerFlag:
	dp = &data->fddimibPORTLerFlag;
	break;
#endif				       /* I_fddimibPORTLerFlag */

#ifdef I_fddimibPORTHardwarePresent
      case I_fddimibPORTHardwarePresent:
	dp = &data->fddimibPORTHardwarePresent;
	break;
#endif				       /* I_fddimibPORTHardwarePresent */

#ifdef I_fddimibPORTAction
      case I_fddimibPORTAction:
	dp = &data->fddimibPORTAction;
	break;
#endif				       /* I_fddimibPORTAction */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the fddimibPORTEntry data object.
 *---------------------------------------------------------------------*/
void
fddimibPORTEntry_free(
    fddimibPORTEntry_t *data)
{
    if (data != NULL) {
	if (data->fddimibPORTRequestedPaths != NULL) {
	    FreeOctetString(data->fddimibPORTRequestedPaths);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after fddimibPORTEntry set/undo
 *---------------------------------------------------------------------*/
static int
fddimibPORTEntry_cleanup(
    doList_t       *trash)
{
    fddimibPORTEntry_free(trash->data);
#ifdef SR_SNMPv2
    fddimibPORTEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
fddimibPORTEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength;
    doList_t       *dp;
    VarBind        *vb;
    int             found;
    int             carry;
    fddimibPORTEntry_t *fddimibPORTEntry;
    long            fddimibPORTSMTIndex;
    long            fddimibPORTIndex;

    instLength = incoming->length - object->oid.length;
    vb = (VarBind *) NULL;
    carry = 0;

    /*
     * Validate the object instance
     * 
     */
    if (instLength != 2) {
	return NO_CREATION_ERROR;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &fddimibPORTSMTIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, 1 + object->oid.length, &fddimibPORTIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    fddimibPORTEntry = k_fddimibPORTEntry_get(-1, contextInfo, object->nominator, EXACT, fddimibPORTSMTIndex, fddimibPORTIndex);

#ifndef fddimibPORTEntry_READ_CREATE

    if (fddimibPORTEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* fddimibPORTEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == fddimibPORTEntry_set) &&
	    (((fddimibPORTEntry_t *) (dp->data)) != NULL) &&
	    (((fddimibPORTEntry_t *) (dp->data))->fddimibPORTSMTIndex == fddimibPORTSMTIndex) &&
	    (((fddimibPORTEntry_t *) (dp->data))->fddimibPORTIndex == fddimibPORTIndex)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(fddimibPORTEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(fddimibPORTEntry_t));

	dp->setMethod = fddimibPORTEntry_set;
	dp->cleanupMethod = fddimibPORTEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_fddimibPORTSMTIndex, ((fddimibPORTEntry_t *) (dp->data))->valid);
	((fddimibPORTEntry_t *) (dp->data))->fddimibPORTSMTIndex = fddimibPORTSMTIndex;

	SET_VALID(I_fddimibPORTIndex, ((fddimibPORTEntry_t *) (dp->data))->valid);
	((fddimibPORTEntry_t *) (dp->data))->fddimibPORTIndex = fddimibPORTIndex;

#ifdef fddimibPORTEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (fddimibPORTEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, fddimibPORTEntry, sizeof(fddimibPORTEntry_t));

	    SET_ALL_VALID(((fddimibPORTEntry_t *) (dp->data))->valid);

	    ((fddimibPORTEntry_t *) (dp->data))->fddimibPORTRequestedPaths =
		CloneOctetString(fddimibPORTEntry->fddimibPORTRequestedPaths);

	} else {


	    /* Fill in default values here */


	}
#endif				       /* fddimibPORTEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_fddimibPORTConnectionPolicies
      case I_fddimibPORTConnectionPolicies:

	if (value->sl_value < D_fddimibPortConnPlcy_LowBound ||
	    value->sl_value > D_fddimibPortConnPlcy_HighBound)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_fddimibPORTConnectionPolicies, ((fddimibPORTEntry_t *) (dp->data))->valid);

	((fddimibPORTEntry_t *) (dp->data))->fddimibPORTConnectionPolicies = value->sl_value;
	break;
#endif				       /* I_fddimibPORTConnectionPolicies */

#ifdef I_fddimibPORTRequestedPaths
      case I_fddimibPORTRequestedPaths:
	
	if (value->os_value->length > SIZE_FddiMibPortReqPaths)
	    return (WRONG_LENGTH_ERROR);

	SET_VALID(I_fddimibPORTRequestedPaths, ((fddimibPORTEntry_t *) (dp->data))->valid);

	if (((fddimibPORTEntry_t *) (dp->data))->fddimibPORTRequestedPaths != NULL) {
	    FreeOctetString(((fddimibPORTEntry_t *) (dp->data))->fddimibPORTRequestedPaths);
	}
	((fddimibPORTEntry_t *) (dp->data))->fddimibPORTRequestedPaths =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_fddimibPORTRequestedPaths */

#ifdef I_fddimibPORTLerCutoff
      case I_fddimibPORTLerCutoff:

	if (value->sl_value < D_fddimibPortLnkErr_LowBound ||
	    value->sl_value > D_fddimibPortLnkErr_HighBound)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_fddimibPORTLerCutoff, ((fddimibPORTEntry_t *) (dp->data))->valid);

	((fddimibPORTEntry_t *) (dp->data))->fddimibPORTLerCutoff = value->sl_value;
	break;
#endif				       /* I_fddimibPORTLerCutoff */

#ifdef I_fddimibPORTLerAlarm
      case I_fddimibPORTLerAlarm:

	/* same value upper/lower bounds as fddimibPORTLerCutoff's (i.e. 4..15) */
	if (value->sl_value < D_fddimibPortLnkErr_LowBound ||
	    value->sl_value > D_fddimibPortLnkErr_HighBound)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_fddimibPORTLerAlarm, ((fddimibPORTEntry_t *) (dp->data))->valid);

	((fddimibPORTEntry_t *) (dp->data))->fddimibPORTLerAlarm = value->sl_value;
	break;
#endif				       /* I_fddimibPORTLerAlarm */

#ifdef I_fddimibPORTAction
      case I_fddimibPORTAction:

	if (value->sl_value <= D_fddimibPORTAction_other ||
	    value->sl_value > D_fddimibPORTAction_stopPORT)
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_fddimibPORTAction, ((fddimibPORTEntry_t *) (dp->data))->valid);

	((fddimibPORTEntry_t *) (dp->data))->fddimibPORTAction = value->sl_value;
	break;
#endif				       /* I_fddimibPORTAction */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in fddimibPORTEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
fddimibPORTEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_fddimibPORTEntry_set((fddimibPORTEntry_t *) (doCur->data),
				   contextInfo, doCur->state));
}

#endif				       /* SETS */






/*
 * snmpfddi_findIdb_exact 
 *	- for searchType==EXACT, search through the IDB's based on Station ID
 *	- the input stnID begins from 1 as used as external index
 *	- return idb pointer if found; NULL otherwise
 */
static hwidbtype *
snmpfddi_findIdb_exact(long stnID)
{
    return ((stnID > 0 && stnID <= MAX_STATION_COUNT) ?
	     STADATA(stnID - 1, hwIDB[0]) : NULL);
}


/*
 * snmpfddi_findIdb_next
 *	- for searchType==NEXT, search through the IDB's based on Station ID
 *	- the input stnID begins from 0 as used as internal index
 *	- return idb pointer if found; NULL otherwise
 */
static hwidbtype *
snmpfddi_findIdb_next(long stnID)
{
    hwidbtype *idb;
    int i;

    idb = NULL;
    for (i = 0; (stnID + i) < MAX_STATION_COUNT; i++)
	if ((idb = STADATA(stnID + i, hwIDB[0])) != NULL)
	    break;
    return (idb);
}



fddimibSMT_t   *
k_fddimibSMT_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator)
{
    static fddimibSMT_t fddimibSMTData;

    fddimibSMTData.fddimibSMTNumber = MAX_STATION_COUNT;
    return (&fddimibSMTData);
}



fddimibSMTEntry_t *
k_fddimibSMTEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            fddimibSMTIndex)
{
    static fddimibSMTEntry_t fddimibSMTEntryData;
    hwidbtype *idb;
    SMTBaseAttrType *smtPtr;
    static OctetString station_id, userdata;
    static uchar stationid_string[SIZE_SMTStationIdType],
		 userdata_string[SIZE_SMTUserDataType];
    uint stnID;

    if (fddimibSMTIndex > MAX_STATION_COUNT || fddimibSMTIndex < 0)
	return (NULL);
    if (searchType == EXACT)
	idb = snmpfddi_findIdb_exact(fddimibSMTIndex);
    else
	idb = fddimibSMTIndex == 0 ?
	      snmpfddi_findIdb_next(fddimibSMTIndex) :
	      snmpfddi_findIdb_next(fddimibSMTIndex - 1);
    if (idb == NULL)
	return (NULL);
    stnID = idb->fddi_stn_id;
    smtPtr = &MIBDATA(stnID, mib->smtData);
    fddimibSMTEntryData.fddimibSMTIndex = stnID + 1;
    fddimibSMTEntryData.fddimibSMTStationId = &station_id;
    fddimibSMTEntryData.fddimibSMTStationId->length = SIZE_SMTStationIdType;
    fddimibSMTEntryData.fddimibSMTStationId->octet_ptr = stationid_string;
    bcopy((uchar *)&smtPtr->StationId, stationid_string, SIZE_SMTStationIdType);
    fddimibSMTEntryData.fddimibSMTOpVersionId = smtPtr->OpVersionId;
    fddimibSMTEntryData.fddimibSMTHiVersionId = smtPtr->HiVersionId;
    fddimibSMTEntryData.fddimibSMTLoVersionId = smtPtr->LoVersionId;
    fddimibSMTEntryData.fddimibSMTUserData = &userdata;
    fddimibSMTEntryData.fddimibSMTUserData->length = SIZE_SMTUserDataType;
    bcopy((uchar *)smtPtr->UserData, userdata_string, SIZE_SMTUserDataType);
    fddimibSMTEntryData.fddimibSMTUserData->octet_ptr = userdata_string;
    fddimibSMTEntryData.fddimibSMTMIBVersionId = smtPtr->MIBVersionId;
    fddimibSMTEntryData.fddimibSMTMACCts = smtPtr->Mac_Ct;
    fddimibSMTEntryData.fddimibSMTNonMasterCts = smtPtr->NonMaster_Ct;
    fddimibSMTEntryData.fddimibSMTMasterCts = smtPtr->Master_Ct;
    fddimibSMTEntryData.fddimibSMTAvailablePaths = smtPtr->AvailablePaths;
    fddimibSMTEntryData.fddimibSMTConfigCapabilities = smtPtr->ConfigCapabilities;
    fddimibSMTEntryData.fddimibSMTConfigPolicy = smtPtr->ConfigPolicy;
    fddimibSMTEntryData.fddimibSMTConnectionPolicy = smtPtr->ConnectionPolicy;
    fddimibSMTEntryData.fddimibSMTTNotify = smtPtr->T_Notify;
    fddimibSMTEntryData.fddimibSMTStatRptPolicy = smtPtr->StatRptPolicy ? 
		D_fddimibSMTStatRptPolicy_true : D_fddimibSMTStatRptPolicy_false;
    fddimibSMTEntryData.fddimibSMTTraceMaxExpiration = 
		snmpFddi_80ns2ms(smtPtr->Trace_MaxExpiration);
    fddimibSMTEntryData.fddimibSMTBypassPresent = smtPtr->BypassPresent ?
		D_fddimibSMTBypassPresent_true : D_fddimibSMTBypassPresent_false;
    fddimibSMTEntryData.fddimibSMTECMState = smtPtr->ECMState + 1;
    fddimibSMTEntryData.fddimibSMTCFState = smtPtr->CF_State + 1;
    fddimibSMTEntryData.fddimibSMTRemoteDisconnectFlag =
	smtPtr->RemoteDisconnectFlag ?
	D_fddimibSMTRemoteDisconnectFlag_true : D_fddimibSMTRemoteDisconnectFlag_false;
    switch (smtPtr->CF_State) {
      case CF_thru:
    	fddimibSMTEntryData.fddimibSMTStationStatus = D_fddimibSMTStationStatus_thru;
	break;
      case CF_c_wrap_a:
      case CF_c_wrap_b:
      case CF_c_wrap_s:
    	fddimibSMTEntryData.fddimibSMTStationStatus = D_fddimibSMTStationStatus_concatenated;
	break;
      default:
    	fddimibSMTEntryData.fddimibSMTStationStatus = D_fddimibSMTStationStatus_separated;
    }
    fddimibSMTEntryData.fddimibSMTPeerWrapFlag = smtPtr->PeerWrapFlag ?
	D_fddimibSMTPeerWrapFlag_true : D_fddimibSMTPeerWrapFlag_false;
    bcopy((uchar *)&smtPtr->TimeStamp,
	  (uchar *)&fddimibSMTEntryData.fddimibSMTTimeStamp, SIZE_FDDITimeStamp);
    bcopy((uchar *)&smtPtr->TransitionTimeStamp,
	  (uchar *)&fddimibSMTEntryData.fddimibSMTTransitionTimeStamp, SIZE_FDDITimeStamp);
    fddimibSMTEntryData.fddimibSMTStationAction = D_fddimibSMTStationAction_other;

    return (&fddimibSMTEntryData);
}



#ifdef SETS

int
k_fddimibSMTEntry_set(
    fddimibSMTEntry_t *data,
    ContextInfo    *contextInfo,
    int             function)
{
    SMTMessage       notifyMsg;             /* message to notify other tasks */
    SMTBaseAttrType *smtPtr;                /* SMT object info */
    uint stnID;
    hwidbtype *idb;

    if (data == NULL ||			/* safety */
	(idb = snmpfddi_findIdb_exact(data->fddimibSMTIndex)) == NULL)
	return (GEN_ERROR);
    stnID = idb->fddi_stn_id;
    smtPtr = &MIBDATA(stnID, mib->smtData);
    /*
     * Set notification message in case other tasks need to be notified of
     * the change.
     */
    notifyMsg.source = MIB_MSG_ID;
    notifyMsg.type = MIB_EVENT_NOTIFY_CHANGE;
    notifyMsg.entity = 0;
    notifyMsg.localID = 0;
    notifyMsg.len1 = 0;
    notifyMsg.len2 = 0;
    notifyMsg.stnID = stnID;

#ifdef I_fddimibSMTUserData
    if (VALID(I_fddimibSMTUserData, data->valid))
	bcopy(data->fddimibSMTUserData->octet_ptr, smtPtr->UserData, SIZE_SMTUserDataType);
#endif

#ifdef I_fddimibSMTConfigPolicy
    if (VALID(I_fddimibSMTConfigPolicy, data->valid)) {
	smtPtr->ConfigPolicy = data->fddimibSMTConfigPolicy; 
	/*
	* Send notification. Policies are NOT bounded by the object's capabilities.
	* However, the value reported to CSP is bounded by the capability.
	*/
        notifyMsg.typeInfo = fddiSMTConfigPolicy;
	notifyMsg.destination = CSP_MSG_ID;
	notifyMsg.data.b16 = smtPtr->ConfigPolicy & smtPtr->ConfigCapabilities;
	SendMIBMessage (&notifyMsg);
    }
#endif

#ifdef I_fddimibSMTConnectionPolicy
    if (VALID(I_fddimibSMTConnectionPolicy, data->valid)) {
	smtPtr->ConnectionPolicy = data->fddimibSMTConnectionPolicy;
	/* send notification message */
	notifyMsg.typeInfo = fddiSMTConnectionPolicy;
	notifyMsg.destination = CSP_MSG_ID;
	notifyMsg.data.b16 = smtPtr->ConnectionPolicy;
	SendMIBMessage (&notifyMsg);
    }
#endif

#ifdef I_fddimibSMTTNotify
    if (VALID(I_fddimibSMTTNotify, data->valid)) {
	smtPtr->T_Notify = data->fddimibSMTTNotify; 
	/* send notification message */
	notifyMsg.typeInfo = fddiSMTT_Notify;
	notifyMsg.destination = FBM_MSG_ID;
	notifyMsg.data.b16 = smtPtr->T_Notify;
	SendMIBMessage (&notifyMsg);
    }
#endif

#ifdef I_fddimibSMTStatRptPolicy
    if (VALID(I_fddimibSMTStatRptPolicy, data->valid)) {
	smtPtr->StatRptPolicy =
		data->fddimibSMTStatRptPolicy == D_fddimibSMTStatRptPolicy_true ?
		TRUE : FALSE;
	/* send notification message */
	notifyMsg.typeInfo = fddiSMTStatRptPolicy;
	notifyMsg.destination = FBM_MSG_ID;
	notifyMsg.data.b8 = smtPtr->StatRptPolicy;
	SendMIBMessage (&notifyMsg);
    }
#endif

#ifdef I_fddimibSMTTraceMaxExpiration
    if (VALID(I_fddimibSMTTraceMaxExpiration, data->valid)) {
	smtPtr->Trace_MaxExpiration =
		snmpFddi_ms2ns80(data->fddimibSMTTraceMaxExpiration); 
	/* send notification message */
	notifyMsg.typeInfo = fddiSMTTrace_MaxExpiration;
	notifyMsg.destination = CSP_MSG_ID;
	notifyMsg.data.b32 = smtPtr->Trace_MaxExpiration;
	SendMIBMessage (&notifyMsg);
    }
#endif

#ifdef I_fddimibSMTStationAction
    if (VALID(I_fddimibSMTStationAction, data->valid)) {
	notifyMsg.typeInfo = fddiSMTStationAction;
	switch (data->fddimibSMTStationAction) {
	case D_fddimibSMTStationAction_connect:
	    smtPtr->RemoteDisconnectFlag = CLEAR;
	    notifyMsg.typeInfo = SMTAction_connect;
	    break;
	case D_fddimibSMTStationAction_disconnect:
	    notifyMsg.typeInfo = SMTAction_disconnect;
	    break;
	case D_fddimibSMTStationAction_path_Test:
	    notifyMsg.typeInfo = SMTAction_path_Test;
	    break;
	case D_fddimibSMTStationAction_disable_a:
	    notifyMsg.typeInfo = SMTAction_disable_a;
	    break;
	case D_fddimibSMTStationAction_disable_b:
	    notifyMsg.typeInfo = SMTAction_disable_b;
	    break;
	case D_fddimibSMTStationAction_disable_m:
	    notifyMsg.typeInfo = SMTAction_disable_m;
	}
	/* Pass message to CSP */
	notifyMsg.destination = CSP_MSG_ID;
	notifyMsg.source = MIB_MSG_ID;
	notifyMsg.type = CSP_ACTION_FDDI_SMT;
	notifyMsg.localID = 0;
	notifyMsg.len1 = 0;
	notifyMsg.len2 = 0;
	SendMIBMessage (&notifyMsg);
    }
#endif

    return (NO_ERROR);
}

#endif				       /* SETS */



fddimibMAC_t   *
k_fddimibMAC_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator)
{
    static fddimibMAC_t fddimibMACData;

    fddimibMACData.fddimibMACNumber = MAX_MAC_COUNT * MAX_STATION_COUNT;

    return (&fddimibMACData);
}


/*
 * snmpfddi_findMac_exact () - given MAC resource index, find and return
 *	the index for database table (of [MAC|PORT]DataType struct).
 *	- same functionality as SearchResourceID() with SEARCH_FIND to be the
 *	  function parameter op's value.
 *	- This routine does linear search, and yet that routine does binary.
 *	  The searching list is so short that it's not worthwhile to have the
 *	  cost on overhead for binary search.
 */
static uint 
snmpfddi_findMac_exact(
    MIBType	*mibPtr,
    uint	macIndex)
{
    uint	macSearchIdx;
    ResourceTableType	*macPtr;

    if (macIndex > 0  && macIndex <= MAX_MAC_COUNT)
	for (macSearchIdx = 0, macPtr = &mibPtr->macTable[0]; 
	     macSearchIdx < MAX_MAC_COUNT; macSearchIdx++, macPtr++)
	     if (macIndex == macPtr->resourceID && mibPtr->macBase[macSearchIdx].inUse)
		return (macSearchIdx);
    return (-1);
}


fddimibMACEntry_t *
k_fddimibMACEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            fddimibMACSMTIndex,
    long            fddimibMACIndex)
{
    static fddimibMACEntry_t fddimibMACEntryData;
    static OctetString upstreamNbr,
			downstreamNbr,
			old_upstreamNbr,
			old_downstreamNbr,
			macaddr;
    static uchar upstrmNbr_string[IEEEBYTES],
		 downstrmNbr_string[IEEEBYTES],
		 old_upstrmNbr_string[IEEEBYTES],
		 old_downstrmNbr_string[IEEEBYTES],
		 macaddr_string[IEEEBYTES];
    hwidbtype *idb;
    MIBType *mibPtr = NULL;
    MACDataType *macp;
    MACBaseAttrType *macPtr;
    ResourceTableType *macRscPtr;
    MACHWAttrType *macHW;
    long macIndex = 0, macIdx, smtIdx;
    long result, timer;

    if (fddimibMACSMTIndex > MAX_STATION_COUNT || fddimibMACSMTIndex < 0)
	return (NULL);
    if (searchType == EXACT) {
        if ((idb = snmpfddi_findIdb_exact(fddimibMACSMTIndex)) == NULL)
	    return (NULL);
	smtIdx = idb->fddi_stn_id;
	mibPtr = MIBDATA(smtIdx, mib);
	if ((macIndex = snmpfddi_findMac_exact(mibPtr, fddimibMACIndex)) < 0)
	    return (NULL);
    } else {				/* searchType == NEXT */
	if (fddimibMACSMTIndex == 0) {
	    smtIdx = 0;
	    macIdx = 1;
	} else {
	    smtIdx = fddimibMACSMTIndex - 1;
	    macIdx = fddimibMACIndex == 0 ? 1 : fddimibMACIndex;
	}
	if (macIdx > MAX_MAC_COUNT || macIdx < 0) {
	    macIdx = 1;
	    smtIdx++;
	}
	while (smtIdx < MAX_STATION_COUNT) {
	    if ((idb = snmpfddi_findIdb_next(smtIdx)) != NULL) {
		smtIdx = idb->fddi_stn_id;
		mibPtr = MIBDATA(smtIdx, mib);
		for (macIndex = 0, macRscPtr = &mibPtr->macTable[0]; 
		    macIndex < MAX_MAC_COUNT; macIndex++, macRscPtr++)
		    if (macIdx <= macRscPtr->resourceID && mibPtr->macBase[macIndex].inUse)
			break;
		if (macIndex < MAX_MAC_COUNT)
		    break;		/* found it */
		else {
		    smtIdx++;		/* mac not found, try next station */
		    macIdx = 1;
		}
	    } else
		smtIdx = MAX_STATION_COUNT;	/* quit searching */
	}
	if (smtIdx >= MAX_STATION_COUNT)
	    return (NULL);
    }
    macp = &mibPtr->macBase[macIndex];
    macPtr = &macp->baseData;

    memset(&fddimibMACEntryData, 0, sizeof(fddimibMACEntry_t));
    fddimibMACEntryData.fddimibMACSMTIndex = smtIdx + 1;
    fddimibMACEntryData.fddimibMACIndex = macPtr->Index;
    fddimibMACEntryData.fddimibMACIfIndex = idb->snmp_if_index;
    fddimibMACEntryData.fddimibMACRequestedPaths = macPtr->RequestedPaths.reqPaths;
    fddimibMACEntryData.fddimibMACHardwarePresent = macPtr->HardwarePresent ?
	D_fddimibMACHardwarePresent_true : D_fddimibMACHardwarePresent_false;
    fddimibMACEntryData.fddimibMACMAUnitdataEnable = macPtr->MA_UnitdataEnable ?
	D_fddimibMACMAUnitdataEnable_true : D_fddimibMACMAUnitdataEnable_false;

    if (macPtr->HardwarePresent) {
	macHW = &mibPtr->macBase[macIndex].hwData;
	fddimibMACEntryData.fddimibMACFrameStatusFunctions = macHW->FrameStatusFunctions;
	fddimibMACEntryData.fddimibMACTMaxCapability =
		snmpFddi_2sCompToTimeNano((ulong) macHW->T_MaxCapability);
	fddimibMACEntryData.fddimibMACTVXCapability = 
		snmpFddi_2sCompToTimeNano((ulong) macHW->TVXCapability);
	fddimibMACEntryData.fddimibMACAvailablePaths = macHW->AvailablePaths;
	fddimibMACEntryData.fddimibMACCurrentPath = macHW->CurrentPath + 1;
	fddimibMACEntryData.fddimibMACUpstreamNbr = &upstreamNbr;
	fddimibMACEntryData.fddimibMACUpstreamNbr->length = IEEEBYTES;
	MCopyAddress(upstrmNbr_string, macHW->UpstreamNbr);
	ieee_swap(upstrmNbr_string, upstrmNbr_string);
	fddimibMACEntryData.fddimibMACUpstreamNbr->octet_ptr = upstrmNbr_string;
	fddimibMACEntryData.fddimibMACDownstreamNbr = &downstreamNbr;
	fddimibMACEntryData.fddimibMACDownstreamNbr->length = IEEEBYTES;
	MCopyAddress(downstrmNbr_string, macHW->DownstreamNbr);
	ieee_swap(downstrmNbr_string, downstrmNbr_string);
	fddimibMACEntryData.fddimibMACDownstreamNbr->octet_ptr = downstrmNbr_string;
	fddimibMACEntryData.fddimibMACOldUpstreamNbr = &old_upstreamNbr;
	fddimibMACEntryData.fddimibMACOldUpstreamNbr->length = IEEEBYTES;
	MCopyAddress(old_upstrmNbr_string, macHW->OldUpstreamNbr);
	ieee_swap(old_upstrmNbr_string, old_upstrmNbr_string);
	fddimibMACEntryData.fddimibMACOldUpstreamNbr->octet_ptr = old_upstrmNbr_string;
	fddimibMACEntryData.fddimibMACOldDownstreamNbr = &old_downstreamNbr;
	fddimibMACEntryData.fddimibMACOldDownstreamNbr->length = IEEEBYTES;
	MCopyAddress(old_downstrmNbr_string, macHW->OldDownstreamNbr);
	ieee_swap(old_downstrmNbr_string, old_downstrmNbr_string);
	fddimibMACEntryData.fddimibMACOldDownstreamNbr->octet_ptr = old_downstrmNbr_string;
	fddimibMACEntryData.fddimibMACDupAddressTest = macHW->DupAddressTest + 1;
	startIndex = macPtr->xdi.xdiIndex;
	startType = RT_mac;
	do {
	    /* get the connected entity */
	    GetConnectedResource((ushort)smtIdx, startIndex, startType,
			 	&currentIndex, &currentType);
	    if (currentType == RT_port)
		break;			/* port found */
	    startIndex = currentIndex;
	    startType = currentType;
	} while (currentIndex != macPtr->xdi.xdiIndex);
	fddimibMACEntryData.fddimibMACDownstreamPORTType =
	    currentType == RT_port ?
	    MIBDATA(smtIdx, mib->portBase[currentIndex].baseData.My_Type) + 1 :
	    D_fddimibMACDownstreamPORTType_none;
	fddimibMACEntryData.fddimibMACSMTAddress = &macaddr;
	fddimibMACEntryData.fddimibMACSMTAddress->length = IEEEBYTES;
	MCopyAddress(macaddr_string, macHW->SMTAddress);
	ieee_swap(macaddr_string,macaddr_string);
	fddimibMACEntryData.fddimibMACSMTAddress->octet_ptr = macaddr_string;

	result = GetMACDataMulti(smtIdx, fddiMACT_Req, macp, (uchar *)&timer);
	fddimibMACEntryData.fddimibMACTReq = snmpFddi_2sCompToTimeNano(timer);
	result = GetMACDataMulti(smtIdx, fddiMACTvxValue, macp, (uchar *)&timer);
	fddimibMACEntryData.fddimibMACTvxValue = snmpFddi_2sCompToTimeNano(timer);
	result = GetMACDataMulti(smtIdx, fddiMACT_Neg, macp, (uchar *)&timer);
	fddimibMACEntryData.fddimibMACTNeg = snmpFddi_2sCompToTimeNano(timer);
	result = GetMACDataMulti(smtIdx, fddiMACT_Max, macp, (uchar *)&timer);
	fddimibMACEntryData.fddimibMACTMax = snmpFddi_2sCompToTimeNano(timer);

	result = GetMACDataMulti(smtIdx, fddiMACFrame_Ct, macp,
		 (uchar *)&fddimibMACEntryData.fddimibMACFrameCts);
	result = GetMACDataMulti(smtIdx, fddiMACCopied_Ct, macp,
		 (uchar *)&fddimibMACEntryData.fddimibMACCopiedCts);
	result = GetMACDataMulti(smtIdx, fddiMACTransmit_Ct, macp,
		 (uchar *)&fddimibMACEntryData.fddimibMACTransmitCts);
	result = GetMACDataMulti(smtIdx, fddiMACError_Ct, macp,
		 (uchar *)&fddimibMACEntryData.fddimibMACErrorCts);
	result = GetMACDataMulti(smtIdx, fddiMACLost_Ct, macp,
		 (uchar *)&fddimibMACEntryData.fddimibMACLostCts);

	fddimibMACEntryData.fddimibMACFrameErrorThreshold = macPtr->FrameErrorThreshold;
	fddimibMACEntryData.fddimibMACFrameErrorRatio = macHW->FrameErrorRatio;
	fddimibMACEntryData.fddimibMACRMTState = macHW->RMTState + 1;
	fddimibMACEntryData.fddimibMACDaFlag = macHW->DA_Flag == SET? 
		D_fddimibMACDaFlag_true : D_fddimibMACDaFlag_false;
	fddimibMACEntryData.fddimibMACUnaDaFlag = macHW->UNDA_Flag == TRUE?
		D_fddimibMACUnaDaFlag_true : D_fddimibMACUnaDaFlag_false;
	fddimibMACEntryData.fddimibMACFrameErrorFlag = macHW->FrameErrorFlag ?
		D_fddimibMACFrameErrorFlag_true : D_fddimibMACFrameErrorFlag_false;
	fddimibMACEntryData.fddimibMACMAUnitdataAvailable = macHW->MA_UnitdataAvailable?
		D_fddimibMACMAUnitdataAvailable_true : D_fddimibMACMAUnitdataAvailable_false;
    }

    return (&fddimibMACEntryData);
}

#ifdef SETS

int
k_fddimibMACEntry_set(
    fddimibMACEntry_t *data,
    ContextInfo    *contextInfo,
    int             function)
{
    hwidbtype *idb;
    MIBType *mibPtr;
    MACDataType *macPtr;
    SMTMessage notifyMsg;
    long macIndex;

    if (data == NULL || (idb = snmpfddi_findIdb_exact(data->fddimibMACSMTIndex)) == NULL)
	return (GEN_ERROR);		/* safety */
    mibPtr = MIBDATA(idb->fddi_stn_id, mib);
    if ((macIndex = snmpfddi_findMac_exact(mibPtr, data->fddimibMACIndex)) < 0)
	return (GEN_ERROR);		/* safety */
    macPtr = &mibPtr->macBase[macIndex];
    /* Set up notification message */
    notifyMsg.source = MIB_MSG_ID;
    notifyMsg.type = MIB_EVENT_NOTIFY_CHANGE;
    notifyMsg.entity = macIndex;
    notifyMsg.localID = 0;
    notifyMsg.len1 = 0;
    notifyMsg.len2 = 0;
    notifyMsg.stnID = idb->fddi_stn_id;

#ifdef I_fddimibMACRequestedPaths
    if (VALID(I_fddimibMACRequestedPaths, data->valid)) {
	notifyMsg.data.b8 = macPtr->baseData.RequestedPaths.reqPaths =
			    data->fddimibMACRequestedPaths;
	notifyMsg.typeInfo = fddiMACRequestedPaths;
	notifyMsg.destination = CSP_MSG_ID;
	SendMIBMessage (&notifyMsg);
    }
#endif

#ifdef I_fddimibMACFrameErrorThreshold
    if (VALID(I_fddimibMACFrameErrorThreshold, data->valid)) {
	macPtr->baseData.FrameErrorThreshold = data->fddimibMACFrameErrorThreshold;
/*
	notifyMsg.typeInfo = fddiMACFrameErrorThreshold;
	notifyMsg.destination = CSP_MSG_ID;
	SendMIBMessage (&notifyMsg);
 */
    }
#endif

#ifdef I_fddimibMACMAUnitdataEnable
    if (VALID(I_fddimibMACMAUnitdataEnable, data->valid)) {
	notifyMsg.data.b8 = macPtr->baseData.MA_UnitdataEnable =
		data->fddimibMACMAUnitdataEnable == D_fddimibMACMAUnitdataEnable_true ?
		TRUE : FALSE;
	notifyMsg.typeInfo = fddiMACMA_UnitdataEnable;
	notifyMsg.destination = CSP_MSG_ID;
	SendMIBMessage (&notifyMsg);
    }
#endif

    return (NO_ERROR);
}

#endif				       /* SETS */


/* 8/18/94
 * Some of this Enhanced MAC Counters group are not supported (those with 0
 * assigned below).
 * See GetMACDataMulti() in hes/hes_xdi.c, GetMIBMACAttr() in mibget.c,
 * and ChangeMIBMACAttr() in mibchng.c
 *
 * But because of the following statement in RFC1512 this group is considered
 * not supported.
 *        -- the Enhanced MAC Counters group
 *        -- Implementation of this Group is optional, but systems
 *        -- claiming support must implement all variables in this
 *        -- group
 */


fddimibMACCountersEntry_t *
k_fddimibMACCountersEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            fddimibMACSMTIndex,
    long            fddimibMACIndex)
{
    static fddimibMACCountersEntry_t fddimibMACCountersEntryData;
    hwidbtype *idb;
    MIBType *mibPtr = NULL;
    MACDataType *macPtr;
    MACBaseAttrType *macBasePtr;
    ResourceTableType *macRscPtr;
    long macIndex = 0, macIdx, smtIdx;
    ulong result, tmp;
    boolean hdwrPresent;
#define MAC_MIB_NO_VALUE 0

    if (fddimibMACSMTIndex > MAX_STATION_COUNT || fddimibMACSMTIndex < 0)
	return (NULL);
    if (searchType == EXACT) {
        if ((idb = snmpfddi_findIdb_exact(fddimibMACSMTIndex)) == NULL)
	    return (NULL);
	smtIdx = idb->fddi_stn_id;
	mibPtr = MIBDATA(smtIdx, mib);
	if ((macIndex = snmpfddi_findMac_exact(mibPtr, fddimibMACIndex)) < 0)
	    return (NULL);
    } else {				/* searchType == NEXT */
	if (fddimibMACSMTIndex == 0) {
	    smtIdx = 0;
	    macIdx = 1;
	} else {
	    smtIdx = fddimibMACSMTIndex - 1;
	    macIdx = fddimibMACIndex == 0 ? 1 : fddimibMACIndex;
	}
	if (macIdx > MAX_MAC_COUNT || macIdx < 0) {
	    macIdx = 1;
	    smtIdx++;
	}
	while (smtIdx < MAX_STATION_COUNT) {
	    if ((idb = snmpfddi_findIdb_next(smtIdx)) != NULL) {
		smtIdx = idb->fddi_stn_id;
		mibPtr = MIBDATA(smtIdx, mib);
		for (macIndex = 0, macRscPtr = &mibPtr->macTable[0]; 
		    macIndex < MAX_MAC_COUNT; macIndex++, macRscPtr++)
		    if (macIdx <= macRscPtr->resourceID && mibPtr->macBase[macIndex].inUse)
			break;
		if (macIndex < MAX_MAC_COUNT)
		    break;		/* found it */
		else {
		    smtIdx++;		/* mac not found, try next station */
		    macIdx = 1;
		}
	    } else
		smtIdx = MAX_STATION_COUNT;	/* quit searching */
	}
	if (smtIdx >= MAX_STATION_COUNT)
	    return (NULL);
    }
    macPtr = &mibPtr->macBase[macIndex];
    macBasePtr = &macPtr->baseData;
    hdwrPresent = macBasePtr->HardwarePresent ? TRUE : FALSE;

    fddimibMACCountersEntryData.fddimibMACSMTIndex = smtIdx + 1;
    fddimibMACCountersEntryData.fddimibMACIndex = macBasePtr->Index;

    if (hdwrPresent && (macBasePtr->xdi.packages & PKG_tokencounter)) {
	result = GetMACDataMulti(smtIdx, fddiMACToken_Ct, macPtr, (uchar *)&tmp);
	fddimibMACCountersEntryData.fddimibMACTokenCts =
	    result == RC_NoParameter ? MAC_MIB_NO_VALUE : tmp;
    } else
	fddimibMACCountersEntryData.fddimibMACTokenCts = MAC_MIB_NO_VALUE;

    if (hdwrPresent && (macBasePtr->xdi.packages & PKG_tvxexpired)) {
	result = GetMACDataMulti(smtIdx, fddiMACTvxExpired_Ct, macPtr, (uchar *)&tmp);
	fddimibMACCountersEntryData.fddimibMACTvxExpiredCts =
	    result == RC_NoParameter ? MAC_MIB_NO_VALUE : tmp;
    } else
	fddimibMACCountersEntryData.fddimibMACTvxExpiredCts = MAC_MIB_NO_VALUE;

    if (hdwrPresent && (macBasePtr->xdi.packages & PKG_framenotcopied)) {
	result = GetMACDataMulti(smtIdx, fddiMACNotCopied_Ct, macPtr, (uchar *)&tmp);
	fddimibMACCountersEntryData.fddimibMACNotCopiedCts =
	    result == RC_NoParameter ? MAC_MIB_NO_VALUE : tmp;
    } else
	fddimibMACCountersEntryData.fddimibMACNotCopiedCts = MAC_MIB_NO_VALUE;

    if (hdwrPresent && (macBasePtr->xdi.packages & PKG_latecount)) {
	result = GetMACDataMulti(smtIdx, fddiMACLate_Ct, macPtr, (uchar *)&tmp);
	fddimibMACCountersEntryData.fddimibMACLateCts = 
	    result == RC_NoParameter ? MAC_MIB_NO_VALUE : tmp;
    } else
	fddimibMACCountersEntryData.fddimibMACLateCts = MAC_MIB_NO_VALUE;

    if (hdwrPresent && (macBasePtr->xdi.packages & PKG_ringopcount)) {
	result = GetMACDataMulti(smtIdx, fddiMACRingOp_Ct, macPtr, (uchar *)&tmp);
	fddimibMACCountersEntryData.fddimibMACRingOpCts =
	    result == RC_NoParameter ? MAC_MIB_NO_VALUE : tmp;
    } else
	fddimibMACCountersEntryData.fddimibMACRingOpCts = MAC_MIB_NO_VALUE;

    fddimibMACCountersEntryData.fddimibMACNotCopiedRatio = 
	hdwrPresent && (macBasePtr->xdi.packages & PKG_framenotcopied) ?
	    macPtr->hwData.NotCopiedRatio : MAC_MIB_NO_VALUE;

    fddimibMACCountersEntryData.fddimibMACNotCopiedFlag =
	hdwrPresent && (macBasePtr->xdi.packages & PKG_framenotcopied) &&
	macPtr->hwData.NotCopiedFlag ?
	D_fddimibMACNotCopiedFlag_true : D_fddimibMACNotCopiedFlag_false;

    fddimibMACCountersEntryData.fddimibMACNotCopiedThreshold =
	((macBasePtr->xdi.packages & PKG_framenotcopiedmanagement) &&
	 (macBasePtr->xdi.packages & PKG_framenotcopied)) ?
	macBasePtr->NotCopiedThreshold : MAC_MIB_NO_VALUE;

    return (&fddimibMACCountersEntryData);
}


#ifdef SETS
int
k_fddimibMACCountersEntry_set(
    fddimibMACCountersEntry_t *data,
    ContextInfo    *contextInfo,
    int             function)
{
    hwidbtype *idb;
    MIBType *mibPtr;
    MACDataType *macPtr;
    long macIndex;

    if (data == NULL || (idb = snmpfddi_findIdb_exact(data->fddimibMACSMTIndex)) == NULL)
	return (GEN_ERROR);		/* safety */
    mibPtr = MIBDATA(idb->fddi_stn_id, mib);
    if ((macIndex = snmpfddi_findMac_exact(mibPtr, data->fddimibMACIndex)) < 0)
	return (GEN_ERROR);		/* safety */
    macPtr = &mibPtr->macBase[macIndex];

#ifdef I_fddimibMACNotCopiedThreshold
    if (VALID(I_fddimibMACNotCopiedThreshold, data->valid)) {
	macPtr->baseData.NotCopiedThreshold = (ulong)data->fddimibMACNotCopiedThreshold;
    }
#endif					/* I_fddimibMACNotCopiedThreshold */

    return (NO_ERROR);
}

#endif				       /* SETS */



fddimibPATH_t  *
k_fddimibPATH_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator)
{
    static fddimibPATH_t fddimibPATHData;

    fddimibPATHData.fddimibPATHNumber = MAX_PATH_COUNT * MAX_STATION_COUNT;
    return (&fddimibPATHData);
}

fddimibPATHEntry_t *
k_fddimibPATHEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            fddimibPATHSMTIndex,
    long            fddimibPATHIndex)
{
    static fddimibPATHEntry_t fddimibPATHEntryData;
    PATHBaseAttrType	*pathPtr = NULL;
    long	pathIndex, smtIdx;
    hwidbtype	*idb;
    MIBType	*mibPtr = NULL;

    if (fddimibPATHSMTIndex > MAX_STATION_COUNT || fddimibPATHSMTIndex < 0)
	return (NULL);
    idb = NULL;
    if (searchType == EXACT) {
	pathIndex = fddimibPATHIndex;
	if (pathIndex >= MAX_PATH_COUNT || pathIndex < 0 ||
	    (idb = snmpfddi_findIdb_exact(fddimibPATHSMTIndex)) == NULL ||
	    !((mibPtr = MIBDATA(idb->fddi_stn_id, mib))->pathBase[pathIndex].inUse))
	    return (NULL);
	smtIdx = idb->fddi_stn_id;
    } else {			/* searchType == NEXT */
	if (fddimibPATHSMTIndex == 0) {
	    smtIdx = 0;
	    pathIndex = 0;
	} else {
	    smtIdx = fddimibPATHSMTIndex - 1;
	    if ((pathIndex = fddimibPATHIndex) >= MAX_PATH_COUNT || pathIndex < 0) {
		pathIndex = 0;
		smtIdx++;
	    }
	}
	while (smtIdx < MAX_STATION_COUNT) {
	    if ((idb = snmpfddi_findIdb_next(smtIdx)) != NULL) {
		smtIdx = idb->fddi_stn_id;
		mibPtr = MIBDATA(smtIdx, mib);
		for (; pathIndex < MAX_PATH_COUNT && pathIndex >= 0 &&
		       !mibPtr->pathBase[pathIndex].inUse; pathIndex++)
		    ;
		if (pathIndex < MAX_PATH_COUNT)
		    break;
		else {
		    smtIdx++;
		    pathIndex = 0;	/* no path found, try next station */
		}
	    } else
		smtIdx = MAX_STATION_COUNT;	/* quit searching */
	}
	if (smtIdx >= MAX_STATION_COUNT)
	    return (NULL);
    }
    pathPtr = &mibPtr->pathBase[pathIndex].baseData;
    fddimibPATHEntryData.fddimibPATHSMTIndex = smtIdx + 1;
    fddimibPATHEntryData.fddimibPATHIndex = pathIndex;
    fddimibPATHEntryData.fddimibPATHTVXLowerBound = 
	snmpFddi_2sCompToTimeNano((ulong) pathPtr->TVXLowerBound);
    fddimibPATHEntryData.fddimibPATHTMaxLowerBound = 
	snmpFddi_2sCompToTimeNano((ulong) pathPtr->T_MaxLowerBound);
    fddimibPATHEntryData.fddimibPATHMaxTReq = 
	snmpFddi_us2ns((ulong) pathPtr->MaxT_Req);

    return (&fddimibPATHEntryData);
}

#ifdef SETS

int
k_fddimibPATHEntry_set(
    fddimibPATHEntry_t *data,
    ContextInfo    *contextInfo,
    int             function)
{
    PATHBaseAttrType *pathPtr;
    SMTMessage notifyMsg;
    uint stnID, pathIndex;

    if (data == NULL || snmpfddi_findIdb_exact(data->fddimibPATHSMTIndex) == NULL)
	return (GEN_ERROR);		/* safety */
    stnID = data->fddimibPATHSMTIndex - 1;
    pathIndex = data->fddimibPATHIndex;
    pathPtr = &MIBDATA(stnID, mib->pathBase[pathIndex].baseData);
    notifyMsg.source = MIB_MSG_ID;
    notifyMsg.type = MIB_EVENT_NOTIFY_CHANGE;
    notifyMsg.entity = pathIndex;
    notifyMsg.localID = 0;
    notifyMsg.len1 = 0;
    notifyMsg.len2 = 0;
    notifyMsg.stnID = stnID;

#ifdef I_fddimibPATHTVXLowerBound
    if (VALID(I_fddimibPATHTVXLowerBound, data->valid)) {
	notifyMsg.data.b32 = (ulong)pathPtr->TVXLowerBound \
	    = snmpFddi_nsTo2sComp((ulong)data->fddimibPATHTVXLowerBound);
	notifyMsg.destination = CSP_MSG_ID;
	notifyMsg.typeInfo = fddiPATHTVXLowerBound;
	SendMIBMessage (&notifyMsg);
    }
#endif

#ifdef I_fddimibPATHTMaxLowerBound
    if (VALID(I_fddimibPATHTMaxLowerBound, data->valid)) {
	notifyMsg.data.b32 = (ulong) pathPtr->T_MaxLowerBound \
	    = snmpFddi_nsTo2sComp((ulong) data->fddimibPATHTMaxLowerBound);
	notifyMsg.destination = CSP_MSG_ID;
	notifyMsg.typeInfo = fddiPATHT_MaxLowerBound;
	SendMIBMessage (&notifyMsg);
    }
#endif

#ifdef I_fddimibPATHMaxTReq
    if (VALID(I_fddimibPATHMaxTReq, data->valid)) {
	notifyMsg.data.b32 = (ulong) pathPtr->MaxT_Req \
	    = snmpFddi_ns2us((ulong) data->fddimibPATHMaxTReq);
	notifyMsg.destination = CSP_MSG_ID;
	notifyMsg.typeInfo = fddiPATHMaxT_Req;
	SendMIBMessage (&notifyMsg);
    }
#endif

    return (NO_ERROR);
}

#endif				       /* SETS */



/*
 * find_fddi_pathCfg
 *	- find the first resource on a path configuration list
 *	- return TRUE if found one, either a port or a MAC, and the
 *	  searchPath, startType and startIndex get set;
 *	  return FALSE if identified an invalid path resource index  or
 *	  somehow failed to find any resource on this configuration list.
 */
static boolean
find_fddi_pathCfg_start(
    long	pathIdx,
    MIBType	*mibPtr)
{
    int	i;
    MACDataPtr	macPtr;
    PORTDataPtr	portPtr;

    switch (pathIdx) {
    case PI_primary:
	searchPath = AP_primary;
	break;
    case PI_secondary:
	searchPath = AP_secondary;
	break;
    case PI_local:
	searchPath = AP_local;
	break;
    default:
	return (FALSE);
    }
    /* find first PORT object on this path; if not found, try first MAC */
    startIndex = startType = 0;
    for (i = 0, portPtr = mibPtr->portBase; i < MAX_PORT_COUNT; i++, portPtr++)
	if (portPtr->inUse && portPtr->baseData.HardwarePresent &&
	    (portPtr->hwData.AvailablePaths & searchPath)) {
	    startIndex = i;
	    startType = RT_port;
	    break;
	}
    if (startType != RT_port)		/* no port found, try MACs */
	for (i = 0, macPtr = mibPtr->macBase; i < MAX_MAC_COUNT; i++, macPtr++)
	    if (macPtr->inUse && macPtr->baseData.HardwarePresent &&
		(macPtr->hwData.AvailablePaths & searchPath)) {
		startIndex = i;
		startType = RT_mac;
		break;
	    }
    return (startType == 0 ? FALSE : TRUE);
}


/*
 * find_fddi_pathCfg_rsrc
 *	- find the resource on the path as indexed by the token order.
 *	- return TRUE if found one, either a port or a MAC,
 *	  and the mib data block is filled; return FALSE otherwise.
 */
static boolean
find_fddi_pathCfg_rsrc(
    MIBType	*mibPtr,
    long	pathIndex,
    long	tokenOrder)
{
    MACDataPtr		macPtr = NULL;
    PORTDataPtr		portPtr = NULL;
    PathConfigType	*pathCfgPtr = NULL;

    while (resourceCt < tokenOrder &&
	   (currentIndex != startIndex || currentType != startType)) {
	if (currentType == RT_mac) {
	    macPtr = &mibPtr->macBase[currentIndex];
	    pathCfgPtr = &macPtr->baseData.xdi.configList[pathIndex];
	} else {
	    portPtr = &mibPtr->portBase[currentIndex];
	    pathCfgPtr = &portPtr->baseData.xdi.configList[pathIndex];
	}
	/* get next resource on the path */
	currentIndex = pathCfgPtr->nextIndex;
	currentType = pathCfgPtr->nextType;
	resourceCt++;
    }
    return (resourceCt == tokenOrder ? TRUE : FALSE);
}



fddimibPATHConfigEntry_t *
k_fddimibPATHConfigEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            fddimibPATHConfigSMTIndex,
    long            fddimibPATHConfigPATHIndex,
    long            fddimibPATHConfigTokenOrder)
{
    static fddimibPATHConfigEntry_t	fddimibPATHConfigEntryData;
    MIBType		*mibPtr = NULL;
    long		smtIdx, pathIndex, tokenOrder;
    hwidbtype		*idb;

    if (searchType == EXACT) {
	if (fddimibPATHConfigPATHIndex > MAX_PATH_COUNT ||
	    fddimibPATHConfigPATHIndex <= 0 ||
	    fddimibPATHConfigTokenOrder > totalResource ||
	    fddimibPATHConfigTokenOrder <= 0)
	    return (NULL);		/* invalid index */
	if ((idb = snmpfddi_findIdb_exact(fddimibPATHConfigSMTIndex)) == NULL)
	    return (NULL);		/* no such idb for this SMT id */
	mibPtr = MIBDATA((smtIdx = idb->fddi_stn_id), mib);
	if (!mibPtr->pathBase[(pathIndex = fddimibPATHConfigPATHIndex - 1)].inUse)
	    return (NULL);
	if (!find_fddi_pathCfg_start(fddimibPATHConfigPATHIndex, mibPtr))
	    return (NULL);		/* invalid index or no resource found */
	/* search through the Path Config doubled linked list
	 * startIndex and startType have been set */
	currentIndex = startIndex;
	currentType = startType;
	resourceCt = 1;
	if (!find_fddi_pathCfg_rsrc(mibPtr, pathIndex, fddimibPATHConfigTokenOrder))
	    return (NULL);	/* no such resource on the path as indexed */

    } else {				/* searchType == NEXT */
	if (fddimibPATHConfigSMTIndex == 0) {
	    smtIdx = 0;
	    pathIndex = 0;
	    tokenOrder = 1;
	} else {
	    smtIdx = fddimibPATHConfigSMTIndex - 1;
	    if (fddimibPATHConfigPATHIndex == 0) {
		pathIndex = 0;
		tokenOrder = 1;
	    } else {
		pathIndex = fddimibPATHConfigPATHIndex - 1;
		tokenOrder = fddimibPATHConfigTokenOrder == 0 ?
			 1 : fddimibPATHConfigTokenOrder;
		if (tokenOrder > totalResource || tokenOrder < 0)  {
		    tokenOrder = 1;
		    pathIndex++;
		}
		if (pathIndex >= MAX_PATH_COUNT || pathIndex < 0) {
	    	    tokenOrder = 1;
	    	    pathIndex = 0;
	    	    smtIdx++;
		} 
	    }
	}
	while (smtIdx < MAX_STATION_COUNT) {
	    if ((idb = snmpfddi_findIdb_next(smtIdx)) == NULL) {
		smtIdx = MAX_STATION_COUNT;		/* quit searching */
		break;
	    }
	    smtIdx = idb->fddi_stn_id;
	    mibPtr = MIBDATA(smtIdx, mib);
findfddiPathCfgPath:
	    for (; pathIndex < MAX_PATH_COUNT
		   && !mibPtr->pathBase[pathIndex].inUse; pathIndex++);
	    if (pathIndex >= MAX_PATH_COUNT) {
		/* no such path for this station */
		pathIndex = 0;		/* reset the path index */
		tokenOrder = 1;		/* reset the resource count */
		smtIdx++;		/* try next station */
		continue;
	    } else {
		if (!find_fddi_pathCfg_start(pathIndex + 1, mibPtr)) {
		    tokenOrder = 1;
		    pathIndex++;
		    goto findfddiPathCfgPath;
		}
    	        resourceCt = 1;
	        currentIndex = startIndex;
	        currentType = startType;
findfddiPathCfgRsrc:
	        /* search through the Path Config (doubled linked) list */
	        if (find_fddi_pathCfg_rsrc(mibPtr, pathIndex, tokenOrder))
		    break;		/* found it */
		else {
	    	    /* failed to find the PORT or MAC on this path as indexed */
		    if ((currentIndex == startIndex && currentType == startType) 
			|| ++tokenOrder > totalResource) {
			tokenOrder = 1;
			pathIndex++;
			goto findfddiPathCfgPath;
		    }
		    goto findfddiPathCfgRsrc;
		}
	    }		/* endif on finding pathIndex */
	}		/* endwhile for next station */
	if (smtIdx >= MAX_STATION_COUNT)
	    return (NULL);
    }			/* endif on searchType */
    fddimibPATHConfigEntryData.fddimibPATHConfigSMTIndex = smtIdx + 1;
    fddimibPATHConfigEntryData.fddimibPATHConfigPATHIndex = pathIndex + 1;
    fddimibPATHConfigEntryData.fddimibPATHConfigTokenOrder = resourceCt;
    fddimibPATHConfigEntryData.fddimibPATHConfigResourceType = currentType;
    fddimibPATHConfigEntryData.fddimibPATHConfigResourceIndex = 
	currentType == RT_mac ? mibPtr->macBase[currentIndex].baseData.Index
			: mibPtr->portBase[currentIndex].baseData.Index;
    fddimibPATHConfigEntryData.fddimibPATHConfigCurrentPath =
        currentType == RT_mac ?
	mibPtr->macBase[currentIndex].hwData.CurrentPath + 1 :
	mibPtr->portBase[currentIndex].hwData.CurrentPath + 1;

    return (&fddimibPATHConfigEntryData);
}


static uint 
snmpfddi_findPort_exact(
    MIBType	*mibPtr,
    uint	portIndex)
{
    uint	portSearchIdx;
    ResourceTableType	*portPtr;

    for (portSearchIdx = 0, portPtr = &mibPtr->portTable[0]; 
    	 portSearchIdx < MAX_PORT_COUNT; portSearchIdx++, portPtr++)
	if (portIndex == portPtr->resourceID && mibPtr->portBase[portSearchIdx].inUse)
	    return (portSearchIdx);
    return (-1);
}



fddimibPORT_t  *
k_fddimibPORT_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator)
{
    static fddimibPORT_t fddimibPORTData;

    fddimibPORTData.fddimibPORTNumber = MAX_PORT_COUNT * MAX_STATION_COUNT;
    return (&fddimibPORTData);
}

fddimibPORTEntry_t *
k_fddimibPORTEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            fddimibPORTSMTIndex,
    long            fddimibPORTIndex)
{
    static fddimibPORTEntry_t fddimibPORTEntryData;
    PORTDataType *portPtr = NULL;
    ResourceTableType *portRscPtr;
    PORTBaseAttrType *portBasePtr;
    PORTHWAttrType *portHW;
    long	stnID, portIndex, portIdx;
    hwidbtype	*idb;
    static OctetString	reqPaths;
    static uchar reqPaths_string[SIZE_DEFAULT];
    MIBType	*mibPtr;

    if (fddimibPORTSMTIndex > MAX_STATION_COUNT || fddimibPORTSMTIndex < 0)
	return (NULL);
    if (searchType == EXACT) {
        if ((idb = snmpfddi_findIdb_exact(fddimibPORTSMTIndex)) == NULL)
	    return (NULL);
	stnID = idb->fddi_stn_id;
	mibPtr = MIBDATA(stnID, mib);
	if ((portIndex = snmpfddi_findPort_exact(mibPtr, fddimibPORTIndex)) < 0)
	    return (NULL);
	portPtr = &mibPtr->portBase[portIndex];
    } else {			/* searchType == NEXT */
	if (fddimibPORTSMTIndex == 0) {
	    stnID = 0;
	    portIdx = 1;
	} else {
	    stnID = fddimibPORTSMTIndex - 1;
	    portIdx = fddimibPORTIndex == 0 ? 1 : fddimibPORTIndex;
	    if (portIdx > MAX_PORT_COUNT || portIdx < 0) {
		portIdx = 1;
		stnID++;
	    }
	}
	while (stnID < MAX_STATION_COUNT) {
	    if ((idb = snmpfddi_findIdb_next(stnID)) != NULL) {
		stnID = idb->fddi_stn_id;
		mibPtr = MIBDATA(stnID, mib);
		for (portIndex = 0, portRscPtr = &mibPtr->portTable[0]; 
		    portIndex < MAX_PORT_COUNT; portIndex++, portRscPtr++)
		    if (portIdx <= portRscPtr->resourceID &&
			mibPtr->portBase[portIndex].inUse)
			break;
		if (portIndex < MAX_PORT_COUNT) {
		    portPtr = &mibPtr->portBase[portIndex];
		    break;
		} else {
		    stnID++;		/* port not found, try next station */
		    portIdx = 1;
		}
	    } else
		stnID = MAX_STATION_COUNT;	/* quit searching */
	}
	if (stnID >= MAX_STATION_COUNT)
	    return (NULL);
    }
    memset(&fddimibPORTEntryData, 0, sizeof(fddimibPORTEntry_t));
    portBasePtr = &portPtr->baseData;
    fddimibPORTEntryData.fddimibPORTSMTIndex = stnID + 1;
    fddimibPORTEntryData.fddimibPORTIndex = portBasePtr->Index;
    fddimibPORTEntryData.fddimibPORTMyType = portBasePtr->My_Type + 1;
    fddimibPORTEntryData.fddimibPORTConnectionPolicies = portBasePtr->ConnectionPolicies;
    fddimibPORTEntryData.fddimibPORTLerCutoff = portBasePtr->Ler_Cutoff;
    fddimibPORTEntryData.fddimibPORTLerAlarm = portBasePtr->Ler_Alarm;
    bcopy((uchar *)&portBasePtr->RequestedPaths.reqPaths, reqPaths_string, SIZE_FddiMibPortReqPaths);
    fddimibPORTEntryData.fddimibPORTRequestedPaths = &reqPaths;
    fddimibPORTEntryData.fddimibPORTRequestedPaths->length = SIZE_FddiMibPortReqPaths;
    fddimibPORTEntryData.fddimibPORTRequestedPaths->octet_ptr = reqPaths_string;

    fddimibPORTEntryData.fddimibPORTHardwarePresent = portBasePtr->HardwarePresent?
	D_fddimibPORTHardwarePresent_true : D_fddimibPORTHardwarePresent_false;
    if (!portBasePtr->HardwarePresent)
	fddimibPORTEntryData.fddimibPORTHardwarePresent = D_fddimibPORTHardwarePresent_false;
    else {
	fddimibPORTEntryData.fddimibPORTHardwarePresent = D_fddimibPORTHardwarePresent_true;
	portHW = &portPtr->hwData;
    	fddimibPORTEntryData.fddimibPORTNeighborType = (CSPPCNBR) + 1;
	if (portHW->MACIndicated.t_val9 == FALSE)
	    fddimibPORTEntryData.fddimibPORTMACIndicated =
		portHW->MACIndicated.r_val9 == FALSE ? 
		D_fddimibPORTMACIndicated_tVal9FalseRVal9False :
		D_fddimibPORTMACIndicated_tVal9FalseRVal9True;
	else
	    fddimibPORTEntryData.fddimibPORTMACIndicated =
		portHW->MACIndicated.r_val9 == FALSE ? 
		D_fddimibPORTMACIndicated_tVal9TrueRVal9False :
		D_fddimibPORTMACIndicated_tVal9TrueRVal9True;
    	fddimibPORTEntryData.fddimibPORTCurrentPath = portHW->CurrentPath + 1;
    	fddimibPORTEntryData.fddimibPORTMACPlacement = GetMACPlacement(idb->fddi_stn_id, portPtr);
    	fddimibPORTEntryData.fddimibPORTAvailablePaths = portHW->AvailablePaths;
    	fddimibPORTEntryData.fddimibPORTPMDClass = portHW->PMDClass + 1;
    	fddimibPORTEntryData.fddimibPORTConnectionCapabilities = portHW->ConnectionCapabilities;
    	fddimibPORTEntryData.fddimibPORTBSFlag = portHW->BS_Flag ?
		D_fddimibPORTBSFlag_true : D_fddimibPORTBSFlag_false;
    	fddimibPORTEntryData.fddimibPORTLCTFailCts = portHW->LCTFail_Ct;
    	fddimibPORTEntryData.fddimibPORTLerEstimate = portHW->Ler_Estimate;
    	fddimibPORTEntryData.fddimibPORTLemRejectCts = portHW->Lem_Reject_Ct;
    	fddimibPORTEntryData.fddimibPORTLemCts = portHW->Lem_Ct;
    	fddimibPORTEntryData.fddimibPORTConnectState = (CSPPCCONNST) + 1;
    	fddimibPORTEntryData.fddimibPORTPCMState = (CSPPCSTATE) + 1;
    	fddimibPORTEntryData.fddimibPORTPCWithhold = (CSPPCWITHHOLD) + 1;
    	fddimibPORTEntryData.fddimibPORTLerFlag = portHW->LerFlag ?
		D_fddimibPORTLerFlag_true : D_fddimibPORTLerFlag_false;
    	fddimibPORTEntryData.fddimibPORTAction = D_fddimibPORTAction_other;
    }

    return (&fddimibPORTEntryData);
}



#ifdef SETS

int
k_fddimibPORTEntry_set(
    fddimibPORTEntry_t *data,
    ContextInfo    *contextInfo,
    int             function)
{
    PORTBaseAttrType *portPtr = NULL;
    MIBType *mibPtr;
    SMTMessage notifyMsg;
    long stnID, portIndex;
    uchar *reqPathData;
    PORTRequestedPathsType *reqPathMsg;

    if (data == NULL || snmpfddi_findIdb_exact(data->fddimibPORTSMTIndex) == NULL)
	return (GEN_ERROR);		/* safety */
    stnID = data->fddimibPORTSMTIndex - 1;
    mibPtr = MIBDATA(stnID, mib);
    if ((portIndex = snmpfddi_findPort_exact(mibPtr, data->fddimibPORTIndex)) < 0)
	return (0);		/* safety */
    portPtr = &mibPtr->portBase[portIndex].baseData;
    notifyMsg.source = MIB_MSG_ID;
    notifyMsg.type = MIB_EVENT_NOTIFY_CHANGE;
    notifyMsg.entity = portIndex;
    notifyMsg.localID = 0;
    notifyMsg.len1 = 0;
    notifyMsg.len2 = 0;
    notifyMsg.stnID = stnID;

#ifdef I_fddimibPORTConnectionPolicies
    if (VALID(I_fddimibPORTConnectionPolicies, data->valid)) {
	notifyMsg.data.b8 = portPtr->ConnectionPolicies
			  = (uchar)data->fddimibPORTConnectionPolicies;
	notifyMsg.destination = CSP_MSG_ID;
	notifyMsg.typeInfo = fddiPATHMaxT_Req;
	SendMIBMessage (&notifyMsg);
    }
#endif

#ifdef I_fddimibPORTRequestedPaths
    if (VALID(I_fddimibPORTRequestedPaths, data->valid)) {
	reqPathData = data->fddimibPORTRequestedPaths->octet_ptr;
	reqPathMsg = (PORTRequestedPathsType *)&notifyMsg.data.b32;
	reqPathMsg->reqPaths[RP_none]
		= portPtr->RequestedPaths.reqPaths[RP_none] = reqPathData[RP_none];
	reqPathMsg->reqPaths[RP_tree]
		= portPtr->RequestedPaths.reqPaths[RP_tree] = reqPathData[RP_tree];
	reqPathMsg->reqPaths[RP_peer]
		= portPtr->RequestedPaths.reqPaths[RP_peer] = reqPathData[RP_peer];
	notifyMsg.destination = CSP_MSG_ID;
	notifyMsg.typeInfo = fddiPORTRequestedPaths;
	SendMIBMessage (&notifyMsg);
    }
#endif

#ifdef I_fddimibPORTLerCutoff
    if (VALID(I_fddimibPORTLerCutoff, data->valid)) {
	notifyMsg.data.b8 = portPtr->Ler_Cutoff
			  = (uchar) data->fddimibPORTLerCutoff;
	notifyMsg.destination = CSP_MSG_ID;
	notifyMsg.typeInfo = fddiPORTLer_Cutoff;
	SendMIBMessage (&notifyMsg);
    }
#endif

#ifdef I_fddimibPORTLerAlarm
    if (VALID(I_fddimibPORTLerAlarm, data->valid)) {
	notifyMsg.data.b8 = (uchar)portPtr->Ler_Alarm
			  = (uchar)data->fddimibPORTLerAlarm;
	notifyMsg.destination = CSP_MSG_ID;
	notifyMsg.typeInfo = fddiPORTLer_Alarm;
	SendMIBMessage (&notifyMsg);
    }
#endif

#ifdef I_fddimibPORTAction
    if (VALID(I_fddimibPORTAction, data->valid)) {
    	switch (data->fddimibPORTAction) {
	case D_fddimibPORTAction_maintPORT:
	    notifyMsg.typeInfo = PORTAction_maintport;
	    /* Put maintenance line state in data */
	    notifyMsg.data.b8 = portPtr->Maint_LS;
	    break;
	case D_fddimibPORTAction_enablePORT:
	    notifyMsg.typeInfo = PORTAction_enableport;
	    break;
	case D_fddimibPORTAction_disablePORT:
	    notifyMsg.typeInfo = PORTAction_disableport;
	    break;
	case D_fddimibPORTAction_startPORT:
	    notifyMsg.typeInfo = PORTAction_startport;
	    break;
	case D_fddimibPORTAction_stopPORT:
	    notifyMsg.typeInfo = PORTAction_stopport;
	    break;
	}
        notifyMsg.source = MIB_MSG_ID;
        notifyMsg.type = CSP_ACTION_FDDI_PORT;
	notifyMsg.destination = CSP_MSG_ID;
	notifyMsg.typeInfo = fddiPORTAction;
	SendMIBMessage (&notifyMsg);
    }
#endif
    return (NO_ERROR);
}

#endif				       /* SETS */


/*
 * newfddimib subsystem header
 */

#define MAJVERSION_newfddimib 1
#define MINVERSION_newfddimib 0
#define EDITVERSION_newfddimib 0

SUBSYS_HEADER(fddismt73mib,
              MAJVERSION_newfddimib,
              MINVERSION_newfddimib,
              EDITVERSION_newfddimib,
              init_newfddimib,
              SUBSYS_CLASS_MANAGEMENT,
              NULL,
              NULL);
