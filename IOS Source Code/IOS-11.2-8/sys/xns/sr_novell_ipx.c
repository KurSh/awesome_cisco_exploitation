/* $Id: sr_novell_ipx.c,v 3.6.4.5 1996/07/01 18:47:08 hampton Exp $
 * $Source: /release/112/cvs/Xsys/xns/sr_novell_ipx.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * April 1994, Yunsen Wang (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1995-1997 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_novell_ipx.c,v $
 * Revision 3.6.4.5  1996/07/01  18:47:08  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.6.4.4  1996/05/03  02:20:50  sluong
 * Branch: California_branch
 * IPX ACL Violation Logging, Plaining English Filters, Display SAP by
 * name,
 * NLSP MIBS, Scaleable RIP/SAP, Modularity, and SAP query by name.
 *
 * Revision 3.6.4.3  1996/04/27  06:48:05  syiu
 * Branch: California_branch
 * Commit Dial1_branch
 *
 * Revision 3.6.4.2  1996/04/19  17:55:14  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.3.10.3  1996/04/26  00:13:14  syiu
 * Branch: Dial1_branch
 * Dial1_branch to IosSec_postmerge_960419
 *
 * Revision 3.3.10.2  1996/04/17  00:10:42  syiu
 * Branch: Dial1_branch
 * Sync Dial1_branch to V111_1_3
 *
 * Revision 3.3.10.1  1996/02/23  21:33:43  lbustini
 * Branch: Dial1_branch
 * Move dialer fields out of the idb.
 *
 * Revision 3.6.4.1  1996/03/18  22:54:13  gstovall
 * Branch: California_branch
 * Elvis has left the building.  He headed out to California, and took the
 * port ready changes with him.
 *
 * Revision 3.4.2.3  1996/03/16  08:01:08  gstovall
 * Branch: DeadKingOnAThrone_branch
 * Make the king aware of V111_1_3.
 *
 * Revision 3.4.2.2  1996/03/13  02:15:19  dstine
 * Branch: DeadKingOnAThrone_branch
 *         - commit IDB cleanups
 *
 * Revision 3.4.2.1  1996/03/07  11:22:47  mdb
 * Branch: DeadKingOnAThrone_branch
 * cisco and ANSI/POSIX libraries.
 *
 * Revision 3.6  1996/03/07  23:13:28  mschaef
 * CSCdi49527:  %SYS-3-CPUHOG from NLSP Update or IPX EIGRP process
 *
 * Revision 3.5  1996/02/29  21:45:00  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.4  1996/01/18  15:58:43  anke
 * CSCdi46969:  Change empty req and/or seq strings in SUBSYS_HEADERs to
 *              NULL
 *              Five bytes saved is five bytes earned
 *
 * Revision 3.3  1995/12/14  08:30:22  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.2  1995/11/17  19:24:52  gstovall
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  14:00:17  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.4  1995/09/20  21:35:10  john
 * CSCdi40566:  Lexigraphical error in IPX MIB
 *
 * Revision 2.3  1995/07/17  07:36:07  bchan
 * CSCdi34760:  Ifindex usage incorrect
 *
 * Revision 2.2  1995/06/28  09:34:03  smackie
 * Repair widespread subsystem header braindamage. (CSCdi23568)
 *
 *   o Fix subsystem entry points to be foo(subsystype *) not foo(void)
 *   o Repair nonsensical and redundant subsystem sequences
 *   o Use NULL where no property is required
 *
 * Revision 2.1  1995/06/07  23:30:03  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include "subsys.h"
#include "interface.h"
#include "interface_private.h"
#include "../if/network.h"
#include "../snmp/snmp_api.h"
#include "sr_novell_ipx.h"
#include "sr_novell_ipx-mib.h"
#include "novell.h"
#include "xns.h"
#include "../os/hostname.h"
#include "../h/registry.h"
#include "../h/sys_registry.regh"
#include "../wan/dialer_registry.h"
#include <ciscolib.h>

#define NETBYTES 4
#define SOCKETBYTES 2
#define TYPEBYTES 2

static ulong get_circCount(void);
static ulong snmp_ipxCircType(nidbtype *nidb);
static ulong snmp_ipxCircStaticStatus(nidbtype *nidb);
static void snmp_ipxCircMedia(nidbtype *nidb, OctetString *mediaType);
static ulong snmp_getDestProc(novndbtype *p);
static ulong snmp_getServProc(novell_sapentrytype *p);

extern ulong nov_defnet;

static ipxBasicSysEntry_t ipxBasicSysEntryData;
static ipxAdvSysEntry_t ipxAdvSysEntryData;
static ipxCircEntry_t ipxCircEntryData;
static ipxDestEntry_t ipxDestEntryData;
static ipxStaticRouteEntry_t ipxStaticRouteEntryData;
static ipxServEntry_t ipxServEntryData;
static ipxDestServEntry_t ipxDestServEntryData;
static ipxStaticServEntry_t ipxStaticServEntryData;


void
init_novell_ipx (subsystype *subsys)
{
    memset(&ipxBasicSysEntryData, 0, sizeof(ipxBasicSysEntryData));
    memset(&ipxAdvSysEntryData, 0, sizeof(ipxAdvSysEntryData));
    memset(&ipxCircEntryData, 0, sizeof(ipxCircEntryData));
    memset(&ipxDestEntryData, 0, sizeof(ipxDestEntryData));
    memset(&ipxStaticRouteEntryData, 0, sizeof(ipxStaticRouteEntryData));
    memset(&ipxServEntryData, 0, sizeof(ipxServEntryData));
    memset(&ipxDestServEntryData, 0, sizeof(ipxDestServEntryData));
    memset(&ipxStaticServEntryData, 0, sizeof(ipxStaticServEntryData));
    load_mib(novell_ipx_OidList, novell_ipx_OidListNum);
    load_oid(novell_ipx_oid_table);
}








/*---------------------------------------------------------------------
 * Retrieve data from the ipxBasicSysEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ipxBasicSysEntry_get (
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ipxBasicSysEntry_t *data = NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            ipxBasicSysInstance;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &ipxBasicSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ipxBasicSysEntry_get(serialNum, contextInfo, arg, searchType, ipxBasicSysInstance)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->ipxBasicSysInstance;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ipxBasicSysInstance
      case I_ipxBasicSysInstance:
	dp = &data->ipxBasicSysInstance;
	break;
#endif				       /* I_ipxBasicSysInstance */

#ifdef I_ipxBasicSysExistState
      case I_ipxBasicSysExistState:
	dp = &data->ipxBasicSysExistState;
	break;
#endif				       /* I_ipxBasicSysExistState */

#ifdef I_ipxBasicSysNetNumber
      case I_ipxBasicSysNetNumber:
	dp = MakeOctetString(data->ipxBasicSysNetNumber->octet_ptr, data->ipxBasicSysNetNumber->length);
	break;
#endif				       /* I_ipxBasicSysNetNumber */

#ifdef I_ipxBasicSysNode
      case I_ipxBasicSysNode:
	dp = MakeOctetString(data->ipxBasicSysNode->octet_ptr, data->ipxBasicSysNode->length);
	break;
#endif				       /* I_ipxBasicSysNode */

#ifdef I_ipxBasicSysName
      case I_ipxBasicSysName:
	dp = MakeOctetString(data->ipxBasicSysName->octet_ptr, data->ipxBasicSysName->length);
	break;
#endif				       /* I_ipxBasicSysName */

#ifdef I_ipxBasicSysInReceives
      case I_ipxBasicSysInReceives:
	dp = &data->ipxBasicSysInReceives;
	break;
#endif				       /* I_ipxBasicSysInReceives */

#ifdef I_ipxBasicSysInHdrErrors
      case I_ipxBasicSysInHdrErrors:
	dp = &data->ipxBasicSysInHdrErrors;
	break;
#endif				       /* I_ipxBasicSysInHdrErrors */

#ifdef I_ipxBasicSysInUnknownSockets
      case I_ipxBasicSysInUnknownSockets:
	dp = &data->ipxBasicSysInUnknownSockets;
	break;
#endif				       /* I_ipxBasicSysInUnknownSockets */

#ifdef I_ipxBasicSysInDiscards
      case I_ipxBasicSysInDiscards:
	dp = &data->ipxBasicSysInDiscards;
	break;
#endif				       /* I_ipxBasicSysInDiscards */

#ifdef I_ipxBasicSysInBadChecksums
      case I_ipxBasicSysInBadChecksums:
	dp = &data->ipxBasicSysInBadChecksums;
	break;
#endif				       /* I_ipxBasicSysInBadChecksums */

#ifdef I_ipxBasicSysInDelivers
      case I_ipxBasicSysInDelivers:
	dp = &data->ipxBasicSysInDelivers;
	break;
#endif				       /* I_ipxBasicSysInDelivers */

#ifdef I_ipxBasicSysNoRoutes
      case I_ipxBasicSysNoRoutes:
	dp = &data->ipxBasicSysNoRoutes;
	break;
#endif				       /* I_ipxBasicSysNoRoutes */

#ifdef I_ipxBasicSysOutRequests
      case I_ipxBasicSysOutRequests:
	dp = &data->ipxBasicSysOutRequests;
	break;
#endif				       /* I_ipxBasicSysOutRequests */

#ifdef I_ipxBasicSysOutMalformedRequests
      case I_ipxBasicSysOutMalformedRequests:
	dp = &data->ipxBasicSysOutMalformedRequests;
	break;
#endif				       /* I_ipxBasicSysOutMalformedRequests */

#ifdef I_ipxBasicSysOutDiscards
      case I_ipxBasicSysOutDiscards:
	dp = &data->ipxBasicSysOutDiscards;
	break;
#endif				       /* I_ipxBasicSysOutDiscards */

#ifdef I_ipxBasicSysOutPackets
      case I_ipxBasicSysOutPackets:
	dp = &data->ipxBasicSysOutPackets;
	break;
#endif				       /* I_ipxBasicSysOutPackets */

#ifdef I_ipxBasicSysConfigSockets
      case I_ipxBasicSysConfigSockets:
	dp = &data->ipxBasicSysConfigSockets;
	break;
#endif				       /* I_ipxBasicSysConfigSockets */

#ifdef I_ipxBasicSysOpenSocketFails
      case I_ipxBasicSysOpenSocketFails:
	dp = &data->ipxBasicSysOpenSocketFails;
	break;
#endif				       /* I_ipxBasicSysOpenSocketFails */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the ipxBasicSysEntry data object.
 *---------------------------------------------------------------------*/
void
ipxBasicSysEntry_free(ipxBasicSysEntry_t *data)
{
    if (data != NULL) {
	if (data->ipxBasicSysNetNumber != NULL) {
	    FreeOctetString(data->ipxBasicSysNetNumber);
	}
	if (data->ipxBasicSysNode != NULL) {
	    FreeOctetString(data->ipxBasicSysNode);
	}
	if (data->ipxBasicSysName != NULL) {
	    FreeOctetString(data->ipxBasicSysName);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after ipxBasicSysEntry set/undo
 *---------------------------------------------------------------------*/
static int
ipxBasicSysEntry_cleanup(doList_t *trash)
{
    ipxBasicSysEntry_free(trash->data);
#ifdef SR_SNMPv2
    ipxBasicSysEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
ipxBasicSysEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int             found;
    int             carry = 0;
    ipxBasicSysEntry_t *ipxBasicSysEntry;
    long            ipxBasicSysInstance;
    ulong           net;
    
    /*
     * Validate the object instance
     * 
     */
    if (instLength != 1) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &ipxBasicSysInstance, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    ipxBasicSysEntry = k_ipxBasicSysEntry_get(-1, contextInfo, object->nominator, EXACT, ipxBasicSysInstance);

#ifndef ipxBasicSysEntry_READ_CREATE

    if (ipxBasicSysEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* ipxBasicSysEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == ipxBasicSysEntry_set) &&
	    (((ipxBasicSysEntry_t *) (dp->data)) != NULL) &&
	    (((ipxBasicSysEntry_t *) (dp->data))->ipxBasicSysInstance == ipxBasicSysInstance)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(ipxBasicSysEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(ipxBasicSysEntry_t));

	dp->setMethod = ipxBasicSysEntry_set;
	dp->cleanupMethod = ipxBasicSysEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_ipxBasicSysInstance, ((ipxBasicSysEntry_t *) (dp->data))->valid);
	((ipxBasicSysEntry_t *) (dp->data))->ipxBasicSysInstance = ipxBasicSysInstance;

#ifdef ipxBasicSysEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (ipxBasicSysEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, ipxBasicSysEntry, sizeof(ipxBasicSysEntry_t));

	    SET_ALL_VALID(((ipxBasicSysEntry_t *) (dp->data))->valid);

	    ((ipxBasicSysEntry_t *) (dp->data))->ipxBasicSysNetNumber =
		CloneOctetString(ipxBasicSysEntry->ipxBasicSysNetNumber);

	    ((ipxBasicSysEntry_t *) (dp->data))->ipxBasicSysNode =
		CloneOctetString(ipxBasicSysEntry->ipxBasicSysNode);

	    ((ipxBasicSysEntry_t *) (dp->data))->ipxBasicSysName =
		CloneOctetString(ipxBasicSysEntry->ipxBasicSysName);

	} else {

	  /* Fill in default values here */
	   /* no reasnable defaults, don't set any */

	}
#endif				       /* ipxBasicSysEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_ipxBasicSysInstance
      case I_ipxBasicSysInstance:

        if (value->sl_value != 1)
	  return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxBasicSysInstance, ((ipxBasicSysEntry_t *) (dp->data))->valid);

	((ipxBasicSysEntry_t *) (dp->data))->ipxBasicSysInstance = value->sl_value;
	break;
#endif				       /* I_ipxBasicSysInstance */

#ifdef I_ipxBasicSysExistState
      case I_ipxBasicSysExistState:

	if ((value->sl_value != D_ipxBasicSysExistState_on) &&
	    (value->sl_value != D_ipxBasicSysExistState_off))
	  return(WRONG_VALUE_ERROR);
	SET_VALID(I_ipxBasicSysExistState, ((ipxBasicSysEntry_t *) (dp->data))->valid);

	((ipxBasicSysEntry_t *) (dp->data))->ipxBasicSysExistState = value->sl_value;
	break;
#endif				       /* I_ipxBasicSysExistState */

#ifdef I_ipxBasicSysNetNumber
      case I_ipxBasicSysNetNumber:

	SET_VALID(I_ipxBasicSysNetNumber, ((ipxBasicSysEntry_t *) (dp->data))->valid);

	if (((ipxBasicSysEntry_t *) (dp->data))->ipxBasicSysNetNumber != NULL) {
	    FreeOctetString(((ipxBasicSysEntry_t *) (dp->data))->ipxBasicSysNetNumber);
	}
	((ipxBasicSysEntry_t *) (dp->data))->ipxBasicSysNetNumber =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);
	net = OctetStringToUlong(((ipxBasicSysEntry_t *)
				  (dp->data))->ipxBasicSysNetNumber);
	if ((net < 0x1) || (net > 0xFFFFFFFD))
	  return (WRONG_VALUE_ERROR);
	break;
#endif				       /* I_ipxBasicSysNetNumber */

#ifdef I_ipxBasicSysNode
      case I_ipxBasicSysNode:

	if (value->os_value->length != 12)
	  return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxBasicSysNode, ((ipxBasicSysEntry_t *) (dp->data))->valid);

	if (((ipxBasicSysEntry_t *) (dp->data))->ipxBasicSysNode != NULL) {
	    FreeOctetString(((ipxBasicSysEntry_t *) (dp->data))->ipxBasicSysNode);
	}
	((ipxBasicSysEntry_t *) (dp->data))->ipxBasicSysNode =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_ipxBasicSysNode */

#ifdef I_ipxBasicSysName
      case I_ipxBasicSysName:
	if ((value->os_value->length == 0) ||
	    (value->os_value->length > NOVELL_SERVER_NAME_LEN))
	  return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxBasicSysName, ((ipxBasicSysEntry_t *) (dp->data))->valid);

	if (((ipxBasicSysEntry_t *) (dp->data))->ipxBasicSysName != NULL) {
	    FreeOctetString(((ipxBasicSysEntry_t *) (dp->data))->ipxBasicSysName);
	}
	((ipxBasicSysEntry_t *) (dp->data))->ipxBasicSysName =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_ipxBasicSysName */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in ipxBasicSysEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
ipxBasicSysEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_ipxBasicSysEntry_set((ipxBasicSysEntry_t *) (doCur->data),
				   contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the ipxAdvSysEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ipxAdvSysEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ipxAdvSysEntry_t *data = NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            ipxAdvSysInstance;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &ipxAdvSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ipxAdvSysEntry_get(serialNum, contextInfo, arg, searchType, ipxAdvSysInstance)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->ipxAdvSysInstance;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ipxAdvSysInstance
      case I_ipxAdvSysInstance:
	dp = &data->ipxAdvSysInstance;
	break;
#endif				       /* I_ipxAdvSysInstance */

#ifdef I_ipxAdvSysMaxPathSplits
      case I_ipxAdvSysMaxPathSplits:
	dp = &data->ipxAdvSysMaxPathSplits;
	break;
#endif				       /* I_ipxAdvSysMaxPathSplits */

#ifdef I_ipxAdvSysMaxHops
      case I_ipxAdvSysMaxHops:
	dp = &data->ipxAdvSysMaxHops;
	break;
#endif				       /* I_ipxAdvSysMaxHops */

#ifdef I_ipxAdvSysInTooManyHops
      case I_ipxAdvSysInTooManyHops:
	dp = &data->ipxAdvSysInTooManyHops;
	break;
#endif				       /* I_ipxAdvSysInTooManyHops */

#ifdef I_ipxAdvSysInFiltered
      case I_ipxAdvSysInFiltered:
	dp = &data->ipxAdvSysInFiltered;
	break;
#endif				       /* I_ipxAdvSysInFiltered */

#ifdef I_ipxAdvSysInCompressDiscards
      case I_ipxAdvSysInCompressDiscards:
	dp = &data->ipxAdvSysInCompressDiscards;
	break;
#endif				       /* I_ipxAdvSysInCompressDiscards */

#ifdef I_ipxAdvSysNETBIOSPackets
      case I_ipxAdvSysNETBIOSPackets:
	dp = &data->ipxAdvSysNETBIOSPackets;
	break;
#endif				       /* I_ipxAdvSysNETBIOSPackets */

#ifdef I_ipxAdvSysForwPackets
      case I_ipxAdvSysForwPackets:
	dp = &data->ipxAdvSysForwPackets;
	break;
#endif				       /* I_ipxAdvSysForwPackets */

#ifdef I_ipxAdvSysOutFiltered
      case I_ipxAdvSysOutFiltered:
	dp = &data->ipxAdvSysOutFiltered;
	break;
#endif				       /* I_ipxAdvSysOutFiltered */

#ifdef I_ipxAdvSysOutCompressDiscards
      case I_ipxAdvSysOutCompressDiscards:
	dp = &data->ipxAdvSysOutCompressDiscards;
	break;
#endif				       /* I_ipxAdvSysOutCompressDiscards */

#ifdef I_ipxAdvSysCircCount
      case I_ipxAdvSysCircCount:
	dp = &data->ipxAdvSysCircCount;
	break;
#endif				       /* I_ipxAdvSysCircCount */

#ifdef I_ipxAdvSysDestCount
      case I_ipxAdvSysDestCount:
	dp = &data->ipxAdvSysDestCount;
	break;
#endif				       /* I_ipxAdvSysDestCount */

#ifdef I_ipxAdvSysServCount
      case I_ipxAdvSysServCount:
	dp = &data->ipxAdvSysServCount;
	break;
#endif				       /* I_ipxAdvSysServCount */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the ipxAdvSysEntry data object.
 *---------------------------------------------------------------------*/
void
ipxAdvSysEntry_free(ipxAdvSysEntry_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after ipxAdvSysEntry set/undo
 *---------------------------------------------------------------------*/
static int
ipxAdvSysEntry_cleanup(doList_t       *trash)
{
    ipxAdvSysEntry_free(trash->data);
#ifdef SR_SNMPv2
    ipxAdvSysEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
ipxAdvSysEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int             found;
    int             carry = 0;
    ipxAdvSysEntry_t *ipxAdvSysEntry;
    long            ipxAdvSysInstance;

    /*
     * Validate the object instance
     * 
     */
    if (instLength != 1) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &ipxAdvSysInstance, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    ipxAdvSysEntry = k_ipxAdvSysEntry_get(-1, contextInfo, object->nominator, EXACT, ipxAdvSysInstance);

#ifndef ipxAdvSysEntry_READ_CREATE

    if (ipxAdvSysEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* ipxAdvSysEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == ipxAdvSysEntry_set) &&
	    (((ipxAdvSysEntry_t *) (dp->data)) != NULL) &&
	    (((ipxAdvSysEntry_t *) (dp->data))->ipxAdvSysInstance == ipxAdvSysInstance)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(ipxAdvSysEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(ipxAdvSysEntry_t));

	dp->setMethod = ipxAdvSysEntry_set;
	dp->cleanupMethod = ipxAdvSysEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_ipxAdvSysInstance, ((ipxAdvSysEntry_t *) (dp->data))->valid);
	((ipxAdvSysEntry_t *) (dp->data))->ipxAdvSysInstance = ipxAdvSysInstance;

#ifdef ipxAdvSysEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (ipxAdvSysEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, ipxAdvSysEntry, sizeof(ipxAdvSysEntry_t));

	    SET_ALL_VALID(((ipxAdvSysEntry_t *) (dp->data))->valid);

	} else {


	    /* Fill in default values here */

	}
#endif				       /* ipxAdvSysEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_ipxAdvSysInstance
      case I_ipxAdvSysInstance:

      if (value->sl_value != 1)
	return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxAdvSysInstance, ((ipxAdvSysEntry_t *) (dp->data))->valid);

	((ipxAdvSysEntry_t *) (dp->data))->ipxAdvSysInstance = value->sl_value;
	break;
#endif				       /* I_ipxAdvSysInstance */

#ifdef I_ipxAdvSysMaxPathSplits
      case I_ipxAdvSysMaxPathSplits:

      if ((value->sl_value == 0) ||
	  ((value->sl_value > RIP_MAXPATHS) && !novell_nlsp_running) ||
	  ((value->sl_value > NOVELL_NLSP_MAXPATHS) && novell_nlsp_running))
	return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxAdvSysMaxPathSplits, ((ipxAdvSysEntry_t *) (dp->data))->valid);

	((ipxAdvSysEntry_t *) (dp->data))->ipxAdvSysMaxPathSplits = value->sl_value;
	break;
#endif				       /* I_ipxAdvSysMaxPathSplits */

#ifdef I_ipxAdvSysMaxHops
      case I_ipxAdvSysMaxHops:

      if ((value->sl_value < 1 ) || (value->sl_value > NOVELL_MAX_HOPS_ALLOWED -1))
	return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxAdvSysMaxHops, ((ipxAdvSysEntry_t *) (dp->data))->valid);

	((ipxAdvSysEntry_t *) (dp->data))->ipxAdvSysMaxHops = value->sl_value;
	break;
#endif				       /* I_ipxAdvSysMaxHops */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in ipxAdvSysEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
ipxAdvSysEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_ipxAdvSysEntry_set((ipxAdvSysEntry_t *) (doCur->data),
				 contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the ipxCircEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ipxCircEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ipxCircEntry_t *data = NULL;
    unsigned long   buffer[2];
    OID             inst;
    int             carry;
    long            ipxCircSysInstance;
    long            ipxCircIndex;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 2
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 2) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 1 + object->oid.length, &ipxCircIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &ipxCircSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ipxCircEntry_get(serialNum, contextInfo, arg, searchType, ipxCircSysInstance, ipxCircIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 2;
	inst.oid_ptr[0] = data->ipxCircSysInstance;
	inst.oid_ptr[1] = data->ipxCircIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ipxCircSysInstance
      case I_ipxCircSysInstance:
	dp = &data->ipxCircSysInstance;
	break;
#endif				       /* I_ipxCircSysInstance */

#ifdef I_ipxCircIndex
      case I_ipxCircIndex:
	dp = &data->ipxCircIndex;
	break;
#endif				       /* I_ipxCircIndex */

#ifdef I_ipxCircExistState
      case I_ipxCircExistState:
	dp = &data->ipxCircExistState;
	break;
#endif				       /* I_ipxCircExistState */

#ifdef I_ipxCircOperState
      case I_ipxCircOperState:
	dp = &data->ipxCircOperState;
	break;
#endif				       /* I_ipxCircOperState */

#ifdef I_ipxCircIfIndex
      case I_ipxCircIfIndex:
	dp = &data->ipxCircIfIndex;
	break;
#endif				       /* I_ipxCircIfIndex */

#ifdef I_ipxCircName
      case I_ipxCircName:
	dp = MakeOctetString(data->ipxCircName->octet_ptr, data->ipxCircName->length);
	break;
#endif				       /* I_ipxCircName */

#ifdef I_ipxCircType
      case I_ipxCircType:
	dp = &data->ipxCircType;
	break;
#endif				       /* I_ipxCircType */

#ifdef I_ipxCircDialName
      case I_ipxCircDialName:
	dp = MakeOctetString(data->ipxCircDialName->octet_ptr, data->ipxCircDialName->length);
	break;
#endif				       /* I_ipxCircDialName */

#ifdef I_ipxCircLocalMaxPacketSize
      case I_ipxCircLocalMaxPacketSize:
	dp = &data->ipxCircLocalMaxPacketSize;
	break;
#endif				       /* I_ipxCircLocalMaxPacketSize */

#ifdef I_ipxCircCompressState
      case I_ipxCircCompressState:
	dp = &data->ipxCircCompressState;
	break;
#endif				       /* I_ipxCircCompressState */

#ifdef I_ipxCircCompressSlots
      case I_ipxCircCompressSlots:
	dp = &data->ipxCircCompressSlots;
	break;
#endif				       /* I_ipxCircCompressSlots */

#ifdef I_ipxCircStaticStatus
      case I_ipxCircStaticStatus:
	dp = &data->ipxCircStaticStatus;
	break;
#endif				       /* I_ipxCircStaticStatus */

#ifdef I_ipxCircCompressedSent
      case I_ipxCircCompressedSent:
	dp = &data->ipxCircCompressedSent;
	break;
#endif				       /* I_ipxCircCompressedSent */

#ifdef I_ipxCircCompressedInitSent
      case I_ipxCircCompressedInitSent:
	dp = &data->ipxCircCompressedInitSent;
	break;
#endif				       /* I_ipxCircCompressedInitSent */

#ifdef I_ipxCircCompressedRejectsSent
      case I_ipxCircCompressedRejectsSent:
	dp = &data->ipxCircCompressedRejectsSent;
	break;
#endif				       /* I_ipxCircCompressedRejectsSent */

#ifdef I_ipxCircUncompressedSent
      case I_ipxCircUncompressedSent:
	dp = &data->ipxCircUncompressedSent;
	break;
#endif				       /* I_ipxCircUncompressedSent */

#ifdef I_ipxCircCompressedReceived
      case I_ipxCircCompressedReceived:
	dp = &data->ipxCircCompressedReceived;
	break;
#endif				       /* I_ipxCircCompressedReceived */

#ifdef I_ipxCircCompressedInitReceived
      case I_ipxCircCompressedInitReceived:
	dp = &data->ipxCircCompressedInitReceived;
	break;
#endif				       /* I_ipxCircCompressedInitReceived */

#ifdef I_ipxCircCompressedRejectsReceived
      case I_ipxCircCompressedRejectsReceived:
	dp = &data->ipxCircCompressedRejectsReceived;
	break;
#endif				       /* I_ipxCircCompressedRejectsReceived */

#ifdef I_ipxCircUncompressedReceived
      case I_ipxCircUncompressedReceived:
	dp = &data->ipxCircUncompressedReceived;
	break;
#endif				       /* I_ipxCircUncompressedReceived */

#ifdef I_ipxCircMediaType
      case I_ipxCircMediaType:
	dp = MakeOctetString(data->ipxCircMediaType->octet_ptr, data->ipxCircMediaType->length);
	break;
#endif				       /* I_ipxCircMediaType */

#ifdef I_ipxCircNetNumber
      case I_ipxCircNetNumber:
	dp = MakeOctetString(data->ipxCircNetNumber->octet_ptr, data->ipxCircNetNumber->length);
	break;
#endif				       /* I_ipxCircNetNumber */

#ifdef I_ipxCircStateChanges
      case I_ipxCircStateChanges:
	dp = &data->ipxCircStateChanges;
	break;
#endif				       /* I_ipxCircStateChanges */

#ifdef I_ipxCircInitFails
      case I_ipxCircInitFails:
	dp = &data->ipxCircInitFails;
	break;
#endif				       /* I_ipxCircInitFails */

#ifdef I_ipxCircDelay
      case I_ipxCircDelay:
	dp = &data->ipxCircDelay;
	break;
#endif				       /* I_ipxCircDelay */

#ifdef I_ipxCircThroughput
      case I_ipxCircThroughput:
	dp = &data->ipxCircThroughput;
	break;
#endif				       /* I_ipxCircThroughput */

#ifdef I_ipxCircNeighRouterName
      case I_ipxCircNeighRouterName:
	dp = MakeOctetString(data->ipxCircNeighRouterName->octet_ptr, data->ipxCircNeighRouterName->length);
	break;
#endif				       /* I_ipxCircNeighRouterName */

#ifdef I_ipxCircNeighInternalNetNum
      case I_ipxCircNeighInternalNetNum:
	dp = MakeOctetString(data->ipxCircNeighInternalNetNum->octet_ptr, data->ipxCircNeighInternalNetNum->length);
	break;
#endif				       /* I_ipxCircNeighInternalNetNum */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the ipxCircEntry data object.
 *---------------------------------------------------------------------*/
void
ipxCircEntry_free(ipxCircEntry_t *data)
{
    if (data != NULL) {
	if (data->ipxCircName != NULL) {
	    FreeOctetString(data->ipxCircName);
	}
	if (data->ipxCircDialName != NULL) {
	    FreeOctetString(data->ipxCircDialName);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after ipxCircEntry set/undo
 *---------------------------------------------------------------------*/
static int
ipxCircEntry_cleanup(doList_t       *trash)
{
    ipxCircEntry_free(trash->data);
#ifdef SR_SNMPv2
    ipxCircEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
ipxCircEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int             found;
    int             carry = 0;
    ipxCircEntry_t *ipxCircEntry;
    long            ipxCircSysInstance;
    long            ipxCircIndex;


    /*
     * Validate the object instance
     * 
     */
    if (instLength != 2) {
	return NO_CREATION_ERROR;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &ipxCircSysInstance, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, 1 + object->oid.length, &ipxCircIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    ipxCircEntry = k_ipxCircEntry_get(-1, contextInfo, object->nominator, EXACT, ipxCircSysInstance, ipxCircIndex);

#ifndef ipxCircEntry_READ_CREATE

    if (ipxCircEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* ipxCircEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == ipxCircEntry_set) &&
	    (((ipxCircEntry_t *) (dp->data)) != NULL) &&
	    (((ipxCircEntry_t *) (dp->data))->ipxCircSysInstance == ipxCircSysInstance) &&
	  (((ipxCircEntry_t *) (dp->data))->ipxCircIndex == ipxCircIndex)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(ipxCircEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(ipxCircEntry_t));

	dp->setMethod = ipxCircEntry_set;
	dp->cleanupMethod = ipxCircEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_ipxCircSysInstance, ((ipxCircEntry_t *) (dp->data))->valid);
	((ipxCircEntry_t *) (dp->data))->ipxCircSysInstance = ipxCircSysInstance;

	SET_VALID(I_ipxCircIndex, ((ipxCircEntry_t *) (dp->data))->valid);
	((ipxCircEntry_t *) (dp->data))->ipxCircIndex = ipxCircIndex;

#ifdef ipxCircEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (ipxCircEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, ipxCircEntry, sizeof(ipxCircEntry_t));

	    SET_ALL_VALID(((ipxCircEntry_t *) (dp->data))->valid);

	    ((ipxCircEntry_t *) (dp->data))->ipxCircName =
		CloneOctetString(ipxCircEntry->ipxCircName);

	    ((ipxCircEntry_t *) (dp->data))->ipxCircDialName =
		CloneOctetString(ipxCircEntry->ipxCircDialName);

	} else {

	  /* Fill in default values here */
	  /* nothing here has equivalent default values so don't provide any */
	  /* and much of this group is not writable on a cisco */
	}
#endif				       /* ipxCircEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_ipxCircSysInstance
      case I_ipxCircSysInstance:

      if (value->sl_value != 1)
	return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxCircSysInstance, ((ipxCircEntry_t *) (dp->data))->valid);

	((ipxCircEntry_t *) (dp->data))->ipxCircSysInstance = value->sl_value;
	break;
#endif				       /* I_ipxCircSysInstance */

#ifdef I_ipxCircIndex
      case I_ipxCircIndex:

      if (value->sl_value < 1)  /* What is our max interface limit? */
	return (WRONG_VALUE_ERROR);	
	SET_VALID(I_ipxCircIndex, ((ipxCircEntry_t *) (dp->data))->valid);

	((ipxCircEntry_t *) (dp->data))->ipxCircIndex = value->sl_value;
	break;
#endif				       /* I_ipxCircIndex */

#ifdef I_ipxCircExistState
      case I_ipxCircExistState:
      if ((value->sl_value != D_ipxCircExistState_off) &&
	  (value->sl_value != D_ipxCircExistState_on))
	return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxCircExistState, ((ipxCircEntry_t *) (dp->data))->valid);

	((ipxCircEntry_t *) (dp->data))->ipxCircExistState = value->sl_value;
	break;
#endif				       /* I_ipxCircExistState */

#ifdef I_ipxCircOperState
      case I_ipxCircOperState:
      /* Setting an interface to sleeping isn't supported */
      if ((value->sl_value != D_ipxCircOperState_up) &&
	  (value->sl_value != D_ipxCircOperState_down))
	return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxCircOperState, ((ipxCircEntry_t *) (dp->data))->valid);

	((ipxCircEntry_t *) (dp->data))->ipxCircOperState = value->sl_value;
	break;
#endif				       /* I_ipxCircOperState */

#ifdef I_ipxCircIfIndex
      case I_ipxCircIfIndex:

      if (value->sl_value < 1)  /* What is our max interface limit? */
        return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxCircIfIndex, ((ipxCircEntry_t *) (dp->data))->valid);

	((ipxCircEntry_t *) (dp->data))->ipxCircIfIndex = value->sl_value;
	break;
#endif				       /* I_ipxCircIfIndex */

#ifdef I_ipxCircName
      case I_ipxCircName:
	return (NOT_WRITABLE_ERROR);

	SET_VALID(I_ipxCircName, ((ipxCircEntry_t *) (dp->data))->valid);

	if (((ipxCircEntry_t *) (dp->data))->ipxCircName != NULL) {
	    FreeOctetString(((ipxCircEntry_t *) (dp->data))->ipxCircName);
	}
	((ipxCircEntry_t *) (dp->data))->ipxCircName =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_ipxCircName */

#ifdef I_ipxCircType
      case I_ipxCircType:
	return (NOT_WRITABLE_ERROR);

	SET_VALID(I_ipxCircType, ((ipxCircEntry_t *) (dp->data))->valid);

	((ipxCircEntry_t *) (dp->data))->ipxCircType = value->sl_value;
	break;
#endif				       /* I_ipxCircType */

#ifdef I_ipxCircDialName
      case I_ipxCircDialName:
	return (NOT_WRITABLE_ERROR);

	SET_VALID(I_ipxCircDialName, ((ipxCircEntry_t *) (dp->data))->valid);

	if (((ipxCircEntry_t *) (dp->data))->ipxCircDialName != NULL) {
	    FreeOctetString(((ipxCircEntry_t *) (dp->data))->ipxCircDialName);
	}
	((ipxCircEntry_t *) (dp->data))->ipxCircDialName =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_ipxCircDialName */

#ifdef I_ipxCircLocalMaxPacketSize
      case I_ipxCircLocalMaxPacketSize:
	return (NOT_WRITABLE_ERROR);

	SET_VALID(I_ipxCircLocalMaxPacketSize, ((ipxCircEntry_t *) (dp->data))->valid);

	((ipxCircEntry_t *) (dp->data))->ipxCircLocalMaxPacketSize = value->sl_value;
	break;
#endif				       /* I_ipxCircLocalMaxPacketSize */

#ifdef I_ipxCircCompressState
      case I_ipxCircCompressState:
	return (NOT_WRITABLE_ERROR);

	SET_VALID(I_ipxCircCompressState, ((ipxCircEntry_t *) (dp->data))->valid);

	((ipxCircEntry_t *) (dp->data))->ipxCircCompressState = value->sl_value;
	break;
#endif				       /* I_ipxCircCompressState */

#ifdef I_ipxCircCompressSlots
      case I_ipxCircCompressSlots:
	return (NOT_WRITABLE_ERROR);

	SET_VALID(I_ipxCircCompressSlots, ((ipxCircEntry_t *) (dp->data))->valid);

	((ipxCircEntry_t *) (dp->data))->ipxCircCompressSlots = value->sl_value;
	break;
#endif				       /* I_ipxCircCompressSlots */

#ifdef I_ipxCircStaticStatus
      case I_ipxCircStaticStatus:
	return (NOT_WRITABLE_ERROR);

	SET_VALID(I_ipxCircStaticStatus, ((ipxCircEntry_t *) (dp->data))->valid);

	((ipxCircEntry_t *) (dp->data))->ipxCircStaticStatus = value->sl_value;
	break;
#endif				       /* I_ipxCircStaticStatus */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in ipxCircEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
ipxCircEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_ipxCircEntry_set((ipxCircEntry_t *) (doCur->data),
			       contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the ipxDestEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ipxDestEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ipxDestEntry_t *data = NULL;
    unsigned long   buffer[5];
    OID             inst;
    int             carry;
    int             i;
    long            ipxDestSysInstance;
    int             ipxDestSysInstance_offset;
    OctetString    *ipxDestNetNum;
    int             ipxDestNetNum_offset;
    int             index;
    int             final_index;

    ipxDestSysInstance_offset = object->oid.length;
    ipxDestNetNum_offset = ipxDestSysInstance_offset + 1;
    final_index = ipxDestNetNum_offset + 4;

    if (searchType == EXACT) {
	if (instLength != 5) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToFixedOctetString(incoming, ipxDestNetNum_offset, &ipxDestNetNum, searchType, &carry, 4)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, ipxDestSysInstance_offset, &ipxDestSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ipxDestEntry_get(serialNum, contextInfo, arg, searchType, ipxDestSysInstance, ipxDestNetNum)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	inst.oid_ptr[index++] = (unsigned long) data->ipxDestSysInstance;
	for (i = 0; i < data->ipxDestNetNum->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->ipxDestNetNum->octet_ptr[i];
	}

	inst.length = index;
    }

    if (ipxDestNetNum != NULL) {
	FreeOctetString(ipxDestNetNum);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ipxDestSysInstance
      case I_ipxDestSysInstance:
	dp = &data->ipxDestSysInstance;
	break;
#endif				       /* I_ipxDestSysInstance */

#ifdef I_ipxDestNetNum
      case I_ipxDestNetNum:
	dp = MakeOctetString(data->ipxDestNetNum->octet_ptr, data->ipxDestNetNum->length);
	break;
#endif				       /* I_ipxDestNetNum */

#ifdef I_ipxDestProtocol
      case I_ipxDestProtocol:
	dp = &data->ipxDestProtocol;
	break;
#endif				       /* I_ipxDestProtocol */

#ifdef I_ipxDestTicks
      case I_ipxDestTicks:
	dp = &data->ipxDestTicks;
	break;
#endif				       /* I_ipxDestTicks */

#ifdef I_ipxDestHopCount
      case I_ipxDestHopCount:
	dp = &data->ipxDestHopCount;
	break;
#endif				       /* I_ipxDestHopCount */

#ifdef I_ipxDestNextHopCircIndex
      case I_ipxDestNextHopCircIndex:
	dp = &data->ipxDestNextHopCircIndex;
	break;
#endif				       /* I_ipxDestNextHopCircIndex */

#ifdef I_ipxDestNextHopNICAddress
      case I_ipxDestNextHopNICAddress:
	dp = MakeOctetString(data->ipxDestNextHopNICAddress->octet_ptr, data->ipxDestNextHopNICAddress->length);
	break;
#endif				       /* I_ipxDestNextHopNICAddress */

#ifdef I_ipxDestNextHopNetNum
      case I_ipxDestNextHopNetNum:
	dp = MakeOctetString(data->ipxDestNextHopNetNum->octet_ptr, data->ipxDestNextHopNetNum->length);
	break;
#endif				       /* I_ipxDestNextHopNetNum */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the ipxStaticRouteEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ipxStaticRouteEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ipxStaticRouteEntry_t *data = NULL;
    unsigned long   buffer[6];
    OID             inst;
    int             carry;
    int             i;
    long            ipxStaticRouteSysInstance;
    int             ipxStaticRouteSysInstance_offset;
    long            ipxStaticRouteCircIndex;
    int             ipxStaticRouteCircIndex_offset;
    OctetString    *ipxStaticRouteNetNum;
    int             ipxStaticRouteNetNum_offset;
    int             index;
    int             final_index;

    ipxStaticRouteSysInstance_offset = object->oid.length;
    ipxStaticRouteCircIndex_offset = ipxStaticRouteSysInstance_offset + 1;
    ipxStaticRouteNetNum_offset = ipxStaticRouteCircIndex_offset + 1;
    final_index = ipxStaticRouteNetNum_offset + 4;

    if (searchType == EXACT) {
	if (instLength != 6) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToFixedOctetString(incoming, ipxStaticRouteNetNum_offset, &ipxStaticRouteNetNum, searchType, &carry, 4)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, ipxStaticRouteCircIndex_offset, &ipxStaticRouteCircIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, ipxStaticRouteSysInstance_offset, &ipxStaticRouteSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ipxStaticRouteEntry_get(serialNum, contextInfo, arg, searchType, ipxStaticRouteSysInstance, ipxStaticRouteCircIndex, ipxStaticRouteNetNum)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	inst.oid_ptr[index++] = (unsigned long) data->ipxStaticRouteSysInstance;
	inst.oid_ptr[index++] = (unsigned long) data->ipxStaticRouteCircIndex;
	for (i = 0; i < data->ipxStaticRouteNetNum->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->ipxStaticRouteNetNum->octet_ptr[i];
	}

	inst.length = index;
    }

    if (ipxStaticRouteNetNum != NULL) {
	FreeOctetString(ipxStaticRouteNetNum);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ipxStaticRouteSysInstance
      case I_ipxStaticRouteSysInstance:
	dp = &data->ipxStaticRouteSysInstance;
	break;
#endif				       /* I_ipxStaticRouteSysInstance */

#ifdef I_ipxStaticRouteCircIndex
      case I_ipxStaticRouteCircIndex:
	dp = &data->ipxStaticRouteCircIndex;
	break;
#endif				       /* I_ipxStaticRouteCircIndex */

#ifdef I_ipxStaticRouteNetNum
      case I_ipxStaticRouteNetNum:
	dp = MakeOctetString(data->ipxStaticRouteNetNum->octet_ptr, data->ipxStaticRouteNetNum->length);
	break;
#endif				       /* I_ipxStaticRouteNetNum */

#ifdef I_ipxStaticRouteExistState
      case I_ipxStaticRouteExistState:
	dp = &data->ipxStaticRouteExistState;
	break;
#endif				       /* I_ipxStaticRouteExistState */

#ifdef I_ipxStaticRouteTicks
      case I_ipxStaticRouteTicks:
	dp = &data->ipxStaticRouteTicks;
	break;
#endif				       /* I_ipxStaticRouteTicks */

#ifdef I_ipxStaticRouteHopCount
      case I_ipxStaticRouteHopCount:
	dp = &data->ipxStaticRouteHopCount;
	break;
#endif				       /* I_ipxStaticRouteHopCount */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the ipxStaticRouteEntry data object.
 *---------------------------------------------------------------------*/
void
ipxStaticRouteEntry_free(ipxStaticRouteEntry_t *data)
{
    if (data != NULL) {
	if (data->ipxStaticRouteNetNum != NULL) {
	    FreeOctetString(data->ipxStaticRouteNetNum);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after ipxStaticRouteEntry set/undo
 *---------------------------------------------------------------------*/
static int
ipxStaticRouteEntry_cleanup(doList_t       *trash)
{
    ipxStaticRouteEntry_free(trash->data);
#ifdef SR_SNMPv2
    ipxStaticRouteEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
ipxStaticRouteEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int             found;
    int             carry = 0;
    ipxStaticRouteEntry_t *ipxStaticRouteEntry;
    long            ipxStaticRouteSysInstance;
    int             ipxStaticRouteSysInstance_offset;
    long            ipxStaticRouteCircIndex;
    int             ipxStaticRouteCircIndex_offset;
    OctetString    *ipxStaticRouteNetNum;
    int             ipxStaticRouteNetNum_offset;
    int             final_index;
    ulong           nvalue;

    /*
     * Validate the object instance
     * 
     */
    ipxStaticRouteSysInstance_offset = object->oid.length;
    ipxStaticRouteCircIndex_offset = ipxStaticRouteSysInstance_offset + 1;
    ipxStaticRouteNetNum_offset = ipxStaticRouteCircIndex_offset + 1;
    final_index = ipxStaticRouteNetNum_offset + 4;

    if (instLength != 6) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, ipxStaticRouteSysInstance_offset, &ipxStaticRouteSysInstance, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, ipxStaticRouteCircIndex_offset, &ipxStaticRouteCircIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToFixedOctetString(incoming, ipxStaticRouteNetNum_offset, &ipxStaticRouteNetNum, EXACT, &carry, 4)) < 0) {
	return (NO_CREATION_ERROR);
    }
    ipxStaticRouteEntry = k_ipxStaticRouteEntry_get(-1, contextInfo, object->nominator, EXACT, ipxStaticRouteSysInstance, ipxStaticRouteCircIndex, ipxStaticRouteNetNum);

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == ipxStaticRouteEntry_set) &&
	    (((ipxStaticRouteEntry_t *) (dp->data)) != NULL) &&
	    (((ipxStaticRouteEntry_t *) (dp->data))->ipxStaticRouteSysInstance == ipxStaticRouteSysInstance) &&
	    (((ipxStaticRouteEntry_t *) (dp->data))->ipxStaticRouteCircIndex == ipxStaticRouteCircIndex) &&
	    (CmpOctetStrings(((ipxStaticRouteEntry_t *) (dp->data))->ipxStaticRouteNetNum, ipxStaticRouteNetNum) == 0)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(ipxStaticRouteEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(ipxStaticRouteEntry_t));

	dp->setMethod = ipxStaticRouteEntry_set;
	dp->cleanupMethod = ipxStaticRouteEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_ipxStaticRouteSysInstance, ((ipxStaticRouteEntry_t *) (dp->data))->valid);
	((ipxStaticRouteEntry_t *) (dp->data))->ipxStaticRouteSysInstance = ipxStaticRouteSysInstance;

	SET_VALID(I_ipxStaticRouteCircIndex, ((ipxStaticRouteEntry_t *) (dp->data))->valid);
	((ipxStaticRouteEntry_t *) (dp->data))->ipxStaticRouteCircIndex = ipxStaticRouteCircIndex;

	SET_VALID(I_ipxStaticRouteNetNum, ((ipxStaticRouteEntry_t *) (dp->data))->valid);
	((ipxStaticRouteEntry_t *) (dp->data))->ipxStaticRouteNetNum = 
	  CloneOctetString(ipxStaticRouteNetNum);

#ifdef ipxStaticRouteEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (ipxStaticRouteEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, ipxStaticRouteEntry, sizeof(ipxStaticRouteEntry_t));

	    SET_ALL_VALID(((ipxStaticRouteEntry_t *) (dp->data))->valid);

	    ((ipxStaticRouteEntry_t *) (dp->data))->ipxStaticRouteNetNum =
		CloneOctetString(ipxStaticRouteEntry->ipxStaticRouteNetNum);

	} else {

	    /* Fill in default values here */

	}
#endif				       /* ipxStaticRouteEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_ipxStaticRouteSysInstance
      case I_ipxStaticRouteSysInstance:

      if (value->sl_value != 1)
	return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxStaticRouteSysInstance, ((ipxStaticRouteEntry_t *) (dp->data))->valid);

	((ipxStaticRouteEntry_t *) (dp->data))->ipxStaticRouteSysInstance = value->sl_value;
	break;
#endif				       /* I_ipxStaticRouteSysInstance */

#ifdef I_ipxStaticRouteCircIndex
      case I_ipxStaticRouteCircIndex:

      if (value->sl_value < 1)
	return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxStaticRouteCircIndex, ((ipxStaticRouteEntry_t *) (dp->data))->valid);

	((ipxStaticRouteEntry_t *) (dp->data))->ipxStaticRouteCircIndex = value->sl_value;
	break;
#endif				       /* I_ipxStaticRouteCircIndex */

#ifdef I_ipxStaticRouteNetNum
      case I_ipxStaticRouteNetNum:

	SET_VALID(I_ipxStaticRouteNetNum, ((ipxStaticRouteEntry_t *) (dp->data))->valid);

	if (((ipxStaticRouteEntry_t *) (dp->data))->ipxStaticRouteNetNum != NULL) {
	    FreeOctetString(((ipxStaticRouteEntry_t *) (dp->data))->ipxStaticRouteNetNum);
	}
	((ipxStaticRouteEntry_t *) (dp->data))->ipxStaticRouteNetNum =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);
      nvalue = OctetStringToUlong(((ipxStaticRouteEntry_t *) (dp->data))->ipxStaticRouteNetNum);
      if ((nvalue < 1) || (nvalue > 0xFFFFFFFE))
	return (WRONG_VALUE_ERROR);
	break;
#endif				       /* I_ipxStaticRouteNetNum */

#ifdef I_ipxStaticRouteExistState
      case I_ipxStaticRouteExistState:
	  
      if ((value->sl_value != D_ipxStaticRouteExistState_off) &&
	  (value->sl_value != D_ipxStaticRouteExistState_on))
	return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxStaticRouteExistState, ((ipxStaticRouteEntry_t *) (dp->data))->valid);

	((ipxStaticRouteEntry_t *) (dp->data))->ipxStaticRouteExistState = value->sl_value;
	break;
#endif				       /* I_ipxStaticRouteExistState */

#ifdef I_ipxStaticRouteTicks
      case I_ipxStaticRouteTicks:

      if ((value->sl_value < 1) || (value->sl_value > (NOVELL_INFDELAY - 1)))
	return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxStaticRouteTicks, ((ipxStaticRouteEntry_t *) (dp->data))->valid);

	((ipxStaticRouteEntry_t *) (dp->data))->ipxStaticRouteTicks = value->sl_value;
	break;
#endif				       /* I_ipxStaticRouteTicks */

#ifdef I_ipxStaticRouteHopCount
      case I_ipxStaticRouteHopCount:

      if ((value->sl_value < 1) || (value->sl_value > novell_max_hops))
	return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxStaticRouteHopCount, ((ipxStaticRouteEntry_t *) (dp->data))->valid);

	((ipxStaticRouteEntry_t *) (dp->data))->ipxStaticRouteHopCount = value->sl_value;
	break;
#endif				       /* I_ipxStaticRouteHopCount */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in ipxStaticRouteEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
ipxStaticRouteEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_ipxStaticRouteEntry_set((ipxStaticRouteEntry_t *) (doCur->data),
				      contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the ipxServEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ipxServEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ipxServEntry_t *data = NULL;
    unsigned long   buffer[52];
    OID             inst;
    int             carry;
    int             i;
    long            ipxServSysInstance;
    int             ipxServSysInstance_offset;
    OctetString    *ipxServType;
    int             ipxServType_offset;
    OctetString    *ipxServName;
    int             ipxServName_offset;
    int             index;
    int             final_index;

    ipxServSysInstance_offset = object->oid.length;
    ipxServType_offset = ipxServSysInstance_offset + 1;
    ipxServName_offset = ipxServType_offset + 2 ; 
    final_index = ipxServName_offset + GetVariableIndexLength(incoming, ipxServName_offset);

    if (searchType == EXACT) {
	if (instLength != (final_index - object->oid.length)) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToVariableOctetString(incoming, ipxServName_offset, &ipxServName, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToFixedOctetString(incoming, ipxServType_offset, &ipxServType, searchType, &carry, 2)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, ipxServSysInstance_offset, &ipxServSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ipxServEntry_get(serialNum, contextInfo, arg, searchType, ipxServSysInstance, ipxServType, ipxServName)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	inst.oid_ptr[index++] = (unsigned long) data->ipxServSysInstance;
	for (i = 0; i < data->ipxServType->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->ipxServType->octet_ptr[i];
	}

	inst.oid_ptr[index++] = data->ipxServName->length;
	for (i = 0; i < data->ipxServName->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->ipxServName->octet_ptr[i];
	}

	inst.length = index;
    }

    if (ipxServType != NULL) {
	FreeOctetString(ipxServType);
    }
    if (ipxServName != NULL) {
	FreeOctetString(ipxServName);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ipxServSysInstance
      case I_ipxServSysInstance:
	dp = &data->ipxServSysInstance;
	break;
#endif				       /* I_ipxServSysInstance */

#ifdef I_ipxServType
      case I_ipxServType:
	dp = MakeOctetString(data->ipxServType->octet_ptr, data->ipxServType->length);
	break;
#endif				       /* I_ipxServType */

#ifdef I_ipxServName
      case I_ipxServName:
	dp = MakeOctetString(data->ipxServName->octet_ptr, data->ipxServName->length);
	break;
#endif				       /* I_ipxServName */

#ifdef I_ipxServProtocol
      case I_ipxServProtocol:
	dp = &data->ipxServProtocol;
	break;
#endif				       /* I_ipxServProtocol */

#ifdef I_ipxServNetNum
      case I_ipxServNetNum:
	dp = MakeOctetString(data->ipxServNetNum->octet_ptr, data->ipxServNetNum->length);
	break;
#endif				       /* I_ipxServNetNum */

#ifdef I_ipxServNode
      case I_ipxServNode:
	dp = MakeOctetString(data->ipxServNode->octet_ptr, data->ipxServNode->length);
	break;
#endif				       /* I_ipxServNode */

#ifdef I_ipxServSocket
      case I_ipxServSocket:
	dp = MakeOctetString(data->ipxServSocket->octet_ptr, data->ipxServSocket->length);
	break;
#endif				       /* I_ipxServSocket */

#ifdef I_ipxServHopCount
      case I_ipxServHopCount:
	dp = &data->ipxServHopCount;
	break;
#endif				       /* I_ipxServHopCount */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the ipxDestServEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ipxDestServEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ipxDestServEntry_t *data = NULL;
    unsigned long   buffer[64];
    OID             inst;
    int             carry;
    int             i;
    long            ipxDestServSysInstance;
    int             ipxDestServSysInstance_offset;
    OctetString    *ipxDestServNetNum;
    int             ipxDestServNetNum_offset;
    OctetString    *ipxDestServNode;
    int             ipxDestServNode_offset;
    OctetString    *ipxDestServSocket;
    int             ipxDestServSocket_offset;
    OctetString    *ipxDestServName;
    int             ipxDestServName_offset;
    OctetString    *ipxDestServType;
    int             ipxDestServType_offset;
    int             index;
    int             final_index;

    ipxDestServSysInstance_offset = object->oid.length;
    ipxDestServNetNum_offset = ipxDestServSysInstance_offset + 1;
    ipxDestServNode_offset = ipxDestServNetNum_offset + 4;
    ipxDestServSocket_offset = ipxDestServNode_offset + 6;
    ipxDestServName_offset = ipxDestServSocket_offset + 2;
    ipxDestServType_offset = ipxDestServName_offset + GetVariableIndexLength(incoming, ipxDestServName_offset);
    final_index = ipxDestServType_offset + 2;

    if (searchType == EXACT) {
	if (instLength != (final_index - object->oid.length)) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToFixedOctetString(incoming, ipxDestServType_offset, &ipxDestServType, searchType, &carry, 2)) < 0) {
	arg = -1;
    }
    if ((InstToVariableOctetString(incoming, ipxDestServName_offset, &ipxDestServName, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToFixedOctetString(incoming, ipxDestServSocket_offset, &ipxDestServSocket, searchType, &carry, 2)) < 0) {
	arg = -1;
    }
    if ((InstToFixedOctetString(incoming, ipxDestServNode_offset, &ipxDestServNode, searchType, &carry, 6)) < 0) {
	arg = -1;
    }
    if ((InstToFixedOctetString(incoming, ipxDestServNetNum_offset, &ipxDestServNetNum, searchType, &carry, 4)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, ipxDestServSysInstance_offset, &ipxDestServSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ipxDestServEntry_get(serialNum, contextInfo, arg, searchType, ipxDestServSysInstance, ipxDestServNetNum, ipxDestServNode, ipxDestServSocket, ipxDestServName, ipxDestServType)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	inst.oid_ptr[index++] = (unsigned long) data->ipxDestServSysInstance;
	for (i = 0; i < data->ipxDestServNetNum->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->ipxDestServNetNum->octet_ptr[i];
	}

	for (i = 0; i < data->ipxDestServNode->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->ipxDestServNode->octet_ptr[i];
	}

	for (i = 0; i < data->ipxDestServSocket->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->ipxDestServSocket->octet_ptr[i];
	}

	inst.oid_ptr[index++] = data->ipxDestServName->length;
	for (i = 0; i < data->ipxDestServName->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->ipxDestServName->octet_ptr[i];
	}

	for (i = 0; i < data->ipxDestServType->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->ipxDestServType->octet_ptr[i];
	}

	inst.length = index;
    }

    if (ipxDestServNetNum != NULL) {
	FreeOctetString(ipxDestServNetNum);
    }
    if (ipxDestServNode != NULL) {
	FreeOctetString(ipxDestServNode);
    }
    if (ipxDestServSocket != NULL) {
	FreeOctetString(ipxDestServSocket);
    }
    if (ipxDestServName != NULL) {
	FreeOctetString(ipxDestServName);
    }
    if (ipxDestServType != NULL) {
	FreeOctetString(ipxDestServType);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ipxDestServSysInstance
      case I_ipxDestServSysInstance:
	dp = &data->ipxDestServSysInstance;
	break;
#endif				       /* I_ipxDestServSysInstance */

#ifdef I_ipxDestServNetNum
      case I_ipxDestServNetNum:
	dp = MakeOctetString(data->ipxDestServNetNum->octet_ptr, data->ipxDestServNetNum->length);
	break;
#endif				       /* I_ipxDestServNetNum */

#ifdef I_ipxDestServNode
      case I_ipxDestServNode:
	dp = MakeOctetString(data->ipxDestServNode->octet_ptr, data->ipxDestServNode->length);
	break;
#endif				       /* I_ipxDestServNode */

#ifdef I_ipxDestServSocket
      case I_ipxDestServSocket:
	dp = MakeOctetString(data->ipxDestServSocket->octet_ptr, data->ipxDestServSocket->length);
	break;
#endif				       /* I_ipxDestServSocket */

#ifdef I_ipxDestServName
      case I_ipxDestServName:
	dp = MakeOctetString(data->ipxDestServName->octet_ptr, data->ipxDestServName->length);
	break;
#endif				       /* I_ipxDestServName */

#ifdef I_ipxDestServType
      case I_ipxDestServType:
	dp = MakeOctetString(data->ipxDestServType->octet_ptr, data->ipxDestServType->length);
	break;
#endif				       /* I_ipxDestServType */

#ifdef I_ipxDestServProtocol
      case I_ipxDestServProtocol:
	dp = &data->ipxDestServProtocol;
	break;
#endif				       /* I_ipxDestServProtocol */

#ifdef I_ipxDestServHopCount
      case I_ipxDestServHopCount:
	dp = &data->ipxDestServHopCount;
	break;
#endif				       /* I_ipxDestServHopCount */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the ipxStaticServEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ipxStaticServEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ipxStaticServEntry_t *data = NULL;
    unsigned long   buffer[53];
    OID             inst;
    int             carry;
    int             i;
    long            ipxStaticServSysInstance;
    int             ipxStaticServSysInstance_offset;
    long            ipxStaticServCircIndex;
    int             ipxStaticServCircIndex_offset;
    OctetString    *ipxStaticServName;
    int             ipxStaticServName_offset;
    OctetString    *ipxStaticServType;
    int             ipxStaticServType_offset;
    int             index;
    int             final_index;

    ipxStaticServSysInstance_offset = object->oid.length;
    ipxStaticServCircIndex_offset = ipxStaticServSysInstance_offset + 1;
    ipxStaticServName_offset = ipxStaticServCircIndex_offset + 1;
    ipxStaticServType_offset = ipxStaticServName_offset + GetVariableIndexLength(incoming, ipxStaticServName_offset);
    final_index = ipxStaticServType_offset + 2;

    if (searchType == EXACT) {
	if (instLength != (final_index - object->oid.length)) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToFixedOctetString(incoming, ipxStaticServType_offset, &ipxStaticServType, searchType, &carry, 2)) < 0) {
	arg = -1;
    }
    if ((InstToVariableOctetString(incoming, ipxStaticServName_offset, &ipxStaticServName, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, ipxStaticServCircIndex_offset, &ipxStaticServCircIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, ipxStaticServSysInstance_offset, &ipxStaticServSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ipxStaticServEntry_get(serialNum, contextInfo, arg, searchType, ipxStaticServSysInstance, ipxStaticServCircIndex, ipxStaticServName, ipxStaticServType)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	inst.oid_ptr[index++] = (unsigned long) data->ipxStaticServSysInstance;
	inst.oid_ptr[index++] = (unsigned long) data->ipxStaticServCircIndex;
	inst.oid_ptr[index++] = data->ipxStaticServName->length	;
	for (i = 0; i < data->ipxStaticServName->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->ipxStaticServName->octet_ptr[i];
	}

	for (i = 0; i < data->ipxStaticServType->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->ipxStaticServType->octet_ptr[i];
	}

	inst.length = index;
    }

    if (ipxStaticServName != NULL) {
	FreeOctetString(ipxStaticServName);
    }
    if (ipxStaticServType != NULL) {
	FreeOctetString(ipxStaticServType);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ipxStaticServSysInstance
      case I_ipxStaticServSysInstance:
	dp = &data->ipxStaticServSysInstance;
	break;
#endif				       /* I_ipxStaticServSysInstance */

#ifdef I_ipxStaticServCircIndex
      case I_ipxStaticServCircIndex:
	dp = &data->ipxStaticServCircIndex;
	break;
#endif				       /* I_ipxStaticServCircIndex */

#ifdef I_ipxStaticServName
      case I_ipxStaticServName:
	dp = MakeOctetString(data->ipxStaticServName->octet_ptr, data->ipxStaticServName->length);
	break;
#endif				       /* I_ipxStaticServName */

#ifdef I_ipxStaticServType
      case I_ipxStaticServType:
	dp = MakeOctetString(data->ipxStaticServType->octet_ptr, data->ipxStaticServType->length);
	break;
#endif				       /* I_ipxStaticServType */

#ifdef I_ipxStaticServExistState
      case I_ipxStaticServExistState:
	dp = &data->ipxStaticServExistState;
	break;
#endif				       /* I_ipxStaticServExistState */

#ifdef I_ipxStaticServNetNum
      case I_ipxStaticServNetNum:
	dp = MakeOctetString(data->ipxStaticServNetNum->octet_ptr, data->ipxStaticServNetNum->length);
	break;
#endif				       /* I_ipxStaticServNetNum */

#ifdef I_ipxStaticServNode
      case I_ipxStaticServNode:
	dp = MakeOctetString(data->ipxStaticServNode->octet_ptr, data->ipxStaticServNode->length);
	break;
#endif				       /* I_ipxStaticServNode */

#ifdef I_ipxStaticServSocket
      case I_ipxStaticServSocket:
	dp = MakeOctetString(data->ipxStaticServSocket->octet_ptr, data->ipxStaticServSocket->length);
	break;
#endif				       /* I_ipxStaticServSocket */

#ifdef I_ipxStaticServHopCount
      case I_ipxStaticServHopCount:
	dp = &data->ipxStaticServHopCount;
	break;
#endif				       /* I_ipxStaticServHopCount */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the ipxStaticServEntry data object.
 *---------------------------------------------------------------------*/
void
ipxStaticServEntry_free(ipxStaticServEntry_t *data)
{
    if (data != NULL) {
	if (data->ipxStaticServName != NULL) {
	    FreeOctetString(data->ipxStaticServName);
	}
	if (data->ipxStaticServType != NULL) {
	    FreeOctetString(data->ipxStaticServType);
	}
	if (data->ipxStaticServNetNum != NULL) {
	    FreeOctetString(data->ipxStaticServNetNum);
	}
	if (data->ipxStaticServNode != NULL) {
	    FreeOctetString(data->ipxStaticServNode);
	}
	if (data->ipxStaticServSocket != NULL) {
	    FreeOctetString(data->ipxStaticServSocket);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after ipxStaticServEntry set/undo
 *---------------------------------------------------------------------*/
static int
ipxStaticServEntry_cleanup(doList_t       *trash)
{
    ipxStaticServEntry_free(trash->data);
#ifdef SR_SNMPv2
    ipxStaticServEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
ipxStaticServEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int             found;
    int             carry = 0;
    ipxStaticServEntry_t *ipxStaticServEntry;
    long            ipxStaticServSysInstance;
    int             ipxStaticServSysInstance_offset;
    long            ipxStaticServCircIndex;
    int             ipxStaticServCircIndex_offset;
    OctetString    *ipxStaticServName;
    int             ipxStaticServName_offset;
    OctetString    *ipxStaticServType;
    int             ipxStaticServType_offset;
    int             final_index;
    ulong           nvalue;

    /*
     * Validate the object instance
     * 
     */
    ipxStaticServSysInstance_offset = object->oid.length;
    ipxStaticServCircIndex_offset = ipxStaticServSysInstance_offset + 1;
    ipxStaticServName_offset = ipxStaticServCircIndex_offset + 1;
    ipxStaticServType_offset = ipxStaticServName_offset + GetVariableIndexLength(incoming, ipxStaticServName_offset);
    final_index = ipxStaticServType_offset + 2;

    if (instLength != (final_index - object->oid.length)) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, ipxStaticServSysInstance_offset, &ipxStaticServSysInstance, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    /*
     * We really don't care about the circuit index  for our statics *
     */
    if ((InstToInt(incoming, ipxStaticServCircIndex_offset, &ipxStaticServCircIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToVariableOctetString(incoming, ipxStaticServName_offset, &ipxStaticServName, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToFixedOctetString(incoming, ipxStaticServType_offset, &ipxStaticServType, EXACT, &carry, 2)) < 0) {
	return (NO_CREATION_ERROR);
    }
    ipxStaticServEntry = k_ipxStaticServEntry_get(-1, contextInfo, object->nominator, EXACT, ipxStaticServSysInstance, ipxStaticServCircIndex, ipxStaticServName, ipxStaticServType);

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == ipxStaticServEntry_set) &&
	    (((ipxStaticServEntry_t *) (dp->data)) != NULL) &&
	    (((ipxStaticServEntry_t *) (dp->data))->ipxStaticServSysInstance == ipxStaticServSysInstance) &&
	    (((ipxStaticServEntry_t *) (dp->data))->ipxStaticServCircIndex == ipxStaticServCircIndex) &&
	    (CmpOctetStrings(((ipxStaticServEntry_t *) (dp->data))->ipxStaticServName, ipxStaticServName) == 0) &&
	    (CmpOctetStrings(((ipxStaticServEntry_t *) (dp->data))->ipxStaticServType, ipxStaticServType) == 0)) {
	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(ipxStaticServEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(ipxStaticServEntry_t));

	dp->setMethod = ipxStaticServEntry_set;
	dp->cleanupMethod = ipxStaticServEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_ipxStaticServSysInstance, ((ipxStaticServEntry_t *) (dp->data))->valid);
	((ipxStaticServEntry_t *) (dp->data))->ipxStaticServSysInstance = ipxStaticServSysInstance;

	SET_VALID(I_ipxStaticServCircIndex, ((ipxStaticServEntry_t *) (dp->data))->valid);
	((ipxStaticServEntry_t *) (dp->data))->ipxStaticServCircIndex = ipxStaticServCircIndex;

	SET_VALID(I_ipxStaticServName, ((ipxStaticServEntry_t *) (dp->data))->valid);
	((ipxStaticServEntry_t *) (dp->data))->ipxStaticServName = CloneOctetString(ipxStaticServName);

	SET_VALID(I_ipxStaticServType, ((ipxStaticServEntry_t *) (dp->data))->valid);
	((ipxStaticServEntry_t *) (dp->data))->ipxStaticServType = CloneOctetString(ipxStaticServType);

#ifdef ipxStaticServEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (ipxStaticServEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, ipxStaticServEntry, sizeof(ipxStaticServEntry_t));

	    SET_ALL_VALID(((ipxStaticServEntry_t *) (dp->data))->valid);

	    ((ipxStaticServEntry_t *) (dp->data))->ipxStaticServName =
		CloneOctetString(ipxStaticServEntry->ipxStaticServName);

	    ((ipxStaticServEntry_t *) (dp->data))->ipxStaticServType =
		CloneOctetString(ipxStaticServEntry->ipxStaticServType);

	    ((ipxStaticServEntry_t *) (dp->data))->ipxStaticServNetNum =
		CloneOctetString(ipxStaticServEntry->ipxStaticServNetNum);

	    ((ipxStaticServEntry_t *) (dp->data))->ipxStaticServNode =
		CloneOctetString(ipxStaticServEntry->ipxStaticServNode);

	    ((ipxStaticServEntry_t *) (dp->data))->ipxStaticServSocket =
		CloneOctetString(ipxStaticServEntry->ipxStaticServSocket);

	} else {
	  /* Fill in default values here */
	  /* no defaults */

	}
#endif				       /* ipxStaticServEntry_READ_CREATE */
      }
    switch (object->nominator) {

#ifdef I_ipxStaticServSysInstance
      case I_ipxStaticServSysInstance:

      if (value->sl_value != 1)
        return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxStaticServSysInstance, ((ipxStaticServEntry_t *) (dp->data))->valid);

	((ipxStaticServEntry_t *) (dp->data))->ipxStaticServSysInstance = value->sl_value;
	break;
#endif				       /* I_ipxStaticServSysInstance */

#ifdef I_ipxStaticServCircIndex
      case I_ipxStaticServCircIndex:

      if (value->sl_value < 1)
        return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxStaticServCircIndex, ((ipxStaticServEntry_t *) (dp->data))->valid);

	((ipxStaticServEntry_t *) (dp->data))->ipxStaticServCircIndex = value->sl_value;
	break;
#endif				       /* I_ipxStaticServCircIndex */

#ifdef I_ipxStaticServName
      case I_ipxStaticServName:

      if ((value->os_value->length == 0) || 
	  (value->os_value->length > NOVELL_SERVER_NAME_LEN))
	return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxStaticServName, ((ipxStaticServEntry_t *) (dp->data))->valid);

	if (((ipxStaticServEntry_t *) (dp->data))->ipxStaticServName != NULL) {
	    FreeOctetString(((ipxStaticServEntry_t *) (dp->data))->ipxStaticServName);
	}
	((ipxStaticServEntry_t *) (dp->data))->ipxStaticServName =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_ipxStaticServName */

#ifdef I_ipxStaticServType
      case I_ipxStaticServType:
      
	SET_VALID(I_ipxStaticServType, ((ipxStaticServEntry_t *) (dp->data))->valid);

	if (((ipxStaticServEntry_t *) (dp->data))->ipxStaticServType != NULL) {
	    FreeOctetString(((ipxStaticServEntry_t *) (dp->data))->ipxStaticServType);
	}
	((ipxStaticServEntry_t *) (dp->data))->ipxStaticServType =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);
      nvalue = OctetStringToUlong(((ipxStaticServEntry_t *) (dp->data))->ipxStaticServType);
      if ((nvalue < 1) || (nvalue > 0xFFFF))
	return (WRONG_VALUE_ERROR);
      
	break;
#endif				       /* I_ipxStaticServType */

#ifdef I_ipxStaticServExistState
      case I_ipxStaticServExistState:

      if ((value->sl_value != D_ipxStaticServExistState_off) &&
	  (value->sl_value != D_ipxStaticServExistState_on))
        return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxStaticServExistState, ((ipxStaticServEntry_t *) (dp->data))->valid);

	((ipxStaticServEntry_t *) (dp->data))->ipxStaticServExistState = value->sl_value;
	break;
#endif				       /* I_ipxStaticServExistState */

#ifdef I_ipxStaticServNetNum
      case I_ipxStaticServNetNum:

	SET_VALID(I_ipxStaticServNetNum, ((ipxStaticServEntry_t *) (dp->data))->valid);

	if (((ipxStaticServEntry_t *) (dp->data))->ipxStaticServNetNum != NULL) {
	    FreeOctetString(((ipxStaticServEntry_t *) (dp->data))->ipxStaticServNetNum);
	}
	((ipxStaticServEntry_t *) (dp->data))->ipxStaticServNetNum =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);
      nvalue = OctetStringToUlong(((ipxStaticServEntry_t *) (dp->data))->ipxStaticServNetNum);
      if ((nvalue < 1) || (nvalue > 0xFFFFFFFD))
	return (WRONG_VALUE_ERROR);

	break;
#endif				       /* I_ipxStaticServNetNum */

#ifdef I_ipxStaticServNode
      case I_ipxStaticServNode:

      if (value->os_value->length != 12)
	return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxStaticServNode, ((ipxStaticServEntry_t *) (dp->data))->valid);

	if (((ipxStaticServEntry_t *) (dp->data))->ipxStaticServNode != NULL) {
	    FreeOctetString(((ipxStaticServEntry_t *) (dp->data))->ipxStaticServNode);
	}
	((ipxStaticServEntry_t *) (dp->data))->ipxStaticServNode =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_ipxStaticServNode */

#ifdef I_ipxStaticServSocket
      case I_ipxStaticServSocket:
      
        SET_VALID(I_ipxStaticServSocket, ((ipxStaticServEntry_t *) (dp->data))->valid);

	if (((ipxStaticServEntry_t *) (dp->data))->ipxStaticServSocket != NULL) {
	    FreeOctetString(((ipxStaticServEntry_t *) (dp->data))->ipxStaticServSocket);
	}
	((ipxStaticServEntry_t *) (dp->data))->ipxStaticServSocket =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);
      nvalue = OctetStringToUlong(((ipxStaticServEntry_t *) (dp->data))->ipxStaticServSocket);
      if ((nvalue < 1) || (nvalue > 0xFFFF))
	return (WRONG_VALUE_ERROR);
	break;
#endif				       /* I_ipxStaticServSocket */

#ifdef I_ipxStaticServHopCount
      case I_ipxStaticServHopCount:

      if ((value->sl_value < 1) || (value->sl_value > novell_max_hops))
	return (WRONG_VALUE_ERROR);
	SET_VALID(I_ipxStaticServHopCount, ((ipxStaticServEntry_t *) (dp->data))->valid);

	((ipxStaticServEntry_t *) (dp->data))->ipxStaticServHopCount = value->sl_value;
	break;
#endif				       /* I_ipxStaticServHopCount */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in ipxStaticServEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
ipxStaticServEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_ipxStaticServEntry_set((ipxStaticServEntry_t *) (doCur->data),
				     contextInfo, doCur->state));
}

#endif				       /* SETS */

ipxBasicSysEntry_t *
k_ipxBasicSysEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            ipxBasicSysInstance)
{
    static OctetString net; 
    static OctetString node; 
    static OctetString namestring; 

    if (!novell_running || novell_shutting_down) 
	return (NULL);

    if (searchType == NEXT)
	if (ipxBasicSysInstance < 1)
	    ipxBasicSysInstance = 1;

    if (ipxBasicSysInstance != 1)
	return (NULL);
	    
    ipxBasicSysEntryData.ipxBasicSysInstance = ipxBasicSysInstance;
    ipxBasicSysEntryData.ipxBasicSysExistState = D_ipxBasicSysExistState_on;
    ipxBasicSysEntryData.ipxBasicSysNetNumber = &net;
    net.length = NETBYTES;
    net.octet_ptr = (uchar *)&ipx_internal_net;
    ipxBasicSysEntryData.ipxBasicSysNode =  &node;
    node.length = IEEEBYTES;
    node.octet_ptr = nov_defaddr;
    ipxBasicSysEntryData.ipxBasicSysName =  &namestring;
    namestring.length = strlen(hostname);
    namestring.octet_ptr = hostname;
    ipxBasicSysEntryData.ipxBasicSysInReceives = novell_stat[NOVELL_INPUT];
    ipxBasicSysEntryData.ipxBasicSysInHdrErrors = novell_stat[NOVELL_FORMATERROR];
    ipxBasicSysEntryData.ipxBasicSysInUnknownSockets = novell_stat[NOVELL_UNKNOWN_SOCKET];
    ipxBasicSysEntryData.ipxBasicSysInDiscards = novell_stat[NOVELL_IN_DISCARDS];
    ipxBasicSysEntryData.ipxBasicSysInBadChecksums = novell_stat[NOVELL_CKSUMERR];
    ipxBasicSysEntryData.ipxBasicSysInDelivers = novell_stat[NOVELL_LOCALDEST];
    ipxBasicSysEntryData.ipxBasicSysNoRoutes = novell_stat[NOVELL_NOROUTE];
    ipxBasicSysEntryData.ipxBasicSysOutRequests = 
      novell_stat[NOVELL_RIPREQOUT] + novell_stat[NOVELL_SAPREQOUT];
    ipxBasicSysEntryData.ipxBasicSysOutMalformedRequests = 0;
    ipxBasicSysEntryData.ipxBasicSysOutDiscards = novell_stat[NOVELL_OUT_DISCARDS];
    ipxBasicSysEntryData.ipxBasicSysOutPackets = novell_stat[NOVELL_OUTPUT];
    ipxBasicSysEntryData.ipxBasicSysConfigSockets = 0;
    ipxBasicSysEntryData.ipxBasicSysOpenSocketFails = 0;

    return (&ipxBasicSysEntryData);
}

#ifdef SETS
int
k_ipxBasicSysEntry_set(
    ipxBasicSysEntry_t *data,
    ContextInfo    *contextInfo,
    int             function)
{
  ulong net;
  uchar name[48];

  name[0] = (uchar) 0x00;
  switch (function) {
  case DELETE:
    return (GEN_ERROR);
  case ADD_MODIFY:
    if (VALID(I_ipxBasicSysInstance, data->valid)) {
      novell_address_command(FALSE, TRUE, 0 , NULL);
    }
    if (VALID(I_ipxBasicSysExistState, data->valid)) {
      if (data->ipxBasicSysExistState == D_ipxBasicSysExistState_on) {
	novell_address_command(FALSE, TRUE, 0 , NULL);
      } else {
	if (data->ipxBasicSysExistState == D_ipxBasicSysExistState_off) {
	  novell_address_command(FALSE, FALSE, 0 , NULL);
	  } else {
	    return (WRONG_VALUE_ERROR);
	  }
      }
    }
    if (VALID(I_ipxBasicSysNetNumber, data->valid)) {
      net = OctetStringToUlong(data->ipxBasicSysNetNumber);
      novell_internal_net_command(FALSE, TRUE, net);
    }
    if (VALID(I_ipxBasicSysNode, data->valid)) {
      /* This should be a no-op as it's always 0000.0000.0001 */
    }
    if (VALID(I_ipxBasicSysName, data->valid)) {
      sstrncpy(name, data->ipxBasicSysName->octet_ptr, data->ipxBasicSysName->length +1);
      if (strcmp(name, hostname) != 0) {
	set_hostname(name);
	reg_invoke_hostname_changed(TRUE);
      }
    }
    return (NO_ERROR);
  default:
    return (GEN_ERROR);
  }
    return (GEN_ERROR);
}

#endif				       /* SETS */

ipxAdvSysEntry_t *
k_ipxAdvSysEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            ipxAdvSysInstance)
{
    if (!novell_running || novell_shutting_down) 
	return (NULL);

    if (searchType == NEXT)
	if (ipxAdvSysInstance < 1)
	    ipxAdvSysInstance = 1;

    if (ipxAdvSysInstance != 1)
	return (NULL);

    ipxAdvSysEntryData.ipxAdvSysInstance = ipxAdvSysInstance;
    ipxAdvSysEntryData.ipxAdvSysMaxPathSplits = novell_maxpaths;
    ipxAdvSysEntryData.ipxAdvSysMaxHops = novell_infinity;
    ipxAdvSysEntryData.ipxAdvSysInTooManyHops = novell_stat[NOVELL_HOPCOUNT];
    ipxAdvSysEntryData.ipxAdvSysInFiltered = novell_stat[NOVELL_FILTER_IN];
    ipxAdvSysEntryData.ipxAdvSysInCompressDiscards = 0;
    ipxAdvSysEntryData.ipxAdvSysNETBIOSPackets = novell_stat[NOVELL_NETBIOSIN];
    ipxAdvSysEntryData.ipxAdvSysForwPackets = novell_stat[NOVELL_FORWARDED];
    ipxAdvSysEntryData.ipxAdvSysOutFiltered = novell_stat[NOVELL_FILTER_OUT];
    ipxAdvSysEntryData.ipxAdvSysOutCompressDiscards = 0;
    ipxAdvSysEntryData.ipxAdvSysCircCount = get_circCount();
    ipxAdvSysEntryData.ipxAdvSysDestCount = novell_route_count;
    ipxAdvSysEntryData.ipxAdvSysServCount = novell_server_count;

    return (&ipxAdvSysEntryData);
}

#ifdef SETS
int
k_ipxAdvSysEntry_set(
    ipxAdvSysEntry_t *data,
    ContextInfo    *contextInfo,
    int             function)
{
  switch (function) {
  case DELETE:
    return (GEN_ERROR);
    break;
  case ADD_MODIFY:
    if (VALID(I_ipxAdvSysInstance, data->valid)) {
      novell_address_command(FALSE, TRUE, 0 , NULL);
    }
    if (VALID(I_ipxAdvSysMaxPathSplits, data->valid)) {
      novell_paths_command (FALSE, TRUE, data->ipxAdvSysMaxPathSplits);
    }
    if (VALID(I_ipxAdvSysMaxHops, data->valid)) {
      novell_set_max_hops(data->ipxAdvSysMaxHops - 1);
    }
    break;
  default:
    return (GEN_ERROR);
    break;
  }
  return (NO_ERROR);
}

#endif				       /* SETS */

ipxCircEntry_t *
k_ipxCircEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            ipxCircSysInstance,
    long            ipxCircIndex)
{
    static OctetString namestring; /* saved get-result, not instance */
    static OctetString dialname;
    static OctetString mediaType;
    static OctetString net;
    static OctetString neighRouterName;
    static OctetString neighRouterNet;
    idbtype        *idb = NULL, *cur_idb = NULL;
    nidbtype *nidb = NULL;
    char *dialer_string;

    if (!novell_running || novell_shutting_down) 
	return (NULL);

    if (ipxCircSysInstance > 1) /* only  1 system */
	return (NULL);

    if(searchType == EXACT) {
	if (ipxCircSysInstance == 1) {
	    FOR_ALL_SWIDBS(idb) {
		if (idb->primary_nidb != NULL &&
		    idb->if_number == (ulong) ipxCircIndex)
		    break;
	    }
	}
    } else { /* get next */
	if (ipxCircSysInstance < 1) {
	    ipxCircSysInstance = 1;
	    ipxCircIndex = 0;
	}

	/* ipxCircSysInstance == 1 now */
	FOR_ALL_SWIDBS(cur_idb) {
	    if (idb == NULL) {
		if (cur_idb->primary_nidb != NULL && 
		    cur_idb->if_number >= (ulong) ipxCircIndex) 
		    idb = cur_idb;
	    } else {
		if (cur_idb->primary_nidb != NULL && 
		    (cur_idb->if_number >= (ulong) ipxCircIndex) &&
		    (cur_idb->if_number < idb->if_number))
		    idb = cur_idb;
	    }
	}
    }

    if (idb == NULL)
        return (NULL);

    nidb = (nidbtype *)idb->primary_nidb;

    ipxCircEntryData.ipxCircSysInstance = ipxCircSysInstance;
    ipxCircEntryData.ipxCircIndex = idb->if_number;
    ipxCircEntryData.ipxCircExistState = D_ipxCircExistState_on;
    if (NOVELL_NIDB_IDB_UP(nidb))
	ipxCircEntryData.ipxCircOperState = D_ipxCircOperState_up;
    else
	ipxCircEntryData.ipxCircOperState = D_ipxCircOperState_down;
    ipxCircEntryData.ipxCircIfIndex = idb->hwptr->snmp_if_index;
    ipxCircEntryData.ipxCircName = &namestring;
    namestring.length = strlen(idb->namestring);
    namestring.octet_ptr = idb->namestring;
    ipxCircEntryData.ipxCircType = snmp_ipxCircType(nidb);
    ipxCircEntryData.ipxCircDialName = &dialname;
    dialname.length = 0;
    dialname.octet_ptr = NULL;
    if (is_ddr(idb->hwptr)) {
	dialer_string = reg_invoke_get_dialer_string(idb->hwptr);
	if (dialer_string != NULL) {
	    dialname.length = strlen(dialer_string);
	    dialname.octet_ptr = dialer_string;
	}
    }
    ipxCircEntryData.ipxCircLocalMaxPacketSize = idb->hwptr->maxmtu;
    ipxCircEntryData.ipxCircCompressState = D_ipxCircCompressState_off;
    ipxCircEntryData.ipxCircCompressSlots = 0;
    ipxCircEntryData.ipxCircStaticStatus = snmp_ipxCircStaticStatus(nidb);
    ipxCircEntryData.ipxCircCompressedSent = 0;
    ipxCircEntryData.ipxCircCompressedInitSent = 0;
    ipxCircEntryData.ipxCircCompressedRejectsSent = 0;
    ipxCircEntryData.ipxCircUncompressedSent = 0;
    ipxCircEntryData.ipxCircCompressedReceived = 0;
    ipxCircEntryData.ipxCircCompressedInitReceived = 0;
    ipxCircEntryData.ipxCircCompressedRejectsReceived = 0;
    ipxCircEntryData.ipxCircUncompressedReceived = 0;
    ipxCircEntryData.ipxCircMediaType = &mediaType;
    snmp_ipxCircMedia(nidb, &mediaType);
    ipxCircEntryData.ipxCircNetNumber = &net;
    net.length = NETBYTES;
    net.octet_ptr = (uchar *)&nidb->novellnet;
    ipxCircEntryData.ipxCircStateChanges = idb->hwptr->counters.transitions; 
    ipxCircEntryData.ipxCircInitFails = idb->hwptr->counters.resets; 
    ipxCircEntryData.ipxCircDelay = idb->novell_delay * 55;
    ipxCircEntryData.ipxCircThroughput = idb->visible_bandwidth * 1000;
    ipxCircEntryData.ipxCircNeighRouterName = &neighRouterName;
    neighRouterName.length = strlen(nidb->nov_ipxwan_remote_routername);
    neighRouterName.octet_ptr = nidb->nov_ipxwan_remote_routername;
    ipxCircEntryData.ipxCircNeighInternalNetNum = &neighRouterNet;
    neighRouterNet.length = NETBYTES;
    neighRouterNet.octet_ptr = (uchar *)&nidb->nov_ipxwan_remote_internal_net;

    return (&ipxCircEntryData);
}

#ifdef SETS
int
k_ipxCircEntry_set(
    ipxCircEntry_t *data,
    ContextInfo    *contextInfo,
    int             function)
{
  idbtype *idb;
  nidbtype *nidb;

  FOR_ALL_SWIDBS(idb) {
    if ((idb != NULL) && (idb->primary_nidb != NULL) &&
	(idb->if_number == data->ipxCircIndex))
      break;
  }
  if (idb == NULL)    /* This should have already been verified */
    return (GEN_ERROR);

  nidb = (nidbtype *)idb->primary_nidb;

  switch (function) {
  case DELETE:
    return (GEN_ERROR);
    break;
  case ADD_MODIFY:
    if ((VALID(I_ipxCircSysInstance, data->valid)) ||
	(VALID(I_ipxCircIndex, data->valid))) {
      /* Only turn on IPX if it isn't already enabled */
      if (!(idb->novellnets)) {
	novell_ipxwan_enable_ifcommand(FALSE, TRUE, idb, IPX_IPXWAN_DEFAULT, 0,
				       NULL, 0, 0, 0);
      }
    }
    if (VALID(I_ipxCircExistState, data->valid)) {
      switch (data->ipxCircExistState) {
      case D_ipxBasicSysExistState_on:
	if (!(idb->novellnets))
	novell_ipxwan_enable_ifcommand(FALSE, TRUE, idb, IPX_IPXWAN_DEFAULT, 0,
				       NULL, 0, 0, 0);
	break;
      case D_ipxBasicSysExistState_off:
	if (idb->novellnets)
	novell_ipxwan_enable_ifcommand(FALSE, FALSE, idb, IPX_IPXWAN_DEFAULT,
				       0, NULL, 0, 0, 0);
	break;
      default:
	return (WRONG_VALUE_ERROR);
	break;
      }
    }
    if (VALID(I_ipxCircOperState, data->valid)) {
      switch (data->ipxCircOperState) {
      case D_ipxCircOperState_down:
	/* If the idb is up set it to Down */
	if (idb->hwptr->status != IDBS_ADMINDOWN)
	  shutdown_going_down(idb->hwptr);
	break;
      case D_ipxCircOperState_up:
	/* If the idb is down set it do Up */
	if (idb->hwptr->status == IDBS_ADMINDOWN)
	  shutdown_coming_up(idb->hwptr);
       	break;
      default:
	return (WRONG_VALUE_ERROR);
        break;
      }
    }
    if (VALID(I_ipxCircIfIndex, data->valid)) {
      return (NOT_WRITABLE_ERROR);
    }
    if (VALID(I_ipxCircName, data->valid)) {
      return (NOT_WRITABLE_ERROR);
    }
    if (VALID(I_ipxCircType, data->valid)) {
      /* No such parameter on a cisco, we don't have one parameter */
      /* we have to test for a number of items being present */
      /* such as, if NLSP is enable but rip is off, otherwise rip is on */
      return (NOT_WRITABLE_ERROR);
    }
    if (VALID(I_ipxCircDialName, data->valid)) {
      /* No easy way to do this, this is Novell MPR centric */
      return (NOT_WRITABLE_ERROR);
    }
    if (VALID(I_ipxCircLocalMaxPacketSize, data->valid)) {
      /* We have interface mtu and that is all, not implemented */
      return (NOT_WRITABLE_ERROR);
    }
    if (VALID(I_ipxCircCompressState, data->valid)) {
      /* compression was implemented but the read mib parts don't exist */
      return (NOT_WRITABLE_ERROR);
    }
    if (VALID(I_ipxCircCompressSlots, data->valid)) {
      /* compression was implemented but the read mib parts don't exist */
      return (NOT_WRITABLE_ERROR);
    }
    if (VALID(I_ipxCircStaticStatus, data->valid)) {
      /* no such parameter on a cisco, statics are always active status */
      return (NOT_WRITABLE_ERROR);
    }
    break;
  default:
    return (GEN_ERROR);
    break;
  }
  return (NO_ERROR);
}

#endif				       /* SETS */

ipxDestEntry_t *
k_ipxDestEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            ipxDestSysInstance,
    OctetString    *ipxDestNetNum)
{
    static OctetString dstnet;
    static OctetString nicaddr;
    static OctetString nexthop;
    novndbtype *p = NULL, *cur_p = NULL;
    int i;
    novrdbtype *pp = NULL;
    ulong net;

    if (!novell_running || novell_shutting_down) 
	return (NULL);

    if (ipxDestSysInstance > 1) /* only  1 system */
	return (NULL);

    net = OctetStringToUlong(ipxDestNetNum);
    if(searchType == EXACT) {
	if (ipxDestSysInstance == 1) {
	    for (i = 0; i < NOV_NETHASHLEN; i++) {
		p = (*novell_table)[i];
		for (; p; p = p->next) {
		    if ((p->dstnet == net) &&
			(p->path_list != NULL))
			goto get_r_break;
		}
	    }
	    get_r_break:
	}
    } else { /* get next */
	if (ipxDestSysInstance < 1) {
	    ipxDestSysInstance = 1;
	    net = 0;
	}
	for (i = 0; i < NOV_NETHASHLEN; i++) {
	    cur_p = (*novell_table)[i];
	    for (; cur_p; cur_p = cur_p->next) {
		if (p == NULL) {
		    if ((cur_p->dstnet >= net) &&
			(cur_p->path_list != NULL))
			p = cur_p;
		} else 
		    if ((cur_p->dstnet >= net) &&
			(cur_p->dstnet < p->dstnet) &&
			(cur_p->path_list != NULL))
		    p = cur_p;
	    }
	}
    }
    
    if (p == NULL)
	return (NULL);

    pp = p->path_list;

    ipxDestEntryData.ipxDestSysInstance = ipxDestSysInstance;
    ipxDestEntryData.ipxDestNetNum = &dstnet;
    dstnet.length = NETBYTES;
    dstnet.octet_ptr = (uchar *)&p->dstnet;
    ipxDestEntryData.ipxDestProtocol = snmp_getDestProc(p);
    ipxDestEntryData.ipxDestTicks = p->delay;
    ipxDestEntryData.ipxDestHopCount = p->hopcount;
    ipxDestEntryData.ipxDestNextHopCircIndex = pp->nidb->idb->if_number;
    ipxDestEntryData.ipxDestNextHopNICAddress = &nicaddr;
    nicaddr.length = IEEEBYTES;
    nicaddr.octet_ptr = pp->srchost;
    ipxDestEntryData.ipxDestNextHopNetNum = &nexthop;
    nexthop.length = NETBYTES;
    nexthop.octet_ptr = (uchar *)&pp->srcnet;

    return (&ipxDestEntryData);
}

ipxStaticRouteEntry_t *
k_ipxStaticRouteEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            ipxStaticRouteSysInstance,
    long            ipxStaticRouteCircIndex,
    OctetString    *ipxStaticRouteNetNum)
{
    static OctetString dstnet;
    novndbtype *p = NULL, *cur_p = NULL;
    int i;
    novrdbtype *pp = NULL, *cur_pp = NULL;
    ulong net;

    if (!novell_running || novell_shutting_down) 
	return (NULL);

    if (ipxStaticRouteSysInstance > 1) /* only  1 system */
	return (NULL);

    net = OctetStringToUlong(ipxStaticRouteNetNum);
    if(searchType == EXACT) {
	if (ipxStaticRouteSysInstance == 1) {
	    for (i = 0; i < NOV_NETHASHLEN; i++) {
		p = (*novell_table)[i];
		for (; p; p = p->next) {
		    if ((p->flags & NET_STATIC) && (p->dstnet == net)) {
			pp = p->path_list;
			if (pp != NULL &&
			    pp->nidb->idb->if_number == ipxStaticRouteCircIndex)
			goto get_sr_break;
		    }
		}
	    }
	    get_sr_break:
	}
    } else { /* get next */
	if (ipxStaticRouteSysInstance < 1) {
	    ipxStaticRouteSysInstance = 1;
	    ipxStaticRouteCircIndex = 0;
	    net = 0;
	} 
	p = NULL;
	for (i = 0; i < NOV_NETHASHLEN; i++) {
	    cur_p = (*novell_table)[i];
	    for (; cur_p; cur_p = cur_p->next) {
		if (cur_p->flags & NET_STATIC) { /* static route */
		    cur_pp = cur_p->path_list;
		    if (cur_pp != NULL) {
			if (cur_pp->nidb->idb->if_number < ipxStaticRouteCircIndex ||
			    (cur_pp->nidb->idb->if_number == ipxStaticRouteCircIndex &&
			     cur_p->dstnet < net))
			    continue;
			if (p != NULL) { 
			    /* no need check pp != NULL 'cause pp != NULL if p!= NULL */
			    if (cur_pp->nidb->idb->if_number > pp->nidb->idb->if_number ||
				(cur_pp->nidb->idb->if_number == pp->nidb->idb->if_number &&
				 cur_p->dstnet > p->dstnet))
				continue;
			} 
			p = cur_p;
			pp = p->path_list; /* (pp = cur_p) != NULL */
		    }
		}
	    }
	}
    }
		
    if (p == NULL)
	/* no need check pp != NULL 'cause pp != NULL if p!= NULL */
	return (NULL);

    ipxStaticRouteEntryData.ipxStaticRouteSysInstance = ipxStaticRouteSysInstance;
    ipxStaticRouteEntryData.ipxStaticRouteCircIndex = pp->nidb->idb->if_number;
    ipxStaticRouteEntryData.ipxStaticRouteNetNum = &dstnet;
    dstnet.length = NETBYTES;
    dstnet.octet_ptr = (uchar *)&p->dstnet;
    ipxStaticRouteEntryData.ipxStaticRouteExistState = D_ipxStaticRouteExistState_on;
    ipxStaticRouteEntryData.ipxStaticRouteTicks = p->delay;
    ipxStaticRouteEntryData.ipxStaticRouteHopCount = p->hopcount;

    return (&ipxStaticRouteEntryData);
}

#ifdef SETS
int
k_ipxStaticRouteEntry_set(
    ipxStaticRouteEntry_t *data,
    ContextInfo    *contextInfo,
    int             function)
{
  ulong net, ticks, hops, intf;
  idbtype        *idb = NULL;

  net = ticks = hops = intf = 0;

  switch (function) {
  case DELETE:
    return (GEN_ERROR);
  case ADD_MODIFY:
    if ((data != NULL) && (((ipxStaticRouteEntry_t *) data)->ipxStaticRouteHopCount)) {
     net = OctetStringToUlong(((ipxStaticRouteEntry_t *) data)->ipxStaticRouteNetNum);
     hops = ((ipxStaticRouteEntry_t *) data)->ipxStaticRouteHopCount;
     ticks = ((ipxStaticRouteEntry_t *) data)->ipxStaticRouteTicks;
     intf = ((ipxStaticRouteEntry_t *) data)->ipxStaticRouteCircIndex;
/* ### more testing of values */
     FOR_ALL_SWIDBS(idb) {
       if ((idb != NULL) && (idb->primary_nidb != NULL) &&
	   (idb->if_number == intf))
	 break;
     }
     if (idb == NULL)    /* This should have already been verified */
       return (GEN_ERROR);

     /* Ok, Now let us go add the static route */
/* ### make this a logical and retrun a failure if it returns false */
     nov_route_command(FALSE, (data->ipxStaticRouteExistState == 2),
		       net, 0, NULL, ticks, hops, TRUE, idb, FALSE,
		       NOV_NETMASK_ALL, 0,
		       IPX_STATIC_DEFINE_TYPE_NVGEN);
    }
    return(NO_ERROR);
  default:
    return (GEN_ERROR);
  }
    return (GEN_ERROR);
}

#endif				       /* SETS */

ipxServEntry_t *
k_ipxServEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            ipxServSysInstance,
    OctetString    *ipxServType,
    OctetString    *ipxServName)
{
    static OctetString namestring; /* saved get-result, not instance */
    static OctetString servType;
    static OctetString net;
    static OctetString node;
    static OctetString socket;
    novell_sapqueuetype *sapq = NULL, *cur_sapq = NULL;
    novell_sapentrytype *entry = NULL, *cur_entry = NULL;
    ushort type;
    uchar name[NOVELL_SERVER_NAME_LEN];
    int namelen;
    int c_type, c_namelen, c_name;


    if (!novell_running || novell_shutting_down) 
	return (NULL);

    /* only  1 system */
    if ((ipxServSysInstance > 1) ||
        ((searchType == EXACT) && (ipxServSysInstance != 1)))
        return (NULL);

    type = OctetStringToUlong(ipxServType);

    /*
     * convert the ipxServName OctetString into a "real" string
     * note that sstrncpy will copy n-1 characters, and copy '\0'
     * into the n'th byte
     */
    namelen = min(NOVELL_SERVER_NAME_LEN - 1, ipxServName->length);
    sstrncpy(name, ipxServName->octet_ptr, namelen+1);

    if(searchType == EXACT) {
	FOR_ALL_SAP_TYPES(sapq) {
	    if (sapq->server_type != type)
		continue;
	    FOR_ALL_SAPS_OF_TYPE(entry, sapq) {
		if (strcmp(entry->server.server_name, name) == 0)
		    goto get_done;
	    }
	}
	get_done:
    } else { /* get next */
	if (ipxServSysInstance < 1) {
	    ipxServSysInstance = 1;
	    type = 0;
	    name[0] = '\0';
	    namelen = 0;
	} 
	sapq = NULL;
	FOR_ALL_SAPS(cur_entry, cur_sapq) {
	    c_type = cur_sapq->server_type - type;
	    c_namelen = strlen(cur_entry->server.server_name) - namelen;
	    c_name = strcmp(cur_entry->server.server_name, name);
	    if (c_type < 0 || 
		(c_type == 0 && c_namelen < 0) ||
		(c_type == 0 && c_namelen == 0 && c_name < 0))
		continue;
	    if (sapq != NULL) {
		c_type = cur_sapq->server_type - sapq->server_type;
		c_namelen = strlen(cur_entry->server.server_name) -
		    strlen(entry->server.server_name);
		c_name = strcmp(cur_entry->server.server_name, 
				entry->server.server_name);
		if (c_type > 0 || 
		    (c_type == 0 && c_namelen > 0) ||
		    (c_type == 0 && c_namelen == 0 && c_name > 0))
		    continue;
	    }
	    sapq = cur_sapq;
	    entry = cur_entry;
	}
    }

    if (sapq == NULL)
	/* no need check entry != NULL 'cause entry != NULL if sapq != NULL */
	return (NULL);

    ipxServEntryData.ipxServSysInstance = ipxServSysInstance;
    ipxServEntryData.ipxServType = &servType;
    servType.length = TYPEBYTES;
    servType.octet_ptr = (uchar *) &sapq->server_type;
    ipxServEntryData.ipxServName = &namestring;
    namestring.length = strlen(entry->server.server_name);
    namestring.octet_ptr = entry->server.server_name;
    ipxServEntryData.ipxServProtocol = snmp_getServProc(entry);
    ipxServEntryData.ipxServNetNum = &net;
    net.length = NETBYTES;
    net.octet_ptr = (uchar *)&entry->server.dnet;
    ipxServEntryData.ipxServNode = &node;
    node.length = IEEEBYTES;
    node.octet_ptr = (uchar *)&entry->server.dhost;
    ipxServEntryData.ipxServSocket = &socket;
    socket.length = SOCKETBYTES;
    socket.octet_ptr = (uchar *)&entry->server.dsock;
    ipxServEntryData.ipxServHopCount = entry->server.nethops;

    return (&ipxServEntryData);
}

ipxDestServEntry_t *
k_ipxDestServEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            ipxDestServSysInstance,
    OctetString    *ipxDestServNetNum,
    OctetString    *ipxDestServNode,
    OctetString    *ipxDestServSocket,
    OctetString    *ipxDestServName,
    OctetString    *ipxDestServType)
{
    static OctetString namestring; /* saved get-result, not instance */
    static OctetString servType;
    static OctetString servNet;
    static OctetString servNode;
    static OctetString servSocket;
    novell_sapqueuetype *sapq = NULL, *cur_sapq = NULL;
    novell_sapentrytype *entry = NULL, *cur_entry = NULL;
    ulong net;
    ushort socket,type;
    uchar name[NOVELL_SERVER_NAME_LEN];
    int namelen;
    int c_node, c_socket, c_type, c_namelen, c_name;
    boolean c_net, c_net0;

    if (!novell_running || novell_shutting_down) 
	return (NULL);

    /* only  1 system */
    if ((ipxDestServSysInstance > 1) ||
        ((searchType == EXACT) && (ipxDestServSysInstance != 1)))
        return (NULL);

    net = OctetStringToUlong(ipxDestServNetNum);
    socket = OctetStringToUlong(ipxDestServSocket);

    /*
     * convert the ipxDestServName OctetString into a "real" string
     * note that sstrncpy will copy n-1 characters, and copy '\0'
     * into the n'th byte
     */
    namelen = min(NOVELL_SERVER_NAME_LEN - 1, ipxDestServName->length);
    sstrncpy(name, ipxDestServName->octet_ptr, namelen+1);

    type = OctetStringToUlong(ipxDestServType);

    if(searchType == EXACT) {
	FOR_ALL_SAP_TYPES(sapq) {
	    if (sapq->server_type != type)
		continue;
	    FOR_ALL_SAPS_OF_TYPE(entry, sapq) {
		if (entry->server.dnet == net &&
		    (ieee_compare(entry->server.dhost, ipxDestServNode->octet_ptr) == 0) &&
		    entry->server.dsock == socket &&
		    (strcmp(entry->server.server_name, name) == 0) )
		    goto get_end;
	    }
	}
	get_end:
    } else { /* get next */
	if (ipxDestServSysInstance < 1) {
	    ipxDestServSysInstance = 1;
	    net = 0;
	    ieee_zero(ipxDestServNode->octet_ptr);
	    socket = 0;
	    name[0] = '\0';
	    namelen = 0;
	    type = 0;
	} 
	sapq = NULL;
	FOR_ALL_SAPS(cur_entry, cur_sapq) {
	    c_net = (cur_entry->server.dnet < net);
	    c_net0 = (cur_entry->server.dnet == net);
	    c_node = ieee_compare(cur_entry->server.dhost, ipxDestServNode->octet_ptr);
	    c_socket = cur_entry->server.dsock - socket;
	    c_namelen = strlen(cur_entry->server.server_name) - namelen;
	    c_name = strcmp(cur_entry->server.server_name, name);
	    c_type = cur_sapq->server_type - type;
	    if (c_net || 
		(c_net0 && c_node < 0) ||
		(c_net0 && c_node == 0 && c_socket < 0) ||
		(c_net0 && c_node == 0 && c_socket == 0 && c_namelen < 0) ||
		(c_net0 && c_node == 0 && c_socket == 0 && c_namelen == 0 && c_name < 0) ||
		(c_net0 && c_node == 0 && c_socket == 0 && c_namelen == 0 && c_name == 0 && c_type < 0))
		continue;
	    if (sapq != NULL) {
		c_net = (cur_entry->server.dnet > entry->server.dnet);
		c_net0 = (cur_entry->server.dnet == entry->server.dnet);
		c_node = ieee_compare(cur_entry->server.dhost, entry->server.dhost);
		c_socket = cur_entry->server.dsock - entry->server.dsock;
		c_namelen = strlen(cur_entry->server.server_name) - 
		    strlen(entry->server.server_name);
		c_name = strcmp(cur_entry->server.server_name, 
				entry->server.server_name);
		c_type = cur_sapq->server_type - sapq->server_type;
		if (c_net || 
		    (c_net0 && c_node > 0) ||
		    (c_net0 && c_node == 0 && c_socket > 0) ||
		    (c_net0 && c_node == 0 && c_socket == 0 && c_namelen > 0) ||
		    (c_net0 && c_node == 0 && c_socket == 0 && c_namelen == 0 && c_name > 0) ||
		    (c_net0 && c_node == 0 && c_socket == 0 && c_namelen == 0 && c_name == 0 && c_type > 0))
		    continue;
	    }
	    sapq = cur_sapq;
	    entry = cur_entry;
	}
    }

    if (sapq == NULL)
	/* no need check entry != NULL 'cause entry != NULL if sapq != NULL */
	return (NULL);
    ipxDestServEntryData.ipxDestServSysInstance = ipxDestServSysInstance;
    ipxDestServEntryData.ipxDestServNetNum = &servNet;
    servNet.length = NETBYTES;
    servNet.octet_ptr = (uchar *)&entry->server.dnet;
    ipxDestServEntryData.ipxDestServNode = &servNode;
    servNode.length = IEEEBYTES;
    servNode.octet_ptr = (uchar *)&entry->server.dhost;
    ipxDestServEntryData.ipxDestServSocket = &servSocket;
    servSocket.length = SOCKETBYTES;
    servSocket.octet_ptr = (uchar *)&entry->server.dsock;
    ipxDestServEntryData.ipxDestServName = &namestring;
    namestring.length = strlen(entry->server.server_name);
    namestring.octet_ptr = entry->server.server_name;
    ipxDestServEntryData.ipxDestServType = &servType;
    servType.length = TYPEBYTES;
    servType.octet_ptr = (uchar *) &sapq->server_type;
    ipxDestServEntryData.ipxDestServProtocol = snmp_getServProc(entry);
    ipxDestServEntryData.ipxDestServHopCount = entry->server.nethops;

    return (&ipxDestServEntryData);
}

ipxStaticServEntry_t *
k_ipxStaticServEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            ipxStaticServSysInstance,
    long            ipxStaticServCircIndex,
    OctetString    *ipxStaticServName,
    OctetString    *ipxStaticServType)
{
    static OctetString namestring; /* saved get-result, not instance */
    static OctetString servType;
    static OctetString net;
    static OctetString node;
    static OctetString socket;
    novell_sapqueuetype *sapq = NULL, *cur_sapq = NULL;
    novell_sapentrytype *entry = NULL, *cur_entry = NULL;
    ushort type;
    uchar name[NOVELL_SERVER_NAME_LEN];
    int namelen;
    int c_circ, c_type, c_namelen, c_name;


    if (!novell_running || novell_shutting_down) 
	return (NULL);

    /* only  1 system */
    if ((ipxStaticServSysInstance > 1) ||
        ((searchType == EXACT) && (ipxStaticServSysInstance != 1)))
        return (NULL);

    type = OctetStringToUlong(ipxStaticServType);

    /*
     * convert the ipxStaticServName OctetString into a "real" string
     * note that sstrncpy will copy n-1 characters, and copy '\0'
     * into the n'th byte
     */
    namelen = min(NOVELL_SERVER_NAME_LEN - 1, ipxStaticServName->length);
    sstrncpy(name, ipxStaticServName->octet_ptr, namelen+1);

    if(searchType == EXACT) {
	FOR_ALL_SAP_TYPES(sapq) {
	    if (sapq->server_type != type)
		continue;
	    FOR_ALL_SAPS_OF_TYPE(entry, sapq) {
		if ((entry->flags & NET_STATIC) &&
		    (entry->paths->nidb->idb->if_number ==
		     ipxStaticServCircIndex) &&
		    (strcmp(entry->server.server_name, name) == 0))
		    goto g_done;
	    }
	}
	g_done:
    } else { /* get next */
	if (ipxStaticServSysInstance < 1) {
	    ipxStaticServSysInstance = 1;
	    ipxStaticServCircIndex = 0;
	    name[0] = '\0';
	    namelen = 0;
	    type = 0;
	} 
	sapq = NULL;
 	FOR_ALL_SAPS(cur_entry, cur_sapq) {
	    if (cur_entry->flags & NET_STATIC) {
		c_circ = cur_entry->paths->nidb->idb->if_number - ipxStaticServCircIndex;
		c_namelen = strlen(cur_entry->server.server_name) - namelen;
		c_name = strcmp(cur_entry->server.server_name, name);
		c_type = cur_sapq->server_type - type;
		if (c_circ < 0 ||
		    (c_circ == 0 && c_namelen < 0) ||
		    (c_circ == 0 && c_namelen == 0 && c_name < 0) ||
		    (c_circ == 0 && c_namelen == 0 && c_name == 0 && c_type < 0))
		    continue;
		if (sapq != NULL) {
		    c_circ = cur_entry->paths->nidb->idb->if_number - entry->paths->nidb->idb->if_number;
		    c_namelen = strlen(cur_entry->server.server_name) -
			strlen(entry->server.server_name);
		    c_name = strcmp(cur_entry->server.server_name, 
				    entry->server.server_name);
		    c_type = cur_sapq->server_type - sapq->server_type;
		    if (c_circ > 0 ||
			(c_circ == 0 && c_namelen > 0) ||
			(c_circ == 0 && c_namelen == 0 && c_name > 0) ||
			(c_circ == 0 && c_namelen == 0 && c_name == 0 && c_type > 0))
			continue;
		}
		sapq = cur_sapq;
		entry = cur_entry;
	    }
	}
    }

    if (sapq == NULL)
	/* no need check entry != NULL 'cause entry != NULL if sapq != NULL */
	return (NULL);
    ipxStaticServEntryData.ipxStaticServSysInstance = ipxStaticServSysInstance;
    ipxStaticServEntryData.ipxStaticServCircIndex = entry->paths->nidb->idb->if_number;
    ipxStaticServEntryData.ipxStaticServName = &namestring;
    namestring.length = strlen(entry->server.server_name);
    namestring.octet_ptr = entry->server.server_name;
    ipxStaticServEntryData.ipxStaticServType = &servType;
    servType.length = TYPEBYTES;
    servType.octet_ptr = (uchar *) &sapq->server_type;
    ipxStaticServEntryData.ipxStaticServExistState = D_ipxStaticServExistState_on;
    ipxStaticServEntryData.ipxStaticServNetNum = &net;
    net.length = NETBYTES;
    net.octet_ptr = (uchar *)&entry->server.dnet;
    ipxStaticServEntryData.ipxStaticServNode = &node;
    node.length = IEEEBYTES;
    node.octet_ptr = (uchar *)&entry->server.dhost;
    ipxStaticServEntryData.ipxStaticServSocket = &socket;
    socket.length = SOCKETBYTES;
    socket.octet_ptr = (uchar *)&entry->server.dsock;
    ipxStaticServEntryData.ipxStaticServHopCount = entry->server.nethops;;

    return (&ipxStaticServEntryData);
}

#ifdef SETS
int
k_ipxStaticServEntry_set(
    ipxStaticServEntry_t *data,
    ContextInfo    *contextInfo,
    int             function)
{
  int namelen;
  ulong type, net, socket, hops;
  uchar name[NOVELL_SERVER_NAME_LEN];  
  uchar node[IEEEBYTES];
  
  namelen = 0;
  type = net = socket = hops = 0L;

  switch (function) {
  case DELETE:
    return(GEN_ERROR);
    break;
  case ADD_MODIFY:
    ieee_zero(node);
    if ((data != NULL) && (data->ipxStaticServHopCount)) {
      type = OctetStringToUlong(((ipxStaticServEntry_t *) data)->ipxStaticServType);

      namelen = min(NOVELL_SERVER_NAME_LEN - 1, data->ipxStaticServName->length);
      sstrncpy(name, data->ipxStaticServName->octet_ptr, namelen + 1);
      if (data->ipxStaticServNode != NULL)
	ieee_copy(data->ipxStaticServNode->octet_ptr, node); 
      net = OctetStringToUlong(data->ipxStaticServNetNum);
      socket = OctetStringToUlong(data->ipxStaticServSocket);
      hops = data->ipxStaticServHopCount;
      
      nov_sap_command(FALSE, (data->ipxStaticServExistState ==
			      D_ipxStaticServExistState_on), name, type,
		      net, node, socket, hops, IPX_STATIC_DEFINE_TYPE_NVGEN);
    }
    return(NO_ERROR);
  default:
    return (GEN_ERROR);
  }    
  return (GEN_ERROR);
}
#endif				       /* SETS */


static ulong get_circCount(void)
{
    idbtype *idb;
    ulong count;
    count = 0;
    FOR_ALL_SWIDBS(idb) {
	if (idb->novellnets) count++;
    }
    return (count);
}

static ulong snmp_ipxCircType(nidbtype *nidb)
{
if (nidb->idb->hwptr->status & IDB_BCAST)
     return (D_ipxCircType_broadcast);
if (nidb->idb->hwptr->status & IDB_SERIAL)
     return (D_ipxCircType_wanRIP);
return(D_ipxCircType_other);
}


static ulong snmp_ipxCircStaticStatus(nidbtype *nidb)
{
return(D_ipxCircStaticStatus_current);
}

static void snmp_ipxCircMedia(nidbtype *nidb, OctetString *mediaType)
{
    static ushort type;
    mediaType->length = 2;
/* check media type definitions in Novell NLSP spec. 1.0 p5-11 */
    if (nidb->idb->hwptr->status & IDB_BCAST)
	type = D_ipxCircMediaType_GenericLan; /* default LAN type */
    if (nidb->idb->hwptr->status & IDB_SERIAL)
	type = D_ipxCircMediaType_GenericWan; /* default WAN type */
    if (nidb->enctype == ET_NOVELL_ETHER)
	type = D_ipxCircMediaType_NovellEther;
    if (nidb->enctype == ET_SAP) {
	if (nidb->idb->hwptr->status & IDB_ETHER)
	    type = D_ipxCircMediaType_EtherSap;
	else if (nidb->idb->hwptr->status & IDB_TR)
	    type = D_ipxCircMediaType_TokenSap;
	else if (nidb->idb->hwptr->status & IDB_FDDI)
	    type = D_ipxCircMediaType_FddiSap;
    }
    if (nidb->enctype == ET_SNAP) {
	if (nidb->idb->hwptr->status & IDB_ETHER)
	    type = D_ipxCircMediaType_EtherSnap;
	else if (nidb->idb->hwptr->status & IDB_TR)
	    type = D_ipxCircMediaType_TokenSnap;
	else if (nidb->idb->hwptr->status & IDB_FDDI)
	    type = D_ipxCircMediaType_FddiSnap;
    }
    if (nidb->idb->hwptr->enctype == ET_PPP)
	type = D_ipxCircMediaType_PPP;
    if (is_x25(nidb->idb->hwptr))
	type = D_ipxCircMediaType_X25;
    if (nidb->idb->hwptr->enctype == ET_FR_IETF || 
	nidb->idb->hwptr->enctype == ET_FRAME_RELAY)
	type = D_ipxCircMediaType_Fr;
    if (nidb->idb->hwptr->status & IDB_ISDN)
	type = D_ipxCircMediaType_Isdn;

    mediaType->octet_ptr = (uchar *)&type;
}

static ulong snmp_getDestProc(novndbtype *p)
{
if (p->flags & NET_CONNECTED)
    return (D_ipxDestProtocol_local);
if (p->flags & NET_RIP)
    return (D_ipxDestProtocol_rip);
if (p->flags & NET_STATIC)
    return (D_ipxDestProtocol_static);
return (D_ipxDestProtocol_other);
}

static ulong snmp_getServProc(novell_sapentrytype *p)
{
if (p->flags & NET_CONNECTED)
    return (D_ipxServProtocol_local);
if (p->flags & NET_STATIC)
    return (D_ipxServProtocol_static);
return (D_ipxServProtocol_sap);
/* return (D_ipxServProtocol_other); */
}


/*
 * novell_ipx subsystem header
 */

#define MAJVERSION_novell_ipx 1
#define MINVERSION_novell_ipx 0
#define EDITVERSION_novell_ipx 0

SUBSYS_HEADER(ipxmib,
              MAJVERSION_novell_ipx,
              MINVERSION_novell_ipx,
              EDITVERSION_novell_ipx,
              init_novell_ipx,
              SUBSYS_CLASS_MANAGEMENT,
              "req: ipx",
              NULL);
      
