/* $Id: sr_novell_nlsp.c,v 3.5.8.5 1996/07/01 18:47:12 hampton Exp $
 * $Source: /release/112/cvs/Xsys/xns/sr_novell_nlsp.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * October 1994, John Wright (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1994-1996 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_novell_nlsp.c,v $
 * Revision 3.5.8.5  1996/07/01  18:47:12  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.5.8.4  1996/05/03  02:21:00  sluong
 * Branch: California_branch
 * IPX ACL Violation Logging, Plaining English Filters, Display SAP by
 * name,
 * NLSP MIBS, Scaleable RIP/SAP, Modularity, and SAP query by name.
 *
 * Revision 3.5.8.3  1996/04/19  17:55:17  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.5.8.2  1996/04/14  18:19:53  john
 * CSCdi54546:  System reloaded when snmp querying the NLSP neighbor table
 * Branch: California_branch
 *
 * Revision 3.5.8.1  1996/04/10  16:44:03  john
 * CSCdi40886:  NLSP mib returns wrong values for objects
 * Branch: California_branch
 *
 * Revision 3.5  1996/02/29  22:06:55  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.4  1996/01/18  15:58:46  anke
 * CSCdi46969:  Change empty req and/or seq strings in SUBSYS_HEADERs to
 *              NULL
 *              Five bytes saved is five bytes earned
 *
 * Revision 3.3  1995/12/14  08:30:25  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.2  1995/11/17  19:24:58  gstovall
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  14:00:21  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.3  1995/11/08  21:40:06  shaker
 * Merge Arkansas_branch into 11.1 mainline.
 *
 * Revision 2.2  1995/06/28  09:34:07  smackie
 * Repair widespread subsystem header braindamage. (CSCdi23568)
 *
 *   o Fix subsystem entry points to be foo(subsystype *) not foo(void)
 *   o Repair nonsensical and redundant subsystem sequences
 *   o Use NULL where no property is required
 *
 * Revision 2.1  1995/06/07  23:30:09  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include "subsys.h"
#include "interface.h"
#include "interface_private.h"
#include "../if/network.h"
#include "../snmp/snmp_api.h"
#include "sr_novell_nlsp.h"
#include "sr_novell_nlspdefs.h"
#include "sr_novell_nlsp-mib.h"
#include "novell.h"
#include "xns.h"
#include "novroute.h"
#include "novnlsp.h"
#include "../clns/clns_route.h"
#include "../clns/isis.h"
#include "../clns/isis_ipx.h"
#include "../clns/isis_externs.h"
#include "../clns/clns_externs.h"
#include "../clns/isis_inlines.h"
#include "ipx_registry.h"

#define NETBYTES 4
#define MAXBUFSIZE 100

void
init_novell_nlsp (subsystype *subsys)
{
    load_mib(novell_nlsp_OidList, novell_nlsp_OidListNum);
    load_oid(novell_nlsp_oid_table);
}









/*---------------------------------------------------------------------
 * Retrieve data from the nlspSysEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
nlspSysEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    nlspSysEntry_t *data;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            nlspSysInstance;

    data = NULL;
    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &nlspSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_nlspSysEntry_get(serialNum, contextInfo, arg, searchType, nlspSysInstance)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->nlspSysInstance;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_nlspSysInstance
      case I_nlspSysInstance:
	dp = &data->nlspSysInstance;
	break;
#endif				       /* I_nlspSysInstance */

#ifdef I_nlspSysState
      case I_nlspSysState:
	dp = &data->nlspSysState;
	break;
#endif				       /* I_nlspSysState */

#ifdef I_nlspSysID
      case I_nlspSysID:
	dp = MakeOctetString(data->nlspSysID->octet_ptr, data->nlspSysID->length);
	break;
#endif				       /* I_nlspSysID */

#ifdef I_nlspSysMinNonBcastLSPTransInt
      case I_nlspSysMinNonBcastLSPTransInt:
	dp = &data->nlspSysMinNonBcastLSPTransInt;
	break;
#endif				       /* I_nlspSysMinNonBcastLSPTransInt */

#ifdef I_nlspSysMinBcastLSPTransInt
      case I_nlspSysMinBcastLSPTransInt:
	dp = &data->nlspSysMinBcastLSPTransInt;
	break;
#endif				       /* I_nlspSysMinBcastLSPTransInt */

#ifdef I_nlspSysMinLSPGenInt
      case I_nlspSysMinLSPGenInt:
	dp = &data->nlspSysMinLSPGenInt;
	break;
#endif				       /* I_nlspSysMinLSPGenInt */

#ifdef I_nlspSysMaxLSPGenInt
      case I_nlspSysMaxLSPGenInt:
	dp = &data->nlspSysMaxLSPGenInt;
	break;
#endif				       /* I_nlspSysMaxLSPGenInt */

#ifdef I_nlspSysMaxLSPAge
      case I_nlspSysMaxLSPAge:
	dp = &data->nlspSysMaxLSPAge;
	break;
#endif				       /* I_nlspSysMaxLSPAge */

#ifdef I_nlspSysBcastHelloInt
      case I_nlspSysBcastHelloInt:
	dp = &data->nlspSysBcastHelloInt;
	break;
#endif				       /* I_nlspSysBcastHelloInt */

#ifdef I_nlspSysNonBcastHelloInt
      case I_nlspSysNonBcastHelloInt:
	dp = &data->nlspSysNonBcastHelloInt;
	break;
#endif				       /* I_nlspSysNonBcastHelloInt */

#ifdef I_nlspSysDRBcastHelloInt
      case I_nlspSysDRBcastHelloInt:
	dp = &data->nlspSysDRBcastHelloInt;
	break;
#endif				       /* I_nlspSysDRBcastHelloInt */

#ifdef I_nlspSysHoldTimeMultiplier
      case I_nlspSysHoldTimeMultiplier:
	dp = &data->nlspSysHoldTimeMultiplier;
	break;
#endif				       /* I_nlspSysHoldTimeMultiplier */

#ifdef I_nlspSysCompSNPInt
      case I_nlspSysCompSNPInt:
	dp = &data->nlspSysCompSNPInt;
	break;
#endif				       /* I_nlspSysCompSNPInt */

#ifdef I_nlspSysPartSNPInt
      case I_nlspSysPartSNPInt:
	dp = &data->nlspSysPartSNPInt;
	break;
#endif				       /* I_nlspSysPartSNPInt */

#ifdef I_nlspSysWaitTime
      case I_nlspSysWaitTime:
	dp = &data->nlspSysWaitTime;
	break;
#endif				       /* I_nlspSysWaitTime */

#ifdef I_nlspSysOrigL1LSPBufSize
      case I_nlspSysOrigL1LSPBufSize:
	dp = &data->nlspSysOrigL1LSPBufSize;
	break;
#endif				       /* I_nlspSysOrigL1LSPBufSize */

#ifdef I_nlspSysVersion
      case I_nlspSysVersion:
	dp = &data->nlspSysVersion;
	break;
#endif				       /* I_nlspSysVersion */

#ifdef I_nlspSysCorrLSPs
      case I_nlspSysCorrLSPs:
	dp = &data->nlspSysCorrLSPs;
	break;
#endif				       /* I_nlspSysCorrLSPs */

#ifdef I_nlspSysL1Overloaded
      case I_nlspSysL1Overloaded:
	dp = &data->nlspSysL1Overloaded;
	break;
#endif				       /* I_nlspSysL1Overloaded */

#ifdef I_nlspSysL1DbaseOverloads
      case I_nlspSysL1DbaseOverloads:
	dp = &data->nlspSysL1DbaseOverloads;
	break;
#endif				       /* I_nlspSysL1DbaseOverloads */

#ifdef I_nlspSysMaxSeqNums
      case I_nlspSysMaxSeqNums:
	dp = &data->nlspSysMaxSeqNums;
	break;
#endif				       /* I_nlspSysMaxSeqNums */

#ifdef I_nlspSysSeqNumSkips
      case I_nlspSysSeqNumSkips:
	dp = &data->nlspSysSeqNumSkips;
	break;
#endif				       /* I_nlspSysSeqNumSkips */

#ifdef I_nlspSysTransmittedLSPs
      case I_nlspSysTransmittedLSPs:
	dp = &data->nlspSysTransmittedLSPs;
	break;
#endif				       /* I_nlspSysTransmittedLSPs */

#ifdef I_nlspSysReceivedLSPs
      case I_nlspSysReceivedLSPs:
	dp = &data->nlspSysReceivedLSPs;
	break;
#endif				       /* I_nlspSysReceivedLSPs */

#ifdef I_nlspSysOwnLSPPurges
      case I_nlspSysOwnLSPPurges:
	dp = &data->nlspSysOwnLSPPurges;
	break;
#endif				       /* I_nlspSysOwnLSPPurges */

#ifdef I_nlspSysVersionErrors
      case I_nlspSysVersionErrors:
	dp = &data->nlspSysVersionErrors;
	break;
#endif				       /* I_nlspSysVersionErrors */

#ifdef I_nlspSysIncorrectPackets
      case I_nlspSysIncorrectPackets:
	dp = &data->nlspSysIncorrectPackets;
	break;
#endif				       /* I_nlspSysIncorrectPackets */

#ifdef I_nlspSysNearestL2DefaultExists
      case I_nlspSysNearestL2DefaultExists:
	dp = &data->nlspSysNearestL2DefaultExists;
	break;
#endif				       /* I_nlspSysNearestL2DefaultExists */

#ifdef I_nlspSysNearestL2DefaultRouter
      case I_nlspSysNearestL2DefaultRouter:
	dp = MakeOctetString(data->nlspSysNearestL2DefaultRouter->octet_ptr, data->nlspSysNearestL2DefaultRouter->length);
	break;
#endif				       /* I_nlspSysNearestL2DefaultRouter */

#ifdef I_nlspSysResourceFailures
      case I_nlspSysResourceFailures:
	dp = &data->nlspSysResourceFailures;
	break;
#endif				       /* I_nlspSysResourceFailures */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the nlspSysEntry data object.
 *---------------------------------------------------------------------*/
void
nlspSysEntry_free(nlspSysEntry_t *data)
/*    nlspSysEntry_t *data; */
{
    if (data != NULL) {
	if (data->nlspSysID != NULL) {
	    FreeOctetString(data->nlspSysID);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after nlspSysEntry set/undo
 *---------------------------------------------------------------------*/
static int
nlspSysEntry_cleanup(doList_t *trash)
/*    doList_t       *trash; */
{
    nlspSysEntry_free(trash->data);
#ifdef SR_SNMPv2
    nlspSysEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
nlspSysEntry_test(incoming, object, value, doHead, doCur, contextInfo)
    OID            *incoming;
    ObjectInfo     *object;
    ObjectSyntax   *value;
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
/*    VarBind        *vb = (VarBind *) NULL; */
    int             found;
    int             carry = 0;
    nlspSysEntry_t *nlspSysEntry;
    long            nlspSysInstance;

    /*
     * Validate the object instance
     * 
     */
    if (instLength != 1) {
	return NO_CREATION_ERROR;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &nlspSysInstance, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    nlspSysEntry = k_nlspSysEntry_get(-1, contextInfo, object->nominator, EXACT, nlspSysInstance);

#ifndef nlspSysEntry_READ_CREATE

    if (nlspSysEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* nlspSysEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == nlspSysEntry_set) &&
	    (((nlspSysEntry_t *) (dp->data)) != NULL) &&
	    (((nlspSysEntry_t *) (dp->data))->nlspSysInstance == nlspSysInstance)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(nlspSysEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(nlspSysEntry_t));

	dp->setMethod = nlspSysEntry_set;
	dp->cleanupMethod = nlspSysEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_nlspSysInstance, ((nlspSysEntry_t *) (dp->data))->valid);
	((nlspSysEntry_t *) (dp->data))->nlspSysInstance = nlspSysInstance;

#ifdef nlspSysEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (nlspSysEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, nlspSysEntry, sizeof(nlspSysEntry_t));

	    SET_ALL_VALID(((nlspSysEntry_t *) (dp->data))->valid);

	    ((nlspSysEntry_t *) (dp->data))->nlspSysID =
		CloneOctetString(nlspSysEntry->nlspSysID);

	} else {


	    /* Fill in default values here */
	   /* no reasnable defaults, don't set any */

	}
#endif				       /* nlspSysEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_nlspSysInstance
      case I_nlspSysInstance:

      if (value->sl_value > 1)
	return(WRONG_VALUE_ERROR);

	SET_VALID(I_nlspSysInstance, ((nlspSysEntry_t *) (dp->data))->valid);

	((nlspSysEntry_t *) (dp->data))->nlspSysInstance = value->sl_value;
	break;
#endif				       /* I_nlspSysInstance */

#ifdef I_nlspSysState
      case I_nlspSysState:


	if ((value->sl_value != D_nlspSysState_off) &&
	    (value->sl_value != D_nlspSysState_nlspLevel1Router))
	    return (WRONG_VALUE_ERROR);

	SET_VALID(I_nlspSysState, ((nlspSysEntry_t *) (dp->data))->valid);

	((nlspSysEntry_t *) (dp->data))->nlspSysState = value->sl_value;
	break;
#endif				       /* I_nlspSysState */

#ifdef I_nlspSysID
      case I_nlspSysID:

	SET_VALID(I_nlspSysID, ((nlspSysEntry_t *) (dp->data))->valid);

	if (((nlspSysEntry_t *) (dp->data))->nlspSysID != NULL) {
	    FreeOctetString(((nlspSysEntry_t *) (dp->data))->nlspSysID);
	}
	((nlspSysEntry_t *) (dp->data))->nlspSysID =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_nlspSysID */

#ifdef I_nlspSysMinNonBcastLSPTransInt
      case I_nlspSysMinNonBcastLSPTransInt:

      if (value->sl_value < 1 || value->sl_value > 30)
	return(WRONG_VALUE_ERROR);
	SET_VALID(I_nlspSysMinNonBcastLSPTransInt, ((nlspSysEntry_t *) (dp->data))->valid);

	((nlspSysEntry_t *) (dp->data))->nlspSysMinNonBcastLSPTransInt = value->sl_value;
	break;
#endif				       /* I_nlspSysMinNonBcastLSPTransInt */

#ifdef I_nlspSysMinBcastLSPTransInt
      case I_nlspSysMinBcastLSPTransInt:

      if (value->sl_value < 1 || value->sl_value > 30)
	return(WRONG_VALUE_ERROR);
	SET_VALID(I_nlspSysMinBcastLSPTransInt, ((nlspSysEntry_t *) (dp->data))->valid);

	((nlspSysEntry_t *) (dp->data))->nlspSysMinBcastLSPTransInt = value->sl_value;
	break;
#endif				       /* I_nlspSysMinBcastLSPTransInt */

#ifdef I_nlspSysMinLSPGenInt
      case I_nlspSysMinLSPGenInt:

      if (value->sl_value < 0 || value->sl_value > 120)
	return(WRONG_VALUE_ERROR);

	SET_VALID(I_nlspSysMinLSPGenInt, ((nlspSysEntry_t *) (dp->data))->valid);

	((nlspSysEntry_t *) (dp->data))->nlspSysMinLSPGenInt = value->sl_value;
	break;
#endif				       /* I_nlspSysMinLSPGenInt */

#ifdef I_nlspSysMaxLSPGenInt
      case I_nlspSysMaxLSPGenInt:

      if (value->sl_value < 1 || value->sl_value > 50000)
	return(WRONG_VALUE_ERROR);
	SET_VALID(I_nlspSysMaxLSPGenInt, ((nlspSysEntry_t *) (dp->data))->valid);

	((nlspSysEntry_t *) (dp->data))->nlspSysMaxLSPGenInt = value->sl_value;
	break;
#endif				       /* I_nlspSysMaxLSPGenInt */

#ifdef I_nlspSysMaxLSPAge
      case I_nlspSysMaxLSPAge:

      if (value->sl_value < 1 || value->sl_value > 50000)
	return(WRONG_VALUE_ERROR);
	SET_VALID(I_nlspSysMaxLSPAge, ((nlspSysEntry_t *) (dp->data))->valid);

	((nlspSysEntry_t *) (dp->data))->nlspSysMaxLSPAge = value->sl_value;
	break;
#endif				       /* I_nlspSysMaxLSPAge */

#ifdef I_nlspSysBcastHelloInt
      case I_nlspSysBcastHelloInt:

      if (value->sl_value < 1 || value->sl_value > 100)
	return(WRONG_VALUE_ERROR);
	SET_VALID(I_nlspSysBcastHelloInt, ((nlspSysEntry_t *) (dp->data))->valid);

	((nlspSysEntry_t *) (dp->data))->nlspSysBcastHelloInt = value->sl_value;
	break;
#endif				       /* I_nlspSysBcastHelloInt */

#ifdef I_nlspSysNonBcastHelloInt
      case I_nlspSysNonBcastHelloInt:

      if (value->sl_value < 1 || value->sl_value > 100)
	return(WRONG_VALUE_ERROR);
	SET_VALID(I_nlspSysNonBcastHelloInt, ((nlspSysEntry_t *) (dp->data))->valid);

	((nlspSysEntry_t *) (dp->data))->nlspSysNonBcastHelloInt = value->sl_value;
	break;
#endif				       /* I_nlspSysNonBcastHelloInt */

#ifdef I_nlspSysDRBcastHelloInt
      case I_nlspSysDRBcastHelloInt:

      if (value->sl_value < 1 || value->sl_value > 100)
	return(WRONG_VALUE_ERROR);
	SET_VALID(I_nlspSysDRBcastHelloInt, ((nlspSysEntry_t *) (dp->data))->valid);

	((nlspSysEntry_t *) (dp->data))->nlspSysDRBcastHelloInt = value->sl_value;
	break;
#endif				       /* I_nlspSysDRBcastHelloInt */

#ifdef I_nlspSysHoldTimeMultiplier
      case I_nlspSysHoldTimeMultiplier:

      if (value->sl_value < 2 || value->sl_value > 20)
	return(WRONG_VALUE_ERROR);
	SET_VALID(I_nlspSysHoldTimeMultiplier, ((nlspSysEntry_t *) (dp->data))->valid);

	((nlspSysEntry_t *) (dp->data))->nlspSysHoldTimeMultiplier = value->sl_value;
	break;
#endif				       /* I_nlspSysHoldTimeMultiplier */

#ifdef I_nlspSysCompSNPInt
      case I_nlspSysCompSNPInt:

      if (value->sl_value < 1 || value->sl_value > 600)
	return(WRONG_VALUE_ERROR);
	SET_VALID(I_nlspSysCompSNPInt, ((nlspSysEntry_t *) (dp->data))->valid);

	((nlspSysEntry_t *) (dp->data))->nlspSysCompSNPInt = value->sl_value;
	break;
#endif				       /* I_nlspSysCompSNPInt */

#ifdef I_nlspSysPartSNPInt
      case I_nlspSysPartSNPInt:

      if (value->sl_value < 1 || value->sl_value > 60)
	return(WRONG_VALUE_ERROR);
	SET_VALID(I_nlspSysPartSNPInt, ((nlspSysEntry_t *) (dp->data))->valid);

	((nlspSysEntry_t *) (dp->data))->nlspSysPartSNPInt = value->sl_value;
	break;
#endif				       /* I_nlspSysPartSNPInt */

#ifdef I_nlspSysWaitTime
      case I_nlspSysWaitTime:

      if (value->sl_value < 1 || value->sl_value > 300)
	return(WRONG_VALUE_ERROR);
	SET_VALID(I_nlspSysWaitTime, ((nlspSysEntry_t *) (dp->data))->valid);

	((nlspSysEntry_t *) (dp->data))->nlspSysWaitTime = value->sl_value;
	break;
#endif				       /* I_nlspSysWaitTime */

#ifdef I_nlspSysOrigL1LSPBufSize
      case I_nlspSysOrigL1LSPBufSize:

      if (value->sl_value < 512 || value->sl_value > 4096)
	return(WRONG_VALUE_ERROR);
	SET_VALID(I_nlspSysOrigL1LSPBufSize, ((nlspSysEntry_t *) (dp->data))->valid);

	((nlspSysEntry_t *) (dp->data))->nlspSysOrigL1LSPBufSize = value->sl_value;
	break;
#endif				       /* I_nlspSysOrigL1LSPBufSize */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in nlspSysEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
nlspSysEntry_set(doHead, doCur, contextInfo)
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    return (k_nlspSysEntry_set((nlspSysEntry_t *) (doCur->data),
			       contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the nlspSysAreaEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
nlspSysAreaEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
/*    int             instLength = incoming->length - object->oid.length; */
    int             arg = object->nominator;
    void           *dp;
    nlspSysAreaEntry_t *data;
    unsigned long   buffer[MAXBUFSIZE];
    OID             inst;
    int             carry;
    int             i;
    long            nlspSysAreaSysInstance;
    int             nlspSysAreaSysInstance_offset;
    OctetString    *nlspSysAreaNet;
    int             nlspSysAreaNet_offset;
    OctetString    *nlspSysAreaMask;
    int             nlspSysAreaMask_offset;
    int             index;
    int             final_index;

    data = NULL;
    nlspSysAreaSysInstance_offset = object->oid.length;
    nlspSysAreaNet_offset = nlspSysAreaSysInstance_offset + 1;
    nlspSysAreaMask_offset = nlspSysAreaNet_offset + 4;
    final_index = nlspSysAreaMask_offset + 4;

    if (searchType == EXACT) {
	if (final_index != incoming->length) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToFixedOctetString(incoming, nlspSysAreaMask_offset, &nlspSysAreaMask, searchType, &carry, 4)) < 0) {
	arg = -1;
    }
    if ((InstToFixedOctetString(incoming, nlspSysAreaNet_offset, &nlspSysAreaNet, searchType, &carry, 4)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, nlspSysAreaSysInstance_offset, &nlspSysAreaSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_nlspSysAreaEntry_get(serialNum, contextInfo, arg, searchType, nlspSysAreaSysInstance, nlspSysAreaNet, nlspSysAreaMask)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	inst.oid_ptr[index++] = (unsigned long) data->nlspSysAreaSysInstance;
	for (i = 0; i < data->nlspSysAreaNet->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->nlspSysAreaNet->octet_ptr[i];
	}

	for (i = 0; i < data->nlspSysAreaMask->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->nlspSysAreaMask->octet_ptr[i];
	}

	inst.length = index;
    }

    if (nlspSysAreaNet != NULL) {
	FreeOctetString(nlspSysAreaNet);
    }
    if (nlspSysAreaMask != NULL) {
	FreeOctetString(nlspSysAreaMask);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_nlspSysAreaSysInstance
      case I_nlspSysAreaSysInstance:
	dp = &data->nlspSysAreaSysInstance;
	break;
#endif				       /* I_nlspSysAreaSysInstance */

#ifdef I_nlspSysAreaNet
      case I_nlspSysAreaNet:
	dp = MakeOctetString(data->nlspSysAreaNet->octet_ptr, data->nlspSysAreaNet->length);
	break;
#endif				       /* I_nlspSysAreaNet */

#ifdef I_nlspSysAreaMask
      case I_nlspSysAreaMask:
	dp = MakeOctetString(data->nlspSysAreaMask->octet_ptr, data->nlspSysAreaMask->length);
	break;
#endif				       /* I_nlspSysAreaMask */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the nlspSysAreaEntry data object.
 *---------------------------------------------------------------------*/
void
nlspSysAreaEntry_free(nlspSysAreaEntry_t *data)
/*    nlspSysAreaEntry_t *data; */
{
    if (data != NULL) {
	if (data->nlspSysAreaNet != NULL) {
	    FreeOctetString(data->nlspSysAreaNet);
	}
	if (data->nlspSysAreaMask != NULL) {
	    FreeOctetString(data->nlspSysAreaMask);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after nlspSysAreaEntry set/undo
 *---------------------------------------------------------------------*/
static int
nlspSysAreaEntry_cleanup(doList_t *trash)
/*    doList_t       *trash; */
{
    nlspSysAreaEntry_free(trash->data);
#ifdef SR_SNMPv2
    nlspSysAreaEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
nlspSysAreaEntry_test(incoming, object, value, doHead, doCur, contextInfo)
    OID            *incoming;
    ObjectInfo     *object;
    ObjectSyntax   *value;
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
/*    int             instLength = incoming->length - object->oid.length; */
    doList_t       *dp;
/*    VarBind        *vb = (VarBind *) NULL; */
    int             found;
    int             carry = 0;
    nlspSysAreaEntry_t *nlspSysAreaEntry;
    long            nlspSysAreaSysInstance;
    int             nlspSysAreaSysInstance_offset;
    OctetString    *nlspSysAreaNet;
    int             nlspSysAreaNet_offset;
    OctetString    *nlspSysAreaMask;
    int             nlspSysAreaMask_offset;
    int             final_index;

    /*
     * Validate the object instance
     * 
     */
    nlspSysAreaSysInstance_offset = object->oid.length;
    nlspSysAreaNet_offset = nlspSysAreaSysInstance_offset + 1;
    nlspSysAreaMask_offset = nlspSysAreaNet_offset + 4;
    final_index = nlspSysAreaMask_offset + 4;

    if (final_index != incoming->length) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, nlspSysAreaSysInstance_offset, &nlspSysAreaSysInstance, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToFixedOctetString(incoming, nlspSysAreaNet_offset, &nlspSysAreaNet, EXACT, &carry, 4)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToFixedOctetString(incoming, nlspSysAreaMask_offset, &nlspSysAreaMask, EXACT, &carry, 4)) < 0) {
	return (NO_CREATION_ERROR);
    }
    nlspSysAreaEntry = k_nlspSysAreaEntry_get(-1, contextInfo, object->nominator, EXACT, nlspSysAreaSysInstance, nlspSysAreaNet, nlspSysAreaMask);

#ifndef nlspSysAreaEntry_READ_CREATE

    if (nlspSysAreaEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* nlspSysAreaEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == nlspSysAreaEntry_set) &&
	    (((nlspSysAreaEntry_t *) (dp->data)) != NULL) &&
	    (((nlspSysAreaEntry_t *) (dp->data))->nlspSysAreaSysInstance == nlspSysAreaSysInstance) &&
	    (((nlspSysAreaEntry_t *) (dp->data))->nlspSysAreaNet == nlspSysAreaNet) &&
	    (((nlspSysAreaEntry_t *) (dp->data))->nlspSysAreaMask == nlspSysAreaMask)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(nlspSysAreaEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(nlspSysAreaEntry_t));

	dp->setMethod = nlspSysAreaEntry_set;
	dp->cleanupMethod = nlspSysAreaEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_nlspSysAreaSysInstance, ((nlspSysAreaEntry_t *) (dp->data))->valid);
	((nlspSysAreaEntry_t *) (dp->data))->nlspSysAreaSysInstance = nlspSysAreaSysInstance;

	SET_VALID(I_nlspSysAreaNet, ((nlspSysAreaEntry_t *) (dp->data))->valid);
	((nlspSysAreaEntry_t *) (dp->data))->nlspSysAreaNet = nlspSysAreaNet;

	SET_VALID(I_nlspSysAreaMask, ((nlspSysAreaEntry_t *) (dp->data))->valid);
	((nlspSysAreaEntry_t *) (dp->data))->nlspSysAreaMask = nlspSysAreaMask;

#ifdef nlspSysAreaEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (nlspSysAreaEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, nlspSysAreaEntry, sizeof(nlspSysAreaEntry_t));

	    SET_ALL_VALID(((nlspSysAreaEntry_t *) (dp->data))->valid);

	    ((nlspSysAreaEntry_t *) (dp->data))->nlspSysAreaNet =
		CloneOctetString(nlspSysAreaEntry->nlspSysAreaNet);

	    ((nlspSysAreaEntry_t *) (dp->data))->nlspSysAreaMask =
		CloneOctetString(nlspSysAreaEntry->nlspSysAreaMask);

	} else {


	    /* Fill in default values here */
	   /* no reasnable defaults, don't set any */


	}
#endif				       /* nlspSysAreaEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_nlspSysAreaSysInstance
      case I_nlspSysAreaSysInstance:

	SET_VALID(I_nlspSysAreaSysInstance, ((nlspSysAreaEntry_t *) (dp->data))->valid);

	((nlspSysAreaEntry_t *) (dp->data))->nlspSysAreaSysInstance = value->sl_value;
	break;
#endif				       /* I_nlspSysAreaSysInstance */

#ifdef I_nlspSysAreaNet
      case I_nlspSysAreaNet:

	SET_VALID(I_nlspSysAreaNet, ((nlspSysAreaEntry_t *) (dp->data))->valid);

	if (((nlspSysAreaEntry_t *) (dp->data))->nlspSysAreaNet != NULL) {
	    FreeOctetString(((nlspSysAreaEntry_t *) (dp->data))->nlspSysAreaNet);
	}
	((nlspSysAreaEntry_t *) (dp->data))->nlspSysAreaNet =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_nlspSysAreaNet */

#ifdef I_nlspSysAreaMask
      case I_nlspSysAreaMask:

	SET_VALID(I_nlspSysAreaMask, ((nlspSysAreaEntry_t *) (dp->data))->valid);

	if (((nlspSysAreaEntry_t *) (dp->data))->nlspSysAreaMask != NULL) {
	    FreeOctetString(((nlspSysAreaEntry_t *) (dp->data))->nlspSysAreaMask);
	}
	((nlspSysAreaEntry_t *) (dp->data))->nlspSysAreaMask =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_nlspSysAreaMask */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in nlspSysAreaEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
nlspSysAreaEntry_set(doHead, doCur, contextInfo)
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    return (k_nlspSysAreaEntry_set((nlspSysAreaEntry_t *) (doCur->data),
				   contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the nlspActAreaEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
nlspActAreaEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
/*    int             instLength = incoming->length - object->oid.length; */
    int             arg = object->nominator;
    void           *dp;
    nlspActAreaEntry_t *data;
    unsigned long   buffer[MAXBUFSIZE];
    OID             inst;
    int             carry;
    int             i;
    long            nlspActAreaSysInstance;
    int             nlspActAreaSysInstance_offset;
    OctetString    *nlspActAreaNet;
    int             nlspActAreaNet_offset;
    OctetString    *nlspActAreaMask;
    int             nlspActAreaMask_offset;
    int             index;
    int             final_index;

    data = NULL;
    nlspActAreaSysInstance_offset = object->oid.length;
    nlspActAreaNet_offset = nlspActAreaSysInstance_offset + 1;
    nlspActAreaMask_offset = nlspActAreaNet_offset + 4;
    final_index = nlspActAreaMask_offset + 4;

    if (searchType == EXACT) {
	if (final_index != incoming->length) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToFixedOctetString(incoming, nlspActAreaMask_offset, &nlspActAreaMask, searchType, &carry, 4)) < 0) {
	arg = -1;
    }
    if ((InstToFixedOctetString(incoming, nlspActAreaNet_offset, &nlspActAreaNet, searchType, &carry, 4)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, nlspActAreaSysInstance_offset, &nlspActAreaSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_nlspActAreaEntry_get(serialNum, contextInfo, arg, searchType, nlspActAreaSysInstance, nlspActAreaNet, nlspActAreaMask)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	inst.oid_ptr[index++] = (unsigned long) data->nlspActAreaSysInstance;
	for (i = 0; i < data->nlspActAreaNet->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->nlspActAreaNet->octet_ptr[i];
	}

	for (i = 0; i < data->nlspActAreaMask->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->nlspActAreaMask->octet_ptr[i];
	}

	inst.length = index;
    }

    if (nlspActAreaNet != NULL) {
	FreeOctetString(nlspActAreaNet);
    }
    if (nlspActAreaMask != NULL) {
	FreeOctetString(nlspActAreaMask);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_nlspActAreaSysInstance
      case I_nlspActAreaSysInstance:
	dp = &data->nlspActAreaSysInstance;
	break;
#endif				       /* I_nlspActAreaSysInstance */

#ifdef I_nlspActAreaNet
      case I_nlspActAreaNet:
	dp = MakeOctetString(data->nlspActAreaNet->octet_ptr, data->nlspActAreaNet->length);
	break;
#endif				       /* I_nlspActAreaNet */

#ifdef I_nlspActAreaMask
      case I_nlspActAreaMask:
	dp = MakeOctetString(data->nlspActAreaMask->octet_ptr, data->nlspActAreaMask->length);
	break;
#endif				       /* I_nlspActAreaMask */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the nlspActAreaEntry data object.
 *---------------------------------------------------------------------*/
void
nlspActAreaEntry_free(nlspActAreaEntry_t *data)
/*    nlspActAreaEntry_t *data; */
{
    if (data != NULL) {
	if (data->nlspActAreaNet != NULL) {
	    FreeOctetString(data->nlspActAreaNet);
	}
	if (data->nlspActAreaMask != NULL) {
	    FreeOctetString(data->nlspActAreaMask);
	}
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after nlspActAreaEntry set/undo
 *---------------------------------------------------------------------*/
static int
nlspActAreaEntry_cleanup(doList_t *trash)
/*    doList_t       *trash; */
{
    nlspActAreaEntry_free(trash->data);
#ifdef SR_SNMPv2
    nlspActAreaEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
nlspActAreaEntry_test(incoming, object, value, doHead, doCur, contextInfo)
    OID            *incoming;
    ObjectInfo     *object;
    ObjectSyntax   *value;
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
/*    int             instLength = incoming->length - object->oid.length; */
    doList_t       *dp;
/*    VarBind        *vb = (VarBind *) NULL; */
    int             found;
    int             carry = 0;
    nlspActAreaEntry_t *nlspActAreaEntry;
    long            nlspActAreaSysInstance;
    int             nlspActAreaSysInstance_offset;
    OctetString    *nlspActAreaNet;
    int             nlspActAreaNet_offset;
    OctetString    *nlspActAreaMask;
    int             nlspActAreaMask_offset;
    int             final_index;

    /*
     * Validate the object instance
     * 
     */
    nlspActAreaSysInstance_offset = object->oid.length;
    nlspActAreaNet_offset = nlspActAreaSysInstance_offset + 1;
    nlspActAreaMask_offset = nlspActAreaNet_offset + 4;
    final_index = nlspActAreaMask_offset + 4;

    if (final_index != incoming->length) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, nlspActAreaSysInstance_offset, &nlspActAreaSysInstance, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToFixedOctetString(incoming, nlspActAreaNet_offset, &nlspActAreaNet, EXACT, &carry, 4)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToFixedOctetString(incoming, nlspActAreaMask_offset, &nlspActAreaMask, EXACT, &carry, 4)) < 0) {
	return (NO_CREATION_ERROR);
    }
    nlspActAreaEntry = k_nlspActAreaEntry_get(-1, contextInfo, object->nominator, EXACT, nlspActAreaSysInstance, nlspActAreaNet, nlspActAreaMask);

#ifndef nlspActAreaEntry_READ_CREATE

    if (nlspActAreaEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* nlspActAreaEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == nlspActAreaEntry_set) &&
	    (((nlspActAreaEntry_t *) (dp->data)) != NULL) &&
	    (((nlspActAreaEntry_t *) (dp->data))->nlspActAreaSysInstance == nlspActAreaSysInstance) &&
	    (((nlspActAreaEntry_t *) (dp->data))->nlspActAreaNet == nlspActAreaNet) &&
	    (((nlspActAreaEntry_t *) (dp->data))->nlspActAreaMask == nlspActAreaMask)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(nlspActAreaEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(nlspActAreaEntry_t));

	dp->setMethod = nlspActAreaEntry_set;
	dp->cleanupMethod = nlspActAreaEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_nlspActAreaSysInstance, ((nlspActAreaEntry_t *) (dp->data))->valid);
	((nlspActAreaEntry_t *) (dp->data))->nlspActAreaSysInstance = nlspActAreaSysInstance;

	SET_VALID(I_nlspActAreaNet, ((nlspActAreaEntry_t *) (dp->data))->valid);
	((nlspActAreaEntry_t *) (dp->data))->nlspActAreaNet = nlspActAreaNet;

	SET_VALID(I_nlspActAreaMask, ((nlspActAreaEntry_t *) (dp->data))->valid);
	((nlspActAreaEntry_t *) (dp->data))->nlspActAreaMask = nlspActAreaMask;

#ifdef nlspActAreaEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (nlspActAreaEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, nlspActAreaEntry, sizeof(nlspActAreaEntry_t));

	    SET_ALL_VALID(((nlspActAreaEntry_t *) (dp->data))->valid);

	    ((nlspActAreaEntry_t *) (dp->data))->nlspActAreaNet =
		CloneOctetString(nlspActAreaEntry->nlspActAreaNet);

	    ((nlspActAreaEntry_t *) (dp->data))->nlspActAreaMask =
		CloneOctetString(nlspActAreaEntry->nlspActAreaMask);

	} else {


	    /* Fill in default values here */
	   /* no reasnable defaults, don't set any */


	}
#endif				       /* nlspActAreaEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_nlspActAreaSysInstance
      case I_nlspActAreaSysInstance:

	SET_VALID(I_nlspActAreaSysInstance, ((nlspActAreaEntry_t *) (dp->data))->valid);

	((nlspActAreaEntry_t *) (dp->data))->nlspActAreaSysInstance = value->sl_value;
	break;
#endif				       /* I_nlspActAreaSysInstance */

#ifdef I_nlspActAreaNet
      case I_nlspActAreaNet:

	SET_VALID(I_nlspActAreaNet, ((nlspActAreaEntry_t *) (dp->data))->valid);

	if (((nlspActAreaEntry_t *) (dp->data))->nlspActAreaNet != NULL) {
	    FreeOctetString(((nlspActAreaEntry_t *) (dp->data))->nlspActAreaNet);
	}
	((nlspActAreaEntry_t *) (dp->data))->nlspActAreaNet =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_nlspActAreaNet */

#ifdef I_nlspActAreaMask
      case I_nlspActAreaMask:

	SET_VALID(I_nlspActAreaMask, ((nlspActAreaEntry_t *) (dp->data))->valid);

	if (((nlspActAreaEntry_t *) (dp->data))->nlspActAreaMask != NULL) {
	    FreeOctetString(((nlspActAreaEntry_t *) (dp->data))->nlspActAreaMask);
	}
	((nlspActAreaEntry_t *) (dp->data))->nlspActAreaMask =
	    MakeOctetString(value->os_value->octet_ptr, value->os_value->length);

	break;
#endif				       /* I_nlspActAreaMask */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in nlspActAreaEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
nlspActAreaEntry_set(doHead, doCur, contextInfo)
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    return (k_nlspActAreaEntry_set((nlspActAreaEntry_t *) (doCur->data),
				   contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the nlspCircEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
nlspCircEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    nlspCircEntry_t *data;
    unsigned long   buffer[2];
    OID             inst;
    int             carry;
    long            nlspCircSysInstance;
    long            nlspCircIndex;

    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 2
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 2) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 1 + object->oid.length, &nlspCircIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &nlspCircSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_nlspCircEntry_get(serialNum, contextInfo, arg, searchType, nlspCircSysInstance, nlspCircIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 2;
	inst.oid_ptr[0] = data->nlspCircSysInstance;
	inst.oid_ptr[1] = data->nlspCircIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_nlspCircSysInstance
      case I_nlspCircSysInstance:
	dp = &data->nlspCircSysInstance;
	break;
#endif				       /* I_nlspCircSysInstance */

#ifdef I_nlspCircIndex
      case I_nlspCircIndex:
	dp = &data->nlspCircIndex;
	break;
#endif				       /* I_nlspCircIndex */

#ifdef I_nlspCircState
      case I_nlspCircState:
	dp = &data->nlspCircState;
	break;
#endif				       /* I_nlspCircState */

#ifdef I_nlspCircPace
      case I_nlspCircPace:
	dp = &data->nlspCircPace;
	break;
#endif				       /* I_nlspCircPace */

#ifdef I_nlspCircHelloTimer
      case I_nlspCircHelloTimer:
	dp = &data->nlspCircHelloTimer;
	break;
#endif				       /* I_nlspCircHelloTimer */

#ifdef I_nlspCircL1DefaultCost
      case I_nlspCircL1DefaultCost:
	dp = &data->nlspCircL1DefaultCost;
	break;
#endif				       /* I_nlspCircL1DefaultCost */

#ifdef I_nlspCircL1DesRouterPriority
      case I_nlspCircL1DesRouterPriority:
	dp = &data->nlspCircL1DesRouterPriority;
	break;
#endif				       /* I_nlspCircL1DesRouterPriority */

#ifdef I_nlspCircL1CircID
      case I_nlspCircL1CircID:
	dp = MakeOctetString(data->nlspCircL1CircID->octet_ptr, data->nlspCircL1CircID->length);
	break;
#endif				       /* I_nlspCircL1CircID */

#ifdef I_nlspCircL1DesRouter
      case I_nlspCircL1DesRouter:
	dp = MakeOctetString(data->nlspCircL1DesRouter->octet_ptr, data->nlspCircL1DesRouter->length);
	break;
#endif				       /* I_nlspCircL1DesRouter */

#ifdef I_nlspCircLANL1DesRouterChanges
      case I_nlspCircLANL1DesRouterChanges:
	dp = &data->nlspCircLANL1DesRouterChanges;
	break;
#endif				       /* I_nlspCircLANL1DesRouterChanges */

#ifdef I_nlspCircNeighChanges
      case I_nlspCircNeighChanges:
	dp = &data->nlspCircNeighChanges;
	break;
#endif				       /* I_nlspCircNeighChanges */

#ifdef I_nlspCircRejNeighbors
      case I_nlspCircRejNeighbors:
	dp = &data->nlspCircRejNeighbors;
	break;
#endif				       /* I_nlspCircRejNeighbors */

#ifdef I_nlspCircOutPackets
      case I_nlspCircOutPackets:
	dp = &data->nlspCircOutPackets;
	break;
#endif				       /* I_nlspCircOutPackets */

#ifdef I_nlspCircInPackets
      case I_nlspCircInPackets:
	dp = &data->nlspCircInPackets;
	break;
#endif				       /* I_nlspCircInPackets */

#ifdef I_nlspCircActualMaxPacketSize
      case I_nlspCircActualMaxPacketSize:
	dp = &data->nlspCircActualMaxPacketSize;
	break;
#endif				       /* I_nlspCircActualMaxPacketSize */

#ifdef I_nlspCircPSNPsSent
      case I_nlspCircPSNPsSent:
	dp = &data->nlspCircPSNPsSent;
	break;
#endif				       /* I_nlspCircPSNPsSent */

#ifdef I_nlspCircPSNPsReceived
      case I_nlspCircPSNPsReceived:
	dp = &data->nlspCircPSNPsReceived;
	break;
#endif				       /* I_nlspCircPSNPsReceived */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the nlspCircEntry data object.
 *---------------------------------------------------------------------*/
void
nlspCircEntry_free(nlspCircEntry_t *data)
/*    nlspCircEntry_t *data; */
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after nlspCircEntry set/undo
 *---------------------------------------------------------------------*/
static int
nlspCircEntry_cleanup(doList_t *trash)
/*    doList_t       *trash; */
{
    nlspCircEntry_free(trash->data);
#ifdef SR_SNMPv2
    nlspCircEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
nlspCircEntry_test(incoming, object, value, doHead, doCur, contextInfo)
    OID            *incoming;
    ObjectInfo     *object;
    ObjectSyntax   *value;
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
/*    VarBind        *vb = (VarBind *) NULL; */
    int             found;
    int             carry = 0;
    nlspCircEntry_t *nlspCircEntry;
    long            nlspCircSysInstance;
    long            nlspCircIndex;

    /*
     * Validate the object instance
     * 
     */
    if (instLength != 2) {
	return NO_CREATION_ERROR;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &nlspCircSysInstance, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, 1 + object->oid.length, &nlspCircIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    nlspCircEntry = k_nlspCircEntry_get(-1, contextInfo, object->nominator, EXACT, nlspCircSysInstance, nlspCircIndex);

#ifndef nlspCircEntry_READ_CREATE

    if (nlspCircEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* nlspCircEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == nlspCircEntry_set) &&
	    (((nlspCircEntry_t *) (dp->data)) != NULL) &&
	    (((nlspCircEntry_t *) (dp->data))->nlspCircSysInstance == nlspCircSysInstance) &&
	(((nlspCircEntry_t *) (dp->data))->nlspCircIndex == nlspCircIndex)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(nlspCircEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(nlspCircEntry_t));

	dp->setMethod = nlspCircEntry_set;
	dp->cleanupMethod = nlspCircEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_nlspCircSysInstance, ((nlspCircEntry_t *) (dp->data))->valid);
	((nlspCircEntry_t *) (dp->data))->nlspCircSysInstance = nlspCircSysInstance;

	SET_VALID(I_nlspCircIndex, ((nlspCircEntry_t *) (dp->data))->valid);
	((nlspCircEntry_t *) (dp->data))->nlspCircIndex = nlspCircIndex;

#ifdef nlspCircEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (nlspCircEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, nlspCircEntry, sizeof(nlspCircEntry_t));

	    SET_ALL_VALID(((nlspCircEntry_t *) (dp->data))->valid);

	} else {


	    /* Fill in default values here */
	   /* no reasnable defaults, don't set any */


	}
#endif				       /* nlspCircEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_nlspCircSysInstance
      case I_nlspCircSysInstance:

	SET_VALID(I_nlspCircSysInstance, ((nlspCircEntry_t *) (dp->data))->valid);

	((nlspCircEntry_t *) (dp->data))->nlspCircSysInstance = value->sl_value;
	break;
#endif				       /* I_nlspCircSysInstance */

#ifdef I_nlspCircIndex
      case I_nlspCircIndex:

	SET_VALID(I_nlspCircIndex, ((nlspCircEntry_t *) (dp->data))->valid);

	((nlspCircEntry_t *) (dp->data))->nlspCircIndex = value->sl_value;
	break;
#endif				       /* I_nlspCircIndex */

#ifdef I_nlspCircState
      case I_nlspCircState:

	SET_VALID(I_nlspCircState, ((nlspCircEntry_t *) (dp->data))->valid);

	((nlspCircEntry_t *) (dp->data))->nlspCircState = value->sl_value;
	break;
#endif				       /* I_nlspCircState */

#ifdef I_nlspCircPace
      case I_nlspCircPace:

	SET_VALID(I_nlspCircPace, ((nlspCircEntry_t *) (dp->data))->valid);

	((nlspCircEntry_t *) (dp->data))->nlspCircPace = value->sl_value;
	break;
#endif				       /* I_nlspCircPace */

#ifdef I_nlspCircHelloTimer
      case I_nlspCircHelloTimer:

	if ((value->sl_value < 1) || (value->sl_value > 100))
          return (WRONG_VALUE_ERROR);

	SET_VALID(I_nlspCircHelloTimer, ((nlspCircEntry_t *) (dp->data))->valid);

	((nlspCircEntry_t *) (dp->data))->nlspCircHelloTimer = value->sl_value;
	break;
#endif				       /* I_nlspCircHelloTimer */

#ifdef I_nlspCircL1DefaultCost
      case I_nlspCircL1DefaultCost:

	SET_VALID(I_nlspCircL1DefaultCost, ((nlspCircEntry_t *) (dp->data))->valid);

	((nlspCircEntry_t *) (dp->data))->nlspCircL1DefaultCost = value->sl_value;
	break;
#endif				       /* I_nlspCircL1DefaultCost */

#ifdef I_nlspCircL1DesRouterPriority
      case I_nlspCircL1DesRouterPriority:

	if ((value->sl_value < 1) || (value->sl_value > 127))
	  return (WRONG_VALUE_ERROR);
	SET_VALID(I_nlspCircL1DesRouterPriority, ((nlspCircEntry_t *) (dp->data))->valid);

	((nlspCircEntry_t *) (dp->data))->nlspCircL1DesRouterPriority = value->sl_value;
	break;
#endif				       /* I_nlspCircL1DesRouterPriority */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in nlspCircEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
nlspCircEntry_set(doHead, doCur, contextInfo)
    doList_t       *doHead;
    doList_t       *doCur;
    ContextInfo    *contextInfo;
{
    return (k_nlspCircEntry_set((nlspCircEntry_t *) (doCur->data),
				contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the nlspDestEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
nlspDestEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    nlspDestEntry_t *data = NULL;
    unsigned long   buffer[5];
    OID             inst;
    int             carry;
    int             i;
    long            nlspDestSysInstance;
    int             nlspDestSysInstance_offset;
    OctetString    *nlspDestNetNum;
    int             nlspDestNetNum_offset;
    int             index;
    int             final_index;

    nlspDestSysInstance_offset = object->oid.length;
    nlspDestNetNum_offset = nlspDestSysInstance_offset + 1;
    final_index = nlspDestNetNum_offset + 4;

    if (searchType == EXACT) {
	if (instLength != 5) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToFixedOctetString(incoming, nlspDestNetNum_offset, &nlspDestNetNum, searchType, &carry, 4)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, nlspDestSysInstance_offset, &nlspDestSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_nlspDestEntry_get(serialNum, contextInfo, arg, searchType, nlspDestSysInstance, nlspDestNetNum)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	inst.oid_ptr[index++] = (unsigned long) data->nlspDestSysInstance;
	for (i = 0; i < data->nlspDestNetNum->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->nlspDestNetNum->octet_ptr[i];
	}

	inst.length = index;
    }

    if (nlspDestNetNum != NULL) {
	FreeOctetString(nlspDestNetNum);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_nlspDestSysInstance
      case I_nlspDestSysInstance:
	dp = &data->nlspDestSysInstance;
	break;
#endif				       /* I_nlspDestSysInstance */

#ifdef I_nlspDestNetNum
      case I_nlspDestNetNum:
	dp = MakeOctetString(data->nlspDestNetNum->octet_ptr, data->nlspDestNetNum->length);
	break;
#endif				       /* I_nlspDestNetNum */

#ifdef I_nlspDestID
      case I_nlspDestID:
	dp = MakeOctetString(data->nlspDestID->octet_ptr, data->nlspDestID->length);
	break;
#endif				       /* I_nlspDestID */

#ifdef I_nlspDestEstDelay
      case I_nlspDestEstDelay:
	dp = &data->nlspDestEstDelay;
	break;
#endif				       /* I_nlspDestEstDelay */

#ifdef I_nlspDestEstThroughput
      case I_nlspDestEstThroughput:
	dp = &data->nlspDestEstThroughput;
	break;
#endif				       /* I_nlspDestEstThroughput */

#ifdef I_nlspDestNextHopID
      case I_nlspDestNextHopID:
	dp = MakeOctetString(data->nlspDestNextHopID->octet_ptr, data->nlspDestNextHopID->length);
	break;
#endif				       /* I_nlspDestNextHopID */

#ifdef I_nlspDestCost
      case I_nlspDestCost:
	dp = &data->nlspDestCost;
	break;
#endif				       /* I_nlspDestCost */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the nlspNeighEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
nlspNeighEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    nlspNeighEntry_t *data;
    unsigned long   buffer[3];
    OID             inst;
    int             carry;
    long            nlspNeighSysInstance;
    long            nlspNeighCircIndex;
    long            nlspNeighIndex;

    data = NULL;

    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 3
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 3) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 2 + object->oid.length, &nlspNeighIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 1 + object->oid.length, &nlspNeighCircIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &nlspNeighSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_nlspNeighEntry_get(serialNum, contextInfo, arg, searchType, nlspNeighSysInstance, nlspNeighCircIndex, nlspNeighIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 3;
	inst.oid_ptr[0] = data->nlspNeighSysInstance;
	inst.oid_ptr[1] = data->nlspNeighCircIndex;
	inst.oid_ptr[2] = data->nlspNeighIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_nlspNeighSysInstance
      case I_nlspNeighSysInstance:
	dp = &data->nlspNeighSysInstance;
	break;
#endif				       /* I_nlspNeighSysInstance */

#ifdef I_nlspNeighCircIndex
      case I_nlspNeighCircIndex:
	dp = &data->nlspNeighCircIndex;
	break;
#endif				       /* I_nlspNeighCircIndex */

#ifdef I_nlspNeighIndex
      case I_nlspNeighIndex:
	dp = &data->nlspNeighIndex;
	break;
#endif				       /* I_nlspNeighIndex */

#ifdef I_nlspNeighState
      case I_nlspNeighState:
	dp = &data->nlspNeighState;
	break;
#endif				       /* I_nlspNeighState */

#ifdef I_nlspNeighNICAddress
      case I_nlspNeighNICAddress:
	dp = MakeOctetString(data->nlspNeighNICAddress->octet_ptr, data->nlspNeighNICAddress->length);
	break;
#endif				       /* I_nlspNeighNICAddress */

#ifdef I_nlspNeighSysType
      case I_nlspNeighSysType:
	dp = &data->nlspNeighSysType;
	break;
#endif				       /* I_nlspNeighSysType */

#ifdef I_nlspNeighSysID
      case I_nlspNeighSysID:
	dp = MakeOctetString(data->nlspNeighSysID->octet_ptr, data->nlspNeighSysID->length);
	break;
#endif				       /* I_nlspNeighSysID */

#ifdef I_nlspNeighName
      case I_nlspNeighName:
	dp = MakeOctetString(data->nlspNeighName->octet_ptr, data->nlspNeighName->length);
	break;
#endif				       /* I_nlspNeighName */

#ifdef I_nlspNeighUsage
      case I_nlspNeighUsage:
	dp = &data->nlspNeighUsage;
	break;
#endif				       /* I_nlspNeighUsage */

#ifdef I_nlspNeighHoldTimer
      case I_nlspNeighHoldTimer:
	dp = &data->nlspNeighHoldTimer;
	break;
#endif				       /* I_nlspNeighHoldTimer */

#ifdef I_nlspNeighRemainingTime
      case I_nlspNeighRemainingTime:
	dp = &data->nlspNeighRemainingTime;
	break;
#endif				       /* I_nlspNeighRemainingTime */

#ifdef I_nlspNeighPriority
      case I_nlspNeighPriority:
	dp = &data->nlspNeighPriority;
	break;
#endif				       /* I_nlspNeighPriority */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the nlspIDMapEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
nlspIDMapEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
/*    int             instLength = incoming->length - object->oid.length; */
    int             arg = object->nominator;
    void           *dp;
    nlspIDMapEntry_t *data;
    unsigned long   buffer[MAXBUFSIZE];
    OID             inst;
    int             carry;
    int             i;
    long            nlspIDMapSysInstance;
    int             nlspIDMapSysInstance_offset;
    OctetString    *nlspIDMapID;
    int             nlspIDMapID_offset;
    int             index;
    int             final_index;

    data = NULL;

    nlspIDMapSysInstance_offset = object->oid.length;
    nlspIDMapID_offset = nlspIDMapSysInstance_offset + 1;
    final_index = nlspIDMapID_offset + GetVariableIndexLength(incoming, nlspIDMapID_offset);

    if (searchType == EXACT) {
	if (final_index != incoming->length) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToVariableOctetString(incoming, nlspIDMapID_offset, &nlspIDMapID, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, nlspIDMapSysInstance_offset, &nlspIDMapSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_nlspIDMapEntry_get(serialNum, contextInfo, arg, searchType, nlspIDMapSysInstance, nlspIDMapID)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	inst.oid_ptr[index++] = (unsigned long) data->nlspIDMapSysInstance;
	inst.oid_ptr[index++] = data->nlspIDMapID->length;
	for (i = 0; i < data->nlspIDMapID->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->nlspIDMapID->octet_ptr[i];
	}

	inst.length = index;
    }

    if (nlspIDMapID != NULL) {
	FreeOctetString(nlspIDMapID);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_nlspIDMapSysInstance
      case I_nlspIDMapSysInstance:
	dp = &data->nlspIDMapSysInstance;
	break;
#endif				       /* I_nlspIDMapSysInstance */

#ifdef I_nlspIDMapID
      case I_nlspIDMapID:
	dp = MakeOctetString(data->nlspIDMapID->octet_ptr, data->nlspIDMapID->length);
	break;
#endif				       /* I_nlspIDMapID */

#ifdef I_nlspIDMapServerName
      case I_nlspIDMapServerName:
	dp = MakeOctetString(data->nlspIDMapServerName->octet_ptr, data->nlspIDMapServerName->length);
	break;
#endif				       /* I_nlspIDMapServerName */

#ifdef I_nlspIDMapNetNum
      case I_nlspIDMapNetNum:
	dp = MakeOctetString(data->nlspIDMapNetNum->octet_ptr, data->nlspIDMapNetNum->length);
	break;
#endif				       /* I_nlspIDMapNetNum */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the nlspNetMapEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
nlspNetMapEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
/*    int             instLength = incoming->length - object->oid.length; */
    int             arg = object->nominator;
    void           *dp;
    nlspNetMapEntry_t *data;
    unsigned long   buffer[MAXBUFSIZE];
    OID             inst;
    int             carry;
    int             i;
    long            nlspNetMapSysInstance;
    int             nlspNetMapSysInstance_offset;
    OctetString    *nlspNetMapNetNum;
    int             nlspNetMapNetNum_offset;
    int             index;
    int             final_index;

    data = NULL;

    nlspNetMapSysInstance_offset = object->oid.length;
    nlspNetMapNetNum_offset = nlspNetMapSysInstance_offset + 1;
    final_index = nlspNetMapNetNum_offset + GetVariableIndexLength(incoming, nlspNetMapNetNum_offset);

    if (searchType == EXACT) {
	if (final_index != incoming->length) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToVariableOctetString(incoming, nlspNetMapNetNum_offset, &nlspNetMapNetNum, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, nlspNetMapSysInstance_offset, &nlspNetMapSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_nlspNetMapEntry_get(serialNum, contextInfo, arg, searchType, nlspNetMapSysInstance, nlspNetMapNetNum)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	inst.oid_ptr[index++] = (unsigned long) data->nlspNetMapSysInstance;
	inst.oid_ptr[index++] = data->nlspNetMapNetNum->length;
	for (i = 0; i < data->nlspNetMapNetNum->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->nlspNetMapNetNum->octet_ptr[i];
	}

	inst.length = index;
    }

    if (nlspNetMapNetNum != NULL) {
	FreeOctetString(nlspNetMapNetNum);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_nlspNetMapSysInstance
      case I_nlspNetMapSysInstance:
	dp = &data->nlspNetMapSysInstance;
	break;
#endif				       /* I_nlspNetMapSysInstance */

#ifdef I_nlspNetMapNetNum
      case I_nlspNetMapNetNum:
	dp = MakeOctetString(data->nlspNetMapNetNum->octet_ptr, data->nlspNetMapNetNum->length);
	break;
#endif				       /* I_nlspNetMapNetNum */

#ifdef I_nlspNetMapServerName
      case I_nlspNetMapServerName:
	dp = MakeOctetString(data->nlspNetMapServerName->octet_ptr, data->nlspNetMapServerName->length);
	break;
#endif				       /* I_nlspNetMapServerName */

#ifdef I_nlspNetMapID
      case I_nlspNetMapID:
	dp = MakeOctetString(data->nlspNetMapID->octet_ptr, data->nlspNetMapID->length);
	break;
#endif				       /* I_nlspNetMapID */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the nlspNameMapEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
nlspNameMapEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
/*    int             instLength = incoming->length - object->oid.length; */
    int             arg = object->nominator;
    void           *dp;
    nlspNameMapEntry_t *data;
    unsigned long   buffer[MAXBUFSIZE];
    OID             inst;
    int             carry;
    int             i;
    long            nlspNameMapSysInstance;
    int             nlspNameMapSysInstance_offset;
    OctetString    *nlspNameMapServerName;
    int             nlspNameMapServerName_offset;
    int             index;
    int             final_index;

    data = NULL;

    nlspNameMapSysInstance_offset = object->oid.length;
    nlspNameMapServerName_offset = nlspNameMapSysInstance_offset + 1;
    final_index = nlspNameMapServerName_offset + GetVariableIndexLength(incoming, nlspNameMapServerName_offset);

    if (searchType == EXACT) {
	if (final_index != incoming->length) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToVariableOctetString(incoming, nlspNameMapServerName_offset, &nlspNameMapServerName, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, nlspNameMapSysInstance_offset, &nlspNameMapSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_nlspNameMapEntry_get(serialNum, contextInfo, arg, searchType, nlspNameMapSysInstance, nlspNameMapServerName)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	inst.oid_ptr[index++] = (unsigned long) data->nlspNameMapSysInstance;
	inst.oid_ptr[index++] = data->nlspNameMapServerName->length;
	for (i = 0; i < data->nlspNameMapServerName->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->nlspNameMapServerName->octet_ptr[i];
	}

	inst.length = index;
    }

    if (nlspNameMapServerName != NULL) {
	FreeOctetString(nlspNameMapServerName);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_nlspNameMapSysInstance
      case I_nlspNameMapSysInstance:
	dp = &data->nlspNameMapSysInstance;
	break;
#endif				       /* I_nlspNameMapSysInstance */

#ifdef I_nlspNameMapServerName
      case I_nlspNameMapServerName:
	dp = MakeOctetString(data->nlspNameMapServerName->octet_ptr, data->nlspNameMapServerName->length);
	break;
#endif				       /* I_nlspNameMapServerName */

#ifdef I_nlspNameMapNetNum
      case I_nlspNameMapNetNum:
	dp = MakeOctetString(data->nlspNameMapNetNum->octet_ptr, data->nlspNameMapNetNum->length);
	break;
#endif				       /* I_nlspNameMapNetNum */

#ifdef I_nlspNameMapID
      case I_nlspNameMapID:
	dp = MakeOctetString(data->nlspNameMapID->octet_ptr, data->nlspNameMapID->length);
	break;
#endif				       /* I_nlspNameMapID */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the nlspNodeEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
nlspNodeEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
/*    int             instLength = incoming->length - object->oid.length; */
    int             arg = object->nominator;
    void           *dp;
    nlspNodeEntry_t *data;
    unsigned long   buffer[MAXBUFSIZE];
    OID             inst;
    int             carry;
    int             i;
    long            nlspNodeSysInstance;
    int             nlspNodeSysInstance_offset;
    OctetString    *nlspNodeID;
    int             nlspNodeID_offset;
    int             index;
    int             final_index;

    data = NULL;

    nlspNodeSysInstance_offset = object->oid.length;
    nlspNodeID_offset = nlspNodeSysInstance_offset + 1;
    final_index = nlspNodeID_offset + GetVariableIndexLength(incoming, nlspNodeID_offset);

    if (searchType == EXACT) {
	if (final_index != incoming->length) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToVariableOctetString(incoming, nlspNodeID_offset, &nlspNodeID, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, nlspNodeSysInstance_offset, &nlspNodeSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_nlspNodeEntry_get(serialNum, contextInfo, arg, searchType, nlspNodeSysInstance, nlspNodeID)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	inst.oid_ptr[index++] = (unsigned long) data->nlspNodeSysInstance;
	inst.oid_ptr[index++] = data->nlspNodeID->length;
	for (i = 0; i < data->nlspNodeID->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->nlspNodeID->octet_ptr[i];
	}

	inst.length = index;
    }

    if (nlspNodeID != NULL) {
	FreeOctetString(nlspNodeID);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_nlspNodeSysInstance
      case I_nlspNodeSysInstance:
	dp = &data->nlspNodeSysInstance;
	break;
#endif				       /* I_nlspNodeSysInstance */

#ifdef I_nlspNodeID
      case I_nlspNodeID:
	dp = MakeOctetString(data->nlspNodeID->octet_ptr, data->nlspNodeID->length);
	break;
#endif				       /* I_nlspNodeID */

#ifdef I_nlspNodeNetNum
      case I_nlspNodeNetNum:
	dp = MakeOctetString(data->nlspNodeNetNum->octet_ptr, data->nlspNodeNetNum->length);
	break;
#endif				       /* I_nlspNodeNetNum */

#ifdef I_nlspNodeType
      case I_nlspNodeType:
	dp = &data->nlspNodeType;
	break;
#endif				       /* I_nlspNodeType */

#ifdef I_nlspNodeEstDelay
      case I_nlspNodeEstDelay:
	dp = &data->nlspNodeEstDelay;
	break;
#endif				       /* I_nlspNodeEstDelay */

#ifdef I_nlspNodeEstThroughput
      case I_nlspNodeEstThroughput:
	dp = &data->nlspNodeEstThroughput;
	break;
#endif				       /* I_nlspNodeEstThroughput */

#ifdef I_nlspNodeMaxPacketSize
      case I_nlspNodeMaxPacketSize:
	dp = &data->nlspNodeMaxPacketSize;
	break;
#endif				       /* I_nlspNodeMaxPacketSize */

#ifdef I_nlspNodeCost
      case I_nlspNodeCost:
	dp = &data->nlspNodeCost;
	break;
#endif				       /* I_nlspNodeCost */

#ifdef I_nlspNodeOverload
      case I_nlspNodeOverload:
	dp = &data->nlspNodeOverload;
	break;
#endif				       /* I_nlspNodeOverload */

#ifdef I_nlspNodeReachable
      case I_nlspNodeReachable:
	dp = &data->nlspNodeReachable;
	break;
#endif				       /* I_nlspNodeReachable */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the nlspLinkEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
nlspLinkEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
/*    int             instLength = incoming->length - object->oid.length; */
    int             arg = object->nominator;
    void           *dp;
    nlspLinkEntry_t *data;
    unsigned long   buffer[MAXBUFSIZE];
    OID             inst;
    int             carry;
    int             i;
    long            nlspLinkSysInstance;
    int             nlspLinkSysInstance_offset;
    OctetString    *nlspLinkNLSPID;
    int             nlspLinkNLSPID_offset;
    long            nlspLinkIndex;
    int             nlspLinkIndex_offset;
    int             index;
    int             final_index;

    data = NULL;

    nlspLinkSysInstance_offset = object->oid.length;
    nlspLinkNLSPID_offset = nlspLinkSysInstance_offset + 1;
    nlspLinkIndex_offset = nlspLinkNLSPID_offset + GetVariableIndexLength(incoming, nlspLinkNLSPID_offset);
    final_index = nlspLinkIndex_offset + 1;

    if (searchType == EXACT) {
	if (final_index != incoming->length) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, nlspLinkIndex_offset, &nlspLinkIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToVariableOctetString(incoming, nlspLinkNLSPID_offset, &nlspLinkNLSPID, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, nlspLinkSysInstance_offset, &nlspLinkSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_nlspLinkEntry_get(serialNum, contextInfo, arg, searchType, nlspLinkSysInstance, nlspLinkNLSPID, nlspLinkIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	inst.oid_ptr[index++] = (unsigned long) data->nlspLinkSysInstance;
	inst.oid_ptr[index++] = data->nlspLinkNLSPID->length;
	for (i = 0; i < data->nlspLinkNLSPID->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->nlspLinkNLSPID->octet_ptr[i];
	}

	inst.oid_ptr[index++] = (unsigned long) data->nlspLinkIndex;
	inst.length = index;
    }

    if (nlspLinkNLSPID != NULL) {
	FreeOctetString(nlspLinkNLSPID);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_nlspLinkSysInstance
      case I_nlspLinkSysInstance:
	dp = &data->nlspLinkSysInstance;
	break;
#endif				       /* I_nlspLinkSysInstance */

#ifdef I_nlspLinkNLSPID
      case I_nlspLinkNLSPID:
	dp = MakeOctetString(data->nlspLinkNLSPID->octet_ptr, data->nlspLinkNLSPID->length);
	break;
#endif				       /* I_nlspLinkNLSPID */

#ifdef I_nlspLinkIndex
      case I_nlspLinkIndex:
	dp = &data->nlspLinkIndex;
	break;
#endif				       /* I_nlspLinkIndex */

#ifdef I_nlspLinkNeighNLSPID
      case I_nlspLinkNeighNLSPID:
	dp = MakeOctetString(data->nlspLinkNeighNLSPID->octet_ptr, data->nlspLinkNeighNLSPID->length);
	break;
#endif				       /* I_nlspLinkNeighNLSPID */

#ifdef I_nlspLinkFromNeighCost
      case I_nlspLinkFromNeighCost:
	dp = &data->nlspLinkFromNeighCost;
	break;
#endif				       /* I_nlspLinkFromNeighCost */

#ifdef I_nlspLinkMaxPacketSize
      case I_nlspLinkMaxPacketSize:
	dp = &data->nlspLinkMaxPacketSize;
	break;
#endif				       /* I_nlspLinkMaxPacketSize */

#ifdef I_nlspLinkThroughput
      case I_nlspLinkThroughput:
	dp = &data->nlspLinkThroughput;
	break;
#endif				       /* I_nlspLinkThroughput */

#ifdef I_nlspLinkDelay
      case I_nlspLinkDelay:
	dp = &data->nlspLinkDelay;
	break;
#endif				       /* I_nlspLinkDelay */

#ifdef I_nlspLinkMediaType
      case I_nlspLinkMediaType:
	dp = MakeOctetString(data->nlspLinkMediaType->octet_ptr, data->nlspLinkMediaType->length);
	break;
#endif				       /* I_nlspLinkMediaType */

#ifdef I_nlspLinkToNeighCost
      case I_nlspLinkToNeighCost:
	dp = &data->nlspLinkToNeighCost;
	break;
#endif				       /* I_nlspLinkToNeighCost */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the nlspPathEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
nlspPathEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
/*    int             instLength = incoming->length - object->oid.length; */
    int             arg = object->nominator;
    void           *dp;
    nlspPathEntry_t *data;
    unsigned long   buffer[MAXBUFSIZE];
    OID             inst;
    int             carry;
    int             i;
    long            nlspPathSysInstance;
    int             nlspPathSysInstance_offset;
    OctetString    *nlspPathDestNLSPID;
    int             nlspPathDestNLSPID_offset;
    long            nlspPathLinkIndex;
    int             nlspPathLinkIndex_offset;
    int             index;
    int             final_index;

    data = NULL;

    nlspPathSysInstance_offset = object->oid.length;
    nlspPathDestNLSPID_offset = nlspPathSysInstance_offset + 1;
    nlspPathLinkIndex_offset = nlspPathDestNLSPID_offset + GetVariableIndexLength(incoming, nlspPathDestNLSPID_offset);
    final_index = nlspPathLinkIndex_offset + 1;

    if (searchType == EXACT) {
	if (final_index != incoming->length) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, nlspPathLinkIndex_offset, &nlspPathLinkIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToVariableOctetString(incoming, nlspPathDestNLSPID_offset, &nlspPathDestNLSPID, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, nlspPathSysInstance_offset, &nlspPathSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_nlspPathEntry_get(serialNum, contextInfo, arg, searchType, nlspPathSysInstance, nlspPathDestNLSPID, nlspPathLinkIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	inst.oid_ptr[index++] = (unsigned long) data->nlspPathSysInstance;
	inst.oid_ptr[index++] = data->nlspPathDestNLSPID->length;
	for (i = 0; i < data->nlspPathDestNLSPID->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->nlspPathDestNLSPID->octet_ptr[i];
	}

	inst.oid_ptr[index++] = (unsigned long) data->nlspPathLinkIndex;
	inst.length = index;
    }

    if (nlspPathDestNLSPID != NULL) {
	FreeOctetString(nlspPathDestNLSPID);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_nlspPathSysInstance
      case I_nlspPathSysInstance:
	dp = &data->nlspPathSysInstance;
	break;
#endif				       /* I_nlspPathSysInstance */

#ifdef I_nlspPathDestNLSPID
      case I_nlspPathDestNLSPID:
	dp = MakeOctetString(data->nlspPathDestNLSPID->octet_ptr, data->nlspPathDestNLSPID->length);
	break;
#endif				       /* I_nlspPathDestNLSPID */

#ifdef I_nlspPathLinkIndex
      case I_nlspPathLinkIndex:
	dp = &data->nlspPathLinkIndex;
	break;
#endif				       /* I_nlspPathLinkIndex */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the nlspGraphXRouteEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
nlspGraphXRouteEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
/*    int             instLength = incoming->length - object->oid.length; */
    int             arg = object->nominator;
    void           *dp;
    nlspGraphXRouteEntry_t *data;
    unsigned long   buffer[MAXBUFSIZE];
    OID             inst;
    int             carry;
    int             i;
    long            nlspGraphXRouteSysInstance;
    int             nlspGraphXRouteSysInstance_offset;
    OctetString    *nlspGraphXRouteNLSPID;
    int             nlspGraphXRouteNLSPID_offset;
    OctetString    *nlspGraphXRouteNetNum;
    int             nlspGraphXRouteNetNum_offset;
    int             index;
    int             final_index;

    data = NULL;

    nlspGraphXRouteSysInstance_offset = object->oid.length;
    nlspGraphXRouteNLSPID_offset = nlspGraphXRouteSysInstance_offset + 1;
    nlspGraphXRouteNetNum_offset = nlspGraphXRouteNLSPID_offset + GetVariableIndexLength(incoming, nlspGraphXRouteNLSPID_offset);
    final_index = nlspGraphXRouteNetNum_offset + GetVariableIndexLength(incoming, nlspGraphXRouteNetNum_offset);

    if (searchType == EXACT) {
	if (final_index != incoming->length) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToVariableOctetString(incoming, nlspGraphXRouteNetNum_offset, &nlspGraphXRouteNetNum, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToVariableOctetString(incoming, nlspGraphXRouteNLSPID_offset, &nlspGraphXRouteNLSPID, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, nlspGraphXRouteSysInstance_offset, &nlspGraphXRouteSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_nlspGraphXRouteEntry_get(serialNum, contextInfo, arg, searchType, nlspGraphXRouteSysInstance, nlspGraphXRouteNLSPID, nlspGraphXRouteNetNum)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	inst.oid_ptr[index++] = (unsigned long) data->nlspGraphXRouteSysInstance;
	inst.oid_ptr[index++] = data->nlspGraphXRouteNLSPID->length;
	for (i = 0; i < data->nlspGraphXRouteNLSPID->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->nlspGraphXRouteNLSPID->octet_ptr[i];
	}

	inst.oid_ptr[index++] = data->nlspGraphXRouteNetNum->length;
	for (i = 0; i < data->nlspGraphXRouteNetNum->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->nlspGraphXRouteNetNum->octet_ptr[i];
	}

	inst.length = index;
    }

    if (nlspGraphXRouteNLSPID != NULL) {
	FreeOctetString(nlspGraphXRouteNLSPID);
    }
    if (nlspGraphXRouteNetNum != NULL) {
	FreeOctetString(nlspGraphXRouteNetNum);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_nlspGraphXRouteSysInstance
      case I_nlspGraphXRouteSysInstance:
	dp = &data->nlspGraphXRouteSysInstance;
	break;
#endif				       /* I_nlspGraphXRouteSysInstance */

#ifdef I_nlspGraphXRouteNLSPID
      case I_nlspGraphXRouteNLSPID:
	dp = MakeOctetString(data->nlspGraphXRouteNLSPID->octet_ptr, data->nlspGraphXRouteNLSPID->length);
	break;
#endif				       /* I_nlspGraphXRouteNLSPID */

#ifdef I_nlspGraphXRouteNetNum
      case I_nlspGraphXRouteNetNum:
	dp = MakeOctetString(data->nlspGraphXRouteNetNum->octet_ptr, data->nlspGraphXRouteNetNum->length);
	break;
#endif				       /* I_nlspGraphXRouteNetNum */

#ifdef I_nlspGraphXRouteCost
      case I_nlspGraphXRouteCost:
	dp = &data->nlspGraphXRouteCost;
	break;
#endif				       /* I_nlspGraphXRouteCost */

#ifdef I_nlspGraphXRouteHopCount
      case I_nlspGraphXRouteHopCount:
	dp = &data->nlspGraphXRouteHopCount;
	break;
#endif				       /* I_nlspGraphXRouteHopCount */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the nlspGraphServEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
nlspGraphServEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
/*    int             instLength = incoming->length - object->oid.length; */
    int             arg = object->nominator;
    void           *dp;
    nlspGraphServEntry_t *data;
    unsigned long   buffer[MAXBUFSIZE];
    OID             inst;
    int             carry;
    int             i;
    long            nlspGraphServSysInstance;
    int             nlspGraphServSysInstance_offset;
    OctetString    *nlspGraphServNLSPID;
    int             nlspGraphServNLSPID_offset;
    OctetString    *nlspGraphServName;
    int             nlspGraphServName_offset;
    OctetString    *nlspGraphServTypeValue;
    int             nlspGraphServTypeValue_offset;
    int             index;
    int             final_index;

    data = NULL;

    nlspGraphServSysInstance_offset = object->oid.length;
    nlspGraphServNLSPID_offset = nlspGraphServSysInstance_offset + 1;
    nlspGraphServName_offset = nlspGraphServNLSPID_offset + GetVariableIndexLength(incoming, nlspGraphServNLSPID_offset);
    nlspGraphServTypeValue_offset = nlspGraphServName_offset + GetVariableIndexLength(incoming, nlspGraphServName_offset);
    final_index = nlspGraphServTypeValue_offset + 2;

    if (searchType == EXACT) {
	if (final_index != incoming->length) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToFixedOctetString(incoming, nlspGraphServTypeValue_offset, &nlspGraphServTypeValue, searchType, &carry, 2)) < 0) {
	arg = -1;
    }
    if ((InstToVariableOctetString(incoming, nlspGraphServName_offset, &nlspGraphServName, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToVariableOctetString(incoming, nlspGraphServNLSPID_offset, &nlspGraphServNLSPID, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, nlspGraphServSysInstance_offset, &nlspGraphServSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_nlspGraphServEntry_get(serialNum, contextInfo, arg, searchType, nlspGraphServSysInstance, nlspGraphServNLSPID, nlspGraphServName, nlspGraphServTypeValue)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	inst.oid_ptr[index++] = (unsigned long) data->nlspGraphServSysInstance;
	inst.oid_ptr[index++] = data->nlspGraphServNLSPID->length;
	for (i = 0; i < data->nlspGraphServNLSPID->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->nlspGraphServNLSPID->octet_ptr[i];
	}

	inst.oid_ptr[index++] = data->nlspGraphServName->length;
	for (i = 0; i < data->nlspGraphServName->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->nlspGraphServName->octet_ptr[i];
	}

	for (i = 0; i < data->nlspGraphServTypeValue->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->nlspGraphServTypeValue->octet_ptr[i];
	}

	inst.length = index;
    }

    if (nlspGraphServNLSPID != NULL) {
	FreeOctetString(nlspGraphServNLSPID);
    }
    if (nlspGraphServName != NULL) {
	FreeOctetString(nlspGraphServName);
    }
    if (nlspGraphServTypeValue != NULL) {
	FreeOctetString(nlspGraphServTypeValue);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_nlspGraphServSysInstance
      case I_nlspGraphServSysInstance:
	dp = &data->nlspGraphServSysInstance;
	break;
#endif				       /* I_nlspGraphServSysInstance */

#ifdef I_nlspGraphServNLSPID
      case I_nlspGraphServNLSPID:
	dp = MakeOctetString(data->nlspGraphServNLSPID->octet_ptr, data->nlspGraphServNLSPID->length);
	break;
#endif				       /* I_nlspGraphServNLSPID */

#ifdef I_nlspGraphServName
      case I_nlspGraphServName:
	dp = MakeOctetString(data->nlspGraphServName->octet_ptr, data->nlspGraphServName->length);
	break;
#endif				       /* I_nlspGraphServName */

#ifdef I_nlspGraphServTypeValue
      case I_nlspGraphServTypeValue:
	dp = MakeOctetString(data->nlspGraphServTypeValue->octet_ptr, data->nlspGraphServTypeValue->length);
	break;
#endif				       /* I_nlspGraphServTypeValue */

#ifdef I_nlspGraphServType
      case I_nlspGraphServType:
	dp = &data->nlspGraphServType;
	break;
#endif				       /* I_nlspGraphServType */

#ifdef I_nlspGraphServNetNum
      case I_nlspGraphServNetNum:
	dp = MakeOctetString(data->nlspGraphServNetNum->octet_ptr, data->nlspGraphServNetNum->length);
	break;
#endif				       /* I_nlspGraphServNetNum */

#ifdef I_nlspGraphServNode
      case I_nlspGraphServNode:
	dp = MakeOctetString(data->nlspGraphServNode->octet_ptr, data->nlspGraphServNode->length);
	break;
#endif				       /* I_nlspGraphServNode */

#ifdef I_nlspGraphServSocket
      case I_nlspGraphServSocket:
	dp = MakeOctetString(data->nlspGraphServSocket->octet_ptr, data->nlspGraphServSocket->length);
	break;
#endif				       /* I_nlspGraphServSocket */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the nlspLSPEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
nlspLSPEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
/*    int             instLength = incoming->length - object->oid.length; */
    int             arg = object->nominator;
    void           *dp;
    nlspLSPEntry_t *data;
    unsigned long   buffer[MAXBUFSIZE];
    OID             inst;
    int             carry;
    int             i;
    long            nlspLSPSysInstance;
    int             nlspLSPSysInstance_offset;
    OctetString    *nlspLSPID;
    int             nlspLSPID_offset;
    int             index;
    int             final_index;

    data = NULL;

    nlspLSPSysInstance_offset = object->oid.length;
    nlspLSPID_offset = nlspLSPSysInstance_offset + 1;
    final_index = nlspLSPID_offset + 8;

    if (searchType == EXACT) {
	if (final_index != incoming->length) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToFixedOctetString(incoming, nlspLSPID_offset, &nlspLSPID, searchType, &carry, 8)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, nlspLSPSysInstance_offset, &nlspLSPSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_nlspLSPEntry_get(serialNum, contextInfo, arg, searchType, nlspLSPSysInstance, nlspLSPID)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	inst.oid_ptr[index++] = (unsigned long) data->nlspLSPSysInstance;
	for (i = 0; i < data->nlspLSPID->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->nlspLSPID->octet_ptr[i];
	}

	inst.length = index;
    }

    if (nlspLSPID != NULL) {
	FreeOctetString(nlspLSPID);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_nlspLSPSysInstance
      case I_nlspLSPSysInstance:
	dp = &data->nlspLSPSysInstance;
	break;
#endif				       /* I_nlspLSPSysInstance */

#ifdef I_nlspLSPID
      case I_nlspLSPID:
	dp = MakeOctetString(data->nlspLSPID->octet_ptr, data->nlspLSPID->length);
	break;
#endif				       /* I_nlspLSPID */

#ifdef I_nlspLSPLifetime
      case I_nlspLSPLifetime:
	dp = &data->nlspLSPLifetime;
	break;
#endif				       /* I_nlspLSPLifetime */

#ifdef I_nlspLSPSeqNum
      case I_nlspLSPSeqNum:
	dp = &data->nlspLSPSeqNum;
	break;
#endif				       /* I_nlspLSPSeqNum */

#ifdef I_nlspLSPChecksum
      case I_nlspLSPChecksum:
	dp = &data->nlspLSPChecksum;
	break;
#endif				       /* I_nlspLSPChecksum */

#ifdef I_nlspLSPRouterType
      case I_nlspLSPRouterType:
	dp = &data->nlspLSPRouterType;
	break;
#endif				       /* I_nlspLSPRouterType */

#ifdef I_nlspLSPOverload
      case I_nlspLSPOverload:
	dp = &data->nlspLSPOverload;
	break;
#endif				       /* I_nlspLSPOverload */

#ifdef I_nlspLSPHeader
      case I_nlspLSPHeader:
	dp = MakeOctetString(data->nlspLSPHeader->octet_ptr, data->nlspLSPHeader->length);
	break;
#endif				       /* I_nlspLSPHeader */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

/*---------------------------------------------------------------------
 * Retrieve data from the nlspLSPOptEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
nlspLSPOptEntry_get(incoming, object, searchType, contextInfo, serialNum)
    OID            *incoming;
    ObjectInfo     *object;
    int             searchType;
    ContextInfo    *contextInfo;
    int             serialNum;
{
/*    int             instLength = incoming->length - object->oid.length; */
    int             arg = object->nominator;
    void           *dp;
    nlspLSPOptEntry_t *data;
    unsigned long   buffer[MAXBUFSIZE];
    OID             inst;
    int             carry;
    int             i;
    long            nlspLSPOptSysInstance;
    int             nlspLSPOptSysInstance_offset;
    OctetString    *nlspLSPOptLSPID;
    int             nlspLSPOptLSPID_offset;
    long            nlspLSPOptIndex;
    int             nlspLSPOptIndex_offset;
    int             index;
    int             final_index;

    data = NULL;

    nlspLSPOptSysInstance_offset = object->oid.length;
    nlspLSPOptLSPID_offset = nlspLSPOptSysInstance_offset + 1;
    nlspLSPOptIndex_offset = nlspLSPOptLSPID_offset + 8;
    final_index = nlspLSPOptIndex_offset + 1;

    if (searchType == EXACT) {
	if (final_index != incoming->length) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, nlspLSPOptIndex_offset, &nlspLSPOptIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToFixedOctetString(incoming, nlspLSPOptLSPID_offset, &nlspLSPOptLSPID, searchType, &carry, 8)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, nlspLSPOptSysInstance_offset, &nlspLSPOptSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_nlspLSPOptEntry_get(serialNum, contextInfo, arg, searchType, nlspLSPOptSysInstance, nlspLSPOptLSPID, nlspLSPOptIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	index = 0;
	inst.oid_ptr[index++] = (unsigned long) data->nlspLSPOptSysInstance;
	for (i = 0; i < data->nlspLSPOptLSPID->length; i++) {
	    inst.oid_ptr[index++] = (unsigned long) data->nlspLSPOptLSPID->octet_ptr[i];
	}

	inst.oid_ptr[index++] = (unsigned long) data->nlspLSPOptIndex;
	inst.length = index;
    }

    if (nlspLSPOptLSPID != NULL) {
	FreeOctetString(nlspLSPOptLSPID);
    }
    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_nlspLSPOptSysInstance
      case I_nlspLSPOptSysInstance:
	dp = &data->nlspLSPOptSysInstance;
	break;
#endif				       /* I_nlspLSPOptSysInstance */

#ifdef I_nlspLSPOptLSPID
      case I_nlspLSPOptLSPID:
	dp = MakeOctetString(data->nlspLSPOptLSPID->octet_ptr, data->nlspLSPOptLSPID->length);
	break;
#endif				       /* I_nlspLSPOptLSPID */

#ifdef I_nlspLSPOptIndex
      case I_nlspLSPOptIndex:
	dp = &data->nlspLSPOptIndex;
	break;
#endif				       /* I_nlspLSPOptIndex */

#ifdef I_nlspLSPOptCode
      case I_nlspLSPOptCode:
	dp = &data->nlspLSPOptCode;
	break;
#endif				       /* I_nlspLSPOptCode */

#ifdef I_nlspLSPOptLength
      case I_nlspLSPOptLength:
	dp = &data->nlspLSPOptLength;
	break;
#endif				       /* I_nlspLSPOptLength */

#ifdef I_nlspLSPOptValue
      case I_nlspLSPOptValue:
	dp = MakeOctetString(data->nlspLSPOptValue->octet_ptr, data->nlspLSPOptValue->length);
	break;
#endif				       /* I_nlspLSPOptValue */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}





nlspSysEntry_t *
k_nlspSysEntry_get(serialNum, contextInfo, nominator, searchType, nlspSysInstance)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
    int             searchType;
    long            nlspSysInstance;
{
    static nlspSysEntry_t nlspSysEntryData;
    static OctetString net;
    static OctetString l2router;
    clns_pdbtype *pdb;
    idbtype *idb;
    isisidbtype *isisidb = NULL;

    /* Do nothing if IPX routing is disabled or NLSP is not running */
    if (!novell_running || !novell_nlsp_running)
      return (NULL);

    if (searchType == NEXT)
      if (nlspSysInstance < 1)
	nlspSysInstance = 1;

    if (nlspSysInstance < 0 || 
	nlspSysInstance > MAX_NLSP_PROC)
      return (NULL);

    pdb = find_nlsp_pdb_by_instance(nlspSysInstance);
    if (!pdb)
	return NULL;

    /* Get One isisidb to check things we set per interface */
    FOR_ALL_SWIDBS(idb) {
      if ((idb != NULL) && (idb->primary_nidb != NULL)) {
	isisidb = get_isis_idb(pdb, idb);
	if (isisidb != NULL)
	  break;
      }
    }

    nlspSysEntryData.nlspSysInstance = nlspSysInstance;
    nlspSysEntryData.nlspSysState = (pdb ? D_nlspSysState_nlspLevel1Router :
				     D_nlspSysState_off);
    nlspSysEntryData.nlspSysID = &net;
    net.length = STATION_LENGTH;
    net.octet_ptr = (uchar *)&pdb->systemId;
    nlspSysEntryData.nlspSysMinNonBcastLSPTransInt = 10;
    nlspSysEntryData.nlspSysMinBcastLSPTransInt = 5;
    nlspSysEntryData.nlspSysMinLSPGenInt = pdb->lsp_gen_interval[0] / ONESEC;
    nlspSysEntryData.nlspSysMaxLSPGenInt = pdb->lsp_refresh_interval / ONESEC;
    nlspSysEntryData.nlspSysMaxLSPAge = pdb->lsp_lifetime/ONESEC;
    nlspSysEntryData.nlspSysBcastHelloInt = 20;
    nlspSysEntryData.nlspSysNonBcastHelloInt = 20;
    nlspSysEntryData.nlspSysDRBcastHelloInt = isisidb->isis_L1_dr_hello_interval / ONESEC;
    nlspSysEntryData.nlspSysHoldTimeMultiplier = isisidb->isis_L1_hello_multiplier / ONESEC;
    nlspSysEntryData.nlspSysCompSNPInt = isisidb->csnp_ctl[0].csnp_interval / ONESEC;
    nlspSysEntryData.nlspSysPartSNPInt = 1;
    nlspSysEntryData.nlspSysWaitTime = 120;
    nlspSysEntryData.nlspSysOrigL1LSPBufSize = pdb->packet_mtu + pdb->packet_overhead;
    nlspSysEntryData.nlspSysVersion = NLSP_IPX_VERSION_NUMBER;
    nlspSysEntryData.nlspSysCorrLSPs = 
      isis_traffic[PROC_TYPE_NLSP][ISIS_LSP_CORR];
    nlspSysEntryData.nlspSysL1Overloaded = 
      (isis_traffic[PROC_TYPE_NLSP][ISIS_L1_OVR_LOAD] ? D_nlspSysL1Overloaded_yes
: D_nlspSysL1Overloaded_no);
    nlspSysEntryData.nlspSysL1DbaseOverloads =
      isis_traffic[PROC_TYPE_NLSP][ISIS_L1_DBASE_OVR_LOAD];
    nlspSysEntryData.nlspSysMaxSeqNums =
      isis_traffic[PROC_TYPE_NLSP][ISIS_MAXSEQNUMS];
    nlspSysEntryData.nlspSysSeqNumSkips =
      isis_traffic[PROC_TYPE_NLSP][ISIS_SEQNUMSKIPS];
    nlspSysEntryData.nlspSysTransmittedLSPs = 
      isis_traffic[PROC_TYPE_NLSP][ISIS_L1_LSP_OUT];
    nlspSysEntryData.nlspSysReceivedLSPs = 
      isis_traffic[PROC_TYPE_NLSP][ISIS_L1_LSP_IN];
    nlspSysEntryData.nlspSysOwnLSPPurges =
      isis_traffic[PROC_TYPE_NLSP][ISIS_LSP_PURGE];
    nlspSysEntryData.nlspSysVersionErrors =
      isis_traffic[PROC_TYPE_NLSP][ISIS_VERSION_ERR];
    nlspSysEntryData.nlspSysIncorrectPackets =
      isis_traffic[PROC_TYPE_NLSP][ISIS_INCORRECT_PACKETS];
    nlspSysEntryData.nlspSysNearestL2DefaultExists = D_nlspSysNearestL2DefaultExists_no;
    nlspSysEntryData.nlspSysNearestL2DefaultRouter = &l2router;
    l2router.length = 6;
    l2router.octet_ptr = 0x000000000000;
    nlspSysEntryData.nlspSysResourceFailures =
      isis_traffic[PROC_TYPE_NLSP][ISIS_RESOURCE_FAIL];
    return (&nlspSysEntryData);
}

#ifdef SETS
int
k_nlspSysEntry_set(data, contextInfo, function)
    nlspSysEntry_t *data;
    ContextInfo    *contextInfo;
    int             function;
{
  uchar name[IEEEBYTES];
  clns_pdbtype *cpdb;
  novpdbtype *pdb;
  isisidbtype *isisidb;
  idbtype *idb;
  ulong net;
  
  cpdb = find_nlsp_pdb_by_instance(data->nlspSysInstance);
  if (cpdb == NULL)
    return(GEN_ERROR);

  pdb = novnlsp_find_pdb(NULL);  /* Router tag of NULL */

  switch (function) {
  case DELETE:
    return (GEN_ERROR);
    break;
  case ADD_MODIFY:
    if (VALID(I_nlspSysInstance, data->valid)) {
      /* If no NLSP instance and they ask for on, enable NLSP */
    }
    if(VALID(I_nlspSysState, data->valid)) {
      switch(data->nlspSysState) {
      case D_nlspSysState_off:
	/* Turn NLSP routing off */
	nov_nlsp_router_command(FALSE, FALSE, NULL, pdb, NULL);
	break;
      case D_nlspSysState_nlspLevel1Router:
	/* Turn NLSP routing on */
        if (pdb == NULL)
	  return(GEN_ERROR); /* NLSP not enabled?? */
	nov_nlsp_router_command(FALSE, TRUE, NULL, pdb, NULL);
	break;
      default:  
	/* Should never get this far but if we do return an error */
	return (GEN_ERROR);
	break;
      }
    }
    if (VALID(I_nlspSysID, data->valid)) {
      /* We use the Mac address from "ipx routing xxxx.xxxx.xxxx" */
      ieee_copy(data->nlspSysID->octet_ptr, name);
      net = 1;
      novell_address_command(FALSE, TRUE, net, name);
    }
    if (VALID(I_nlspSysMinNonBcastLSPTransInt, data->valid)) {
      return (NOT_WRITABLE_ERROR);
    }
    if (VALID(I_nlspSysMinBcastLSPTransInt, data->valid)) {
      return (NOT_WRITABLE_ERROR);
    }
    if (VALID(I_nlspSysMinLSPGenInt, data->valid)) {
      isis_lsp_gen_command(FALSE, TRUE, FALSE, "lsp-gen-interval",
			   data->nlspSysMinLSPGenInt, 0, cpdb);

    }
    if (VALID(I_nlspSysMaxLSPGenInt, data->valid)) {
      isis_lsp_refresh_command(FALSE, TRUE, FALSE, "lsp-refresh-interval",
			       data->nlspSysMaxLSPGenInt, cpdb);
    }
    if (VALID(I_nlspSysMaxLSPAge, data->valid)) {
      isis_lsp_lifetime_command(FALSE, TRUE, FALSE, "max-lsp-lifetime",
				data->nlspSysMaxLSPAge, cpdb);
    }
    if (VALID(I_nlspSysBcastHelloInt, data->valid)) {
      return (NOT_WRITABLE_ERROR);
    }
    if (VALID(I_nlspSysNonBcastHelloInt, data->valid)) {
      return (NOT_WRITABLE_ERROR);
    }
    if (VALID(I_nlspSysDRBcastHelloInt, data->valid)) {
      FOR_ALL_SWIDBS(idb) {
	if ((idb != NULL) && (idb->primary_nidb != NULL)) {
	  isisidb = get_isis_idb(cpdb, idb);
	  if (isisidb != NULL)
	    isisidb->isis_L1_dr_hello_interval = data->nlspSysDRBcastHelloInt
	      * ONESEC;
	}
      }
    }
    if (VALID(I_nlspSysHoldTimeMultiplier, data->valid)) {
      FOR_ALL_SWIDBS(idb) {
	if ((idb != NULL) && (idb->primary_nidb != NULL)) {
	  isisidb = get_isis_idb(cpdb, idb);
	  if (isisidb != NULL)
	    isisidb->isis_L1_hello_multiplier = data->nlspSysHoldTimeMultiplier
	      * ONESEC;
	}
      }
    }
    if (VALID(I_nlspSysCompSNPInt, data->valid)) {
      FOR_ALL_SWIDBS(idb) {
	if ((idb != NULL) && (idb->primary_nidb != NULL)) {
	  isisidb = get_isis_idb(cpdb, idb);
	  if (isisidb != NULL)
	    isisidb->csnp_ctl[0].csnp_interval = data->nlspSysCompSNPInt
	      * ONESEC;
	  if (isisidb->isis_running) {
	    mgd_timer_start(&isisidb->csnp_ctl[0].isis_csnp_timer,
			    isisidb->csnp_ctl[0].csnp_interval);
	  }
	}
      }
    }
    if (VALID(I_nlspSysPartSNPInt, data->valid)) {
      return (NOT_WRITABLE_ERROR);
    }
    if (VALID(I_nlspSysWaitTime, data->valid)) {
      return (NOT_WRITABLE_ERROR);
    }
    if (VALID(I_nlspSysOrigL1LSPBufSize, data->valid)) {
      isis_lspmtu_command(TRUE, TRUE, FALSE, "lsp-mtu",
			  data->nlspSysOrigL1LSPBufSize, cpdb);
    }
    break;
  default:
    return (GEN_ERROR);
    break;
  }
  return (NO_ERROR);

}

#endif				       /* SETS */

nlspSysAreaEntry_t *
k_nlspSysAreaEntry_get(serialNum, contextInfo, nominator, searchType, nlspSysAreaSysInstance, nlspSysAreaNet, nlspSysAreaMask)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
    int             searchType;
    long            nlspSysAreaSysInstance;
    OctetString    *nlspSysAreaNet;
    OctetString    *nlspSysAreaMask;
{
    static nlspSysAreaEntry_t nlspSysAreaEntryData;
    clns_pdbtype *pdb;
    static OctetString net;
    static OctetString mask;
    int area_index;
    long instance, orig_instance;
    ulong area_num = 0, net_num = 0, net_mask = 0;
    
    if (!novell_running || !novell_nlsp_running) {
      return (NULL);
    }
    orig_instance = instance = nlspSysAreaSysInstance;
    if (searchType == NEXT) 
      if (nlspSysAreaSysInstance < 1) {
	instance  = 1;
      }
    area_index = -1;
    pdb = find_nlsp_pdb_by_instance(instance);
    if (!pdb || (pdb->num_nlsp_areas == 0)) {
      return(NULL);
    }
    net_num = OctetStringToUlong(nlspSysAreaNet);
    net_mask = OctetStringToUlong(nlspSysAreaMask);

    if (searchType == NEXT) {
/*      if (net_mask > 0) net_mask--;  */
      if (nlspSysAreaSysInstance < 1) 
	nlspSysAreaSysInstance = 1;
      for (area_num = 0; area_num < pdb->num_nlsp_areas; area_num++) {
	if (area_index == -1) {
	  if (((pdb->nlsp_manual_area[area_num] >= net_num) &&
	      (pdb->nlsp_manual_area_mask[area_num] >= net_mask)) ||
	      ((orig_instance == 0L) &&
	      ((pdb->nlsp_manual_area[area_num] == net_num) &&
		(pdb->nlsp_manual_area_mask[area_num] == net_mask))))
	    area_index = area_num;
	} else {
	  if (((pdb->nlsp_manual_area[area_num] >= net_num) &&
	      (pdb->nlsp_manual_area[area_num] < 
	       pdb->nlsp_manual_area[area_index])) ||
	      ((pdb->nlsp_manual_area_mask[area_num] >= net_mask) &&
	      (pdb->nlsp_manual_area_mask[area_num] < 
	       pdb->nlsp_manual_area_mask[area_index])))
	    area_index = area_num;
	}
      }
      if (area_index == -1)
	return (NULL);
    } else {       /* end of Get Next */
      /* Get EXACT */
      if (nlspSysAreaSysInstance < 0 ||
	  nlspSysAreaSysInstance > MAX_NLSP_PROC) {
	return(NULL);
      }
      area_index = -1;
      for (area_num = 0; area_num < pdb->num_nlsp_areas; area_num++) {
	if ((pdb->nlsp_manual_area[area_num] == net_num) && 
	    (pdb->nlsp_manual_area_mask[area_num] == net_mask)) {
	  area_index = area_num;
	}
      }
      /* First check for match, if no match then stop */
      if (area_index == -1) {
	return(NULL);
      }
    }
    nlspSysAreaEntryData.nlspSysAreaSysInstance = nlspSysAreaSysInstance;
    net.length = NETBYTES;
    net.octet_ptr =  (uchar *) &pdb->nlsp_manual_area[area_index];
    nlspSysAreaEntryData.nlspSysAreaNet = &net;
    mask.length = NETBYTES;
    mask.octet_ptr = (uchar *) &pdb->nlsp_manual_area_mask[area_index];
    nlspSysAreaEntryData.nlspSysAreaMask = &mask;
    return (&nlspSysAreaEntryData);
}

#ifdef SETS
int
k_nlspSysAreaEntry_set(data, contextInfo, function)
    nlspSysAreaEntry_t *data;
    ContextInfo    *contextInfo;
    int             function;
{
  int instance;
  ulong area, mask;
  clns_pdbtype *cpdb;
  
  if (!novell_running || !novell_nlsp_running)
    return (GEN_ERROR);

  instance = data->nlspSysAreaSysInstance;
  if (instance < 1) {
    instance = 1;
  }
  cpdb = find_nlsp_pdb_by_instance(instance);    
  if (!cpdb)
    return(GEN_ERROR);

  switch (function) {
  case DELETE:
    return (GEN_ERROR);
    break;
  case ADD_MODIFY:
    if (VALID(I_nlspSysAreaSysInstance,data->valid)) {
      if ((VALID(I_nlspSysAreaNet,data->valid)) && 
	   (VALID(I_nlspSysAreaMask,data->valid))) {

	area = OctetStringToUlong(data->nlspSysAreaNet);
	mask = OctetStringToUlong(data->nlspSysAreaMask);
	isis_ipx_area_cmd(cpdb, FALSE, TRUE, FALSE, "area-address",
			  area, mask);
      }
    }
    break;
  default:
    return (GEN_ERROR);
    break;
  }
  return (NO_ERROR);
}

#endif				       /* SETS */

nlspActAreaEntry_t *
k_nlspActAreaEntry_get(serialNum, contextInfo, nominator, searchType, nlspActAreaSysInstance, nlspActAreaNet, nlspActAreaMask)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
    int             searchType;
    long            nlspActAreaSysInstance;
    OctetString    *nlspActAreaNet;
    OctetString    *nlspActAreaMask;
{
    static nlspActAreaEntry_t nlspActAreaEntryData;
    clns_pdbtype *pdb;
    static OctetString net;
    static OctetString mask;
    int area_index;
    long instance, orig_instance;
    ulong area_num = 0, net_num = 0, net_mask = 0;

    if (!novell_running || !novell_nlsp_running)
      return (NULL);

    orig_instance = instance = nlspActAreaSysInstance;
    if (searchType == NEXT) 
      if (nlspActAreaSysInstance < 1) {
	  instance = 1;
      }
    area_index = -1;
    pdb = find_nlsp_pdb_by_instance(instance);    
    if (!pdb || (pdb->num_nlsp_areas == 0))
      return(NULL);

    net_num = OctetStringToUlong(nlspActAreaNet);
    net_mask = OctetStringToUlong(nlspActAreaMask);

    if (searchType == NEXT) {
/*      if (net_mask > 0) net_mask--;  */
      if (nlspActAreaSysInstance < 1)
	nlspActAreaSysInstance = 1;
      for (area_num = 0; area_num < pdb->num_nlsp_areas; area_num++) {
	if (area_index == -1) {
          if (((pdb->nlsp_manual_area[area_num] >= net_num) &&
	       (pdb->nlsp_manual_area_mask[area_num] >= net_mask)) ||
              ((orig_instance == 0L) &&
	       ((pdb->nlsp_manual_area[area_num] == net_num) &&
                (pdb->nlsp_manual_area_mask[area_num] == net_mask))))
            area_index = area_num;
        } else {
          if (((pdb->nlsp_manual_area[area_num] >= net_num) &&
	       (pdb->nlsp_manual_area[area_num] <
		pdb->nlsp_manual_area[area_index])) ||
              ((pdb->nlsp_manual_area_mask[area_num] >= net_mask) &&
	       (pdb->nlsp_manual_area_mask[area_num] <
		pdb->nlsp_manual_area_mask[area_index])))
            area_index = area_num;
	}
      }
      if (area_index == -1)
	return(NULL);
    } else {      /* end of Get Next */
      if (nlspActAreaSysInstance < 0 ||
	  nlspActAreaSysInstance > MAX_NLSP_PROC) {
	return(NULL);
      }
      area_index = -1;
      for (area_num = 0; area_num < pdb->num_nlsp_areas; area_num++) {
	if ((pdb->nlsp_manual_area[area_num] == net_num) &&
	    (pdb->nlsp_manual_area_mask[area_num] == net_mask)) {
	  area_index = area_num;
	}
      }
      /* First check for match, if no match then stop */
      if (area_index == -1) {
	return(NULL);
      }
    }
    nlspActAreaEntryData.nlspActAreaSysInstance = nlspActAreaSysInstance;
    net.length = NETBYTES;
    net.octet_ptr =  (uchar *) &pdb->nlsp_manual_area[area_index];
    nlspActAreaEntryData.nlspActAreaNet = &net;
    mask.length = NETBYTES;
    mask.octet_ptr = (uchar *) &pdb->nlsp_manual_area_mask[area_index];
    nlspActAreaEntryData.nlspActAreaMask = &mask;
    return (&nlspActAreaEntryData);
}

#ifdef SETS
int
k_nlspActAreaEntry_set(data, contextInfo, function)
    nlspActAreaEntry_t *data;
    ContextInfo    *contextInfo;
    int             function;
{
  int instance;
  ulong area, mask;
  clns_pdbtype *cpdb;

  if (!novell_running || !novell_nlsp_running)
    return (GEN_ERROR);

  instance = data->nlspActAreaSysInstance;
  if (instance < 1) {
    instance = 1;
  }
  cpdb = find_nlsp_pdb_by_instance(instance);
  if (!cpdb)
    return(GEN_ERROR);

  switch (function) {
  case DELETE:
    return (GEN_ERROR);
    break;
  case ADD_MODIFY:
    if (VALID(I_nlspActAreaSysInstance,data->valid)) {
      if ((VALID(I_nlspActAreaNet,data->valid)) &&
           (VALID(I_nlspActAreaMask,data->valid))) {

        area = OctetStringToUlong(data->nlspActAreaNet);
        mask = OctetStringToUlong(data->nlspActAreaMask);
        isis_ipx_area_cmd(cpdb, FALSE, TRUE, FALSE, "area-address",
                          area, mask);
      }
    }
    break;
  default:
    return (GEN_ERROR);
    break;
  }
  return (NO_ERROR);
}

#endif				       /* SETS */

nlspCircEntry_t *
k_nlspCircEntry_get(serialNum, contextInfo, nominator, searchType, nlspCircSysInstance, nlspCircIndex)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
    int             searchType;
    long            nlspCircSysInstance;
    long            nlspCircIndex;
{

    static nlspCircEntry_t nlspCircEntryData;
    static OctetString nlspId;
    static OctetString desrtr;
    isisidbtype *isisidb;
    clns_pdbtype *cpdb;

    idbtype        *idb = NULL, *cur_idb = NULL;
    nidbtype *nidb = NULL;
    novpdbtype *pdb;

    if (!novell_running || !novell_nlsp_running)
      return (NULL);
    
    if (nlspCircSysInstance < 0 || 
	nlspCircSysInstance > MAX_NLSP_PROC) 
      return(NULL);
    
    if(searchType == EXACT) {
      if (nlspCircSysInstance == 1) {
            FOR_ALL_SWIDBS(idb) {
                if ((idb != NULL) && (idb->primary_nidb != NULL) &&
                    (idb->if_number == (ulong) nlspCircIndex))
                    break;
	      }
	  }
      } else { /* get next */
        if (nlspCircSysInstance < 1) {
            nlspCircSysInstance = 1;
            nlspCircIndex = 0;
	  }

	cpdb = find_nlsp_pdb_by_instance(nlspCircSysInstance);    
	if (!cpdb)
	    return(NULL);

        FOR_ALL_SWIDBS(cur_idb) {
	    isisidb = get_isis_idb(cpdb, cur_idb);
            if (idb == NULL) {
                if ((cur_idb->primary_nidb != NULL) &&
		    (isisidb != NULL) &&
                    (cur_idb->if_number >= (ulong) nlspCircIndex))
                    idb = cur_idb;
	      } else {
                if (cur_idb->primary_nidb != NULL &&
		    (isisidb != NULL) &&
                    (cur_idb->if_number >= (ulong) nlspCircIndex) &&
                    (cur_idb->if_number < idb->if_number))
                    idb = cur_idb;
	      }
	  }
      }

    if (idb == NULL)
        return (NULL);
    
    nidb = idb->primary_nidb;
    if (!(pdb = novnlsp_find_pdb(nidb->pname)))
	return NULL;
    if (!pdb->osi_pdb)
	return NULL;
    isisidb = get_isis_idb(pdb->osi_pdb, idb);
    if (!isisidb)
      return (NULL);
    
    nlspCircEntryData.nlspCircSysInstance = nlspCircSysInstance; 
    nlspCircEntryData.nlspCircIndex = idb->if_number;
    nlspCircEntryData.nlspCircState = nidb->nov_lsp_enabled ? 2 : 1;
    nlspCircEntryData.nlspCircPace = 1000/isisidb->pacing_interval;
    nlspCircEntryData.nlspCircHelloTimer = 
	isisidb->isis_L1_hello_interval / ONESEC;
    nlspCircEntryData.nlspCircL1DefaultCost = isisidb->isis_L1_metric;
    nlspCircEntryData.nlspCircL1DesRouterPriority = isisidb->isis_L1_prio;
    nlspCircEntryData.nlspCircL1CircID = &nlspId;
    nlspId.length = SYSTEMID_LENGTH;
    nlspId.octet_ptr = (uchar *) &isisidb->isis_L1_circuit_id;
    nlspCircEntryData.nlspCircL1DesRouter = &desrtr;
    desrtr.length = STATION_LENGTH;
    desrtr.octet_ptr = (uchar *) &isisidb->isis_L1_dr_id;;
    nlspCircEntryData.nlspCircLANL1DesRouterChanges = 
      isisidb->isisidb_traffic[ISISIDB_L1DRCHANGES];
    nlspCircEntryData.nlspCircNeighChanges = 
      isisidb->isisidb_traffic[ISISIDB_CIRCNEIGHCHANGE];
    nlspCircEntryData.nlspCircRejNeighbors = 
      isisidb->isisidb_traffic[ISISIDB_CIRCREJNEIGHBORS];
    nlspCircEntryData.nlspCircOutPackets = 
      isisidb->isisidb_traffic[ISISIDB_L1_HELLO_OUT] +
      isisidb->isisidb_traffic[ISISIDB_L2_HELLO_OUT] +
      isisidb->isisidb_traffic[ISISIDB_PTP_HELLO_OUT] +
      isisidb->isisidb_traffic[ISISIDB_L1_LSP_OUT] +
      isisidb->isisidb_traffic[ISISIDB_L2_LSP_OUT] +
      isisidb->isisidb_traffic[ISISIDB_L1_CSNP_OUT] +
      isisidb->isisidb_traffic[ISISIDB_L1_PSNP_OUT];
    nlspCircEntryData.nlspCircInPackets = 
      isisidb->isisidb_traffic[ISISIDB_L1_HELLO_IN] +
      isisidb->isisidb_traffic[ISISIDB_L2_HELLO_IN] +
      isisidb->isisidb_traffic[ISISIDB_PTP_HELLO_IN] +
      isisidb->isisidb_traffic[ISISIDB_L1_LSP_IN] +
      isisidb->isisidb_traffic[ISISIDB_L2_LSP_IN] +
      isisidb->isisidb_traffic[ISISIDB_L1_CSNP_IN] +
      isisidb->isisidb_traffic[ISISIDB_L1_PSNP_IN];
    nlspCircEntryData.nlspCircActualMaxPacketSize = idb->hwptr->maxmtu;
    nlspCircEntryData.nlspCircPSNPsSent = 
      isisidb->isisidb_traffic[ISISIDB_L1_PSNP_OUT] +
      isisidb->isisidb_traffic[ISISIDB_L2_PSNP_OUT];
    nlspCircEntryData.nlspCircPSNPsReceived = 
      isisidb->isisidb_traffic[ISISIDB_L1_PSNP_IN] +
      isisidb->isisidb_traffic[ISISIDB_L2_PSNP_IN];
    return (&nlspCircEntryData);
}

#ifdef SETS
int
k_nlspCircEntry_set(data, contextInfo, function)
    nlspCircEntry_t *data;
    ContextInfo    *contextInfo;
    int             function;
{
  novpdbtype *pdb;
  isisidbtype *isisidb;
  idbtype        *idb = NULL;
  nidbtype *nidb = NULL;
  boolean change;
  char *name = NULL;

  if (!novell_running || novell_shutting_down) {
    return (GEN_ERROR);
  }

  FOR_ALL_SWIDBS(idb) {
    if ((idb != NULL) && (idb->primary_nidb != NULL) &&
	(idb->if_number == (ulong) (data->nlspCircIndex)))
      break;
  }

  if (idb == NULL)
    return (GEN_ERROR);

  if (idb->primary_nidb)
    return (GEN_ERROR);

  nidb = idb->primary_nidb;
  if (!idb->isis_idb)
    return (GEN_ERROR);
  isisidb = idb->isis_idb[isis_pdbindex_to_procindex(CLNS_PDBINDEX_NLSP0)];
  change = FALSE;
  pdb = novnlsp_find_pdb(nidb->pname);

  switch (function) {
  case DELETE:
    return (GEN_ERROR);
    break;
  case ADD_MODIFY:
    if (VALID(I_nlspCircSysInstance, data->valid) && 
	(VALID(I_nlspCircIndex, data->valid))) {
      if (VALID(I_nlspCircState, data->valid)) {
	if (data->nlspCircState == D_nlspCircState_on) {
	  if (nidb->nov_lsp_enabled)
	    return (NO_ERROR); /* already enabled */
	  if (pdb == NULL)
	    pdb = reg_invoke_ipx_nlsp_start(name);
	  if (!pdb->running) {
	    if (pdb->restart) {
	      (*pdb->restart)(pdb);
	    }
	  }
	  pdb->entered = TRUE;
	}
	if (!pdb || !pdb->osi_pdb) {
	  return (GEN_ERROR);
	  
	  isisidb = isis_alloc_isisidb(idb, PROC_TYPE_NLSP,
				       pdb->osi_pdb->index);
	  if (!isisidb) {
	    return (GEN_ERROR);
	  }
	  setstring(&nidb->pname, name);
	  novnlsp_change_interface(pdb, nidb, TRUE, 
				   (data->nlspCircState == D_nlspCircState_on));

	  change = TRUE;
	}
	if (data->nlspCircState == D_nlspCircState_off) {
	  novnlsp_change_interface(pdb, nidb, TRUE,
				   (data->nlspCircState == D_nlspCircState_on));
	  if (nidb->pname) {
	    free(nidb->pname);
	    nidb->pname = NULL;
	  }
	change = TRUE;
	}
      }
      pdb = novnlsp_find_pdb(nidb->pname);
      if (!pdb || !pdb->osi_pdb)
	return (GEN_ERROR);
      isisidb = get_isis_idb(pdb->osi_pdb, idb);
      if (!isisidb)
	return (GEN_ERROR);

      if (VALID(I_nlspCircPace, data->valid)) {
	return (NOT_WRITABLE_ERROR);
      }
      if (VALID(I_nlspCircHelloTimer, data->valid)) {
	isisidb->isis_L1_hello_interval = data->nlspCircHelloTimer * ONESEC;
	isisidb->isis_L1_dr_hello_interval = isisidb->isis_L1_hello_interval /
	  NLSP_LAN_DR_HELLO_DIVISOR;
	change = TRUE;
      }
      if (VALID(I_nlspCircL1DefaultCost, data->valid)) {
	isisidb->nlsp_explicit_cost = TRUE;
	isisidb->isis_L1_metric = data->nlspCircL1DefaultCost;
	ipx_mark_non_dr_info_change(pdb);
	change = TRUE;
      }
      if (VALID(I_nlspCircL1DesRouterPriority, data->valid)) {
	isisidb->isis_L1_prio = data->nlspCircL1DesRouterPriority;
	isisidb->isis_L1_cur_prio = data->nlspCircL1DesRouterPriority;
	isis_schedule_hello(pdb->osi_pdb, isisidb, ISIS_CIRCUIT_L1);
	isis_trigger_dr_election(pdb->osi_pdb, isisidb, ISIS_CIRCUIT_L1);
	change = TRUE;
      }
    } else {
      return (GEN_ERROR);  /* Should have been pre-verified in _test */
    }
    break;
  default:
    return (GEN_ERROR);
    break;
  }
  if (change) {
    /* Force world to know it's gone and bring IPXWAN down... */
    novell_nidb_newstate(nidb, NOVELL_NIDB_DOWN);
    novell_nidb_newstate(nidb, NOVELL_NIDB_UP);
  }
  return (NO_ERROR);
}

#endif				       /* SETS */

nlspDestEntry_t *
k_nlspDestEntry_get(serialNum, contextInfo, nominator, searchType, nlspDestSysInstance, nlspDestNetNum)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
    int             searchType;
    long            nlspDestSysInstance;
    OctetString    *nlspDestNetNum;
{
    static nlspDestEntry_t nlspDestEntryData;
    static OctetString dstid;
    static OctetString nextid;
    static OctetString dstnet;

    novndbtype *p = NULL, *cur_p = NULL;
    int i;
    novrdbtype *pp = NULL;
    isisidbtype *isisidb =NULL;
    ulong net;

    if (!novell_running || !novell_nlsp_running)
      return (NULL);

    if (searchType == NEXT)
      if (nlspDestSysInstance < 1) {
	nlspDestSysInstance = 1;
	net = 0;
    }

    if (nlspDestSysInstance < 0 ||
	nlspDestSysInstance > MAX_NLSP_PROC) 
      return (NULL);

    net = OctetStringToUlong(nlspDestNetNum);

    p = NULL;
    if(searchType == EXACT) {
      if (nlspDestSysInstance == 1) {
	for (i = 0; i < NOV_NETHASHLEN; i++) {
	  cur_p = (*novell_table)[i];
	  for (; cur_p; cur_p = cur_p->next) {
	    if ((cur_p->dstnet == net) && (cur_p->path_list != NULL) &&
		(cur_p->flags & (NET_NLSP | NET_CONNECTED))) {
	      p = cur_p;
	      goto get_r_break;
	    }
	  }
	}
      get_r_break:
      } else {
	return (NULL);
      }
    } else { /* get next */
      for (i = 0; i < NOV_NETHASHLEN; i++) {
	cur_p = (*novell_table)[i];
	for (; cur_p; cur_p = cur_p->next) {
	  if (p == NULL) {
	    if ((cur_p->dstnet >= net) &&
		(cur_p->dstnet != 0L) &&
		(cur_p->path_list != NULL) &&
		(cur_p->flags & (NET_NLSP | NET_CONNECTED)))
	      p = cur_p;
	  } else
	    if ((cur_p->dstnet >= net) &&
		(cur_p->dstnet < p->dstnet) &&
		(cur_p->dstnet != 0L) &&
		(cur_p->path_list != NULL) &&
		(cur_p->flags & (NET_NLSP | NET_CONNECTED)))
	      p = cur_p;
	}
      }
    }
    if (p == NULL)
        return (NULL);

    pp = p->path_list;
    if (pp == NULL)
      return (NULL);

    nlspDestEntryData.nlspDestSysInstance = nlspDestSysInstance;
    nlspDestEntryData.nlspDestNetNum = &dstnet;
    dstnet.length = NETBYTES;
    dstnet.octet_ptr = (uchar *)&p->dstnet;
    nlspDestEntryData.nlspDestID = &dstid;
    dstid.length = SYSTEMID_LENGTH;
    if (p->flags & NET_NLSP) {
      dstid.octet_ptr = (uchar *) &(pp->protocol_info.nlsp_info.cost.system_id);
    } else {
      if (pp->nidb->idb->isis_idb) {
        isisidb = pp->nidb->idb->isis_idb[isis_pdbindex_to_procindex(CLNS_PDBINDEX_NLSP0)];
	if (isisidb != NULL) {
	  dstid.octet_ptr = (uchar *) &isisidb->isis_L1_circuit_id; 
	}
      }	
    }
    nlspDestEntryData.nlspDestEstDelay = 
      pp->protocol_info.nlsp_info.cost.total_delay;
    nlspDestEntryData.nlspDestEstThroughput = 
      pp->protocol_info.nlsp_info.cost.total_throughput;
    nlspDestEntryData.nlspDestNextHopID = &nextid;
    nextid.length = SYSTEMID_LENGTH;
    if (p->flags & NET_NLSP) {
      nextid.octet_ptr = (uchar *) &(pp->protocol_info.nlsp_info.cost.system_id);
    } else {
      if (pp->nidb->idb->isis_idb) {
	isisidb = pp->nidb->idb->isis_idb[isis_pdbindex_to_procindex(CLNS_PDBINDEX_NLSP0)];
	if (isisidb != NULL) {
	    nextid.octet_ptr = (uchar *) &isisidb->isis_L1_circuit_id; 
	}
      }
    }
    nlspDestEntryData.nlspDestCost = p->path_metric;

    return (&nlspDestEntryData);
}

nlspNeighEntry_t *
k_nlspNeighEntry_get(serialNum, contextInfo, nominator, searchType, nlspNeighSysInstance, nlspNeighCircIndex, nlspNeighIndex)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
    int             searchType;
    long            nlspNeighSysInstance;
    long            nlspNeighCircIndex;
    long            nlspNeighIndex;
{
    static nlspNeighEntry_t nlspNeighEntryData;
    static OctetString nsysid;
    static OctetString nnicaddr;
    static OctetString nname;
    isisidbtype *isisidb;
    clns_adjtype *adj, *next_adj, *cur_adj;
    idbtype  *idb = NULL, *cur_idb = NULL;
    nidbtype *nidb = NULL;
    int bucket, t, adj_on_circ_count;
    novpdbtype *pdb = NULL;
    char *str = NULL;
    clns_pdbtype *cpdb = NULL;
    clns_station_lookup_type lookup_proc = NULL;

    /* Do nothing if IPX routing is disabled or NLSP is not running */
    if (!novell_running || !novell_nlsp_running)
      return (NULL);

    if (nlspNeighSysInstance < 0 || 
	nlspNeighSysInstance > MAX_NLSP_PROC)
      return (NULL);
      if (nlspNeighSysInstance < 1) {
	nlspNeighSysInstance = 1;
	nlspNeighCircIndex = 1;
	nlspNeighIndex = 1;
      }
    cpdb = find_nlsp_pdb_by_instance(nlspNeighSysInstance);
    if (cpdb)
      lookup_proc = cpdb->stationid_lookup;
    if (!lookup_proc)
      lookup_proc = clns_stationid_lookup;

    /* Two Indices, Circuit and Neighbor */

    if(searchType == EXACT) {
      if (nlspNeighSysInstance == 1) {
	FOR_ALL_SWIDBS(idb) {
	  if ((idb != NULL) && (idb->primary_nidb != NULL) &&
	      (idb->if_number == (ulong) nlspNeighCircIndex))
	    break;
	}
      }
    } else { /* get next */
      cpdb = find_nlsp_pdb_by_instance(nlspNeighSysInstance);    
      if (!cpdb)
	  return(NULL);
      FOR_ALL_SWIDBS(cur_idb) {
	isisidb = get_isis_idb(cpdb, cur_idb);
	if (idb == NULL) {
	  if ((cur_idb != NULL) && (cur_idb->primary_nidb != NULL) &&
	      (isisidb != NULL) &&
	      (isisidb->isis_adj_count[0] >= nlspNeighIndex) &&
	      (cur_idb->if_number >= (ulong) nlspNeighCircIndex)) {
	    idb = cur_idb;
	  }
	} else {
	  if ((cur_idb != NULL) && (cur_idb->primary_nidb != NULL) && 
	      (isisidb != NULL) &&
	      (isisidb->isis_adj_count[0] >= nlspNeighIndex) &&
	      (cur_idb->if_number >= (ulong) nlspNeighCircIndex) &&
	      (cur_idb->if_number < idb->if_number))
	    idb = cur_idb;
	}
	/* Have we no more neighbors for this interface? */
	if ((cur_idb != NULL) && 
	    (cur_idb->if_number == (ulong) nlspNeighCircIndex) &&
	    (isisidb != NULL) &&
	    (nlspNeighIndex >= isisidb->isis_adj_count[0]))
	  nlspNeighIndex = 1;
      }
    }

    if (idb == NULL)
      return (NULL);
    if (idb->primary_nidb == NULL)
      return (NULL);
    nidb = idb->primary_nidb;
    if (!(pdb = novnlsp_find_pdb(nidb->pname)))
	return NULL;
    if (!pdb->osi_pdb)
	return NULL;
    isisidb = get_isis_idb(pdb->osi_pdb, idb);
    if (!isisidb)
      return (NULL);
    /* now we have an interface/circuit only present circuits which
     * have NLSP enabled. Duh, neighbors can't exist elsewhere */

    if (!nidb->nov_lsp_enabled)
      return (NULL);

    /* Now let's find neighbor number nlspNeighCircIndex on this interface */

    if (idb->if_number > nlspNeighCircIndex)
      nlspNeighIndex = 1;
    nlspNeighCircIndex = idb->if_number; /* First interface with neighbor */
    adj_on_circ_count = 1;
    cur_adj = NULL;
    /* Now we must find adjacencies on this interface */
    for (bucket = 0; bucket < CLNS_ADJ_DB_SIZE; bucket++) {
      for (adj = pdb->osi_pdb->adjacency_db[bucket]; adj; ) {
	if ((adj->adjacencyType == CLNS_NLSP_IS_ADJ_TYPE) &&
	    (adj->idb == idb)) {
	  if ((!cur_adj) && (adj_on_circ_count >= nlspNeighIndex)) {
	    adj_on_circ_count = nlspNeighIndex;
	    cur_adj = adj;
	  } else {
	    adj_on_circ_count++;
	  }
	}
	next_adj = adj->next;
	adj = next_adj;
      }
    }

    if (!cur_adj)  /* Did We get one, no return NULL */
      return (NULL);

    nlspNeighEntryData.nlspNeighSysInstance = nlspNeighSysInstance;
    nlspNeighEntryData.nlspNeighCircIndex = nlspNeighCircIndex;
    nlspNeighEntryData.nlspNeighIndex = nlspNeighIndex;
    switch(cur_adj->state) {
    case CLNS_ADJ_INIT_STATE:
      nlspNeighEntryData.nlspNeighState = D_nlspNeighState_initializing;
      break;
      
    case CLNS_ADJ_UP_STATE:
      if ((cur_adj->idb == NULL) || !interface_up(cur_adj->idb)) {
	nlspNeighEntryData.nlspNeighState = D_nlspNeighState_down;
      } else {
	nlspNeighEntryData.nlspNeighState = D_nlspNeighState_up;
      }
      break;
      
    case CLNS_ADJ_FAILED_STATE:
      nlspNeighEntryData.nlspNeighState = D_nlspNeighState_failed;
      break;

    default:
      nlspNeighEntryData.nlspNeighState = D_nlspNeighState_failed;
    }
    nlspNeighEntryData.nlspNeighNICAddress = &nnicaddr;
    nnicaddr.length = IEEEBYTES;
    nnicaddr.octet_ptr = (uchar *) &cur_adj->snpa.addr;
    /* Can only be a level 1 router so far but use adjacencyType field */
    nlspNeighEntryData.nlspNeighSysType = 
      (cur_adj->adjacencyType ? D_nlspNeighSysType_nlspLevel1Router :
       D_nlspNeighSysType_unknown);
    nlspNeighEntryData.nlspNeighSysID = &nsysid;
    nsysid.octet_ptr = (uchar *) &cur_adj->key[1];
    nsysid.length = STATION_LENGTH;
    nlspNeighEntryData.nlspNeighName = &nname;
    str = (*lookup_proc)(cpdb, &cur_adj->key[1]);
    nname.length = strlen(str);
    nname.octet_ptr = (uchar *) str;
    nlspNeighEntryData.nlspNeighUsage = D_nlspNeighUsage_level1;
    t = 0;
    if (TIMER_RUNNING(cur_adj->expiration_time)) {
      t = TIME_LEFT_SLEEPING(cur_adj->expiration_time);
    }
    nlspNeighEntryData.nlspNeighHoldTimer = t/ONESEC;
    nlspNeighEntryData.nlspNeighRemainingTime = t/ONESEC;
    nlspNeighEntryData.nlspNeighPriority = 
      ((cur_adj->adjacencyType == CLNS_L2_IS_ADJ_TYPE) ?
	cur_adj->L2_lan_priority : cur_adj->L1_lan_priority);

    return (&nlspNeighEntryData);
}

nlspIDMapEntry_t *
k_nlspIDMapEntry_get(serialNum, contextInfo, nominator, searchType, nlspIDMapSysInstance, nlspIDMapID)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
    int             searchType;
    long            nlspIDMapSysInstance;
    OctetString    *nlspIDMapID;
{
#ifdef NOT_YET
    static nlspIDMapEntry_t nlspIDMapEntryData;
    OctetString mapnet, mapservername, mapid;

    /* Do nothing if IPX routing is disabled or NLSP is not running */
    if (!novell_running || !novell_nlsp_running)
      return (NULL);

    if (nlspIDMapSysInstance > LAST_NLSP_PROC_TYPE)
      return (NULL);

    if (searchType == EXACT) {
      if (nlspIDMapSysInstance == 1) {
	/* Exact SystemID lookup here */
      } else {
	return (NULL);
      }
    } else {  /* Get Next */
      if (nlspIDMapSysInstance < 1) {
	/* Must be first getnext, set to known values */
	nlspIDMapSysInstance = 1;
      }
      /* Get Next Processing Here */
    }
    
    nlspIDMapEntryData.nlspIDMapSysInstance = nlspIDMapSysInstance;
    mapid.length = 6;
    mapid.octet_ptr = "NOTYET";
    nlspIDMapEntryData.nlspIDMapID = &mapservername;
    mapservername.length = 6;
    mapservername.octet_ptr = "NOTYET";
    nlspIDMapEntryData.nlspIDMapServerName = &mapservername;
    mapnet.length = 6;
    mapnet.octet_ptr = "NOTYET";
    nlspIDMapEntryData.nlspIDMapNetNum = &mapnet;

    return (&nlspIDMapEntryData);
#else
    return (NULL);
#endif
}

nlspNetMapEntry_t *
k_nlspNetMapEntry_get(serialNum, contextInfo, nominator, searchType, nlspNetMapSysInstance, nlspNetMapNetNum)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
    int             searchType;
    long            nlspNetMapSysInstance;
    OctetString    *nlspNetMapNetNum;
{
#ifdef NOT_YET
    static nlspNetMapEntry_t nlspNetMapEntryData;
    OctetString mapnet, mapservername, mapid;
    novndbtype *p = NULL, *cur_p = NULL;
    int i;
    novrdbtype *pp = NULL;
    ulong net;

    net = OctetStringToUlong(nlspNetMapNetNum);

    /* Do nothing if IPX routing is disabled or NLSP is not running */
    if (!novell_running || !novell_nlsp_running)
      return (NULL);

    if (nlspNetMapSysInstance > LAST_NLSP_PROC_TYPE) 
      return (NULL);

    if (searchType == EXACT) {
      if (nlspNetMapSysInstance == 1) {
        for (i = 0; i < NOV_NETHASHLEN; i++) {
          p = (*novell_table)[i];
          for (; p; p = p->next) {
            if ((p->dstnet == net) && (p->path_list != NULL))
              goto get_r_break;
          }
        }
      get_r_break:
      }
    } else { /* Get Next */
      if (nlspNetMapSysInstance < 1) {
        nlspNetMapSysInstance = 1;
	net = 0;
      }
      /* Find Next network in nlsp route table and return NLSP info */
      for (i = 0; i < NOV_NETHASHLEN; i++) {
        cur_p = (*novell_table)[i];
        for (; cur_p; cur_p = cur_p->next) {
          if (p == NULL) {
            if ((cur_p->dstnet >= net) &&
                (cur_p->path_list != NULL))
              p = cur_p;
          } else
            if ((cur_p->dstnet >= net) &&
                (cur_p->dstnet < p->dstnet) &&
                (cur_p->path_list != NULL))
              p = cur_p;
        }
      }
    }
    
    if (p == NULL)
      return (NULL);
    
    pp = p->path_list;

    /* Now we have the network and it's route table entry */

    nlspNetMapEntryData.nlspNetMapSysInstance = nlspNetMapSysInstance;
    mapid.length = strlen(pp->protocol_info.nlsp_info.cost.system_id);
    mapid.octet_ptr = (uchar *) &pp->protocol_info.nlsp_info.cost.system_id;
    nlspNetMapEntryData.nlspNetMapID = &mapid;
    mapservername.length = 6;
    mapservername.octet_ptr = "NOTYET";
    nlspNetMapEntryData.nlspNetMapServerName = &mapservername;
    mapnet.length = NETBYTES;
    mapnet.octet_ptr = (uchar *) &p->dstnet;
    nlspNetMapEntryData.nlspNetMapNetNum = &mapnet;

    return (&nlspNetMapEntryData);
#else                                  /* NOT_YET */
    return (NULL);
#endif                                 /* NOT_YET */
}

nlspNameMapEntry_t *
k_nlspNameMapEntry_get(serialNum, contextInfo, nominator, searchType, nlspNameMapSysInstance, nlspNameMapServerName)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
    int             searchType;
    long            nlspNameMapSysInstance;
    OctetString    *nlspNameMapServerName;
{
#ifdef NOT_YET
    static nlspNameMapEntry_t nlspNameMapEntryData;

    /* Do nothing if IPX routing is disabled or NLSP is not running */
    if (!novell_running || !novell_nlsp_running)
      return (NULL);

    if (nlspNameMapSysInstance > LAST_NLSP_PROC_TYPE)
      return (NULL);

    if (searchType == EXACT) {
      if (nlspNameMapSysInstance == 1) {
        /* Exact Servername Match lookup here */
      }
    } else {
      if (nlspNameMapSysInstance < 1) {
        nlspNameMapSysInstance = 1;
	nlspNameMapServerName.length = 0;
	nlspNameMapServerName.octet_ptr = NULL;
      }
    }

    nlspNameMapEntryData.nlspNameMapSysInstance = nlspNameMapSysInstance;
    mapid.length = 6;
    mapid.octet_ptr = "NOTYET";
    nlspNameMapEntryData.nlspNameMapID = &mapid;
    mapservername.length = 6;
    mapservername.octet_ptr = "NOTYET";
    nlspNameMapEntryData.nlspNameMapServerName = &mapservername;
    mapnet.length = 6;
    mapnet.octet_ptr = "NOTYET";
    nlspNameMapEntryData.nlspNameMapNetNum = &mapnet;

    return (&nlspNameMapEntryData);
#else				       /* NOT_YET */
    return (NULL);
#endif				       /* NOT_YET */
}

nlspNodeEntry_t *
k_nlspNodeEntry_get(serialNum, contextInfo, nominator, searchType, nlspNodeSysInstance, nlspNodeID)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
    int             searchType;
    long            nlspNodeSysInstance;
    OctetString    *nlspNodeID;
{
#ifdef NOT_YET
    static nlspNodeEntry_t nlspNodeEntryData;

    nlspNodeEntryData.nlspNodeSysInstance =;
    nlspNodeEntryData.nlspNodeID =;
    nlspNodeEntryData.nlspNodeNetNum =;
    nlspNodeEntryData.nlspNodeType =;
    nlspNodeEntryData.nlspNodeEstDelay =;
    nlspNodeEntryData.nlspNodeEstThroughput =;
    nlspNodeEntryData.nlspNodeMaxPacketSize =;
    nlspNodeEntryData.nlspNodeCost =;
    nlspNodeEntryData.nlspNodeOverload =;
    nlspNodeEntryData.nlspNodeReachable =;

    return (&nlspNodeEntryData);
#else				       /* NOT_YET */
    return (NULL);
#endif				       /* NOT_YET */
}

nlspLinkEntry_t *
k_nlspLinkEntry_get(serialNum, contextInfo, nominator, searchType, nlspLinkSysInstance, nlspLinkNLSPID, nlspLinkIndex)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
    int             searchType;
    long            nlspLinkSysInstance;
    OctetString    *nlspLinkNLSPID;
    long            nlspLinkIndex;
{
#ifdef NOT_YET
    static nlspLinkEntry_t nlspLinkEntryData;

    nlspLinkEntryData.nlspLinkSysInstance =;
    nlspLinkEntryData.nlspLinkNLSPID =;
    nlspLinkEntryData.nlspLinkIndex =;
    nlspLinkEntryData.nlspLinkNeighNLSPID =;
    nlspLinkEntryData.nlspLinkFromNeighCost =;
    nlspLinkEntryData.nlspLinkMaxPacketSize =;
    nlspLinkEntryData.nlspLinkThroughput =;
    nlspLinkEntryData.nlspLinkDelay =;
    nlspLinkEntryData.nlspLinkMediaType =;
    nlspLinkEntryData.nlspLinkToNeighCost =;

    return (&nlspLinkEntryData);
#else				       /* NOT_YET */
    return (NULL);
#endif				       /* NOT_YET */
}

nlspPathEntry_t *
k_nlspPathEntry_get(serialNum, contextInfo, nominator, searchType, nlspPathSysInstance, nlspPathDestNLSPID, nlspPathLinkIndex)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
    int             searchType;
    long            nlspPathSysInstance;
    OctetString    *nlspPathDestNLSPID;
    long            nlspPathLinkIndex;
{
#ifdef NOT_YET
    static nlspPathEntry_t nlspPathEntryData;

    nlspPathEntryData.nlspPathSysInstance =;
    nlspPathEntryData.nlspPathDestNLSPID =;
    nlspPathEntryData.nlspPathLinkIndex =;

    return (&nlspPathEntryData);
#else				       /* NOT_YET */
    return (NULL);
#endif				       /* NOT_YET */
}

nlspGraphXRouteEntry_t *
k_nlspGraphXRouteEntry_get(serialNum, contextInfo, nominator, searchType, nlspGraphXRouteSysInstance, nlspGraphXRouteNLSPID, nlspGraphXRouteNetNum)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
    int             searchType;
    long            nlspGraphXRouteSysInstance;
    OctetString    *nlspGraphXRouteNLSPID;
    OctetString    *nlspGraphXRouteNetNum;
{
#ifdef NOT_YET
    static nlspGraphXRouteEntry_t nlspGraphXRouteEntryData;

    nlspGraphXRouteEntryData.nlspGraphXRouteSysInstance =;
    nlspGraphXRouteEntryData.nlspGraphXRouteNLSPID =;
    nlspGraphXRouteEntryData.nlspGraphXRouteNetNum =;
    nlspGraphXRouteEntryData.nlspGraphXRouteCost =;
    nlspGraphXRouteEntryData.nlspGraphXRouteHopCount =;

    return (&nlspGraphXRouteEntryData);
#else				       /* NOT_YET */
    return (NULL);
#endif				       /* NOT_YET */
}

nlspGraphServEntry_t *
k_nlspGraphServEntry_get(serialNum, contextInfo, nominator, searchType, nlspGraphServSysInstance, nlspGraphServNLSPID, nlspGraphServName, nlspGraphServTypeValue)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
    int             searchType;
    long            nlspGraphServSysInstance;
    OctetString    *nlspGraphServNLSPID;
    OctetString    *nlspGraphServName;
    OctetString    *nlspGraphServTypeValue;
{
#ifdef NOT_YET
    static nlspGraphServEntry_t nlspGraphServEntryData;

    nlspGraphServEntryData.nlspGraphServSysInstance =;
    nlspGraphServEntryData.nlspGraphServNLSPID =;
    nlspGraphServEntryData.nlspGraphServName =;
    nlspGraphServEntryData.nlspGraphServTypeValue =;
    nlspGraphServEntryData.nlspGraphServType =;
    nlspGraphServEntryData.nlspGraphServNetNum =;
    nlspGraphServEntryData.nlspGraphServNode =;
    nlspGraphServEntryData.nlspGraphServSocket =;

    return (&nlspGraphServEntryData);
#else				       /* NOT_YET */
    return (NULL);
#endif				       /* NOT_YET */
}

nlspLSPEntry_t *
k_nlspLSPEntry_get(serialNum, contextInfo, nominator, searchType, nlspLSPSysInstance, nlspLSPID)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
    int             searchType;
    long            nlspLSPSysInstance;
    OctetString    *nlspLSPID;
{
#ifdef NOT_YET
    static nlspLSPEntry_t nlspLSPEntryData;

    nlspLSPEntryData.nlspLSPSysInstance =;
    nlspLSPEntryData.nlspLSPID =;
    nlspLSPEntryData.nlspLSPLifetime =;
    nlspLSPEntryData.nlspLSPSeqNum =;
    nlspLSPEntryData.nlspLSPChecksum =;
    nlspLSPEntryData.nlspLSPRouterType =;
    nlspLSPEntryData.nlspLSPOverload =;
    nlspLSPEntryData.nlspLSPHeader =;

    return (&nlspLSPEntryData);
#else				       /* NOT_YET */
    return (NULL);
#endif				       /* NOT_YET */
}

nlspLSPOptEntry_t *
k_nlspLSPOptEntry_get(serialNum, contextInfo, nominator, searchType, nlspLSPOptSysInstance, nlspLSPOptLSPID, nlspLSPOptIndex)
    int             serialNum;
    ContextInfo    *contextInfo;
    int             nominator;
    int             searchType;
    long            nlspLSPOptSysInstance;
    OctetString    *nlspLSPOptLSPID;
    long            nlspLSPOptIndex;
{
#ifdef NOT_YET
    static nlspLSPOptEntry_t nlspLSPOptEntryData;

    nlspLSPOptEntryData.nlspLSPOptSysInstance =;
    nlspLSPOptEntryData.nlspLSPOptLSPID =;
    nlspLSPOptEntryData.nlspLSPOptIndex =;
    nlspLSPOptEntryData.nlspLSPOptCode =;
    nlspLSPOptEntryData.nlspLSPOptLength =;
    nlspLSPOptEntryData.nlspLSPOptValue =;
    return (&nlspLSPOptEntryData);
#else				       /* NOT_YET */
    return (NULL);
#endif				       /* NOT_YET */
}

/*
 * novell_nlsp subsystem header
 */

#define MAJVERSION_novell_nlsp 1
#define MINVERSION_novell_nlsp 0
#define EDITVERSION_novell_nlsp 0

SUBSYS_HEADER(nlspmib,
              MAJVERSION_novell_nlsp,
              MINVERSION_novell_nlsp,
              EDITVERSION_novell_nlsp,
              init_novell_nlsp,
              SUBSYS_CLASS_MANAGEMENT,
              "req: ipxnlsp",
              NULL);
      
