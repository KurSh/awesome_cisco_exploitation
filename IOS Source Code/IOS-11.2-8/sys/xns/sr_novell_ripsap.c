/* $Id: sr_novell_ripsap.c,v 3.6.8.4 1996/07/01 18:47:15 hampton Exp $
 * $Source: /release/112/cvs/Xsys/xns/sr_novell_ripsap.c,v $
 *------------------------------------------------------------------
 * SNMP/SNMPv2 bi-lingual agent code.
 *
 * May 1994, Yunsen Wang (via the SNMP Research MIB Compiler)
 *
 * Copyright (c) 1995-1997 by cisco Systems, Inc.
 * All rights reserved.
 *
 *------------------------------------------------------------------
 * $Log: sr_novell_ripsap.c,v $
 * Revision 3.6.8.4  1996/07/01  18:47:15  hampton
 * Remove gratuitous casting.  [CSCdi61655]
 * Branch: California_branch
 *
 * Revision 3.6.8.3  1996/05/03  02:21:09  sluong
 * Branch: California_branch
 * IPX ACL Violation Logging, Plaining English Filters, Display SAP by
 * name,
 * NLSP MIBS, Scaleable RIP/SAP, Modularity, and SAP query by name.
 *
 * Revision 3.6.8.2  1996/04/19  17:55:20  jjohnson
 * CSCdi55117:  Need to support the Draft Standard SNMPv2 SMI
 * Branch: California_branch
 * Prototypes for the <foo>_free functions are auto-generated by the
 * SR 14.0 MIB Compiler.  Make the declarations match the prototypes.
 *
 * Revision 3.6.8.1  1996/04/10  16:44:07  john
 * CSCdi40886:  NLSP mib returns wrong values for objects
 * Branch: California_branch
 *
 * Revision 3.6  1996/02/29  22:21:11  bstewart
 * CSCdi48325:  SNMP MIBs need modularized translation tables
 *
 * Revision 3.5  1996/02/13  08:18:05  dstine
 * CSCdi48797:  Extraneous definitions in interface_private.h
 *
 * Revision 3.4  1996/01/18  15:58:48  anke
 * CSCdi46969:  Change empty req and/or seq strings in SUBSYS_HEADERs to
 *              NULL
 *              Five bytes saved is five bytes earned
 *
 * Revision 3.3  1995/12/14  08:30:27  jjohnson
 * CSCdi44148:  rationalize snmp library services
 *
 * Revision 3.2  1995/11/17  19:25:03  gstovall
 * Remove old entries from the RCS header logs.
 *
 * Revision 3.1  1995/11/09  14:00:25  shaker
 * Bump version numbers from 2.x to 3.x.
 *
 * Revision 2.3  1995/07/01  03:39:33  hampton
 * Minor Novell IPX Cleanups.  Remove some unused variables and routines.
 * Eliminate direct references to the system clock.  [CSCdi36668]
 *
 * Revision 2.2  1995/06/28 09:34:10  smackie
 * Repair widespread subsystem header braindamage. (CSCdi23568)
 *
 *   o Fix subsystem entry points to be foo(subsystype *) not foo(void)
 *   o Repair nonsensical and redundant subsystem sequences
 *   o Use NULL where no property is required
 *
 * Revision 2.1  1995/06/07  23:30:14  hampton
 * Bump version numbers from 1.x to 2.x.
 *
 *------------------------------------------------------------------
 * $Endlog$
 */

/*
 *
 * Copyright (C) 1994 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 52.227-7013
 *  and in similar clauses in the FAR and NASA FAR Supplement.
 *
 */

#include "master.h"
#include "subsys.h"
#include "interface_private.h"
#include "../snmp/snmp_api.h"
#include "sr_novell_ripsap.h"
#include "sr_novell_ripsap-mib.h"
#include "novell.h"
#include "../iprouting/igrp.h"

static ripSysEntry_t ripSysEntryData;
static sapSysEntry_t sapSysEntryData;
static ripCircEntry_t ripCircEntryData;
static sapCircEntry_t sapCircEntryData;



void
init_novell_ripsap (subsystype *subsys)
{
    memset(&ripSysEntryData, 0, sizeof(ripSysEntryData));
    memset(&sapSysEntryData, 0, sizeof(sapSysEntryData));
    memset(&ripCircEntryData, 0, sizeof(ripCircEntryData));
    memset(&sapCircEntryData, 0, sizeof(sapCircEntryData));
    load_mib(novell_ripsap_OidList, novell_ripsap_OidListNum);
    load_oid(novell_ripsap_oid_table);
}








/*---------------------------------------------------------------------
 * Retrieve data from the ripSysEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ripSysEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ripSysEntry_t  *data = NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            ripSysInstance;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &ripSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ripSysEntry_get(serialNum, contextInfo, arg, searchType, ripSysInstance)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->ripSysInstance;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ripSysInstance
      case I_ripSysInstance:
	dp = &data->ripSysInstance;
	break;
#endif				       /* I_ripSysInstance */

#ifdef I_ripSysState
      case I_ripSysState:
	dp = &data->ripSysState;
	break;
#endif				       /* I_ripSysState */

#ifdef I_ripSysIncorrectPackets
      case I_ripSysIncorrectPackets:
	dp = &data->ripSysIncorrectPackets;
	break;
#endif				       /* I_ripSysIncorrectPackets */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the ripSysEntry data object.
 *---------------------------------------------------------------------*/
void
ripSysEntry_free(ripSysEntry_t  *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after ripSysEntry set/undo
 *---------------------------------------------------------------------*/
static int
ripSysEntry_cleanup(doList_t       *trash)
{
    ripSysEntry_free(trash->data);
#ifdef SR_SNMPv2
    ripSysEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
ripSysEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int             found;
    int             carry = 0;
    ripSysEntry_t  *ripSysEntry;
    long            ripSysInstance;

    /*
     * Validate the object instance
     * 
     */
    if (instLength != 1) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &ripSysInstance, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    ripSysEntry = k_ripSysEntry_get(-1, contextInfo, object->nominator, EXACT, ripSysInstance);

#ifndef ripSysEntry_READ_CREATE

    if (ripSysEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* ripSysEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == ripSysEntry_set) &&
	    (((ripSysEntry_t *) (dp->data)) != NULL) &&
	(((ripSysEntry_t *) (dp->data))->ripSysInstance == ripSysInstance)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(ripSysEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(ripSysEntry_t));

	dp->setMethod = ripSysEntry_set;
	dp->cleanupMethod = ripSysEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_ripSysInstance, ((ripSysEntry_t *) (dp->data))->valid);
	((ripSysEntry_t *) (dp->data))->ripSysInstance = ripSysInstance;

#ifdef ripSysEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (ripSysEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, ripSysEntry, sizeof(ripSysEntry_t));

	    SET_ALL_VALID(((ripSysEntry_t *) (dp->data))->valid);

	} else {

	  /* Fill in default values here */

	}
#endif				       /* ripSysEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_ripSysInstance
      case I_ripSysInstance:

      if (value->sl_value != 1)
	return(WRONG_VALUE_ERROR);
	SET_VALID(I_ripSysInstance, ((ripSysEntry_t *) (dp->data))->valid);

	((ripSysEntry_t *) (dp->data))->ripSysInstance = value->sl_value;
	break;
#endif				       /* I_ripSysInstance */

#ifdef I_ripSysState
      case I_ripSysState:

	if (value->sl_value != D_ripSysState_on)  /* Can't turn RIP off */
	  return(WRONG_VALUE_ERROR);

	/* If RIP isn't on it means IPX isn't on, so we'll enable it */

	SET_VALID(I_ripSysState, ((ripSysEntry_t *) (dp->data))->valid);

	((ripSysEntry_t *) (dp->data))->ripSysState = value->sl_value;
	break;
#endif				       /* I_ripSysState */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in ripSysEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
ripSysEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_ripSysEntry_set((ripSysEntry_t *) (doCur->data),
			      contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the sapSysEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
sapSysEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    sapSysEntry_t  *data = NULL;
    unsigned long   buffer[1];
    OID             inst;
    int             carry;
    long            sapSysInstance;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 1
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 1) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 0 + object->oid.length, &sapSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_sapSysEntry_get(serialNum, contextInfo, arg, searchType, sapSysInstance)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 1;
	inst.oid_ptr[0] = data->sapSysInstance;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_sapSysInstance
      case I_sapSysInstance:
	dp = &data->sapSysInstance;
	break;
#endif				       /* I_sapSysInstance */

#ifdef I_sapSysState
      case I_sapSysState:
	dp = &data->sapSysState;
	break;
#endif				       /* I_sapSysState */

#ifdef I_sapSysIncorrectPackets
      case I_sapSysIncorrectPackets:
	dp = &data->sapSysIncorrectPackets;
	break;
#endif				       /* I_sapSysIncorrectPackets */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the sapSysEntry data object.
 *---------------------------------------------------------------------*/
void
sapSysEntry_free(sapSysEntry_t  *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after sapSysEntry set/undo
 *---------------------------------------------------------------------*/
static int
sapSysEntry_cleanup(doList_t       *trash)
{
    sapSysEntry_free(trash->data);
#ifdef SR_SNMPv2
    sapSysEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
sapSysEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int             found;
    int             carry = 0;
    sapSysEntry_t  *sapSysEntry;
    long            sapSysInstance;

    /*
     * Validate the object instance
     * 
     */
    if (instLength != 1) {
	return NO_CREATION_ERROR;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &sapSysInstance, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    sapSysEntry = k_sapSysEntry_get(-1, contextInfo, object->nominator, EXACT, sapSysInstance);

#ifndef sapSysEntry_READ_CREATE

    if (sapSysEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* sapSysEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == sapSysEntry_set) &&
	    (((sapSysEntry_t *) (dp->data)) != NULL) &&
	(((sapSysEntry_t *) (dp->data))->sapSysInstance == sapSysInstance)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(sapSysEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(sapSysEntry_t));

	dp->setMethod = sapSysEntry_set;
	dp->cleanupMethod = sapSysEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_sapSysInstance, ((sapSysEntry_t *) (dp->data))->valid);
	((sapSysEntry_t *) (dp->data))->sapSysInstance = sapSysInstance;

#ifdef sapSysEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (sapSysEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, sapSysEntry, sizeof(sapSysEntry_t));

	    SET_ALL_VALID(((sapSysEntry_t *) (dp->data))->valid);

	} else {


	    /* Fill in default values here */


	}
#endif				       /* sapSysEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_sapSysInstance
      case I_sapSysInstance:

      if (value->sl_value != 1)
	return(WRONG_VALUE_ERROR);
	SET_VALID(I_sapSysInstance, ((sapSysEntry_t *) (dp->data))->valid);

	((sapSysEntry_t *) (dp->data))->sapSysInstance = value->sl_value;
	break;
#endif				       /* I_sapSysInstance */

#ifdef I_sapSysState
      case I_sapSysState:


        if (value->sl_value != D_sapSysState_on)  /* Can't turn SAP off */
          return(WRONG_VALUE_ERROR);

        /* If SAP isn't on it means IPX isn't on, so we'll enable it */

	SET_VALID(I_sapSysState, ((sapSysEntry_t *) (dp->data))->valid);

	((sapSysEntry_t *) (dp->data))->sapSysState = value->sl_value;
	break;
#endif				       /* I_sapSysState */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in sapSysEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
sapSysEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_sapSysEntry_set((sapSysEntry_t *) (doCur->data),
			      contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the ripCircEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
ripCircEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    ripCircEntry_t *data = NULL;
    unsigned long   buffer[2];
    OID             inst;
    int             carry;
    long            ripCircSysInstance;
    long            ripCircIndex;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 2
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 2) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 1 + object->oid.length, &ripCircIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &ripCircSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_ripCircEntry_get(serialNum, contextInfo, arg, searchType, ripCircSysInstance, ripCircIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 2;
	inst.oid_ptr[0] = data->ripCircSysInstance;
	inst.oid_ptr[1] = data->ripCircIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_ripCircSysInstance
      case I_ripCircSysInstance:
	dp = &data->ripCircSysInstance;
	break;
#endif				       /* I_ripCircSysInstance */

#ifdef I_ripCircIndex
      case I_ripCircIndex:
	dp = &data->ripCircIndex;
	break;
#endif				       /* I_ripCircIndex */

#ifdef I_ripCircState
      case I_ripCircState:
	dp = &data->ripCircState;
	break;
#endif				       /* I_ripCircState */

#ifdef I_ripCircPace
      case I_ripCircPace:
	dp = &data->ripCircPace;
	break;
#endif				       /* I_ripCircPace */

#ifdef I_ripCircUpdate
      case I_ripCircUpdate:
	dp = &data->ripCircUpdate;
	break;
#endif				       /* I_ripCircUpdate */

#ifdef I_ripCircAgeMultiplier
      case I_ripCircAgeMultiplier:
	dp = &data->ripCircAgeMultiplier;
	break;
#endif				       /* I_ripCircAgeMultiplier */

#ifdef I_ripCircPacketSize
      case I_ripCircPacketSize:
	dp = &data->ripCircPacketSize;
	break;
#endif				       /* I_ripCircPacketSize */

#ifdef I_ripCircOutPackets
      case I_ripCircOutPackets:
	dp = &data->ripCircOutPackets;
	break;
#endif				       /* I_ripCircOutPackets */

#ifdef I_ripCircInPackets
      case I_ripCircInPackets:
	dp = &data->ripCircInPackets;
	break;
#endif				       /* I_ripCircInPackets */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the ripCircEntry data object.
 *---------------------------------------------------------------------*/
void
ripCircEntry_free(ripCircEntry_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after ripCircEntry set/undo
 *---------------------------------------------------------------------*/
static int
ripCircEntry_cleanup(doList_t       *trash)
{
    ripCircEntry_free(trash->data);
#ifdef SR_SNMPv2
    ripCircEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
ripCircEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int             found;
    int             carry = 0;
    ripCircEntry_t *ripCircEntry;
    long            ripCircSysInstance;
    long            ripCircIndex;

    /*
     * Validate the object instance
     * 
     */
    if (instLength != 2) {
	return NO_CREATION_ERROR;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &ripCircSysInstance, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, 1 + object->oid.length, &ripCircIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    ripCircEntry = k_ripCircEntry_get(-1, contextInfo, object->nominator, EXACT, ripCircSysInstance, ripCircIndex);

#ifndef ripCircEntry_READ_CREATE

    if (ripCircEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* ripCircEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == ripCircEntry_set) &&
	    (((ripCircEntry_t *) (dp->data)) != NULL) &&
	    (((ripCircEntry_t *) (dp->data))->ripCircSysInstance == ripCircSysInstance) &&
	  (((ripCircEntry_t *) (dp->data))->ripCircIndex == ripCircIndex)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(ripCircEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(ripCircEntry_t));

	dp->setMethod = ripCircEntry_set;
	dp->cleanupMethod = ripCircEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_ripCircSysInstance, ((ripCircEntry_t *) (dp->data))->valid);
	((ripCircEntry_t *) (dp->data))->ripCircSysInstance = ripCircSysInstance;

	SET_VALID(I_ripCircIndex, ((ripCircEntry_t *) (dp->data))->valid);
	((ripCircEntry_t *) (dp->data))->ripCircIndex = ripCircIndex;

#ifdef ripCircEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (ripCircEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, ripCircEntry, sizeof(ripCircEntry_t));

	    SET_ALL_VALID(((ripCircEntry_t *) (dp->data))->valid);

	} else {

	  /* No reasonable default, make em explicitly set them */

	}
#endif				       /* ripCircEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_ripCircSysInstance
      case I_ripCircSysInstance:

      if (value->sl_value != 1)
	return(WRONG_VALUE_ERROR);
	SET_VALID(I_ripCircSysInstance, ((ripCircEntry_t *) (dp->data))->valid);

	((ripCircEntry_t *) (dp->data))->ripCircSysInstance = value->sl_value;
	break;
#endif				       /* I_ripCircSysInstance */

#ifdef I_ripCircIndex
      case I_ripCircIndex:

      if (value->sl_value < 1)
	return(WRONG_VALUE_ERROR);
	SET_VALID(I_ripCircIndex, ((ripCircEntry_t *) (dp->data))->valid);

	((ripCircEntry_t *) (dp->data))->ripCircIndex = value->sl_value;
	break;
#endif				       /* I_ripCircIndex */

#ifdef I_ripCircState
      case I_ripCircState:

      if ((value->sl_value < D_ripCircState_off) ||
	  (value->sl_value > D_ripCircState_auto_off))
	return(WRONG_VALUE_ERROR);
	SET_VALID(I_ripCircState, ((ripCircEntry_t *) (dp->data))->valid);

	((ripCircEntry_t *) (dp->data))->ripCircState = value->sl_value;
	break;
#endif				       /* I_ripCircState */

#ifdef I_ripCircPace
      case I_ripCircPace:

      return(NOT_WRITABLE_ERROR);
	SET_VALID(I_ripCircPace, ((ripCircEntry_t *) (dp->data))->valid);

	((ripCircEntry_t *) (dp->data))->ripCircPace = value->sl_value;
	break;
#endif				       /* I_ripCircPace */

#ifdef I_ripCircUpdate
      case I_ripCircUpdate:
      if ((value->sl_value < 10))  /* Large values are allowed */
	return(WRONG_VALUE_ERROR);
	SET_VALID(I_ripCircUpdate, ((ripCircEntry_t *) (dp->data))->valid);

	((ripCircEntry_t *) (dp->data))->ripCircUpdate = value->sl_value;
	break;
#endif				       /* I_ripCircUpdate */

#ifdef I_ripCircAgeMultiplier
      case I_ripCircAgeMultiplier:
	  
      if ((value->sl_value < 1))
	return(WRONG_VALUE_ERROR);
	SET_VALID(I_ripCircAgeMultiplier, ((ripCircEntry_t *) (dp->data))->valid);

	((ripCircEntry_t *) (dp->data))->ripCircAgeMultiplier = value->sl_value;
	break;
#endif				       /* I_ripCircAgeMultiplier */

#ifdef I_ripCircPacketSize
      case I_ripCircPacketSize:

      if ((value->sl_value < NOVELL_RIP_MAXSIZE) ||
	  (value->sl_value > NOVELL_MAXSIZE))
	return(WRONG_VALUE_ERROR);
	SET_VALID(I_ripCircPacketSize, ((ripCircEntry_t *) (dp->data))->valid);

	((ripCircEntry_t *) (dp->data))->ripCircPacketSize = value->sl_value;
	break;
#endif				       /* I_ripCircPacketSize */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in ripCircEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
ripCircEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_ripCircEntry_set((ripCircEntry_t *) (doCur->data),
			       contextInfo, doCur->state));
}

#endif				       /* SETS */


/*---------------------------------------------------------------------
 * Retrieve data from the sapCircEntry family. This is
 * performed in 3 steps:
 *
 *   1) Test the validity of the object instance.
 *   2) Retrieve the data.
 *   3) Build the variable binding (VarBind) that will be returned.
 *---------------------------------------------------------------------*/
VarBind        *
sapCircEntry_get(
    OID            *incoming,
    ObjectInfo     *object,
    int             searchType,
    ContextInfo    *contextInfo,
    int             serialNum)
{
    int             instLength = incoming->length - object->oid.length;
    int             arg = object->nominator;
    void           *dp;
    sapCircEntry_t *data = NULL;
    unsigned long   buffer[2];
    OID             inst;
    int             carry;
    long            sapCircSysInstance;
    long            sapCircIndex;


    /*
     * Check the object instance.
     * 
     * An EXACT search requires that the instance be of length 2
     * 
     * A NEXT search requires that the requested object does not
     * lexicographically precede the current object type.
     */

    if (searchType == EXACT) {
	if (instLength != 2) {
	    return ((VarBind *) NULL);
	}
	carry = 0;
    } else {
	carry = 1;
    }

    if ((InstToInt(incoming, 1 + object->oid.length, &sapCircIndex, searchType, &carry)) < 0) {
	arg = -1;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &sapCircSysInstance, searchType, &carry)) < 0) {
	arg = -1;
    }
    if (carry) {
	arg = -1;
    }
    /*
     * Retrieve the data from the kernel-specific routine.
     */
    if ((arg == -1) || (data = k_sapCircEntry_get(serialNum, contextInfo, arg, searchType, sapCircSysInstance, sapCircIndex)) == NULL) {
	arg = -1;
    } else {
	/*
	 * Build instance information
	 */
	inst.oid_ptr = buffer;
	inst.length = 2;
	inst.oid_ptr[0] = data->sapCircSysInstance;
	inst.oid_ptr[1] = data->sapCircIndex;
    }

    /*
     * Build the the variable binding for the variable that will be returned.
     */

    switch (arg) {

#ifdef I_sapCircSysInstance
      case I_sapCircSysInstance:
	dp = &data->sapCircSysInstance;
	break;
#endif				       /* I_sapCircSysInstance */

#ifdef I_sapCircIndex
      case I_sapCircIndex:
	dp = &data->sapCircIndex;
	break;
#endif				       /* I_sapCircIndex */

#ifdef I_sapCircState
      case I_sapCircState:
	dp = &data->sapCircState;
	break;
#endif				       /* I_sapCircState */

#ifdef I_sapCircPace
      case I_sapCircPace:
	dp = &data->sapCircPace;
	break;
#endif				       /* I_sapCircPace */

#ifdef I_sapCircUpdate
      case I_sapCircUpdate:
	dp = &data->sapCircUpdate;
	break;
#endif				       /* I_sapCircUpdate */

#ifdef I_sapCircAgeMultiplier
      case I_sapCircAgeMultiplier:
	dp = &data->sapCircAgeMultiplier;
	break;
#endif				       /* I_sapCircAgeMultiplier */

#ifdef I_sapCircPacketSize
      case I_sapCircPacketSize:
	dp = &data->sapCircPacketSize;
	break;
#endif				       /* I_sapCircPacketSize */

#ifdef I_sapCircGetNearestServerReply
      case I_sapCircGetNearestServerReply:
	dp = &data->sapCircGetNearestServerReply;
	break;
#endif				       /* I_sapCircGetNearestServerReply */

#ifdef I_sapCircOutPackets
      case I_sapCircOutPackets:
	dp = &data->sapCircOutPackets;
	break;
#endif				       /* I_sapCircOutPackets */

#ifdef I_sapCircInPackets
      case I_sapCircInPackets:
	dp = &data->sapCircInPackets;
	break;
#endif				       /* I_sapCircInPackets */

      default:
	return ((VarBind *) NULL);

    }				       /* switch */

    return (MakeVarBind(object, &inst, dp));

}

#ifdef SETS

/*----------------------------------------------------------------------
 * Free the sapCircEntry data object.
 *---------------------------------------------------------------------*/
void
sapCircEntry_free(sapCircEntry_t *data)
{
    if (data != NULL) {
	free((char *) data);
    }
}

/*----------------------------------------------------------------------
 * cleanup after sapCircEntry set/undo
 *---------------------------------------------------------------------*/
static int
sapCircEntry_cleanup(doList_t       *trash)
{
    sapCircEntry_free(trash->data);
#ifdef SR_SNMPv2
    sapCircEntry_free(trash->undodata);
#endif				       /* SR_SNMPv2 */
    return NO_ERROR;
}

/*---------------------------------------------------------------------
 * Determine if this SET request is valid. If so, add it to the do-list.
 * This operation is performed in 4 steps:
 *
 *   1) Validate the object instance.
 *   2) Locate a "related" do-list element, or create a new do-list
 *      element.
 *   3) Add the SET request to the selected do-list element.
 *   4) Finally, determine if the do-list element (all "related" set
 *      requests) is completely valid.
 *---------------------------------------------------------------------*/
int
sapCircEntry_test(
    OID            *incoming,
    ObjectInfo     *object,
    ObjectSyntax   *value,
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    int             instLength = incoming->length - object->oid.length;
    doList_t       *dp;
    int             found;
    int             carry = 0;
    sapCircEntry_t *sapCircEntry;
    long            sapCircSysInstance;
    long            sapCircIndex;

    /*
     * Validate the object instance
     * 
     */
    if (instLength != 2) {
	return NO_CREATION_ERROR;
    }
    if ((InstToInt(incoming, 0 + object->oid.length, &sapCircSysInstance, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    if ((InstToInt(incoming, 1 + object->oid.length, &sapCircIndex, EXACT, &carry)) < 0) {
	return (NO_CREATION_ERROR);
    }
    sapCircEntry = k_sapCircEntry_get(-1, contextInfo, object->nominator, EXACT, sapCircSysInstance, sapCircIndex);

#ifndef sapCircEntry_READ_CREATE

    if (sapCircEntry == NULL) {
	return (NO_ACCESS_ERROR);
    }
#endif				       /* sapCircEntry_READ_CREATE */

    /*
     * Determine the element of the do-list which should contain this SET
     * request. This is decided by looking for a previous do-list element for
     * the same row.
     */
    found = 0;

    for (dp = doHead; dp != NULL; dp = dp->next) {
	if ((dp->setMethod == sapCircEntry_set) &&
	    (((sapCircEntry_t *) (dp->data)) != NULL) &&
	    (((sapCircEntry_t *) (dp->data))->sapCircSysInstance == sapCircSysInstance) &&
	  (((sapCircEntry_t *) (dp->data))->sapCircIndex == sapCircIndex)) {

	    found = 1;
	    break;
	}
    }

    if (!found) {
	dp = doCur;
	if ((dp->data = malloc(sizeof(sapCircEntry_t))) == NULL) {
	    DPRINTF((APALWAYS, "snmpd: Cannot allocate memory\n"));
	    return (RESOURCE_UNAVAILABLE_ERROR);
	}
	memset(dp->data, 0, sizeof(sapCircEntry_t));

	dp->setMethod = sapCircEntry_set;
	dp->cleanupMethod = sapCircEntry_cleanup;
#ifdef SR_SNMPv2
	dp->undoMethod = NULL;
#endif				       /* SR_SNMPv2 */
	dp->state = UNKNOWN;

	SET_VALID(I_sapCircSysInstance, ((sapCircEntry_t *) (dp->data))->valid);
	((sapCircEntry_t *) (dp->data))->sapCircSysInstance = sapCircSysInstance;

	SET_VALID(I_sapCircIndex, ((sapCircEntry_t *) (dp->data))->valid);
	((sapCircEntry_t *) (dp->data))->sapCircIndex = sapCircIndex;

#ifdef sapCircEntry_READ_CREATE

	/*
	 * Try to fill in reasonable default values for this new entry.
	 */

	if (sapCircEntry != NULL) {
	    /* use existing values as default values */
	    memcpy(dp->data, sapCircEntry, sizeof(sapCircEntry_t));

	    SET_ALL_VALID(((sapCircEntry_t *) (dp->data))->valid);

	} else {

	  /* make 'em set the values, don't default */

	}
#endif				       /* sapCircEntry_READ_CREATE */
    }
    switch (object->nominator) {

#ifdef I_sapCircSysInstance
      case I_sapCircSysInstance:

      if (value->sl_value != 1)
        return(WRONG_VALUE_ERROR);
	SET_VALID(I_sapCircSysInstance, ((sapCircEntry_t *) (dp->data))->valid);

	((sapCircEntry_t *) (dp->data))->sapCircSysInstance = value->sl_value;
	break;
#endif				       /* I_sapCircSysInstance */

#ifdef I_sapCircIndex
      case I_sapCircIndex:

      if (value->sl_value < 1)
        return(WRONG_VALUE_ERROR);
	SET_VALID(I_sapCircIndex, ((sapCircEntry_t *) (dp->data))->valid);

	((sapCircEntry_t *) (dp->data))->sapCircIndex = value->sl_value;
	break;
#endif				       /* I_sapCircIndex */

#ifdef I_sapCircState
      case I_sapCircState:

      if ((value->sl_value < D_ripCircState_off) ||
          (value->sl_value > D_ripCircState_auto_off))
        return(WRONG_VALUE_ERROR);
	SET_VALID(I_sapCircState, ((sapCircEntry_t *) (dp->data))->valid);

	((sapCircEntry_t *) (dp->data))->sapCircState = value->sl_value;
	break;
#endif				       /* I_sapCircState */

#ifdef I_sapCircPace
      case I_sapCircPace:

      return(NOT_WRITABLE_ERROR);
	SET_VALID(I_sapCircPace, ((sapCircEntry_t *) (dp->data))->valid);

	((sapCircEntry_t *) (dp->data))->sapCircPace = value->sl_value;
	break;
#endif				       /* I_sapCircPace */

#ifdef I_sapCircUpdate
      case I_sapCircUpdate:

      if ((value->sl_value < 0))  /* 0 and Large values are allowed */
        return(WRONG_VALUE_ERROR);

	SET_VALID(I_sapCircUpdate, ((sapCircEntry_t *) (dp->data))->valid);

	((sapCircEntry_t *) (dp->data))->sapCircUpdate = value->sl_value;
	break;
#endif				       /* I_sapCircUpdate */

#ifdef I_sapCircAgeMultiplier
      case I_sapCircAgeMultiplier:

      if ((value->sl_value < 1))
        return(WRONG_VALUE_ERROR);

	SET_VALID(I_sapCircAgeMultiplier, ((sapCircEntry_t *) (dp->data))->valid);

	((sapCircEntry_t *) (dp->data))->sapCircAgeMultiplier = value->sl_value;
	break;
#endif				       /* I_sapCircAgeMultiplier */

#ifdef I_sapCircPacketSize
      case I_sapCircPacketSize:

      if ((value->sl_value < NOVELL_SAP_MAXSIZE) ||
          (value->sl_value > NOVELL_MAXSIZE))
        return(WRONG_VALUE_ERROR);
	SET_VALID(I_sapCircPacketSize, ((sapCircEntry_t *) (dp->data))->valid);

	((sapCircEntry_t *) (dp->data))->sapCircPacketSize = value->sl_value;
	break;
#endif				       /* I_sapCircPacketSize */

#ifdef I_sapCircGetNearestServerReply
      case I_sapCircGetNearestServerReply:

	SET_VALID(I_sapCircGetNearestServerReply, ((sapCircEntry_t *) (dp->data))->valid);

	((sapCircEntry_t *) (dp->data))->sapCircGetNearestServerReply = value->sl_value;
	break;
#endif				       /* I_sapCircGetNearestServerReply */

      default:
	DPRINTF((APALWAYS, "snmpd: Internal error (invalid nominator in sapCircEntry_test)\n"));
	return (GEN_ERROR);

    }				       /* switch */
    dp->state = ADD_MODIFY;

    return (NO_ERROR);

}

/*---------------------------------------------------------------------
 * Perform the kernel-specific set function for this group of
 * related objects.
 *---------------------------------------------------------------------*/
int
sapCircEntry_set(
    doList_t       *doHead,
    doList_t       *doCur,
    ContextInfo    *contextInfo)
{
    return (k_sapCircEntry_set((sapCircEntry_t *) (doCur->data),
			       contextInfo, doCur->state));
}

#endif				       /* SETS */






ripSysEntry_t  *
k_ripSysEntry_get (
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            ripSysInstance)
{
    if (searchType == NEXT)
	if (ripSysInstance < 1)
	    ripSysInstance = 1;

    if (ripSysInstance != 1)
	return (NULL);

    ripSysEntryData.ripSysInstance = ripSysInstance;
    ripSysEntryData.ripSysState = (!novell_running || novell_shutting_down) ?
      D_ripSysState_off : D_ripSysState_on;
    ripSysEntryData.ripSysIncorrectPackets = novell_stat[NOVELL_RIPFMTERROR];

    return (&ripSysEntryData);
}

#ifdef SETS
int
k_ripSysEntry_set (
    ripSysEntry_t  *data,
    ContextInfo    *contextInfo,
    int             function)
{
  switch(function) {
  case DELETE:
    break;
  case ADD_MODIFY:
    novell_address_command(FALSE, TRUE, 0 , NULL);
    return(NO_ERROR);
    break;
  default:
    return(GEN_ERROR);
  }
  return (GEN_ERROR);
}

#endif				       /* SETS */

sapSysEntry_t  *
k_sapSysEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            sapSysInstance)
{

    if (searchType == NEXT)
	if (sapSysInstance < 1)
	    sapSysInstance = 1;

    if (sapSysInstance != 1)
	return (NULL);

    sapSysEntryData.sapSysInstance = sapSysInstance;
    sapSysEntryData.sapSysState = (!novell_running || novell_shutting_down) ?
      D_sapSysState_off : D_sapSysState_on;
    sapSysEntryData.sapSysIncorrectPackets = novell_stat[NOVELL_SAPFMTERROR];

    return (&sapSysEntryData);
}

#ifdef SETS
int
k_sapSysEntry_set(
    sapSysEntry_t  *data,
    ContextInfo    *contextInfo,
    int             function)
{
  switch(function) {
  case DELETE:
    break;
  case ADD_MODIFY:
    novell_address_command(FALSE, TRUE, 0 , NULL);
    return(NO_ERROR);
    break;
  default:
    return(GEN_ERROR);
  }
  return (GEN_ERROR);
}

#endif				       /* SETS */

ripCircEntry_t *
k_ripCircEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            ripCircSysInstance,
    long            ripCircIndex)
{
    idbtype        *idb = NULL, *cur_idb = NULL;
    nidbtype *nidb = NULL;

    if (!novell_running || novell_shutting_down) 
	return (NULL);

    if (ripCircSysInstance > 1) /* only  1 system */
	return (NULL);

    if(searchType == EXACT) {
	if (ripCircSysInstance == 1) {
	    FOR_ALL_SWIDBS(idb) {
		if (idb->primary_nidb != NULL &&
		    idb->if_number == (ulong) ripCircIndex)
		    break;
	    }
	}
    } else { /* get next */
	if (ripCircSysInstance < 1) {
	    ripCircSysInstance = 1;
	    ripCircIndex = 0;
	}

	/* ripCircSysInstance == 1 now */
	FOR_ALL_SWIDBS(cur_idb) {
	    if (idb == NULL) {
		if (cur_idb->primary_nidb != NULL && 
		    cur_idb->if_number >= (ulong) ripCircIndex) 
		    idb = cur_idb;
	    } else {
		if (cur_idb->primary_nidb != NULL && 
		    (cur_idb->if_number >= (ulong) ripCircIndex) &&
		    (cur_idb->if_number < idb->if_number))
		    idb = cur_idb;
	    }
	}
    }

    if (idb == NULL)
        return (NULL);

    nidb = (nidbtype *)idb->primary_nidb;

    ripCircEntryData.ripCircSysInstance = ripCircSysInstance;
    ripCircEntryData.ripCircIndex = idb->if_number;
    ripCircEntryData.ripCircState = D_ripCircState_on;
    if ((nidb->nov_lsp_enabled)) {
      ripCircEntryData.ripCircState = (nidb->lsp_rip_on ? D_ripCircState_on : 
				       D_ripCircState_off);
      if (nidb->lsp_rip_cfg == IPX_RIPSAP_CONFIG_AUTO) {
	ripCircEntryData.ripCircState = (nidb->lsp_rip_on ?
					 D_ripCircState_auto_on :
					 D_ripCircState_auto_off);
      }
    }
    ripCircEntryData.ripCircPace = SCALED_BANDWIDTH(idb->visible_bandwidth) /
	(NOVELL_RIP_MAXSIZE * 8);
    ripCircEntryData.ripCircUpdate = idb->nov_update_interval/ONESEC;
    ripCircEntryData.ripCircAgeMultiplier = idb->nov_rip_multiplier;
    ripCircEntryData.ripCircPacketSize = idb->nov_rip_maxpacketsize;
    ripCircEntryData.ripCircOutPackets = idb->nov_rip_out_packets;
    ripCircEntryData.ripCircInPackets = idb->nov_rip_in_packets;

    return (&ripCircEntryData);
}

#ifdef SETS
int
k_ripCircEntry_set(
    ripCircEntry_t *data,
    ContextInfo    *contextInfo,
    int             function)
{
  boolean change;
  idbtype *idb;
  nidbtype *nidb;
  
  change = FALSE;
  FOR_ALL_SWIDBS(idb) {
    if (idb->primary_nidb != NULL &&
	idb->if_number == (ulong) data->ripCircIndex)
      break;
  }
  if (idb == NULL)
    return (GEN_ERROR);

  nidb = (nidbtype *)idb->primary_nidb;

  switch(function) {
  case DELETE:
    return (GEN_ERROR);
  case ADD_MODIFY:
    if (VALID(I_ripCircSysInstance, data->valid)) {
      /* If this is a WAN interface should we enable IPXWAN? */
    }
    if (VALID(I_ripCircIndex, data->valid)) {
      /* If this is a WAN interface should we enable IPXWAN? */
    }
    if (VALID(I_ripCircState, data->valid)) {
      /* RIP is always on unless NLSP turns it off */
      switch(data->ripCircState) {
      case D_ripCircState_off:
        if (nidb->lsp_rip_cfg != IPX_RIPSAP_CONFIG_OFF) {
          change = TRUE;
          novell_set_nidb_rip_mode(nidb, IPX_RIPSAP_CONFIG_AUTO);
        }
        break;
      case D_ripCircState_on:
        if (nidb->lsp_rip_cfg != IPX_RIPSAP_CONFIG_ON) {
          change = TRUE;
           novell_set_nidb_rip_mode(nidb, IPX_RIPSAP_CONFIG_ON);
        }
        break;
      case D_ripCircState_auto_on:
      case D_ripCircState_auto_off:
        if (nidb->lsp_rip_cfg != IPX_RIPSAP_CONFIG_AUTO) {
          change = TRUE;
          novell_set_nidb_rip_mode(nidb, IPX_RIPSAP_CONFIG_AUTO);
        }
        break;
      default:
        return (GEN_ERROR);
      }
      if (change) {
      /* Force world to know it's gone and bring IPXWAN down... */
      novell_nidb_newstate(nidb, NOVELL_NIDB_DOWN);
      novell_nidb_newstate(nidb, NOVELL_NIDB_UP);
      }
    }
    if (VALID(I_ripCircPace, data->valid)) {
      return (NOT_WRITABLE_ERROR);
      /* Not currently supported */
    }
    if (VALID(I_ripCircUpdate, data->valid)) {
      novell_updatetime_ifcommand(TRUE, idb, data->ripCircUpdate);
    }
    if (VALID(I_ripCircAgeMultiplier, data->valid)) {
      novell_rip_multiplier_ifcommand(TRUE, idb, data->ripCircAgeMultiplier);
    }
    if (VALID(I_ripCircPacketSize, data->valid)) {
      novell_rip_max_packetsize_ifcommand(TRUE, idb, data->ripCircPacketSize);
    }
    return (NO_ERROR);
  default:
    return (GEN_ERROR);
  }
  return (GEN_ERROR);
}

#endif				       /* SETS */

sapCircEntry_t *
k_sapCircEntry_get(
    int             serialNum,
    ContextInfo    *contextInfo,
    int             nominator,
    int             searchType,
    long            sapCircSysInstance,
    long            sapCircIndex)
{
    idbtype        *idb = NULL, *cur_idb = NULL;
    nidbtype *nidb = NULL;

    if (!novell_running || novell_shutting_down) 
	return (NULL);

    if (sapCircSysInstance > 1) /* only  1 system */
	return (NULL);

    if(searchType == EXACT) {
	if (sapCircSysInstance == 1) {
	    FOR_ALL_SWIDBS(idb) {
		if (idb->primary_nidb != NULL &&
		    idb->if_number == (ulong) sapCircIndex)
		    break;
	    }
	}
    } else { /* get next */
	if (sapCircSysInstance < 1) {
	    sapCircSysInstance = 1;
	    sapCircIndex = 0;
	}

	/* sapCircSysInstance == 1 now */
	FOR_ALL_SWIDBS(cur_idb) {
	    if (idb == NULL) {
		if (cur_idb->primary_nidb != NULL &&
		    cur_idb->if_number >= (ulong) sapCircIndex) 
		    idb = cur_idb;
	    } else {
		if (cur_idb->primary_nidb != NULL &&
		    (cur_idb->if_number >= (ulong) sapCircIndex) &&
		    (cur_idb->if_number < idb->if_number))
		    idb = cur_idb;
	    }
	}
    }
    if (idb == NULL)
        return (NULL);

    nidb = (nidbtype *)idb->primary_nidb;

    sapCircEntryData.sapCircSysInstance = sapCircSysInstance;
    sapCircEntryData.sapCircIndex = idb->if_number;
    sapCircEntryData.sapCircState = D_sapCircState_on;
    if ((nidb->nov_lsp_enabled)) {
      sapCircEntryData.sapCircState = (nidb->lsp_sap_on ? D_sapCircState_on :
                                       D_sapCircState_off);
      if (nidb->lsp_sap_cfg == IPX_RIPSAP_CONFIG_AUTO) {
        sapCircEntryData.sapCircState = (nidb->lsp_sap_on ?
                                         D_sapCircState_auto_on :
                                         D_sapCircState_auto_off);
      }
    }
    sapCircEntryData.sapCircPace = SCALED_BANDWIDTH(idb->visible_bandwidth) /
	(NOVELL_SAP_MAXSIZE * 8);
    sapCircEntryData.sapCircUpdate = idb->novell_interval * 60; /* seconds */
    sapCircEntryData.sapCircAgeMultiplier = idb->nov_sap_multiplier;
    sapCircEntryData.sapCircPacketSize = idb->nov_sap_maxpacketsize;
    sapCircEntryData.sapCircGetNearestServerReply =
      idb->nov_respond_to_gns ? D_sapCircGetNearestServerReply_yes :
	D_sapCircGetNearestServerReply_no;
    sapCircEntryData.sapCircOutPackets = idb->nov_sap_out_packets;
    sapCircEntryData.sapCircInPackets = idb->nov_sap_in_packets;

    return (&sapCircEntryData);
}

#ifdef SETS
int
k_sapCircEntry_set(
    sapCircEntry_t *data,
    ContextInfo    *contextInfo,
    int             function)
{
  boolean change;
  idbtype *idb;
  nidbtype *nidb;

  change = FALSE;
  FOR_ALL_SWIDBS(idb) {
    if (idb->primary_nidb != NULL &&
        idb->if_number == (ulong) data->sapCircIndex)
      break;
  }
  if (idb == NULL)
    return (GEN_ERROR);

  nidb = (nidbtype *)idb->primary_nidb;

  switch(function) {
  case DELETE:
    return (GEN_ERROR);
    break;
  case ADD_MODIFY:
    if (VALID(I_sapCircSysInstance, data->valid)) {
      /* If this is a WAN interface should we enable IPXWAN? */
    }
    if (VALID(I_sapCircIndex, data->valid)) {
      /* If this is a WAN interface should we enable IPXWAN? */
    }
    if (VALID(I_sapCircState, data->valid)) {
      /* SAP is always on unless NLSP turns it off */
      switch(data->sapCircState) {
      case D_sapCircState_off:
	if (nidb->lsp_sap_cfg != IPX_RIPSAP_CONFIG_OFF) {
	  change = TRUE;
	  novell_set_nidb_sap_mode(nidb, IPX_RIPSAP_CONFIG_AUTO);
	}
	break;
      case D_sapCircState_on:
	if (nidb->lsp_sap_cfg != IPX_RIPSAP_CONFIG_ON) {
	  change = TRUE;
	  novell_set_nidb_sap_mode(nidb, IPX_RIPSAP_CONFIG_ON);
	}
	break;
      case D_sapCircState_auto_on:
      case D_sapCircState_auto_off:
	if (nidb->lsp_sap_cfg != IPX_RIPSAP_CONFIG_AUTO) {
	  change = TRUE;
	  novell_set_nidb_sap_mode(nidb, IPX_RIPSAP_CONFIG_AUTO);
	}
	break;
      default:
	return (GEN_ERROR);
      }
      if (change) {
	/* Force world to know it's gone and bring IPXWAN down... */
	novell_nidb_newstate(nidb, NOVELL_NIDB_DOWN);
	novell_nidb_newstate(nidb, NOVELL_NIDB_UP);
      }
    }
    if (VALID(I_sapCircPace, data->valid)) {
      /* Not currently supported */
      return (NOT_WRITABLE_ERROR);
    }
    if (VALID(I_sapCircUpdate, data->valid)) {
      novell_sapint_ifcommand(FALSE, TRUE, idb, data->sapCircUpdate/60);
    }
    if (VALID(I_sapCircAgeMultiplier, data->valid)) {
      novell_sap_multiplier_ifcommand(TRUE, idb, data->sapCircAgeMultiplier);
    }
    if (VALID(I_sapCircPacketSize, data->valid)) {
      novell_sap_max_packetsize_ifcommand(TRUE, idb, data->sapCircPacketSize);
    }
    if (VALID(I_sapCircGetNearestServerReply, data->valid)) {
      novell_gns_reply_disable_ifcommand((data->sapCircGetNearestServerReply == D_sapCircGetNearestServerReply_no), idb);
    }
    return (NO_ERROR);
    break;
  default:
    return (GEN_ERROR);
  }
  return (GEN_ERROR);
}

#endif				       /* SETS */

/*
 * novell_ripsap subsystem header
 */

#define MAJVERSION_novell_ripsap 1
#define MINVERSION_novell_ripsap 0
#define EDITVERSION_novell_ripsap 0

SUBSYS_HEADER(ripsapmib,
              MAJVERSION_novell_ripsap,
              MINVERSION_novell_ripsap,
              EDITVERSION_novell_ripsap,
              init_novell_ripsap,
              SUBSYS_CLASS_MANAGEMENT,
              "req: ipx",
              NULL);
      
